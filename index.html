<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Home | 右上↗</title><meta name="description" content="agatan のブログです。主にエンジニアリングに関する内容を書きます。"/><meta property="og:type" content="website"/><meta property="og:title" content="Home"/><meta property="og:description" content="agatan のブログです。主にエンジニアリングに関する内容を書きます。"/><meta property="og:site_name" content="右上↗"/><meta property="twitter:card" content="summary"/><meta property="twitter:creator" content="@agatan_"/><meta property="twitter:title" content="Home"/><meta property="twitter:description" content="agatan のブログです。主にエンジニアリングに関する内容を書きます。"/><meta name="next-head-count" content="12"/><link rel="preload" href="/_next/static/css/fcf459cc03a0aa33d72b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/fcf459cc03a0aa33d72b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-20d43e08bea62467b090.js" defer=""></script><script src="/_next/static/chunks/framework-92300432a1172ef1338b.js" defer=""></script><script src="/_next/static/chunks/main-588261c74baf7142d208.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a9e8b7fcb86503283a43.js" defer=""></script><script src="/_next/static/chunks/1bfc9850-b731c6aa1c491f14d361.js" defer=""></script><script src="/_next/static/chunks/191-ac794077f326adb56e38.js" defer=""></script><script src="/_next/static/chunks/pages/index-272dde73972cc3be3818.js" defer=""></script><script src="/_next/static/MrBI3Vp9UtpEWQt6jMgGf/_buildManifest.js" defer=""></script><script src="/_next/static/MrBI3Vp9UtpEWQt6jMgGf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><style data-emotion="css-global o7558t">:host,:root{--chakra-ring-inset:var(--chakra-empty,/*!*/ /*!*/);--chakra-ring-offset-width:0px;--chakra-ring-offset-color:#fff;--chakra-ring-color:rgba(66, 153, 225, 0.6);--chakra-ring-offset-shadow:0 0 #0000;--chakra-ring-shadow:0 0 #0000;--chakra-space-x-reverse:0;--chakra-space-y-reverse:0;--chakra-colors-transparent:transparent;--chakra-colors-current:currentColor;--chakra-colors-black:#000000;--chakra-colors-white:#FFFFFF;--chakra-colors-whiteAlpha-50:rgba(255, 255, 255, 0.04);--chakra-colors-whiteAlpha-100:rgba(255, 255, 255, 0.06);--chakra-colors-whiteAlpha-200:rgba(255, 255, 255, 0.08);--chakra-colors-whiteAlpha-300:rgba(255, 255, 255, 0.16);--chakra-colors-whiteAlpha-400:rgba(255, 255, 255, 0.24);--chakra-colors-whiteAlpha-500:rgba(255, 255, 255, 0.36);--chakra-colors-whiteAlpha-600:rgba(255, 255, 255, 0.48);--chakra-colors-whiteAlpha-700:rgba(255, 255, 255, 0.64);--chakra-colors-whiteAlpha-800:rgba(255, 255, 255, 0.80);--chakra-colors-whiteAlpha-900:rgba(255, 255, 255, 0.92);--chakra-colors-blackAlpha-50:rgba(0, 0, 0, 0.04);--chakra-colors-blackAlpha-100:rgba(0, 0, 0, 0.06);--chakra-colors-blackAlpha-200:rgba(0, 0, 0, 0.08);--chakra-colors-blackAlpha-300:rgba(0, 0, 0, 0.16);--chakra-colors-blackAlpha-400:rgba(0, 0, 0, 0.24);--chakra-colors-blackAlpha-500:rgba(0, 0, 0, 0.36);--chakra-colors-blackAlpha-600:rgba(0, 0, 0, 0.48);--chakra-colors-blackAlpha-700:rgba(0, 0, 0, 0.64);--chakra-colors-blackAlpha-800:rgba(0, 0, 0, 0.80);--chakra-colors-blackAlpha-900:rgba(0, 0, 0, 0.92);--chakra-colors-gray-50:#F7FAFC;--chakra-colors-gray-100:#EDF2F7;--chakra-colors-gray-200:#E2E8F0;--chakra-colors-gray-300:#CBD5E0;--chakra-colors-gray-400:#A0AEC0;--chakra-colors-gray-500:#718096;--chakra-colors-gray-600:#4A5568;--chakra-colors-gray-700:#2D3748;--chakra-colors-gray-800:#1A202C;--chakra-colors-gray-900:#171923;--chakra-colors-red-50:#FFF5F5;--chakra-colors-red-100:#FED7D7;--chakra-colors-red-200:#FEB2B2;--chakra-colors-red-300:#FC8181;--chakra-colors-red-400:#F56565;--chakra-colors-red-500:#E53E3E;--chakra-colors-red-600:#C53030;--chakra-colors-red-700:#9B2C2C;--chakra-colors-red-800:#822727;--chakra-colors-red-900:#63171B;--chakra-colors-orange-50:#FFFAF0;--chakra-colors-orange-100:#FEEBC8;--chakra-colors-orange-200:#FBD38D;--chakra-colors-orange-300:#F6AD55;--chakra-colors-orange-400:#ED8936;--chakra-colors-orange-500:#DD6B20;--chakra-colors-orange-600:#C05621;--chakra-colors-orange-700:#9C4221;--chakra-colors-orange-800:#7B341E;--chakra-colors-orange-900:#652B19;--chakra-colors-yellow-50:#FFFFF0;--chakra-colors-yellow-100:#FEFCBF;--chakra-colors-yellow-200:#FAF089;--chakra-colors-yellow-300:#F6E05E;--chakra-colors-yellow-400:#ECC94B;--chakra-colors-yellow-500:#D69E2E;--chakra-colors-yellow-600:#B7791F;--chakra-colors-yellow-700:#975A16;--chakra-colors-yellow-800:#744210;--chakra-colors-yellow-900:#5F370E;--chakra-colors-green-50:#F0FFF4;--chakra-colors-green-100:#C6F6D5;--chakra-colors-green-200:#9AE6B4;--chakra-colors-green-300:#68D391;--chakra-colors-green-400:#48BB78;--chakra-colors-green-500:#38A169;--chakra-colors-green-600:#2F855A;--chakra-colors-green-700:#276749;--chakra-colors-green-800:#22543D;--chakra-colors-green-900:#1C4532;--chakra-colors-teal-50:#E6FFFA;--chakra-colors-teal-100:#B2F5EA;--chakra-colors-teal-200:#81E6D9;--chakra-colors-teal-300:#4FD1C5;--chakra-colors-teal-400:#38B2AC;--chakra-colors-teal-500:#319795;--chakra-colors-teal-600:#2C7A7B;--chakra-colors-teal-700:#285E61;--chakra-colors-teal-800:#234E52;--chakra-colors-teal-900:#1D4044;--chakra-colors-blue-50:#ebf8ff;--chakra-colors-blue-100:#bee3f8;--chakra-colors-blue-200:#90cdf4;--chakra-colors-blue-300:#63b3ed;--chakra-colors-blue-400:#4299e1;--chakra-colors-blue-500:#3182ce;--chakra-colors-blue-600:#2b6cb0;--chakra-colors-blue-700:#2c5282;--chakra-colors-blue-800:#2a4365;--chakra-colors-blue-900:#1A365D;--chakra-colors-cyan-50:#EDFDFD;--chakra-colors-cyan-100:#C4F1F9;--chakra-colors-cyan-200:#9DECF9;--chakra-colors-cyan-300:#76E4F7;--chakra-colors-cyan-400:#0BC5EA;--chakra-colors-cyan-500:#00B5D8;--chakra-colors-cyan-600:#00A3C4;--chakra-colors-cyan-700:#0987A0;--chakra-colors-cyan-800:#086F83;--chakra-colors-cyan-900:#065666;--chakra-colors-purple-50:#FAF5FF;--chakra-colors-purple-100:#E9D8FD;--chakra-colors-purple-200:#D6BCFA;--chakra-colors-purple-300:#B794F4;--chakra-colors-purple-400:#9F7AEA;--chakra-colors-purple-500:#805AD5;--chakra-colors-purple-600:#6B46C1;--chakra-colors-purple-700:#553C9A;--chakra-colors-purple-800:#44337A;--chakra-colors-purple-900:#322659;--chakra-colors-pink-50:#FFF5F7;--chakra-colors-pink-100:#FED7E2;--chakra-colors-pink-200:#FBB6CE;--chakra-colors-pink-300:#F687B3;--chakra-colors-pink-400:#ED64A6;--chakra-colors-pink-500:#D53F8C;--chakra-colors-pink-600:#B83280;--chakra-colors-pink-700:#97266D;--chakra-colors-pink-800:#702459;--chakra-colors-pink-900:#521B41;--chakra-colors-linkedin-50:#E8F4F9;--chakra-colors-linkedin-100:#CFEDFB;--chakra-colors-linkedin-200:#9BDAF3;--chakra-colors-linkedin-300:#68C7EC;--chakra-colors-linkedin-400:#34B3E4;--chakra-colors-linkedin-500:#00A0DC;--chakra-colors-linkedin-600:#008CC9;--chakra-colors-linkedin-700:#0077B5;--chakra-colors-linkedin-800:#005E93;--chakra-colors-linkedin-900:#004471;--chakra-colors-facebook-50:#E8F4F9;--chakra-colors-facebook-100:#D9DEE9;--chakra-colors-facebook-200:#B7C2DA;--chakra-colors-facebook-300:#6482C0;--chakra-colors-facebook-400:#4267B2;--chakra-colors-facebook-500:#385898;--chakra-colors-facebook-600:#314E89;--chakra-colors-facebook-700:#29487D;--chakra-colors-facebook-800:#223B67;--chakra-colors-facebook-900:#1E355B;--chakra-colors-messenger-50:#D0E6FF;--chakra-colors-messenger-100:#B9DAFF;--chakra-colors-messenger-200:#A2CDFF;--chakra-colors-messenger-300:#7AB8FF;--chakra-colors-messenger-400:#2E90FF;--chakra-colors-messenger-500:#0078FF;--chakra-colors-messenger-600:#0063D1;--chakra-colors-messenger-700:#0052AC;--chakra-colors-messenger-800:#003C7E;--chakra-colors-messenger-900:#002C5C;--chakra-colors-whatsapp-50:#dffeec;--chakra-colors-whatsapp-100:#b9f5d0;--chakra-colors-whatsapp-200:#90edb3;--chakra-colors-whatsapp-300:#65e495;--chakra-colors-whatsapp-400:#3cdd78;--chakra-colors-whatsapp-500:#22c35e;--chakra-colors-whatsapp-600:#179848;--chakra-colors-whatsapp-700:#0c6c33;--chakra-colors-whatsapp-800:#01421c;--chakra-colors-whatsapp-900:#001803;--chakra-colors-twitter-50:#E5F4FD;--chakra-colors-twitter-100:#C8E9FB;--chakra-colors-twitter-200:#A8DCFA;--chakra-colors-twitter-300:#83CDF7;--chakra-colors-twitter-400:#57BBF5;--chakra-colors-twitter-500:#1DA1F2;--chakra-colors-twitter-600:#1A94DA;--chakra-colors-twitter-700:#1681BF;--chakra-colors-twitter-800:#136B9E;--chakra-colors-twitter-900:#0D4D71;--chakra-colors-telegram-50:#E3F2F9;--chakra-colors-telegram-100:#C5E4F3;--chakra-colors-telegram-200:#A2D4EC;--chakra-colors-telegram-300:#7AC1E4;--chakra-colors-telegram-400:#47A9DA;--chakra-colors-telegram-500:#0088CC;--chakra-colors-telegram-600:#007AB8;--chakra-colors-telegram-700:#006BA1;--chakra-colors-telegram-800:#005885;--chakra-colors-telegram-900:#003F5E;--chakra-borders-none:0;--chakra-borders-1px:1px solid;--chakra-borders-2px:2px solid;--chakra-borders-4px:4px solid;--chakra-borders-8px:8px solid;--chakra-fonts-heading:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--chakra-fonts-body:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--chakra-fonts-mono:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--chakra-fontSizes-xs:0.75rem;--chakra-fontSizes-sm:0.875rem;--chakra-fontSizes-md:1rem;--chakra-fontSizes-lg:1.125rem;--chakra-fontSizes-xl:1.25rem;--chakra-fontSizes-2xl:1.5rem;--chakra-fontSizes-3xl:1.875rem;--chakra-fontSizes-4xl:2.25rem;--chakra-fontSizes-5xl:3rem;--chakra-fontSizes-6xl:3.75rem;--chakra-fontSizes-7xl:4.5rem;--chakra-fontSizes-8xl:6rem;--chakra-fontSizes-9xl:8rem;--chakra-fontWeights-hairline:100;--chakra-fontWeights-thin:200;--chakra-fontWeights-light:300;--chakra-fontWeights-normal:400;--chakra-fontWeights-medium:500;--chakra-fontWeights-semibold:600;--chakra-fontWeights-bold:700;--chakra-fontWeights-extrabold:800;--chakra-fontWeights-black:900;--chakra-letterSpacings-tighter:-0.05em;--chakra-letterSpacings-tight:-0.025em;--chakra-letterSpacings-normal:0;--chakra-letterSpacings-wide:0.025em;--chakra-letterSpacings-wider:0.05em;--chakra-letterSpacings-widest:0.1em;--chakra-lineHeights-3:.75rem;--chakra-lineHeights-4:1rem;--chakra-lineHeights-5:1.25rem;--chakra-lineHeights-6:1.5rem;--chakra-lineHeights-7:1.75rem;--chakra-lineHeights-8:2rem;--chakra-lineHeights-9:2.25rem;--chakra-lineHeights-10:2.5rem;--chakra-lineHeights-normal:normal;--chakra-lineHeights-none:1;--chakra-lineHeights-shorter:1.25;--chakra-lineHeights-short:1.375;--chakra-lineHeights-base:1.5;--chakra-lineHeights-tall:1.625;--chakra-lineHeights-taller:2;--chakra-radii-none:0;--chakra-radii-sm:0.125rem;--chakra-radii-base:0.25rem;--chakra-radii-md:0.375rem;--chakra-radii-lg:0.5rem;--chakra-radii-xl:0.75rem;--chakra-radii-2xl:1rem;--chakra-radii-3xl:1.5rem;--chakra-radii-full:9999px;--chakra-space-1:0.25rem;--chakra-space-2:0.5rem;--chakra-space-3:0.75rem;--chakra-space-4:1rem;--chakra-space-5:1.25rem;--chakra-space-6:1.5rem;--chakra-space-7:1.75rem;--chakra-space-8:2rem;--chakra-space-9:2.25rem;--chakra-space-10:2.5rem;--chakra-space-12:3rem;--chakra-space-14:3.5rem;--chakra-space-16:4rem;--chakra-space-20:5rem;--chakra-space-24:6rem;--chakra-space-28:7rem;--chakra-space-32:8rem;--chakra-space-36:9rem;--chakra-space-40:10rem;--chakra-space-44:11rem;--chakra-space-48:12rem;--chakra-space-52:13rem;--chakra-space-56:14rem;--chakra-space-60:15rem;--chakra-space-64:16rem;--chakra-space-72:18rem;--chakra-space-80:20rem;--chakra-space-96:24rem;--chakra-space-px:1px;--chakra-space-0\.5:0.125rem;--chakra-space-1\.5:0.375rem;--chakra-space-2\.5:0.625rem;--chakra-space-3\.5:0.875rem;--chakra-shadows-xs:0 0 0 1px rgba(0, 0, 0, 0.05);--chakra-shadows-sm:0 1px 2px 0 rgba(0, 0, 0, 0.05);--chakra-shadows-base:0 1px 3px 0 rgba(0, 0, 0, 0.1),0 1px 2px 0 rgba(0, 0, 0, 0.06);--chakra-shadows-md:0 4px 6px -1px rgba(0, 0, 0, 0.1),0 2px 4px -1px rgba(0, 0, 0, 0.06);--chakra-shadows-lg:0 10px 15px -3px rgba(0, 0, 0, 0.1),0 4px 6px -2px rgba(0, 0, 0, 0.05);--chakra-shadows-xl:0 20px 25px -5px rgba(0, 0, 0, 0.1),0 10px 10px -5px rgba(0, 0, 0, 0.04);--chakra-shadows-2xl:0 25px 50px -12px rgba(0, 0, 0, 0.25);--chakra-shadows-outline:0 0 0 3px rgba(66, 153, 225, 0.6);--chakra-shadows-inner:inset 0 2px 4px 0 rgba(0,0,0,0.06);--chakra-shadows-none:none;--chakra-shadows-dark-lg:rgba(0, 0, 0, 0.1) 0px 0px 0px 1px,rgba(0, 0, 0, 0.2) 0px 5px 10px,rgba(0, 0, 0, 0.4) 0px 15px 40px;--chakra-sizes-1:0.25rem;--chakra-sizes-2:0.5rem;--chakra-sizes-3:0.75rem;--chakra-sizes-4:1rem;--chakra-sizes-5:1.25rem;--chakra-sizes-6:1.5rem;--chakra-sizes-7:1.75rem;--chakra-sizes-8:2rem;--chakra-sizes-9:2.25rem;--chakra-sizes-10:2.5rem;--chakra-sizes-12:3rem;--chakra-sizes-14:3.5rem;--chakra-sizes-16:4rem;--chakra-sizes-20:5rem;--chakra-sizes-24:6rem;--chakra-sizes-28:7rem;--chakra-sizes-32:8rem;--chakra-sizes-36:9rem;--chakra-sizes-40:10rem;--chakra-sizes-44:11rem;--chakra-sizes-48:12rem;--chakra-sizes-52:13rem;--chakra-sizes-56:14rem;--chakra-sizes-60:15rem;--chakra-sizes-64:16rem;--chakra-sizes-72:18rem;--chakra-sizes-80:20rem;--chakra-sizes-96:24rem;--chakra-sizes-px:1px;--chakra-sizes-0\.5:0.125rem;--chakra-sizes-1\.5:0.375rem;--chakra-sizes-2\.5:0.625rem;--chakra-sizes-3\.5:0.875rem;--chakra-sizes-max:max-content;--chakra-sizes-min:min-content;--chakra-sizes-full:100%;--chakra-sizes-3xs:14rem;--chakra-sizes-2xs:16rem;--chakra-sizes-xs:20rem;--chakra-sizes-sm:24rem;--chakra-sizes-md:28rem;--chakra-sizes-lg:32rem;--chakra-sizes-xl:36rem;--chakra-sizes-2xl:42rem;--chakra-sizes-3xl:48rem;--chakra-sizes-4xl:56rem;--chakra-sizes-5xl:64rem;--chakra-sizes-6xl:72rem;--chakra-sizes-7xl:80rem;--chakra-sizes-8xl:90rem;--chakra-sizes-container-sm:640px;--chakra-sizes-container-md:768px;--chakra-sizes-container-lg:1024px;--chakra-sizes-container-xl:1280px;--chakra-zIndices-hide:-1;--chakra-zIndices-auto:auto;--chakra-zIndices-base:0;--chakra-zIndices-docked:10;--chakra-zIndices-dropdown:1000;--chakra-zIndices-sticky:1100;--chakra-zIndices-banner:1200;--chakra-zIndices-overlay:1300;--chakra-zIndices-modal:1400;--chakra-zIndices-popover:1500;--chakra-zIndices-skipLink:1600;--chakra-zIndices-toast:1700;--chakra-zIndices-tooltip:1800;--chakra-transition-property-common:background-color,border-color,color,fill,stroke,opacity,box-shadow,transform;--chakra-transition-property-colors:background-color,border-color,color,fill,stroke;--chakra-transition-property-dimensions:width,height;--chakra-transition-property-position:left,right,top,bottom;--chakra-transition-property-background:background-color,background-image,background-position;--chakra-transition-easing-ease-in:cubic-bezier(0.4, 0, 1, 1);--chakra-transition-easing-ease-out:cubic-bezier(0, 0, 0.2, 1);--chakra-transition-easing-ease-in-out:cubic-bezier(0.4, 0, 0.2, 1);--chakra-transition-duration-ultra-fast:50ms;--chakra-transition-duration-faster:100ms;--chakra-transition-duration-fast:150ms;--chakra-transition-duration-normal:200ms;--chakra-transition-duration-slow:300ms;--chakra-transition-duration-slower:400ms;--chakra-transition-duration-ultra-slow:500ms;--chakra-blur-none:0;--chakra-blur-sm:4px;--chakra-blur-base:8px;--chakra-blur-md:12px;--chakra-blur-lg:16px;--chakra-blur-xl:24px;--chakra-blur-2xl:40px;--chakra-blur-3xl:64px;}</style><style data-emotion="css-global 1syi0wy">html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:system-ui,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;touch-action:manipulation;}body{position:relative;min-height:100%;font-feature-settings:'kern';}*,*::before,*::after{border-width:0;border-style:solid;box-sizing:border-box;}main{display:block;}hr{border-top-width:1px;box-sizing:content-box;height:0;overflow:visible;}pre,code,kbd,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:1em;}a{background-color:transparent;color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit;}abbr[title]{border-bottom:none;-webkit-text-decoration:underline;text-decoration:underline;-webkit-text-decoration:underline dotted;-webkit-text-decoration:underline dotted;text-decoration:underline dotted;}b,strong{font-weight:bold;}small{font-size:80%;}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline;}sub{bottom:-0.25em;}sup{top:-0.5em;}img{border-style:none;}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0;}button,input{overflow:visible;}button,select{text-transform:none;}button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner{border-style:none;padding:0;}fieldset{padding:0.35em 0.75em 0.625em;}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal;}progress{vertical-align:baseline;}textarea{overflow:auto;}[type="checkbox"],[type="radio"]{box-sizing:border-box;padding:0;}[type="number"]::-webkit-inner-spin-button,[type="number"]::-webkit-outer-spin-button{-webkit-appearance:none!important;}input[type="number"]{-moz-appearance:textfield;}[type="search"]{-webkit-appearance:textfield;outline-offset:-2px;}[type="search"]::-webkit-search-decoration{-webkit-appearance:none!important;}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit;}details{display:block;}summary{display:-webkit-box;display:-webkit-list-item;display:-ms-list-itembox;display:list-item;}template{display:none;}[hidden]{display:none!important;}body,blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0;}button{background:transparent;padding:0;}fieldset{margin:0;padding:0;}ol,ul{margin:0;padding:0;}textarea{resize:vertical;}button,[role="button"]{cursor:pointer;}button::-moz-focus-inner{border:0!important;}table{border-collapse:collapse;}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit;}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit;}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle;}img,video{max-width:100%;height:auto;}[data-js-focus-visible] :focus:not([data-focus-visible-added]){outline:none;box-shadow:none;}select::-ms-expand{display:none;}</style><style data-emotion="css-global 1baqkrf">body{font-family:var(--chakra-fonts-body);color:var(--chakra-colors-gray-800);background:var(--chakra-colors-white);transition-property:background-color;transition-duration:var(--chakra-transition-duration-normal);line-height:var(--chakra-lineHeights-base);}*::-webkit-input-placeholder{color:var(--chakra-colors-gray-400);}*::-moz-placeholder{color:var(--chakra-colors-gray-400);}*:-ms-input-placeholder{color:var(--chakra-colors-gray-400);}*::placeholder{color:var(--chakra-colors-gray-400);}*,*::before,::after{border-color:var(--chakra-colors-gray-200);word-wrap:break-word;}</style><style data-emotion="css d4xd0d">.css-d4xd0d{background-color:var(--chakra-colors-green-50);min-height:100vh;}</style><div class="css-d4xd0d"><style data-emotion="css 50jqoj">.css-50jqoj{width:100%;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;max-width:var(--chakra-sizes-container-lg);-webkit-padding-start:1rem;padding-inline-start:1rem;-webkit-padding-end:1rem;padding-inline-end:1rem;background-color:var(--chakra-colors-green-600);}</style><div class="chakra-container css-50jqoj"><style data-emotion="css jbx4q3">.css-jbx4q3{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:flex-end;-webkit-box-align:flex-end;-ms-flex-align:flex-end;align-items:flex-end;padding:var(--chakra-space-8);}</style><div class="css-jbx4q3"><style data-emotion="css 1dklj6k">.css-1dklj6k{font-family:var(--chakra-fonts-heading);font-weight:var(--chakra-fontWeights-bold);font-size:var(--chakra-fontSizes-3xl);line-height:1.33;}@media screen and (min-width: 48em){.css-1dklj6k{font-size:var(--chakra-fontSizes-4xl);line-height:1.2;}}</style><h2 class="chakra-heading css-1dklj6k"><style data-emotion="css 1naxmyz">.css-1naxmyz{transition-property:var(--chakra-transition-property-common);transition-duration:var(--chakra-transition-duration-fast);transition-timing-function:var(--chakra-transition-easing-ease-out);cursor:pointer;-webkit-text-decoration:none;text-decoration:none;outline:2px solid transparent;outline-offset:2px;color:var(--chakra-colors-white);}.css-1naxmyz:hover,.css-1naxmyz[data-hover]{-webkit-text-decoration:underline;text-decoration:underline;}.css-1naxmyz:focus,.css-1naxmyz[data-focus]{box-shadow:var(--chakra-shadows-outline);}</style><a class="chakra-link css-1naxmyz" href="/"><u class="chakra-text css-0">↗ agatan blog ↗</u></a></h2><style data-emotion="css 17xejub">.css-17xejub{-webkit-flex:1;-ms-flex:1;flex:1;justify-self:stretch;-webkit-align-self:stretch;-ms-flex-item-align:stretch;align-self:stretch;}</style><div class="css-17xejub"></div><div class="css-0"><style data-emotion="css 1awjy5h">.css-1awjy5h{transition-property:var(--chakra-transition-property-common);transition-duration:var(--chakra-transition-duration-fast);transition-timing-function:var(--chakra-transition-easing-ease-out);cursor:pointer;-webkit-text-decoration:none;text-decoration:none;outline:2px solid transparent;outline-offset:2px;color:inherit;padding:var(--chakra-space-2);}.css-1awjy5h:hover,.css-1awjy5h[data-hover]{-webkit-text-decoration:underline;text-decoration:underline;}.css-1awjy5h:focus,.css-1awjy5h[data-focus]{box-shadow:var(--chakra-shadows-outline);}</style><a class="chakra-link css-1awjy5h" href="/feed.xml"><style data-emotion="css sjogs4">.css-sjogs4{width:var(--chakra-sizes-6);height:var(--chakra-sizes-6);display:inline-block;line-height:1em;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;color:var(--chakra-colors-white);}</style><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" focusable="false" class="chakra-icon css-sjogs4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg></a><a class="chakra-link css-1awjy5h" href="/tags"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 640 512" focusable="false" class="chakra-icon css-sjogs4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M497.941 225.941L286.059 14.059A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0 0 14.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zM112 160c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882 0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397 0h48.721a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882z"></path></svg></a></div></div></div><style data-emotion="css 8shb6n">.css-8shb6n{width:100%;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;max-width:var(--chakra-sizes-container-lg);-webkit-padding-start:1rem;padding-inline-start:1rem;-webkit-padding-end:1rem;padding-inline-end:1rem;background-color:var(--chakra-colors-white);min-height:100vh;}</style><div class="chakra-container css-8shb6n"><style data-emotion="css 10qlibn">.css-10qlibn{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;padding-top:var(--chakra-space-4);padding-bottom:var(--chakra-space-4);}</style><div class="css-10qlibn"><style data-emotion="css 8jfdow">.css-8jfdow{width:100%;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;max-width:var(--chakra-sizes-container-lg);-webkit-padding-start:1rem;padding-inline-start:1rem;-webkit-padding-end:1rem;padding-inline-end:1rem;padding:0px;margin:0px;}</style><div class="chakra-container css-8jfdow"><style data-emotion="css nm5t63">.css-nm5t63{width:100%;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;max-width:var(--chakra-sizes-container-md);-webkit-padding-start:1rem;padding-inline-start:1rem;-webkit-padding-end:1rem;padding-inline-end:1rem;}</style><div class="chakra-container css-nm5t63"><style data-emotion="css u3hp4h">.css-u3hp4h{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;padding-top:var(--chakra-space-4);padding-bottom:var(--chakra-space-4);}</style><div class="chakra-stack css-u3hp4h"><div class="chakra-container css-nm5t63"><style data-emotion="css 18j379d">.css-18j379d{font-family:var(--chakra-fonts-heading);font-weight:var(--chakra-fontWeights-bold);font-size:var(--chakra-fontSizes-xl);line-height:1.2;}</style><h2 class="chakra-heading css-18j379d"><style data-emotion="css f4h6uy">.css-f4h6uy{transition-property:var(--chakra-transition-property-common);transition-duration:var(--chakra-transition-duration-fast);transition-timing-function:var(--chakra-transition-easing-ease-out);cursor:pointer;-webkit-text-decoration:none;text-decoration:none;outline:2px solid transparent;outline-offset:2px;color:inherit;}.css-f4h6uy:hover,.css-f4h6uy[data-hover]{-webkit-text-decoration:underline;text-decoration:underline;}.css-f4h6uy:focus,.css-f4h6uy[data-focus]{box-shadow:var(--chakra-shadows-outline);}</style><a class="chakra-link css-f4h6uy" href="/posts/pgjdbc-error-code">pgjdbc の SQLException.getErrorCode() は常に 0 を返す</a></h2><style data-emotion="css jgpr3k">.css-jgpr3k{color:var(--chakra-colors-gray-800);}</style><p class="chakra-text css-jgpr3k">Wed Jun 23 2021</p><style data-emotion="css 1kqpisq">.css-1kqpisq{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;padding-top:var(--chakra-space-4);padding-bottom:var(--chakra-space-4);}.css-1kqpisq>*:not(style)~*:not(style){margin-top:0px;-webkit-margin-end:0px;margin-inline-end:0px;margin-bottom:0px;-webkit-margin-start:0px;margin-inline-start:0px;}</style><div class="chakra-stack css-1kqpisq"><style data-emotion="css 1h1f62l">.css-1h1f62l{transition-property:var(--chakra-transition-property-common);transition-duration:var(--chakra-transition-duration-fast);transition-timing-function:var(--chakra-transition-easing-ease-out);cursor:pointer;-webkit-text-decoration:none;text-decoration:none;outline:2px solid transparent;outline-offset:2px;color:inherit;padding:var(--chakra-space-1);}.css-1h1f62l:hover,.css-1h1f62l[data-hover]{-webkit-text-decoration:underline;text-decoration:underline;}.css-1h1f62l:focus,.css-1h1f62l[data-focus]{box-shadow:var(--chakra-shadows-outline);}</style><a class="chakra-link css-1h1f62l" href="/tags/Java"><style data-emotion="css 6rl2qk">.css-6rl2qk{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;vertical-align:top;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;max-width:100%;font-weight:var(--chakra-fontWeights-medium);line-height:1.2;outline:2px solid transparent;outline-offset:2px;min-height:1.5rem;min-width:1.5rem;font-size:var(--chakra-fontSizes-sm);border-radius:var(--chakra-radii-md);-webkit-padding-start:var(--chakra-space-2);padding-inline-start:var(--chakra-space-2);-webkit-padding-end:var(--chakra-space-2);padding-inline-end:var(--chakra-space-2);color:#3182ce;box-shadow:inset 0 0 0px 1px #3182ce;padding:var(--chakra-space-1);}.css-6rl2qk:focus,.css-6rl2qk[data-focus]{box-shadow:var(--chakra-shadows-outline);}</style><span class="css-6rl2qk"><style data-emotion="css 1qpz0yi">.css-1qpz0yi{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding-left:var(--chakra-space-1);padding-right:var(--chakra-space-1);}</style><div class="css-1qpz0yi"><style data-emotion="css 1uhrip0">.css-1uhrip0{line-height:1.2;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:small;}</style><span class="css-1uhrip0">Java</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/Kotlin"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">Kotlin</span></div></span></a></div></div><style data-emotion="css 1q5cbl">.css-1q5cbl{border-width:0;-webkit-align-self:stretch;-ms-flex-item-align:stretch;align-self:stretch;border-color:inherit;width:auto;height:auto;}.css-1q5cbl{margin-top:var(--chakra-space-4);margin-bottom:var(--chakra-space-4);-webkit-margin-start:0px;margin-inline-start:0px;-webkit-margin-end:0px;margin-inline-end:0px;border-left-width:0;border-bottom-width:1px;}</style><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/atmacup5th">atmaCup #5 に参加してきて Private 29 位（Public 27 位）でした！</a></h2><p class="chakra-text css-jgpr3k">Sun Jun 07 2020</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/【論文読み】_Multi-Oriented_Scene_Text_Detection_via_Corner_Localization_and_Region_Segmentation">【論文読み】 Multi-Oriented Scene Text Detection via Corner Localization and Region Segmentation</a></h2><p class="chakra-text css-jgpr3k">Tue Feb 12 2019</p><div class="chakra-stack css-1kqpisq"><a class="chakra-link css-1h1f62l" href="/tags/画像処理"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">画像処理</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/DeepLearning"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">DeepLearning</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/OCR"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">OCR</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/論文読み"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">論文読み</span></div></span></a></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/【論文読み】Semi-convolutional_Operators_for_Instance_Segmentation">【論文読み】Semi-convolutional Operators for Instance Segmentation</a></h2><p class="chakra-text css-jgpr3k">Mon Feb 11 2019</p><div class="chakra-stack css-1kqpisq"><a class="chakra-link css-1h1f62l" href="/tags/DeepLearning"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">DeepLearning</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/論文読み"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">論文読み</span></div></span></a></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/【論文紹介】Concurrent_Spatial_and_Channel_Squeeze_&amp;_Excitation_in_Fully_Convolutional_Networks">【論文紹介】Concurrent Spatial and Channel Squeeze &amp; Excitation in Fully Convolutional Networks</a></h2><p class="chakra-text css-jgpr3k">Fri Jan 04 2019</p><div class="chakra-stack css-1kqpisq"><a class="chakra-link css-1h1f62l" href="/tags/Python"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">Python</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/DeepLearning"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">DeepLearning</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/Keras"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">Keras</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/TensorFlow"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">TensorFlow</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/論文読み"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">論文読み</span></div></span></a></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/DKN:_Deep_Knowledge-Aware_Network_for_News_Recommendation">DKN: Deep Knowledge-Aware Network for News Recommendation</a></h2><p class="chakra-text css-jgpr3k">Wed Dec 19 2018</p><div class="chakra-stack css-1kqpisq"><a class="chakra-link css-1h1f62l" href="/tags/DeepLearning"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">DeepLearning</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/WWW"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">WWW</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/Recommendation"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">Recommendation</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/論文読み"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">論文読み</span></div></span></a></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/ILSVRC_2017_画像分類_Top_の手法_Squeeze-and-Excitation_Networks">ILSVRC 2017 画像分類 Top の手法 Squeeze-and-Excitation Networks</a></h2><p class="chakra-text css-jgpr3k">Thu Dec 13 2018</p><div class="chakra-stack css-1kqpisq"><a class="chakra-link css-1h1f62l" href="/tags/画像処理"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">画像処理</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/ComputerVision"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">ComputerVision</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/MachineLearning"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">MachineLearning</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/DeepLearning"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">DeepLearning</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/CNN"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">CNN</span></div></span></a></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Object_間の関係を使って後処理_0_の物体検出を実現する:_Relation_Networks_for_Object_Detection">Object 間の関係を使って後処理 0 の物体検出を実現する: Relation Networks for Object Detection</a></h2><p class="chakra-text css-jgpr3k">Mon Dec 10 2018</p><div class="chakra-stack css-1kqpisq"><a class="chakra-link css-1h1f62l" href="/tags/画像処理"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">画像処理</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/DeepLearning"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">DeepLearning</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/論文読み"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">論文読み</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/物体検出"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">物体検出</span></div></span></a></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/簡単な問題は省エネで解き、難しい問題には全力を出すネットワーク:_Multi-Scale_Dense_Networks">簡単な問題は省エネで解き、難しい問題には全力を出すネットワーク: Multi-Scale Dense Networks</a></h2><p class="chakra-text css-jgpr3k">Fri Dec 07 2018</p><div class="chakra-stack css-1kqpisq"><a class="chakra-link css-1h1f62l" href="/tags/DeepLearning"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">DeepLearning</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/論文読み"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">論文読み</span></div></span></a></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/focal-loss">[論文紹介] Focal Loss for Dense Object Detection</a></h2><p class="chakra-text css-jgpr3k">Mon Dec 03 2018</p><div class="chakra-stack css-1kqpisq"><a class="chakra-link css-1h1f62l" href="/tags/MachineLearning"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">MachineLearning</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/paper"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">paper</span></div></span></a></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/[論文紹介]_Focal_Loss_for_Dense_Object_Detection">[論文紹介] Focal Loss for Dense Object Detection</a></h2><p class="chakra-text css-jgpr3k">Sun Dec 02 2018</p><div class="chakra-stack css-1kqpisq"><a class="chakra-link css-1h1f62l" href="/tags/DeepLearning"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">DeepLearning</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/論文読み"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">論文読み</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/ICCV"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">ICCV</span></div></span></a></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/applying-deeplearning-to-airbnb-search-papser">&amp;quot;Applying Deep Learning To Airbnb Search&amp;quot;  を読んだ</a></h2><p class="chakra-text css-jgpr3k">Wed Nov 21 2018</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/個人のメモ・ノートを保存するサービス選び">個人のメモ・ノートを保存するサービス選び</a></h2><p class="chakra-text css-jgpr3k">Fri Jan 19 2018</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/golang_でテストのために時間を操作するライブラリ_timejump">golang でテストのために時間を操作するライブラリ timejump</a></h2><p class="chakra-text css-jgpr3k">Thu Dec 14 2017</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/ISUCON_7_本戦出場してきました_「都営三田線東急目黒線直通急行日吉行」">ISUCON 7 本戦出場してきました 「都営三田線東急目黒線直通急行日吉行」</a></h2><p class="chakra-text css-jgpr3k">Sun Nov 26 2017</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/ISUCON7予選1日目に「都営三田線」で参加して通過できた話">ISUCON7予選1日目に「都営三田線」で参加して通過できた話</a></h2><p class="chakra-text css-jgpr3k">Mon Oct 23 2017</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/go_generate_する時のバイナリのバージョンを固定したい">go generate する時のバイナリのバージョンを固定したい</a></h2><p class="chakra-text css-jgpr3k">Sat Aug 05 2017</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Rust_で_Unix_のシグナルを_channel_経由でキャッチする">Rust で Unix のシグナルを channel 経由でキャッチする</a></h2><p class="chakra-text css-jgpr3k">Mon Jul 10 2017</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/BK-tree_を_golang_で実装した">BK-tree を golang で実装した</a></h2><p class="chakra-text css-jgpr3k">Sat May 13 2017</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Rust_でグラフ構造や木構造を作る">Rust でグラフ構造や木構造を作る</a></h2><p class="chakra-text css-jgpr3k">Mon Jan 16 2017</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/mio_で_echo_サーバメモ">mio で echo サーバメモ</a></h2><p class="chakra-text css-jgpr3k">Sat Jan 07 2017</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/NCurses_の_Crystal_binding_を作った">NCurses の Crystal binding を作った</a></h2><p class="chakra-text css-jgpr3k">Thu Dec 08 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Rust_で_Box_に包まれた構造体の所有権分解">Rust で Box に包まれた構造体の所有権分解</a></h2><p class="chakra-text css-jgpr3k">Sun Dec 04 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/日本語の改行を適当にいい感じにするツールを作りました">日本語の改行を適当にいい感じにするツールを作りました</a></h2><p class="chakra-text css-jgpr3k">Sat Oct 29 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Rust_の_Result_と_Iterator">Rust の Result と Iterator</a></h2><p class="chakra-text css-jgpr3k">Mon Sep 05 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/値と参照について">値と参照について</a></h2><p class="chakra-text css-jgpr3k">Sun Aug 14 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/再帰的_grep_ツール_crepe_を作っています">再帰的 grep ツール crepe を作っています</a></h2><p class="chakra-text css-jgpr3k">Fri Jul 08 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/C++_で_result_型を作る">C++ で result 型を作る</a></h2><p class="chakra-text css-jgpr3k">Fri Jul 01 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/C++テンプレートイディオム_CRTP">C++テンプレートイディオム CRTP</a></h2><p class="chakra-text css-jgpr3k">Thu Jun 16 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/C++_のテンプレートの実装">C++ のテンプレートの実装</a></h2><p class="chakra-text css-jgpr3k">Mon Jun 13 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/C++_のテンプレートについてまとめるのまとめ">C++ のテンプレートについてまとめるのまとめ</a></h2><p class="chakra-text css-jgpr3k">Fri Jun 03 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/C++_テンプレートの種類と構文">C++ テンプレートの種類と構文</a></h2><p class="chakra-text css-jgpr3k">Tue May 31 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/C++_:_なぜテンプレートが必要なのか">C++ : なぜテンプレートが必要なのか</a></h2><p class="chakra-text css-jgpr3k">Mon May 30 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Rust_のパーサコンビネータライブラリ_combine_を使う時の_tips">Rust のパーサコンビネータライブラリ combine を使う時の tips</a></h2><p class="chakra-text css-jgpr3k">Sat May 14 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/C++_でパーサコンビネータを書きました">C++ でパーサコンビネータを書きました</a></h2><p class="chakra-text css-jgpr3k">Fri Apr 29 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Rust_における_return文の_LLVM_IR_表現について">Rust における return文の LLVM IR 表現について</a></h2><p class="chakra-text css-jgpr3k">Wed Apr 13 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/C++_の複雑な型を整形するプログラムを作りました">C++ の複雑な型を整形するプログラムを作りました</a></h2><p class="chakra-text css-jgpr3k">Tue Mar 08 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Type_Erasure_による_Visitor_パターンの実装">Type Erasure による Visitor パターンの実装</a></h2><p class="chakra-text css-jgpr3k">Mon Jan 25 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/include-cpp-vim-plugin">#include をソートするVimプラグインを作りました</a></h2><p class="chakra-text css-jgpr3k">Sun Jan 24 2016</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/コンパイラ内部の_AST_表現について">コンパイラ内部の AST 表現について</a></h2><p class="chakra-text css-jgpr3k">Tue Dec 29 2015</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Boost.Spirit.X3_で簡易電卓を実装_1">Boost.Spirit.X3 で簡易電卓を実装 1</a></h2><p class="chakra-text css-jgpr3k">Fri Dec 18 2015</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Boost.Spirit.X3_の練習_2">Boost.Spirit.X3 の練習 2</a></h2><p class="chakra-text css-jgpr3k">Thu Dec 17 2015</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Boost.Spirit.X3_の練習1">Boost.Spirit.X3 の練習1</a></h2><p class="chakra-text css-jgpr3k">Thu Dec 17 2015</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Sokoban.nim_を書いてみた">Sokoban.nim を書いてみた</a></h2><p class="chakra-text css-jgpr3k">Thu Oct 29 2015</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Golang_での文字列連結に関するベンチマーク">Golang での文字列連結に関するベンチマーク</a></h2><p class="chakra-text css-jgpr3k">Tue Sep 08 2015</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Golangでechoサーバ">Golangでechoサーバ</a></h2><p class="chakra-text css-jgpr3k">Tue Sep 08 2015</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Haskellでechoサーバ">Haskellでechoサーバ</a></h2><p class="chakra-text css-jgpr3k">Thu Jul 23 2015</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/HaskellのConcurrentについて調べてまとめる_(MVar編)">HaskellのConcurrentについて調べてまとめる (MVar編)</a></h2><p class="chakra-text css-jgpr3k">Wed Jul 22 2015</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/HaskellのConcurrentについて調べてまとめる_(IORef編)">HaskellのConcurrentについて調べてまとめる (IORef編)</a></h2><p class="chakra-text css-jgpr3k">Tue Jul 21 2015</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/yukicoder_2015_05_08">yukicoder 2015/05/08</a></h2><p class="chakra-text css-jgpr3k">Fri May 08 2015</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/yukicoder_2015_05_03">yukicoder 2015/05/03</a></h2><p class="chakra-text css-jgpr3k">Mon May 04 2015</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/【yukicoder】yukicoder_open_2015_small_-_3完">【yukicoder】yukicoder open 2015 small - 3完</a></h2><p class="chakra-text css-jgpr3k">Sun Apr 26 2015</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/【AtCoder】ABC022_-_競技プログラミング初挑戦！">【AtCoder】ABC022 - 競技プログラミング初挑戦！</a></h2><p class="chakra-text css-jgpr3k">Sat Apr 25 2015</p><div class="chakra-stack css-1kqpisq"></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Rustで自作シェルもどきを作る(単純なコマンド実行編)">Rustで自作シェルもどきを作る(単純なコマンド実行編)</a></h2><p class="chakra-text css-jgpr3k">Sun Dec 21 2014</p><div class="chakra-stack css-1kqpisq"><a class="chakra-link css-1h1f62l" href="/tags/Rust"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">Rust</span></div></span></a></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/Rustで自作シェルもどきを作る(字句解析編)">Rustで自作シェルもどきを作る(字句解析編)</a></h2><p class="chakra-text css-jgpr3k">Sat Dec 20 2014</p><div class="chakra-stack css-1kqpisq"><a class="chakra-link css-1h1f62l" href="/tags/Rust"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">Rust</span></div></span></a></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/RubyでLinuxコマンドの再実装(tree編)">RubyでLinuxコマンドの再実装(tree編)</a></h2><p class="chakra-text css-jgpr3k">Thu Oct 16 2014</p><div class="chakra-stack css-1kqpisq"><a class="chakra-link css-1h1f62l" href="/tags/Ruby"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">Ruby</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/Linux"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">Linux</span></div></span></a></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/RubyでLinuxコマンドの再実装(ls編)">RubyでLinuxコマンドの再実装(ls編)</a></h2><p class="chakra-text css-jgpr3k">Mon Oct 13 2014</p><div class="chakra-stack css-1kqpisq"><a class="chakra-link css-1h1f62l" href="/tags/Ruby"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">Ruby</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/Linux"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">Linux</span></div></span></a></div></div><div class="chakra-stack__divider css-1q5cbl"></div><div class="chakra-container css-nm5t63"><h2 class="chakra-heading css-18j379d"><a class="chakra-link css-f4h6uy" href="/posts/QiitaAPIを通じて複数のタグを持つ記事を検索する">QiitaAPIを通じて複数のタグを持つ記事を検索する</a></h2><p class="chakra-text css-jgpr3k">Mon Oct 13 2014</p><div class="chakra-stack css-1kqpisq"><a class="chakra-link css-1h1f62l" href="/tags/Qiita"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">Qiita</span></div></span></a><a class="chakra-link css-1h1f62l" href="/tags/Ruby"><span class="css-6rl2qk"><div class="css-1qpz0yi"><span class="css-1uhrip0">Ruby</span></div></span></a></div></div></div></div></div><style data-emotion="css ul4ode">.css-ul4ode{width:100%;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;max-width:var(--chakra-sizes-44);-webkit-padding-start:1rem;padding-inline-start:1rem;-webkit-padding-end:1rem;padding-inline-end:1rem;}</style><div class="chakra-container css-ul4ode"><style data-emotion="css xkvmla">.css-xkvmla{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:var(--chakra-space-4);}</style><div class="css-xkvmla"><a class="chakra-link css-f4h6uy" href="https://twitter.com/@agatan_"><style data-emotion="css 1piy145">.css-1piy145{position:relative;width:var(--chakra-sizes-20);height:var(--chakra-sizes-20);}</style><div class="css-1piy145"><style data-emotion="css 1phd9a0">.css-1phd9a0{object-fit:cover;}</style><img alt="agatan" class="chakra-image__placeholder css-1phd9a0" layout="fill"/></div><style data-emotion="css 19dx7hn">.css-19dx7hn{text-align:center;font-size:large;}</style><p class="chakra-text css-19dx7hn">@agatan</p></a><style data-emotion="css 84zodg">.css-84zodg{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;}.css-84zodg>*:not(style)~*:not(style){margin-top:0px;-webkit-margin-end:0px;margin-inline-end:0px;margin-bottom:0px;-webkit-margin-start:0.5rem;margin-inline-start:0.5rem;}</style><div class="chakra-stack css-84zodg"><a class="chakra-link css-1h1f62l" href="https://twitter.com/@agatan_"><style data-emotion="css 15e9ude">.css-15e9ude{width:1.2em;height:1.2em;display:inline-block;line-height:1em;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;color:currentColor;}</style><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" focusable="true" class="chakra-icon css-15e9ude" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a><a class="chakra-link css-1h1f62l" href="https://github.com/agatan"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 496 512" focusable="true" class="chakra-icon css-15e9ude" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a></div></div></div></div></div></div><span></span></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postMetas":[{"rawMarkdown":"---\ntitle: pgjdbc の SQLException.getErrorCode() は常に 0 を返す\ndate: 2021-06-23\ntags:\n  - Java\n  - Kotlin\n---\n\n最近になって仕事で初めて JVM 上で動く言語を書いています。\nそこでちょっとハマったことがあり、色々調べて解決したのでメモがてら共有しようと思い、記事にすることにしました。\nもっと遭遇している人多そうなんですが、パッとググった限り日本語でこの問題について言及している記事が見当たらなかったので、有用だと信じています。（経験ある JDBC ユーザにとっては当たり前なんですかね？）\n\n## TL;DR\n\nhttps://github.com/pgjdbc/pgjdbc を使っていると、 `java.sql.SQLException.getErrorCode()` が常に 0 になる。\n代わりに `java.sql.SQLException.getSQLState()` を使おう。\n\n## 問題\n\nUNIQUE 制約をはったテーブルに対して「レコードがすでにあればそれを SELECT する。なければ新規に作る。」という操作をしたいことがあります。\nそういったときに、文字通り「1. まず SELECT し、 2. なかったら INSERT」というふうに実装してしまうと、同時に二つ以上のリクエストが処理されると想定通りの挙動になりません。（1. と 2. の間に別のリクエストによって 2. が実行されるかもしれない。）\nそこで、こういったケースでは「1. まず INSERT を試み、 2. UNIQUE 制約に引っ掛かったら SELECT」というふうに実装するのが正しいです。（Rails 的にいうと `find_or_create_by` ではなく、 `create_or_find_by` しよう、という話です。）\n\n```kotlin\nval record = try {\n    Users.insertAndGet(...)\n} catch (ex: SQLException) {\n    if ( /* ex が UNIQUE VIOLATION である */ ) {\n\t    Users.select(...)\n\t} else {\n\t    throw ex\n\t}\n}\n```\n\nこんな感じです。（疑似コードですが）\n\nさて、ここで `/* ex が UNIQUE VIOLATION である */` ことの確認をする方法が必要です。\n[`java.sql.SQLException` のドキュメント](https://docs.oracle.com/en/java/javase/13/docs/api/java.sql/java/sql/SQLException.html) を見てみると、`int getErrorCode()` という API があるので、これを使ってみます。vendor-specific exception code が取得できる、と説明があります。\n[PostgreSQL のエラーコード一覧](https://www.postgresql.org/docs/13/errcodes-appendix.html) によると、23505 が `unique_violation` らしいので、以下のようなコードで判定できるように見えます。\n\n```kotlin\nconst val UNIQUE_VIOLATION = 23505\nif (ex.errorCode == UNIQUE_VIOLATION) {\n    ...\n}\n```\n\n## 動かない！\n\nこれでテスト書いてうまく動くことを確かめよう〜と思ったら、なぜか全然テストが通らない！\nしかも `SQLException` が投げられていて、その内容が完全に UNIQUE 制約に引っ掛かっているというエラーでした。\n何事...\n\nデバッガで追ってみると、 `ex.errorCode == UNIQUE_VIOLATION` が false になっているようです。エラーは確かに `unique_violation` だというのに。\n\nさらにデバッガでよく見てみると、なんと `ex.errorCode` が 0 になっています。\n何事...\n\n## pgjdbc は getErrorCode に対応していなかった\n\n[PSQLException の実装](https://github.com/pgjdbc/pgjdbc/blob/master/pgjdbc/src/main/java/org/postgresql/util/PSQLException.java) をよく見てみると、そもそも `getErrorCode` の定義がありません。どうやら常にデフォルトの 0 を返すようです。\n\nhttps://github.com/pgjdbc/pgjdbc/pull/623 で対応が試みられていますが Close されています。\nPostgreSQL のエラーコードはアルファベットを含むものもあり、全てを統一的に `getErrorCode` で返すことができないというのが理由でした。\n言われてみれば当たり前だし、確かによくみると [PostgreSQL のエラーコード一覧](https://www.postgresql.org/docs/13/errcodes-appendix.html) にはちらほらアルファベットがありますね...\n\n## 対応\n\n`String SQLException.getSQLState()` を使います。\nさらに [PSQLState](https://github.com/pgjdbc/pgjdbc/blob/master/pgjdbc/src/main/java/org/postgresql/util/PSQLState.java) という enum が定義されているので、これを併用して\n\n```kotlin\nif (ex.sqlState == PSQLState.UNIQUE\\_VIOLATION.state) {\n    ...\n}\n```\n\nとすれば期待通りの挙動になります。\n\n## まとめ\n\nしかしこの挙動、もうちょっとドキュメントとかに書いてくれていてもいいんじゃないかなぁと思ったんですがどうなんでしょう。\n`PSQLException` のドキュメントを見ても何も書いていないんですよね。\nPostgreSQL のドキュメントをちゃんと見れば Error Code が int で表現しきれないことは自明だ、と言われればそれはそうなんですが。\n\npgjdbc の話からは逸れますが、こういう「統一インターフェースを標準で提供するから内部実装は各自ライブラリでやって差し替える」系のライブラリ、統一インターフェースの方のドキュメントばかり読んでしまって個々のライブラリのドキュメントをあまり読まなくても使えてしまうので、こういう罠があるとハマりますね。よくできているということでもあると思います。\n（まぁ今回は個々のライブラリのドキュメントを見ても何も書いていないと思うのですが...）\n\npgjdbc には別の問題でもハマっていて、そっちは PR 出して無事マージ \u0026 リリースされたので、いつかその問題についても書いてみようと思います。\n","contentMarkdown":"\n最近になって仕事で初めて JVM 上で動く言語を書いています。\nそこでちょっとハマったことがあり、色々調べて解決したのでメモがてら共有しようと思い、記事にすることにしました。\nもっと遭遇している人多そうなんですが、パッとググった限り日本語でこの問題について言及している記事が見当たらなかったので、有用だと信じています。（経験ある JDBC ユーザにとっては当たり前なんですかね？）\n\n## TL;DR\n\nhttps://github.com/pgjdbc/pgjdbc を使っていると、 `java.sql.SQLException.getErrorCode()` が常に 0 になる。\n代わりに `java.sql.SQLException.getSQLState()` を使おう。\n\n## 問題\n\nUNIQUE 制約をはったテーブルに対して「レコードがすでにあればそれを SELECT する。なければ新規に作る。」という操作をしたいことがあります。\nそういったときに、文字通り「1. まず SELECT し、 2. なかったら INSERT」というふうに実装してしまうと、同時に二つ以上のリクエストが処理されると想定通りの挙動になりません。（1. と 2. の間に別のリクエストによって 2. が実行されるかもしれない。）\nそこで、こういったケースでは「1. まず INSERT を試み、 2. UNIQUE 制約に引っ掛かったら SELECT」というふうに実装するのが正しいです。（Rails 的にいうと `find_or_create_by` ではなく、 `create_or_find_by` しよう、という話です。）\n\n```kotlin\nval record = try {\n    Users.insertAndGet(...)\n} catch (ex: SQLException) {\n    if ( /* ex が UNIQUE VIOLATION である */ ) {\n\t    Users.select(...)\n\t} else {\n\t    throw ex\n\t}\n}\n```\n\nこんな感じです。（疑似コードですが）\n\nさて、ここで `/* ex が UNIQUE VIOLATION である */` ことの確認をする方法が必要です。\n[`java.sql.SQLException` のドキュメント](https://docs.oracle.com/en/java/javase/13/docs/api/java.sql/java/sql/SQLException.html) を見てみると、`int getErrorCode()` という API があるので、これを使ってみます。vendor-specific exception code が取得できる、と説明があります。\n[PostgreSQL のエラーコード一覧](https://www.postgresql.org/docs/13/errcodes-appendix.html) によると、23505 が `unique_violation` らしいので、以下のようなコードで判定できるように見えます。\n\n```kotlin\nconst val UNIQUE_VIOLATION = 23505\nif (ex.errorCode == UNIQUE_VIOLATION) {\n    ...\n}\n```\n\n## 動かない！\n\nこれでテスト書いてうまく動くことを確かめよう〜と思ったら、なぜか全然テストが通らない！\nしかも `SQLException` が投げられていて、その内容が完全に UNIQUE 制約に引っ掛かっているというエラーでした。\n何事...\n\nデバッガで追ってみると、 `ex.errorCode == UNIQUE_VIOLATION` が false になっているようです。エラーは確かに `unique_violation` だというのに。\n\nさらにデバッガでよく見てみると、なんと `ex.errorCode` が 0 になっています。\n何事...\n\n## pgjdbc は getErrorCode に対応していなかった\n\n[PSQLException の実装](https://github.com/pgjdbc/pgjdbc/blob/master/pgjdbc/src/main/java/org/postgresql/util/PSQLException.java) をよく見てみると、そもそも `getErrorCode` の定義がありません。どうやら常にデフォルトの 0 を返すようです。\n\nhttps://github.com/pgjdbc/pgjdbc/pull/623 で対応が試みられていますが Close されています。\nPostgreSQL のエラーコードはアルファベットを含むものもあり、全てを統一的に `getErrorCode` で返すことができないというのが理由でした。\n言われてみれば当たり前だし、確かによくみると [PostgreSQL のエラーコード一覧](https://www.postgresql.org/docs/13/errcodes-appendix.html) にはちらほらアルファベットがありますね...\n\n## 対応\n\n`String SQLException.getSQLState()` を使います。\nさらに [PSQLState](https://github.com/pgjdbc/pgjdbc/blob/master/pgjdbc/src/main/java/org/postgresql/util/PSQLState.java) という enum が定義されているので、これを併用して\n\n```kotlin\nif (ex.sqlState == PSQLState.UNIQUE\\_VIOLATION.state) {\n    ...\n}\n```\n\nとすれば期待通りの挙動になります。\n\n## まとめ\n\nしかしこの挙動、もうちょっとドキュメントとかに書いてくれていてもいいんじゃないかなぁと思ったんですがどうなんでしょう。\n`PSQLException` のドキュメントを見ても何も書いていないんですよね。\nPostgreSQL のドキュメントをちゃんと見れば Error Code が int で表現しきれないことは自明だ、と言われればそれはそうなんですが。\n\npgjdbc の話からは逸れますが、こういう「統一インターフェースを標準で提供するから内部実装は各自ライブラリでやって差し替える」系のライブラリ、統一インターフェースの方のドキュメントばかり読んでしまって個々のライブラリのドキュメントをあまり読まなくても使えてしまうので、こういう罠があるとハマりますね。よくできているということでもあると思います。\n（まぁ今回は個々のライブラリのドキュメントを見ても何も書いていないと思うのですが...）\n\npgjdbc には別の問題でもハマっていて、そっちは PR 出して無事マージ \u0026 リリースされたので、いつかその問題についても書いてみようと思います。\n","slug":"pgjdbc-error-code","title":"pgjdbc の SQLException.getErrorCode() は常に 0 を返す","timestamp":1624406400000,"tags":["Java","Kotlin"]},{"rawMarkdown":"---\ntitle: \"atmaCup #5 に参加してきて Private 29 位（Public 27 位）でした！\"\ndate: 2020-06-07T11:00:00.000Z\ntags: []\n---\n\n\u003cp\u003eatmaCup #5 に参加してきました！\n\u003ciframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fatma.connpass.com%2Fevent%2F175139%2F\" title=\"【おうちで】atmaCup オンサイトデータコンペ#5 (2020/05/29 18:00〜)\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://atma.connpass.com/event/175139/\"\u003eatma.connpass.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003eKaggle 以外のコンペに参加したのは初めてだったのですが、お祭り感があってとても楽しかったです！\n参加者・運営全体で盛り上げていく雰囲気があったので、初参加でしたが最後までモチベーション高く取り組み続けることができました。\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Twitter\"\u003eTwitter\u003c/a\u003e TL でよく見かける方々と競えるので燃えました。\u003c/p\u003e\n\n\u003cp\u003e運営のみなさま、本当にありがとうございました！ぜひまた参加したいです！\u003c/p\u003e\n\n\u003ch3\u003e問題設定\u003c/h3\u003e\n\n\u003cp\u003e2 値分類タスクで、評価指標は PR-AUC でした。\n正例が少なく、指標も PR-AUC だったので、CV / LB が安定しなかったのが悩ましいところでした。\u003c/p\u003e\n\n\u003ch3\u003eコンペ中の動き\u003c/h3\u003e\n\n\u003cp\u003e1 週間の開催で短期決戦だったので、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C9%A5%E1%A5%A4%A5%F3\"\u003eドメイン\u003c/a\u003e知識の獲得から始める余裕はないと判断して、CNN 様に抽出していただく戦略を取りました。（結果的にそこそこ NN チューニングに時間を使ったので、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C9%A5%E1%A5%A4%A5%F3\"\u003eドメイン\u003c/a\u003e知識をちゃんと学びに行けばよかったとやや後悔しています）\nまた、短期決戦前提の書き殴り実験をしまくってしまったので、自分が何をやっていたのか正確な記録が無く終盤若干混乱しました。1 週間だったのでギリギリなんとかなりましたが、Kaggle みたいな長期戦は厳しそうなので、そっちに挑む際はもうちょっと丁寧に生きた方が良さそう。仮に入賞したとしても再現できるようにするコストがものすごく高い実装になってしまっていました...\u003c/p\u003e\n\n\u003cp\u003e実験管理を mlflow でやったのですが、結構よかったです。\n最終日はローカルを投げ捨てて \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GPU\"\u003eGPU\u003c/a\u003e 使い始めたので、今までローカルに積み上げてきた実験との比較が若干厄介でした。（統合せず、別の \u003ccode\u003emlflow ui\u003c/code\u003e をタブで開いて眺めていました...）\nただ、CV 戦略を変えたり評価指標をいじったときに、同条件で単純比較できない実験にもかかわらずそれが同じテーブルに並んでしまうのが悩ましいなと思いました。\n時系列で並んでいるうちは良いのですが、指標ごとにソートすると本当にどれが信じられる結果なのかわかり辛くなってしまいました。\nこのあたりはタグなどを活用すると良いのかもしれない？もしくは CV などの設計が変わった時点できちんと experiment のレベルで分離すべきだった気がします。\u003c/p\u003e\n\n\u003cp\u003eまた、実は事前にちょこっとだけ準備していて、「学習データ、テストデータ、CV、モデル、評価関数」あたりを渡すと mlflow にログを書きつつ CV 評価して oof と test の prediction をはく薄い wrapper を書いていました。\n最初はまぁ使えていたんですが、NN のことを全く想定していなかったので NN に移った時点で全く使えなくなってしまったのと、細かいことをやりだすとやっぱり wrap された内部に手を入れたくなってしまって厳しかったです。\n予想はしていたので相当薄めに作ったつもりだったのですが、それでもこうなっちゃうか〜という感じでちょっと辛い。\nライブラリとしての作りにしたのが間違いだったのかもと思っています。ライブラリだと内部にコンペ固有の変更を入れるのは厳しいので。\n単なる\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%CB%A5%DA%A5%C3%A5%C8\"\u003eスニペット\u003c/a\u003e集にしておいて、コンペ中はゴリゴリ内部も書き換える前提で使った方が良さそう。\u003c/p\u003e\n\n\u003ch3\u003eやったこと\u003c/h3\u003e\n\n\u003cp\u003e以下は Discussion にも投稿した内容とほぼ同じですが、こちらにも書いておきます。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://guruguru.ml/competitions/10/discussions/34d99be1-ab52-4868-a46c-45a24fac8308/\"\u003e\u0026#x3050;\u0026#x308B;\u0026#x3050;\u0026#x308B;\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e中盤まで CV スコアすら安定せず、ちょっとシードを変えるだけで大きくスコアが変動してしまっていました。\nそのため、正直何が効いていて何が効かなかったのかの判断を誤っていた可能性が高いです...\u003c/p\u003e\n\n\u003cp\u003e何をやっても安定しなかったので、最終盤にやけになってアンサンブルで誤魔化す作戦に出たのですが、これは結果的によかったと思います。\n特に、CV がある程度安定して比較可能になったおかげで、打つべき手の選択を見誤り辛くなったのが大きかったです。\n逆にいえばもっと早くこれをやっておけば、もう少し良いモデルを作れたかも？と反省しています。次回に活かしたいです。\u003c/p\u003e\n\n\u003cp\u003e最終サブは CNN と、それをベースに stacking した LightGBM の 2 つを出していました。\u003c/p\u003e\n\n\u003ch4\u003eCNN\u003c/h4\u003e\n\n\u003cul\u003e\n\u003cli\u003e正規化 / Scaling を全くせずナイーブに Conv1D ベースの NN に突っ込む\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e((Skip Connection + Conv1D (kernel_size=5) → BatchNorm (or GroupNorm) → ReLU) * 2 → AveragePooling1D (pool_size=2, strides=2)) * 3 → GlobalAveragePooling と GlobalMaxPooling の concat\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eテーブル特徴量は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/MLP\"\u003eMLP\u003c/a\u003e を通して CNN の出力に Concatenate した\n\n\u003cul\u003e\n\u003cli\u003e採用した特徴量は beta, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/rms\"\u003erms\u003c/a\u003e, params1 ~ 6, tsfresh の特徴量たちの中から LightGBM での feature importance が上位 100 以内だったものを取ってきただけ\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eテーブル特徴量を \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/MLP\"\u003eMLP\u003c/a\u003e に通したものを CNN の途中でに足したらなぜかスコアが上がったので採用\n\n\u003cul\u003e\n\u003cli\u003e本当はテーブル特徴量を使って、どの領域に注目するかの Attention の計算をしようと思っていたが、そちらはスコアが上がらず...\u003c/li\u003e\n\u003cli\u003e悔しいので惰性で試した加算がなぜか効いた\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e始めは BN を使っていたが安定しなかった。極端に大きい入力が入ってきたときに BN の statistics がぶっ飛ぶのが悪いのでは、とあたりをつけて GN に変更したところ、伸びはしなかったが安定性が増したように見えたので採用。\u003c/li\u003e\n\u003cli\u003eOptimizer は AdamW を使っていたが安定しなかったので、SWA / Lookahead を試したところどちらも安定性の向上を確認できた。最終性能はほぼ変わらなかったが、Lookahead の方が収束が速かったのと個人的に好きだったので採用。\n\n\u003cul\u003e\n\u003cli\u003eLookahead 採用後は BN でも安定したので、最終的には BN / GN 両方のモデルを作って rank average した。\u003c/li\u003e\n\u003cli\u003e\u0026amp; CosineDecay with linear warmup\u003c/li\u003e\n\u003cli\u003eval prauc で early stopping\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e学習中に checkpoint をとっておき、val loss がよかった 5 epoch 分のモデルの出力の平均を使用\u003c/li\u003e\n\u003cli\u003eclass weight つき binary crossentropy loss\n\n\u003cul\u003e\n\u003cli\u003eclass imbalance については \u003ca href=\"https://www.tensorflow.org/tutorials/structured_data/imbalanced_data#train_on_the_oversampled_data\"\u003ehttps://www.tensorflow.org/tutorials/structured_data/imbalanced_data#train_on_the_oversampled_data\u003c/a\u003e をベースに戦略を立てていました\u003c/li\u003e\n\u003cli\u003eいくつか試しましたが、結局シンプルな class weight が一番よかったです\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCV 戦略は StratifiedKFold(k=5)\n\n\u003cul\u003e\n\u003cli\u003eタスク的には StratifiedKFold じゃまずそうと思いつつも、Group, StratifiedGroup は CV / LB の相関が取れなかったのと、seed を変えた時の暴れ方がすごくて断念\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003eLightGBM\u003c/h4\u003e\n\n\u003cp\u003eこちらは最終日にもう何も思い付かず、とはいえサブを余らせて終わるのも悔しかったので、やってみるかぁという惰性で挑戦したものでした。\nCV は Stacking した LightGBM の方がかなり高かったので興奮したのですが、流石に怖かったので CNN も提出していました。\n結論としてはどちらも  Public / Private 共にほぼ差はなかったです。\u003c/p\u003e\n\n\u003cp\u003e時間がなかったのであまり検証はできず、勘で良さそうな構成を選ぶしかなかったのですが、最終的に採用したのは以下のような構成です。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eCNN (BN, GN) の出力を rank にしたもの + テーブル特徴量全部盛り\u003c/li\u003e\n\u003cli\u003eoptuna の LightGBMCVTuner でハイパラ選択\u003c/li\u003e\n\u003cli\u003e2 Seed Average (Rank Average)\u003c/li\u003e\n\u003cli\u003eimbalance 対策は undersampling + bagging\n\n\u003cul\u003e\n\u003cli\u003e1 : 10 になるように undersampling したデータで普通に 20 モデル作り、単純に平均をとった\u003c/li\u003e\n\u003cli\u003e1:1 にしたり \u003ccode\u003eis_unbalance=True\u003c/code\u003e にしたりいくつか実験しましたが、これがもっとも CV が高かったです\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003eうまくいかなかったこと\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eAttention\n\n\u003cul\u003e\n\u003cli\u003eTransformer ベースのモデルと、Conv ベースモデルに MultiHeadAttention を足したものの両方を試しましたが、どちらも work せず\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSqueeze and Excitation\u003c/li\u003e\n\u003cli\u003eSeparableConv1D にして層を増やす\u003c/li\u003e\n\u003cli\u003eKernel Size を増やす\u003c/li\u003e\n\u003cli\u003eNN で Undersampling + Bagging\u003c/li\u003e\n\u003cli\u003e生データの scaling\n\n\u003cul\u003e\n\u003cli\u003eStandardize や 99.9%ile で clip した方が学習は安定したが、スコアがものすごく下がった...\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e(Denoising) Variational Auto Encoder\n\n\u003cul\u003e\n\u003cli\u003etrain/test で chip が違うことがわかっていたので、教師なし事前学習 → \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/finetune\"\u003efinetune\u003c/a\u003e したら LB 上がるのでは、という目論見\u003c/li\u003e\n\u003cli\u003eReconstruction Error と Encoder の出力 64 次元ベクトルを LightGBM に食わせるのも試したが work せず\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C8%F9%CA%AC\"\u003e微分\u003c/a\u003eして入力チャネルに追加して CNN に通す\u003c/li\u003e\n\u003c/ul\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eatmaCup #5 に参加してきました！\n\u003ciframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fatma.connpass.com%2Fevent%2F175139%2F\" title=\"【おうちで】atmaCup オンサイトデータコンペ#5 (2020/05/29 18:00〜)\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://atma.connpass.com/event/175139/\"\u003eatma.connpass.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003eKaggle 以外のコンペに参加したのは初めてだったのですが、お祭り感があってとても楽しかったです！\n参加者・運営全体で盛り上げていく雰囲気があったので、初参加でしたが最後までモチベーション高く取り組み続けることができました。\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Twitter\"\u003eTwitter\u003c/a\u003e TL でよく見かける方々と競えるので燃えました。\u003c/p\u003e\n\n\u003cp\u003e運営のみなさま、本当にありがとうございました！ぜひまた参加したいです！\u003c/p\u003e\n\n\u003ch3\u003e問題設定\u003c/h3\u003e\n\n\u003cp\u003e2 値分類タスクで、評価指標は PR-AUC でした。\n正例が少なく、指標も PR-AUC だったので、CV / LB が安定しなかったのが悩ましいところでした。\u003c/p\u003e\n\n\u003ch3\u003eコンペ中の動き\u003c/h3\u003e\n\n\u003cp\u003e1 週間の開催で短期決戦だったので、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C9%A5%E1%A5%A4%A5%F3\"\u003eドメイン\u003c/a\u003e知識の獲得から始める余裕はないと判断して、CNN 様に抽出していただく戦略を取りました。（結果的にそこそこ NN チューニングに時間を使ったので、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C9%A5%E1%A5%A4%A5%F3\"\u003eドメイン\u003c/a\u003e知識をちゃんと学びに行けばよかったとやや後悔しています）\nまた、短期決戦前提の書き殴り実験をしまくってしまったので、自分が何をやっていたのか正確な記録が無く終盤若干混乱しました。1 週間だったのでギリギリなんとかなりましたが、Kaggle みたいな長期戦は厳しそうなので、そっちに挑む際はもうちょっと丁寧に生きた方が良さそう。仮に入賞したとしても再現できるようにするコストがものすごく高い実装になってしまっていました...\u003c/p\u003e\n\n\u003cp\u003e実験管理を mlflow でやったのですが、結構よかったです。\n最終日はローカルを投げ捨てて \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GPU\"\u003eGPU\u003c/a\u003e 使い始めたので、今までローカルに積み上げてきた実験との比較が若干厄介でした。（統合せず、別の \u003ccode\u003emlflow ui\u003c/code\u003e をタブで開いて眺めていました...）\nただ、CV 戦略を変えたり評価指標をいじったときに、同条件で単純比較できない実験にもかかわらずそれが同じテーブルに並んでしまうのが悩ましいなと思いました。\n時系列で並んでいるうちは良いのですが、指標ごとにソートすると本当にどれが信じられる結果なのかわかり辛くなってしまいました。\nこのあたりはタグなどを活用すると良いのかもしれない？もしくは CV などの設計が変わった時点できちんと experiment のレベルで分離すべきだった気がします。\u003c/p\u003e\n\n\u003cp\u003eまた、実は事前にちょこっとだけ準備していて、「学習データ、テストデータ、CV、モデル、評価関数」あたりを渡すと mlflow にログを書きつつ CV 評価して oof と test の prediction をはく薄い wrapper を書いていました。\n最初はまぁ使えていたんですが、NN のことを全く想定していなかったので NN に移った時点で全く使えなくなってしまったのと、細かいことをやりだすとやっぱり wrap された内部に手を入れたくなってしまって厳しかったです。\n予想はしていたので相当薄めに作ったつもりだったのですが、それでもこうなっちゃうか〜という感じでちょっと辛い。\nライブラリとしての作りにしたのが間違いだったのかもと思っています。ライブラリだと内部にコンペ固有の変更を入れるのは厳しいので。\n単なる\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%CB%A5%DA%A5%C3%A5%C8\"\u003eスニペット\u003c/a\u003e集にしておいて、コンペ中はゴリゴリ内部も書き換える前提で使った方が良さそう。\u003c/p\u003e\n\n\u003ch3\u003eやったこと\u003c/h3\u003e\n\n\u003cp\u003e以下は Discussion にも投稿した内容とほぼ同じですが、こちらにも書いておきます。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://guruguru.ml/competitions/10/discussions/34d99be1-ab52-4868-a46c-45a24fac8308/\"\u003e\u0026#x3050;\u0026#x308B;\u0026#x3050;\u0026#x308B;\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e中盤まで CV スコアすら安定せず、ちょっとシードを変えるだけで大きくスコアが変動してしまっていました。\nそのため、正直何が効いていて何が効かなかったのかの判断を誤っていた可能性が高いです...\u003c/p\u003e\n\n\u003cp\u003e何をやっても安定しなかったので、最終盤にやけになってアンサンブルで誤魔化す作戦に出たのですが、これは結果的によかったと思います。\n特に、CV がある程度安定して比較可能になったおかげで、打つべき手の選択を見誤り辛くなったのが大きかったです。\n逆にいえばもっと早くこれをやっておけば、もう少し良いモデルを作れたかも？と反省しています。次回に活かしたいです。\u003c/p\u003e\n\n\u003cp\u003e最終サブは CNN と、それをベースに stacking した LightGBM の 2 つを出していました。\u003c/p\u003e\n\n\u003ch4\u003eCNN\u003c/h4\u003e\n\n\u003cul\u003e\n\u003cli\u003e正規化 / Scaling を全くせずナイーブに Conv1D ベースの NN に突っ込む\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e((Skip Connection + Conv1D (kernel_size=5) → BatchNorm (or GroupNorm) → ReLU) * 2 → AveragePooling1D (pool_size=2, strides=2)) * 3 → GlobalAveragePooling と GlobalMaxPooling の concat\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eテーブル特徴量は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/MLP\"\u003eMLP\u003c/a\u003e を通して CNN の出力に Concatenate した\n\n\u003cul\u003e\n\u003cli\u003e採用した特徴量は beta, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/rms\"\u003erms\u003c/a\u003e, params1 ~ 6, tsfresh の特徴量たちの中から LightGBM での feature importance が上位 100 以内だったものを取ってきただけ\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eテーブル特徴量を \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/MLP\"\u003eMLP\u003c/a\u003e に通したものを CNN の途中でに足したらなぜかスコアが上がったので採用\n\n\u003cul\u003e\n\u003cli\u003e本当はテーブル特徴量を使って、どの領域に注目するかの Attention の計算をしようと思っていたが、そちらはスコアが上がらず...\u003c/li\u003e\n\u003cli\u003e悔しいので惰性で試した加算がなぜか効いた\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e始めは BN を使っていたが安定しなかった。極端に大きい入力が入ってきたときに BN の statistics がぶっ飛ぶのが悪いのでは、とあたりをつけて GN に変更したところ、伸びはしなかったが安定性が増したように見えたので採用。\u003c/li\u003e\n\u003cli\u003eOptimizer は AdamW を使っていたが安定しなかったので、SWA / Lookahead を試したところどちらも安定性の向上を確認できた。最終性能はほぼ変わらなかったが、Lookahead の方が収束が速かったのと個人的に好きだったので採用。\n\n\u003cul\u003e\n\u003cli\u003eLookahead 採用後は BN でも安定したので、最終的には BN / GN 両方のモデルを作って rank average した。\u003c/li\u003e\n\u003cli\u003e\u0026amp; CosineDecay with linear warmup\u003c/li\u003e\n\u003cli\u003eval prauc で early stopping\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e学習中に checkpoint をとっておき、val loss がよかった 5 epoch 分のモデルの出力の平均を使用\u003c/li\u003e\n\u003cli\u003eclass weight つき binary crossentropy loss\n\n\u003cul\u003e\n\u003cli\u003eclass imbalance については \u003ca href=\"https://www.tensorflow.org/tutorials/structured_data/imbalanced_data#train_on_the_oversampled_data\"\u003ehttps://www.tensorflow.org/tutorials/structured_data/imbalanced_data#train_on_the_oversampled_data\u003c/a\u003e をベースに戦略を立てていました\u003c/li\u003e\n\u003cli\u003eいくつか試しましたが、結局シンプルな class weight が一番よかったです\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCV 戦略は StratifiedKFold(k=5)\n\n\u003cul\u003e\n\u003cli\u003eタスク的には StratifiedKFold じゃまずそうと思いつつも、Group, StratifiedGroup は CV / LB の相関が取れなかったのと、seed を変えた時の暴れ方がすごくて断念\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003eLightGBM\u003c/h4\u003e\n\n\u003cp\u003eこちらは最終日にもう何も思い付かず、とはいえサブを余らせて終わるのも悔しかったので、やってみるかぁという惰性で挑戦したものでした。\nCV は Stacking した LightGBM の方がかなり高かったので興奮したのですが、流石に怖かったので CNN も提出していました。\n結論としてはどちらも  Public / Private 共にほぼ差はなかったです。\u003c/p\u003e\n\n\u003cp\u003e時間がなかったのであまり検証はできず、勘で良さそうな構成を選ぶしかなかったのですが、最終的に採用したのは以下のような構成です。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eCNN (BN, GN) の出力を rank にしたもの + テーブル特徴量全部盛り\u003c/li\u003e\n\u003cli\u003eoptuna の LightGBMCVTuner でハイパラ選択\u003c/li\u003e\n\u003cli\u003e2 Seed Average (Rank Average)\u003c/li\u003e\n\u003cli\u003eimbalance 対策は undersampling + bagging\n\n\u003cul\u003e\n\u003cli\u003e1 : 10 になるように undersampling したデータで普通に 20 モデル作り、単純に平均をとった\u003c/li\u003e\n\u003cli\u003e1:1 にしたり \u003ccode\u003eis_unbalance=True\u003c/code\u003e にしたりいくつか実験しましたが、これがもっとも CV が高かったです\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003eうまくいかなかったこと\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eAttention\n\n\u003cul\u003e\n\u003cli\u003eTransformer ベースのモデルと、Conv ベースモデルに MultiHeadAttention を足したものの両方を試しましたが、どちらも work せず\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSqueeze and Excitation\u003c/li\u003e\n\u003cli\u003eSeparableConv1D にして層を増やす\u003c/li\u003e\n\u003cli\u003eKernel Size を増やす\u003c/li\u003e\n\u003cli\u003eNN で Undersampling + Bagging\u003c/li\u003e\n\u003cli\u003e生データの scaling\n\n\u003cul\u003e\n\u003cli\u003eStandardize や 99.9%ile で clip した方が学習は安定したが、スコアがものすごく下がった...\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e(Denoising) Variational Auto Encoder\n\n\u003cul\u003e\n\u003cli\u003etrain/test で chip が違うことがわかっていたので、教師なし事前学習 → \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/finetune\"\u003efinetune\u003c/a\u003e したら LB 上がるのでは、という目論見\u003c/li\u003e\n\u003cli\u003eReconstruction Error と Encoder の出力 64 次元ベクトルを LightGBM に食わせるのも試したが work せず\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C8%F9%CA%AC\"\u003e微分\u003c/a\u003eして入力チャネルに追加して CNN に通す\u003c/li\u003e\n\u003c/ul\u003e\n\n---\n\n---\n","slug":"atmacup5th","title":"atmaCup #5 に参加してきて Private 29 位（Public 27 位）でした！","timestamp":1591527600000,"tags":[]},{"rawMarkdown":"---\ntitle: \"【論文読み】 Multi-Oriented Scene Text Detection via Corner Localization and Region Segmentation\"\ndate: 2019-02-13T00:12:22+09:00\ntags: [\"画像処理\", \"DeepLearning\", \"OCR\", \"論文読み\"]\nurl: https://qiita.com/agatan/items/afbdb922688984283775\n---\n\n画像中の文字領域検出における 2 つの主流な手法のいいとこ取りを目指した論文、 Multi-Oriented Scene Text Detection via Corner Localization and Region Segmentation を読んでみました。\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Reference\n\n- Multi-Oriented Scene Text Detection via Corner Localization and Region Segmentation [Pengyuan Lyu, Cong Yao, Wenhao Wu, Shuicheng Yan, Xiang Bai. CVPR 2018]\n- https://arxiv.org/abs/1802.08948\n\n（文中の図表は論文より引用しています）\n\n## Scene Text Detection\n\nScene Text Detection は、風景写真のなかにある文字領域（かんばん、ポスターなど）を検出するタスクです。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/a78b72da-8550-641f-819b-ed024d9be7fa.png)\n(Figure 6.)\n\nCNN を活用した研究が進んでおり、現在では 2 つのアプローチが主流となっています。（このあたりは [【論文読み】Semi-convolutional Operators for Instance Segmentation](https://qiita.com/agatan/items/2cf1209b7370db45eba5) や [[論文紹介] Focal Loss for Dense Object Detection](https://qiita.com/agatan/items/53fe8d21f2147b0ac982) でもすこし触れています）\n\n1 つ目は、文字領域検出を、一般的な物体検知(Object Detection)の特殊系とみなして解く手法です。\n物体検知に対するアプローチとして主流なのは bounding box の座標を regression として解くというものです。\nこの場合、bounding box 形式で当てに行くので、歪んだ形状への対応が難しく、縦横比が大きく偏った文字領域に弱いといった問題があります。\n[EAST: An Efficient and Accurate Scene Text Detector](https://arxiv.org/abs/1704.03155) [X. Zhou et al., CVPR 2018] はこちらのアプローチを採用しています。\n\n2 つ目は、Instance Segmentation として解くアプローチです。\nピクセル単位で文字領域かどうかの 2 クラス分類 + なんらかの方法でインスタンスの分離を行うという方法ですが、インスタンスの分離には複雑な後処理を要するケースが多く、複雑さや実行時間に問題があります。\n[PixelLink: Detecting Scene Text via Instance Segmentation](https://arxiv.org/abs/1801.01315) [D. Deng et al., AAAI 2018] が代表例です。（論文中で refer されているのは Multi-oriented Text Detection with Fully Convolutional Networks [Z. Zhang et al., CVPR 2016])\n\nこの論文ではこれらの 2 つの手法をいいとこ取りした Scene Text Detector を提案しています。\n\n## Network Architecture\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/281d3451-0e23-c20b-bb18-88b46495da15.png)\n\n全体像は ↑ の図のようになっています。\n**Corner Detection** と **Position Sensitive Segmentation** の 2 つからなる architecture です。\n\nCorner Detection はその名の通り、文字領域の角の位置を予測します。ただし、「角である」ことだけを考慮し、「どの 4 つの組み合わせが 1 領域を表しているのか」は考えません。\nCorner Detection が予測した大量の「角」たちを sampling \u0026 grouping し、大量の「文字領域候補」をつくります。\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/d62ec4c7-2e8b-56e9-045c-af825dfac279.png)\n（Corner Detection は概念的にはわかりやすいですが、実際には default box を用意して offset 計算して...と、SSD や YOLO と同程度には複雑なことをしています。詳細は論文をご参照ください...）\n\nCorner Detection と並行して、Position Sensitive Segmentation 側では、各ピクセルを「文字領域の右上」「右下」「左上」「左下」の 4 クラス（+ 背景）に分類します。\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/f8a4b98a-a428-48be-2d97-f57246f53a5a.png)\nそれぞれ、白が「左上」、赤が「右上」、青が「左下」、緑が「右下」に分類された領域です。\n\nさいごに、Corner Detection によって生成された大量の「文字領域候補」を、Position Sensitive Segmentation の結果との整合性に応じてスコアづけします。\n「文字領域候補」の左上にあるピクセルが Segmentation によって「左上」に分類されていればいるほど高いスコアになります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/aad5fe04-8bad-c758-fa7a-fd037c62f877.png)\n\n## 感想\n\nInstance Segmentation 方式は後処理が複雑すぎる、という問題提起のわりには、提案手法の後処理も相当大変そうという印象があります。\nまた、Corner Detection 部分はやけに複雑で、なぜこんなに複雑なことをしているのかあんまり理解できませんでした。\n一方、Object Detection 系のやり方と Segmentation 系のやり方を組み合わせる手法としては概念的にもわかりやすい構成で面白かったです。\nPosition Sensitive Segmentation というアプローチもこの論文を読むまで知らなかったので勉強になりました。\n\nこの論文の少しあとに ECCV 2018 に通った論文で関連していそうなものとして、CornerNet と PixelLink という論文があります。\n[CornerNet: Detecting Objects as Paired Keypoints](https://arxiv.org/abs/1808.01244) は、 Corner を予測 + ピクセル単位の Embedding を計算 → Embedding の距離に応じて Corner のペアを作っていくという手法で、よりシンプルに Corner のグルーピングを実現しています。\nまた、[PixelLink: Detecting Scene Text via Instance Segmentation](https://arxiv.org/abs/1801.01315) は text/non-text の segmentation + 隣接ピクセルと連結するかしないかの 2 クラス分類を組み合わせて Instance Segmentation をし、文字領域検出を行っています。\nどちらもとてもおもしろい論文なのでおすすめです。\n","contentMarkdown":"\n画像中の文字領域検出における 2 つの主流な手法のいいとこ取りを目指した論文、 Multi-Oriented Scene Text Detection via Corner Localization and Region Segmentation を読んでみました。\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Reference\n\n- Multi-Oriented Scene Text Detection via Corner Localization and Region Segmentation [Pengyuan Lyu, Cong Yao, Wenhao Wu, Shuicheng Yan, Xiang Bai. CVPR 2018]\n- https://arxiv.org/abs/1802.08948\n\n（文中の図表は論文より引用しています）\n\n## Scene Text Detection\n\nScene Text Detection は、風景写真のなかにある文字領域（かんばん、ポスターなど）を検出するタスクです。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/a78b72da-8550-641f-819b-ed024d9be7fa.png)\n(Figure 6.)\n\nCNN を活用した研究が進んでおり、現在では 2 つのアプローチが主流となっています。（このあたりは [【論文読み】Semi-convolutional Operators for Instance Segmentation](https://qiita.com/agatan/items/2cf1209b7370db45eba5) や [[論文紹介] Focal Loss for Dense Object Detection](https://qiita.com/agatan/items/53fe8d21f2147b0ac982) でもすこし触れています）\n\n1 つ目は、文字領域検出を、一般的な物体検知(Object Detection)の特殊系とみなして解く手法です。\n物体検知に対するアプローチとして主流なのは bounding box の座標を regression として解くというものです。\nこの場合、bounding box 形式で当てに行くので、歪んだ形状への対応が難しく、縦横比が大きく偏った文字領域に弱いといった問題があります。\n[EAST: An Efficient and Accurate Scene Text Detector](https://arxiv.org/abs/1704.03155) [X. Zhou et al., CVPR 2018] はこちらのアプローチを採用しています。\n\n2 つ目は、Instance Segmentation として解くアプローチです。\nピクセル単位で文字領域かどうかの 2 クラス分類 + なんらかの方法でインスタンスの分離を行うという方法ですが、インスタンスの分離には複雑な後処理を要するケースが多く、複雑さや実行時間に問題があります。\n[PixelLink: Detecting Scene Text via Instance Segmentation](https://arxiv.org/abs/1801.01315) [D. Deng et al., AAAI 2018] が代表例です。（論文中で refer されているのは Multi-oriented Text Detection with Fully Convolutional Networks [Z. Zhang et al., CVPR 2016])\n\nこの論文ではこれらの 2 つの手法をいいとこ取りした Scene Text Detector を提案しています。\n\n## Network Architecture\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/281d3451-0e23-c20b-bb18-88b46495da15.png)\n\n全体像は ↑ の図のようになっています。\n**Corner Detection** と **Position Sensitive Segmentation** の 2 つからなる architecture です。\n\nCorner Detection はその名の通り、文字領域の角の位置を予測します。ただし、「角である」ことだけを考慮し、「どの 4 つの組み合わせが 1 領域を表しているのか」は考えません。\nCorner Detection が予測した大量の「角」たちを sampling \u0026 grouping し、大量の「文字領域候補」をつくります。\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/d62ec4c7-2e8b-56e9-045c-af825dfac279.png)\n（Corner Detection は概念的にはわかりやすいですが、実際には default box を用意して offset 計算して...と、SSD や YOLO と同程度には複雑なことをしています。詳細は論文をご参照ください...）\n\nCorner Detection と並行して、Position Sensitive Segmentation 側では、各ピクセルを「文字領域の右上」「右下」「左上」「左下」の 4 クラス（+ 背景）に分類します。\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/f8a4b98a-a428-48be-2d97-f57246f53a5a.png)\nそれぞれ、白が「左上」、赤が「右上」、青が「左下」、緑が「右下」に分類された領域です。\n\nさいごに、Corner Detection によって生成された大量の「文字領域候補」を、Position Sensitive Segmentation の結果との整合性に応じてスコアづけします。\n「文字領域候補」の左上にあるピクセルが Segmentation によって「左上」に分類されていればいるほど高いスコアになります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/aad5fe04-8bad-c758-fa7a-fd037c62f877.png)\n\n## 感想\n\nInstance Segmentation 方式は後処理が複雑すぎる、という問題提起のわりには、提案手法の後処理も相当大変そうという印象があります。\nまた、Corner Detection 部分はやけに複雑で、なぜこんなに複雑なことをしているのかあんまり理解できませんでした。\n一方、Object Detection 系のやり方と Segmentation 系のやり方を組み合わせる手法としては概念的にもわかりやすい構成で面白かったです。\nPosition Sensitive Segmentation というアプローチもこの論文を読むまで知らなかったので勉強になりました。\n\nこの論文の少しあとに ECCV 2018 に通った論文で関連していそうなものとして、CornerNet と PixelLink という論文があります。\n[CornerNet: Detecting Objects as Paired Keypoints](https://arxiv.org/abs/1808.01244) は、 Corner を予測 + ピクセル単位の Embedding を計算 → Embedding の距離に応じて Corner のペアを作っていくという手法で、よりシンプルに Corner のグルーピングを実現しています。\nまた、[PixelLink: Detecting Scene Text via Instance Segmentation](https://arxiv.org/abs/1801.01315) は text/non-text の segmentation + 隣接ピクセルと連結するかしないかの 2 クラス分類を組み合わせて Instance Segmentation をし、文字領域検出を行っています。\nどちらもとてもおもしろい論文なのでおすすめです。\n","slug":"【論文読み】_Multi-Oriented_Scene_Text_Detection_via_Corner_Localization_and_Region_Segmentation","title":"【論文読み】 Multi-Oriented Scene Text Detection via Corner Localization and Region Segmentation","timestamp":1549984342000,"tags":["画像処理","DeepLearning","OCR","論文読み"]},{"rawMarkdown":"---\ntitle: \"【論文読み】Semi-convolutional Operators for Instance Segmentation\"\ndate: 2019-02-11T16:59:46+09:00\ntags: [\"DeepLearning\", \"論文読み\"]\nurl: https://qiita.com/agatan/items/2cf1209b7370db45eba5\n---\n\nInstance Segmentation のタスクに対する手法を整理・分解し、精度をより向上する `Semi-convolutional operators` を提案した論文です。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/8164ed4c-3f5d-c772-e21d-7d02d5146461.png)\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Reference\n\n- Semi-convolutional Operators for Instance Segmentation [David Novotny, Samuel Albanie, Diane Larlus, and Andrea Vedaldi. ECCV 2018]\n- https://arxiv.org/abs/1807.10712\n\n（文中の図表は論文より引用しています）\n\n## Instance Segmentation\n\nまずはじめに簡単に Instance Segmentation というタスクと、現在主流とされているアプローチについて述べます。\n\nInstance Segmentation とは、画像の各 Pixel について、 **どのクラスに属すか、どのインスタンスに属するか** を予測するタスクです。\n入力画像を「この領域は人、この領域は車、...」というように色塗りしていくタスクです。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/146f0988-659b-4f15-df32-e065ddae5e70.png)(Fig. 5 より)\n\nInstance Segmentation において重要なのが **どのインスタンスに属するか** も予測しなければならないという点です。\nたとえば人が 3 人で肩を組んでいるような画像の場合、どこからどこまでが 1 人目かを予測しなければなりません。\n一方、インスタンスを考慮せず色塗りをしていくようなタスクを Semantic Segmentation といいます。\n\nSemantic Segmentation の場合は、入力画像の各 Pixel について多クラス分類を行えば Segmentation の完成になります。\nInstance Segmentation ではそれに加えて個々のインスタンスを区別するような仕組みが必要になります。\n\n### propose \u0026 verify\n\nInstance Segmentation タスクへのアプローチとして、現在主流とされているのは Mask R-CNN [^1] に代表される Region based な手法です。\n（Mask R-CNN は FAIR から出ている論文で、 OSS として公開されている Detectron に実装が含まれています。 https://github.com/facebookresearch/Detectron ）\n\n[^1]: K. He, et al., https://arxiv.org/abs/1703.06870\n\nMask R-CNN は、物体のクラスと bounding box だけを予測する Object Detection タスクへのアプローチを応用しています。\nまず Object Detection をすることで「この bounding box に人間が 1 人いる」ということを予測し、その後 bounding box 内を色塗りしていきます。\nObject Detection として bounding box を予測している時点で Instance を分離することが出来ています。色塗りのフェーズでは、すでに Instance が分離されているので単なる Pixel 単位の 2 クラス分類をやればよいことになります。\n\nはじめに Region を提案し、その中を精査するこれらの手法を、この論文では _propose \u0026 verify_ (P\u0026V) と呼んでいます。\n\nここで、 **P\u0026V は必ず一度矩形で切り取ってから色塗りをしなければならない** という点が問題になります。\n予測したい物体は必ずしも矩形で近似できるような形状をしているとは限りません。\n実際の形状と極端にかけ離れた場合、bounding box を予測すること自体が難しく、また Instance の分離も難しくなります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/39b808c2-cc63-a245-73c1-5b6ebc89c9be.png)\n\n### instance coloring\n\nP\u0026V の問題点を解決する方法として、Pixel ごとに **ラベル + Instance の identifier となる何か** を予測する方法があります。\nこれらをこの論文では _instance coloring_ (IC) と呼んでいます。\n\n「Instance の identifier となる何か」 は、連番などではうまく学習できません（どの Object が ID 1 なのか ID 2 なのかわからない）。\nそこで、 Pixel ごとに低次元の embedding を出力し、**同じ Instance に所属する Pixel の embedding たちが似たものになるように学習します**。\n入力画像に対して、Pixel ごとのラベルと embedding を出力し、embedding を基に Pixel たちをクラスタリングすることで Instance を分離します。\n\nIC の良いところは、典型的な image-to-image の問題と同じネットワーク構造を利用できるところです。\nSemantic Segmetation, Style Transfer など、画像を入力とし同じサイズの feature map を出力とするタスクは他にも数多くあり、それらと同じ構造をシンプルに流用できるのは大きな利点になります。\n（P\u0026V の場合は Region Proposal + Region ごとの Coloring が必要で、ネットワーク構造としてはかなり複雑かつ独特なものになります）\n\n一方、IC であまり精度が出ない大きな理由の一つに **画像的に似た領域が繰り返されると Instance の分離に失敗する** という問題があります。\nimage-to-image のネットワークは通常 Convolutional operators をベースにしていますが、CNN の出力は、入力である pixel の特徴量にのみ依存し、 **座標は全く結果に影響を及ぼしません** 。\nそのため、画像的にそっくりな領域が複数あると、それらの pixel に対する embedding は同じような値になってしまい、クラスタリングがうまくいきません。\n\n## Semi-convolutional operators\n\n一般的な IC では、出力された embedding が次の条件をみたすことを目標とします。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/00e031cb-860d-d25c-af24-213ad5fd8565.png)\n\nここで、 $\\Omega$ は全 Pixel の集合、 $x$ は入力画像、 $\\Phi$ は学習したい関数（NN）、 $S_k$ はクラス k の segmentation mask、 $M$ はマージン （hyperparameter） です。\n言葉で説明すると、 **同じクラスに属する Pixel $u$, $v$ の embedding の距離をより近づけ、違うクラスに属する場合はより遠ざける** という感じです。\n$M$ は分離境界をよりくっきりさせるためのパラメータです。\n\nさきほど述べたように $\\Phi$ は CNN であり、座標情報を加味できません。\nSemi-convolutinal 版では、 $\\Phi$ の代わりに次のような $\\Psi$ を考えます。\n\n```math\n\\Psi_u(x) = f(\\Phi_u(x), u)\n```\n\nここで、 $u$ は Pixel の座標を表し、 $f$ は $\\Phi$ の結果と座標情報を合成するなんらかの関数です。\n$f$ の簡単な例としては、単純な足し算が考えられます。\n$\\Psi$ は、CNN の結果に加えて座標情報も持ち合わせているため、IC の弱点を克服できています。\n$f$ を単純な加算とし、うまく学習が成功した場合、各 Instance ごとに centroid $c_k$ が決定され、\n\n```math\n\\forall u \\in S_k: \\Phi_u(x) + u = c_k\n```\n\nとなるように $\\Phi$ が学習されます。\nこれを可視化すると次の画像のようになります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/74875b7b-be1b-4eb3-0e3d-f3c53fced5a8.png)\n(Fig.2 より)\n\n各インスタンス内の Pixel から、なんとなく中心っぽい場所へベクトルが伸びているのがわかります。\n\n実際の学習の際の損失関数は次のようになります。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/914e8f93-3c56-8d39-270e-1a5f3703bc79.png\" width=\"60%\"\u003e\n\n同じインスタンスに属する Pixel の embedding たちを平均値になるべく近づける、というのが損失関数になります。\n（マージンの考えも含まれていないし、「違うインスタンスとの距離を取る」という損失も含まれていないですが、これで十分に良い学習ができたと述べられています。）\n\n実際にはもうちょっと複雑な $\\Psi$ や距離の定義を使っていますが、概要としては上記のようなものを Semi-convolutional operators として提案しています。\n\n## Experiments\n\nMask R-CNN との統合もこの論文の重要な topic なのですが、ぶっちゃけ論文を読んだほうがわかりやすいので飛ばして実験結果をざーっと眺めてみます。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/e7516b68-9a66-154b-45ae-61199e0de90a.png)(Fig. 3 より)\n\nまずはじめに、 画像的にそっくりな領域が繰り返されてもうまく Instance を分離できることを確認しています。\n(c) は通常の Conv. のみを使って IC を行った場合の結果です。クラスタリングに大失敗していることがわかります。\n一方 (d) の Semi-conv. 版ではきれいな分離が実現されています。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/09bb8f76-5ba7-ad51-af97-2dbfc902cd66.png)\n\nつぎに線虫の segmentation です。こちらは P\u0026V のように矩形で認識するタイプの手法がニガテとするようなタスクです。\n現在主流である Mask RCNN よりも良い結果が示されています。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/77a2f7fe-ee56-13ae-f49b-faf825cbf406.png)\n\nより一般的なデータである PASCAL VOC2012 に対しても Mask RCNN より良い結果となっています（Mask RCNN に Semi-conv. の仕組みを組み込んだもので比較しています。）\n\n## まとめと感想\n\ninstance coloring の手法をまったく知らなかったのですが、 [CornerNet: Detecting Objects as Paired Keypoints](https://arxiv.org/abs/1808.01244) で Pixel ごとの embedding をクラスタリングしてペアを作るという手法を知り、興味を持ったのでその関連で読んでみた論文です。\nP\u0026V 形式はかなり複雑な構造になるので、それを避けられるならすごく面白いなと思ったのですが、この論文では Mask R-CNN と組み合わせることで精度向上と言っているので、まだまだ IC 単体で勝てる感じではないのでしょうか？\n\n同じタスクに対して全く違う 2 つのアプローチが（比較対象になるくらいには）同じような成果を出しているのも面白いところです。segmentation は主流ではなかった分、まだまだ改善がありそうで楽しみです。\n","contentMarkdown":"\nInstance Segmentation のタスクに対する手法を整理・分解し、精度をより向上する `Semi-convolutional operators` を提案した論文です。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/8164ed4c-3f5d-c772-e21d-7d02d5146461.png)\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Reference\n\n- Semi-convolutional Operators for Instance Segmentation [David Novotny, Samuel Albanie, Diane Larlus, and Andrea Vedaldi. ECCV 2018]\n- https://arxiv.org/abs/1807.10712\n\n（文中の図表は論文より引用しています）\n\n## Instance Segmentation\n\nまずはじめに簡単に Instance Segmentation というタスクと、現在主流とされているアプローチについて述べます。\n\nInstance Segmentation とは、画像の各 Pixel について、 **どのクラスに属すか、どのインスタンスに属するか** を予測するタスクです。\n入力画像を「この領域は人、この領域は車、...」というように色塗りしていくタスクです。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/146f0988-659b-4f15-df32-e065ddae5e70.png)(Fig. 5 より)\n\nInstance Segmentation において重要なのが **どのインスタンスに属するか** も予測しなければならないという点です。\nたとえば人が 3 人で肩を組んでいるような画像の場合、どこからどこまでが 1 人目かを予測しなければなりません。\n一方、インスタンスを考慮せず色塗りをしていくようなタスクを Semantic Segmentation といいます。\n\nSemantic Segmentation の場合は、入力画像の各 Pixel について多クラス分類を行えば Segmentation の完成になります。\nInstance Segmentation ではそれに加えて個々のインスタンスを区別するような仕組みが必要になります。\n\n### propose \u0026 verify\n\nInstance Segmentation タスクへのアプローチとして、現在主流とされているのは Mask R-CNN [^1] に代表される Region based な手法です。\n（Mask R-CNN は FAIR から出ている論文で、 OSS として公開されている Detectron に実装が含まれています。 https://github.com/facebookresearch/Detectron ）\n\n[^1]: K. He, et al., https://arxiv.org/abs/1703.06870\n\nMask R-CNN は、物体のクラスと bounding box だけを予測する Object Detection タスクへのアプローチを応用しています。\nまず Object Detection をすることで「この bounding box に人間が 1 人いる」ということを予測し、その後 bounding box 内を色塗りしていきます。\nObject Detection として bounding box を予測している時点で Instance を分離することが出来ています。色塗りのフェーズでは、すでに Instance が分離されているので単なる Pixel 単位の 2 クラス分類をやればよいことになります。\n\nはじめに Region を提案し、その中を精査するこれらの手法を、この論文では _propose \u0026 verify_ (P\u0026V) と呼んでいます。\n\nここで、 **P\u0026V は必ず一度矩形で切り取ってから色塗りをしなければならない** という点が問題になります。\n予測したい物体は必ずしも矩形で近似できるような形状をしているとは限りません。\n実際の形状と極端にかけ離れた場合、bounding box を予測すること自体が難しく、また Instance の分離も難しくなります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/39b808c2-cc63-a245-73c1-5b6ebc89c9be.png)\n\n### instance coloring\n\nP\u0026V の問題点を解決する方法として、Pixel ごとに **ラベル + Instance の identifier となる何か** を予測する方法があります。\nこれらをこの論文では _instance coloring_ (IC) と呼んでいます。\n\n「Instance の identifier となる何か」 は、連番などではうまく学習できません（どの Object が ID 1 なのか ID 2 なのかわからない）。\nそこで、 Pixel ごとに低次元の embedding を出力し、**同じ Instance に所属する Pixel の embedding たちが似たものになるように学習します**。\n入力画像に対して、Pixel ごとのラベルと embedding を出力し、embedding を基に Pixel たちをクラスタリングすることで Instance を分離します。\n\nIC の良いところは、典型的な image-to-image の問題と同じネットワーク構造を利用できるところです。\nSemantic Segmetation, Style Transfer など、画像を入力とし同じサイズの feature map を出力とするタスクは他にも数多くあり、それらと同じ構造をシンプルに流用できるのは大きな利点になります。\n（P\u0026V の場合は Region Proposal + Region ごとの Coloring が必要で、ネットワーク構造としてはかなり複雑かつ独特なものになります）\n\n一方、IC であまり精度が出ない大きな理由の一つに **画像的に似た領域が繰り返されると Instance の分離に失敗する** という問題があります。\nimage-to-image のネットワークは通常 Convolutional operators をベースにしていますが、CNN の出力は、入力である pixel の特徴量にのみ依存し、 **座標は全く結果に影響を及ぼしません** 。\nそのため、画像的にそっくりな領域が複数あると、それらの pixel に対する embedding は同じような値になってしまい、クラスタリングがうまくいきません。\n\n## Semi-convolutional operators\n\n一般的な IC では、出力された embedding が次の条件をみたすことを目標とします。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/00e031cb-860d-d25c-af24-213ad5fd8565.png)\n\nここで、 $\\Omega$ は全 Pixel の集合、 $x$ は入力画像、 $\\Phi$ は学習したい関数（NN）、 $S_k$ はクラス k の segmentation mask、 $M$ はマージン （hyperparameter） です。\n言葉で説明すると、 **同じクラスに属する Pixel $u$, $v$ の embedding の距離をより近づけ、違うクラスに属する場合はより遠ざける** という感じです。\n$M$ は分離境界をよりくっきりさせるためのパラメータです。\n\nさきほど述べたように $\\Phi$ は CNN であり、座標情報を加味できません。\nSemi-convolutinal 版では、 $\\Phi$ の代わりに次のような $\\Psi$ を考えます。\n\n```math\n\\Psi_u(x) = f(\\Phi_u(x), u)\n```\n\nここで、 $u$ は Pixel の座標を表し、 $f$ は $\\Phi$ の結果と座標情報を合成するなんらかの関数です。\n$f$ の簡単な例としては、単純な足し算が考えられます。\n$\\Psi$ は、CNN の結果に加えて座標情報も持ち合わせているため、IC の弱点を克服できています。\n$f$ を単純な加算とし、うまく学習が成功した場合、各 Instance ごとに centroid $c_k$ が決定され、\n\n```math\n\\forall u \\in S_k: \\Phi_u(x) + u = c_k\n```\n\nとなるように $\\Phi$ が学習されます。\nこれを可視化すると次の画像のようになります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/74875b7b-be1b-4eb3-0e3d-f3c53fced5a8.png)\n(Fig.2 より)\n\n各インスタンス内の Pixel から、なんとなく中心っぽい場所へベクトルが伸びているのがわかります。\n\n実際の学習の際の損失関数は次のようになります。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/914e8f93-3c56-8d39-270e-1a5f3703bc79.png\" width=\"60%\"\u003e\n\n同じインスタンスに属する Pixel の embedding たちを平均値になるべく近づける、というのが損失関数になります。\n（マージンの考えも含まれていないし、「違うインスタンスとの距離を取る」という損失も含まれていないですが、これで十分に良い学習ができたと述べられています。）\n\n実際にはもうちょっと複雑な $\\Psi$ や距離の定義を使っていますが、概要としては上記のようなものを Semi-convolutional operators として提案しています。\n\n## Experiments\n\nMask R-CNN との統合もこの論文の重要な topic なのですが、ぶっちゃけ論文を読んだほうがわかりやすいので飛ばして実験結果をざーっと眺めてみます。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/e7516b68-9a66-154b-45ae-61199e0de90a.png)(Fig. 3 より)\n\nまずはじめに、 画像的にそっくりな領域が繰り返されてもうまく Instance を分離できることを確認しています。\n(c) は通常の Conv. のみを使って IC を行った場合の結果です。クラスタリングに大失敗していることがわかります。\n一方 (d) の Semi-conv. 版ではきれいな分離が実現されています。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/09bb8f76-5ba7-ad51-af97-2dbfc902cd66.png)\n\nつぎに線虫の segmentation です。こちらは P\u0026V のように矩形で認識するタイプの手法がニガテとするようなタスクです。\n現在主流である Mask RCNN よりも良い結果が示されています。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/77a2f7fe-ee56-13ae-f49b-faf825cbf406.png)\n\nより一般的なデータである PASCAL VOC2012 に対しても Mask RCNN より良い結果となっています（Mask RCNN に Semi-conv. の仕組みを組み込んだもので比較しています。）\n\n## まとめと感想\n\ninstance coloring の手法をまったく知らなかったのですが、 [CornerNet: Detecting Objects as Paired Keypoints](https://arxiv.org/abs/1808.01244) で Pixel ごとの embedding をクラスタリングしてペアを作るという手法を知り、興味を持ったのでその関連で読んでみた論文です。\nP\u0026V 形式はかなり複雑な構造になるので、それを避けられるならすごく面白いなと思ったのですが、この論文では Mask R-CNN と組み合わせることで精度向上と言っているので、まだまだ IC 単体で勝てる感じではないのでしょうか？\n\n同じタスクに対して全く違う 2 つのアプローチが（比較対象になるくらいには）同じような成果を出しているのも面白いところです。segmentation は主流ではなかった分、まだまだ改善がありそうで楽しみです。\n","slug":"【論文読み】Semi-convolutional_Operators_for_Instance_Segmentation","title":"【論文読み】Semi-convolutional Operators for Instance Segmentation","timestamp":1549871986000,"tags":["DeepLearning","論文読み"]},{"rawMarkdown":"---\ntitle: \"【論文紹介】Concurrent Spatial and Channel Squeeze \u0026 Excitation in Fully Convolutional Networks\"\ndate: 2019-01-04T14:51:07+09:00\ntags: [\"Python\", \"DeepLearning\", \"Keras\", \"TensorFlow\", \"論文読み\"]\nurl: https://qiita.com/agatan/items/61546d71e7ea7ad14b11\n---\n\nFully Convolutional Network (FCN) の性能を enhance する Concurrent Spatial and Channel Squeeze \u0026 Excitation (scSE) というモジュールを提案した論文です。\n既存の良いとされてきたモデルたちに計算量をそこまで増やさずに \u0026 簡単に組み込むことができ、 Image Segmentation などのタスクで性能を向上させることができます。\n\n[ILSVRC 2017 画像分類 Top の手法 Squeeze-and-Excitation Networks - Qiita](https://qiita.com/agatan/items/8cf2566908228eaa5450) で紹介した SE モジュールの後継にあたります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/f606f8d0-9510-f251-31d8-e9091ed031b9.png)\n\n## Reference\n\n- Abhijit Guha Roy, et al., MICCAI 2018\n- https://arxiv.org/abs/1803.02579\n\n文中の図表は論文から引用しています。\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Squeeze and Excitation を Image Segmentation に応用する\n\nSqueeze and Excitation (SE) モジュールは、[Squeeze-and-Excitation Networks](https://arxiv.org/abs/1709.01507) で提案されたもので、 ILSVRC 2017 でトップのスコアを記録しています。\nSE は Channel 間の関係性を考慮できるようにしたい、というモチベーションで、 チャンネルごとに画像全体の activation の平均を取り（Squeeze)、それをもとにチャンネル間の Attention をとる（Excitation）というものでした。（[ILSVRC 2017 画像分類 Top の手法 Squeeze-and-Excitation Networks - Qiita](https://qiita.com/agatan/items/8cf2566908228eaa5450)）\n本論文ではこのオリジナルの SE モジュールのことを channel SE (Spatial Squeeze and Channel Excitation, cSE) と呼んでいます。\n\n```python\nfrom tensorflow.python.keras.layers import GlovelAveragePooling2D, Dense, multiply\n\ndef spatial_squeeze_and_channel_excitation(x, ch, ratio=16):\n    squeeze = GlobalAveragePooling2D()(x)\n    z = Dense(ch // ratio, activation='relu')(squeeze)\n    excitation = Dense(ch, activation='sigmoid')(x)\n    return multiply([x, excitation])\n```\n\n本論文では Image Classification の性能を大きく向上した SE モジュールを、 Image Segmentation に応用することを考えます。\nImage Segmentation のタスクでは、Fully Convolutional な Architecture がよく採用されます。\nこの論文では、U-Net[^1] やそこから派生した SkipDeconv-Net[^2]， Fully Convolutional DenseNet[^3] などに対して SE モジュール的な考え方で性能を向上できないか実験しています。\n\n[^1]: Ronneberger O, Fischer P, Brox T. U-net: Convolutional networks for biomedical image segmentation. In Proc. MICCAI, Springer 2015, pp. 234-241.\n[^2]: Roy, A.G., Conjeti, S., Sheet, D., Katouzian, A., Navab, N. and Wachinger, C., 2017, September. Error Corrective Boosting for Learning Fully Convolutional Networks with Limited Data. In MICCAI, pp. 231-239, Springer.\n[^3]: J ́egou, S., Drozdzal, M., Vazquez, D., Romero, A. and Bengio, Y., 2017, July. The one hundred layers tiramisu: Fully convolutional densenets for semantic segmentation. In CVPR Workshop, pp. 1175-1183, IEEE.\n\nが、実際に SE モジュールをこれらの FCN に組み込んでみると、 Image Classification のときよりも性能が上がりづらいという結果が得られています。\nこの論文では、 「Image Segmentation は pixel-wise の情報が重要であり、チャンネルごとに画像全体から平均を取る cSE ではピクセル単位の情報をうまく enhance できていないのでは」という仮説を立てています。\n\n## Channel Squeeze and Spatial Excitation Block (sSE)\n\nそこでこの論文で提案されているので、 sSE です。\n名前のとおりですが、 Channel 方向に Squeeze し、Pixel ごとに Excitation を計算します。\ncSE は画像全体（Spatial）で Squeeze し、Channel ごとの Excitation を計算しているので、その逆をやっているというイメージです。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/7c6f2822-ff51-c4f6-2d3f-6c0422dca3fa.png\" width=\"60%\"\u003e\n\n実装はものすごく単純です。以下に `tf.keras` をつかった場合の実装例を載せます。\n\n```python\nimport tensorflow as tf\n\ndef channel_squeeze_and_spatial_excitation(x):\n    excitation = tf.keras.layers.Conv2D(filters=1, kernel_size=1, activation='sigmoid')(x)\n    return tf.keras.layers.multiply([x, excitation])\n```\n\n`Conv2D(filters=1, kernel_size=1, activation='sigmoid')` で、pixel ごとに 1 チャンネルの値を 0~1 で出力させます。\nこれが「ある pixel における excitation」になります。出力は、入力である feature map と excitation の element-wise な積です。\n\n## Spatial and Channel Squeeze \u0026 Excitation (scSE)\n\nまた、提案手法である sSE とオリジナルの cSE は conflict しないので、両方採用してしまおう、というのが scSE です。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/fcbc2c76-3947-f587-eb8a-4422b4a28b7e.png\" width=\"70%\"\u003e\n\nこの図の上部が sSE、下部が cSE です。同じ入力からそれぞれを計算し、最後に単純に足し算したものを scSE と呼んでいます。\n\n```python\ndef _concurrent_spartial_and_channel_se(input_feature, ch, ratio=16):\n    cse = _spatial_squeeze_and_channel_excitation(input_feature, ch, ratio=ratio)\n    sse = _channel_squeeze_and_spatial_excitation(input_feature)\n    return tf.keras.layers.Add()([cse, sse])\n```\n\nこの論文で実験に使われている U-Net の場合、 scSE を使った場合でも計算量は 1.5% 程度の増加で済んでいます。\n\n## Experiments\n\nいくつかのネットワークについて、「素の状態」「cSE」「sSE」「scSE」の 4 パターンで実験しています。\nここでは DenseNet のケースについてまとめた図を論文中の Fig.2 から引用します。\n詳細や全体像は論文を参照してください。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/31a9cee5-5d22-b682-1400-b3f98bfe5ae3.png)\n\n横軸はタスク名です。\nタスクにもよりますが、概ね `DenseNets` \u003c `DenseNets + cSE` \u003c `DenseNets + sSE` \u003c `DenseNets + scSE` になっているように見えます。\ncSE だけをいれると素の状態より性能が悪くなっているケースも見られるのが面白いところです。\n\n## まとめと感想\n\nタスクの特性を見て仮説を立て、実際にそれがうまくハマっているという論文で、よみやすいし納得感のある論文でした。\n実装の容易さと試しやすさ（既存モデルへ着脱できる）がうれしい手法で、実際に活用しているモデルに組み込まれています。\n","contentMarkdown":"\nFully Convolutional Network (FCN) の性能を enhance する Concurrent Spatial and Channel Squeeze \u0026 Excitation (scSE) というモジュールを提案した論文です。\n既存の良いとされてきたモデルたちに計算量をそこまで増やさずに \u0026 簡単に組み込むことができ、 Image Segmentation などのタスクで性能を向上させることができます。\n\n[ILSVRC 2017 画像分類 Top の手法 Squeeze-and-Excitation Networks - Qiita](https://qiita.com/agatan/items/8cf2566908228eaa5450) で紹介した SE モジュールの後継にあたります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/f606f8d0-9510-f251-31d8-e9091ed031b9.png)\n\n## Reference\n\n- Abhijit Guha Roy, et al., MICCAI 2018\n- https://arxiv.org/abs/1803.02579\n\n文中の図表は論文から引用しています。\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Squeeze and Excitation を Image Segmentation に応用する\n\nSqueeze and Excitation (SE) モジュールは、[Squeeze-and-Excitation Networks](https://arxiv.org/abs/1709.01507) で提案されたもので、 ILSVRC 2017 でトップのスコアを記録しています。\nSE は Channel 間の関係性を考慮できるようにしたい、というモチベーションで、 チャンネルごとに画像全体の activation の平均を取り（Squeeze)、それをもとにチャンネル間の Attention をとる（Excitation）というものでした。（[ILSVRC 2017 画像分類 Top の手法 Squeeze-and-Excitation Networks - Qiita](https://qiita.com/agatan/items/8cf2566908228eaa5450)）\n本論文ではこのオリジナルの SE モジュールのことを channel SE (Spatial Squeeze and Channel Excitation, cSE) と呼んでいます。\n\n```python\nfrom tensorflow.python.keras.layers import GlovelAveragePooling2D, Dense, multiply\n\ndef spatial_squeeze_and_channel_excitation(x, ch, ratio=16):\n    squeeze = GlobalAveragePooling2D()(x)\n    z = Dense(ch // ratio, activation='relu')(squeeze)\n    excitation = Dense(ch, activation='sigmoid')(x)\n    return multiply([x, excitation])\n```\n\n本論文では Image Classification の性能を大きく向上した SE モジュールを、 Image Segmentation に応用することを考えます。\nImage Segmentation のタスクでは、Fully Convolutional な Architecture がよく採用されます。\nこの論文では、U-Net[^1] やそこから派生した SkipDeconv-Net[^2]， Fully Convolutional DenseNet[^3] などに対して SE モジュール的な考え方で性能を向上できないか実験しています。\n\n[^1]: Ronneberger O, Fischer P, Brox T. U-net: Convolutional networks for biomedical image segmentation. In Proc. MICCAI, Springer 2015, pp. 234-241.\n[^2]: Roy, A.G., Conjeti, S., Sheet, D., Katouzian, A., Navab, N. and Wachinger, C., 2017, September. Error Corrective Boosting for Learning Fully Convolutional Networks with Limited Data. In MICCAI, pp. 231-239, Springer.\n[^3]: J ́egou, S., Drozdzal, M., Vazquez, D., Romero, A. and Bengio, Y., 2017, July. The one hundred layers tiramisu: Fully convolutional densenets for semantic segmentation. In CVPR Workshop, pp. 1175-1183, IEEE.\n\nが、実際に SE モジュールをこれらの FCN に組み込んでみると、 Image Classification のときよりも性能が上がりづらいという結果が得られています。\nこの論文では、 「Image Segmentation は pixel-wise の情報が重要であり、チャンネルごとに画像全体から平均を取る cSE ではピクセル単位の情報をうまく enhance できていないのでは」という仮説を立てています。\n\n## Channel Squeeze and Spatial Excitation Block (sSE)\n\nそこでこの論文で提案されているので、 sSE です。\n名前のとおりですが、 Channel 方向に Squeeze し、Pixel ごとに Excitation を計算します。\ncSE は画像全体（Spatial）で Squeeze し、Channel ごとの Excitation を計算しているので、その逆をやっているというイメージです。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/7c6f2822-ff51-c4f6-2d3f-6c0422dca3fa.png\" width=\"60%\"\u003e\n\n実装はものすごく単純です。以下に `tf.keras` をつかった場合の実装例を載せます。\n\n```python\nimport tensorflow as tf\n\ndef channel_squeeze_and_spatial_excitation(x):\n    excitation = tf.keras.layers.Conv2D(filters=1, kernel_size=1, activation='sigmoid')(x)\n    return tf.keras.layers.multiply([x, excitation])\n```\n\n`Conv2D(filters=1, kernel_size=1, activation='sigmoid')` で、pixel ごとに 1 チャンネルの値を 0~1 で出力させます。\nこれが「ある pixel における excitation」になります。出力は、入力である feature map と excitation の element-wise な積です。\n\n## Spatial and Channel Squeeze \u0026 Excitation (scSE)\n\nまた、提案手法である sSE とオリジナルの cSE は conflict しないので、両方採用してしまおう、というのが scSE です。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/fcbc2c76-3947-f587-eb8a-4422b4a28b7e.png\" width=\"70%\"\u003e\n\nこの図の上部が sSE、下部が cSE です。同じ入力からそれぞれを計算し、最後に単純に足し算したものを scSE と呼んでいます。\n\n```python\ndef _concurrent_spartial_and_channel_se(input_feature, ch, ratio=16):\n    cse = _spatial_squeeze_and_channel_excitation(input_feature, ch, ratio=ratio)\n    sse = _channel_squeeze_and_spatial_excitation(input_feature)\n    return tf.keras.layers.Add()([cse, sse])\n```\n\nこの論文で実験に使われている U-Net の場合、 scSE を使った場合でも計算量は 1.5% 程度の増加で済んでいます。\n\n## Experiments\n\nいくつかのネットワークについて、「素の状態」「cSE」「sSE」「scSE」の 4 パターンで実験しています。\nここでは DenseNet のケースについてまとめた図を論文中の Fig.2 から引用します。\n詳細や全体像は論文を参照してください。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/31a9cee5-5d22-b682-1400-b3f98bfe5ae3.png)\n\n横軸はタスク名です。\nタスクにもよりますが、概ね `DenseNets` \u003c `DenseNets + cSE` \u003c `DenseNets + sSE` \u003c `DenseNets + scSE` になっているように見えます。\ncSE だけをいれると素の状態より性能が悪くなっているケースも見られるのが面白いところです。\n\n## まとめと感想\n\nタスクの特性を見て仮説を立て、実際にそれがうまくハマっているという論文で、よみやすいし納得感のある論文でした。\n実装の容易さと試しやすさ（既存モデルへ着脱できる）がうれしい手法で、実際に活用しているモデルに組み込まれています。\n","slug":"【論文紹介】Concurrent_Spatial_and_Channel_Squeeze_\u0026_Excitation_in_Fully_Convolutional_Networks","title":"【論文紹介】Concurrent Spatial and Channel Squeeze \u0026 Excitation in Fully Convolutional Networks","timestamp":1546581067000,"tags":["Python","DeepLearning","Keras","TensorFlow","論文読み"]},{"rawMarkdown":"---\ntitle: \"DKN: Deep Knowledge-Aware Network for News Recommendation\"\ndate: 2018-12-19T21:02:20+09:00\ntags: [\"DeepLearning\", \"WWW\", \"Recommendation\", \"論文読み\"]\nurl: https://qiita.com/agatan/items/24c6d8e00f2fc861bb04\n---\n\nニュースの推薦に \"Knowledge Graph\" を活用する論文です。\nMicrosoft Research Asia のチームが WWW 2018 に投稿しています。\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Reference\n\n- DKN: Deep Knowledge-Aware Network for News Recommendation\n  - Hongwei Wang, Fuzheng Zhang, Xing Xie and Minyi Guo, et al., WWW 2018\n  - https://www2018.thewebconf.org/proceedings/#indus-922\n\n文中の図表は論文より引用しています。\n\n### 概要\n\n一般にニュース中の言葉は、常識的知識を仮定していて凝縮された文章になっています。\n一方で推薦系の既存手法は ニュース中に現れない知識を取り扱えておらず、潜在的なニュース間の関係を活かした探索が出来ていないという問題がありました。\n\nこの論文は、knowledge graph を活用した content-based な recommendation framework である _deep knowledge-aware network_ (DKN) を提案しています。\n\nknowledge graph とは、様々なエンティティを様々なエッジでつないだ heterogeneous なグラフで、たとえば \"モナリザ -[の作者」-\u003e ダ・ヴィンチ\" のような情報を溜め込んだ巨大なグラフです。\nGoogle Search の裏でも活躍しているらしく、一般的な「知識」を構造化された形で表現する方法としてよく使われています。\nknowledge graph を使うことで、 \"Donald Trump\" という単語そのものだけからはわからない、 \"United States\" という単語との関連、\"Politician\" という単語との関連などを導くことができます。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/6967d5d1-0708-7e59-51c8-db107866ea63.png)\n\n### 何が難しいか\n\nこの論文では、ニュース推薦の難しさとして以下のようなものを挙げています。\n\n- news の推薦は movie などと違って、リアルタイム性が高い問題（いつ publish されたニュースかが重要）であり、news 間の関係性もすぐにダメになる。\n  - なので ID ベースの既存手法（協調フィルタリングなど）は効果が弱い\n- news はユーザによって興味範囲が違うし、ユーザは複数の興味範囲を持っていることがほとんど。\n- news の文言は凝縮されている。\n  - 常識、大量の既知の entity を仮定している。\n  - “Boris Johnson Has Warned Donald Trump To Stick To The Iran Nuclear Deal\" というニュースは “Boris Johnson”, “Donald Trump”, “Iran\", “Nuclear” を知っている前提で書かれている\n  - ↑ に興味のあるユーザはきっと “North Korean EMP Attack Would Cause Mass U.S. Starvation, Says Congressional Report” にも興味があるが、単語レベルでの関係性はほぼ無い\n\nこれらを Knowledge Graph を活用しつつ解決していきます。\n\n### Knowledge Graph Embedding\n\nKnowledge Graph Embedding 自体はこの研究の contribution ではありませんが重要なので簡単に紹介します。\nKnowledge Graph Embedding は、通常の network embedding に近い問題設定で、 knowledge graph における各エンティティとエッジの低次元な embedding を求めるという問題です。\n`(head, relation, trail)` という triplet 構造をなるべく維持したまま、`h, r, t` それぞれを低次元空間で表現することが目標です。\nDKN は translation-based knowledge graph embedding というのを使っています。\n一番簡単な手法は `h + r = t` になるように embedding を定める手法です。\n（他にもいくつか紹介、実験されているけど大体発想は同じなので省略。）\nまずランダムな値で各エンティティ、エッジの embedding を初期化し、 `h + r = t` を満たすように gradient descent で embedding を微調整していきます。\nこれによって、エンティティやエッジ（＝関係性）の低次元なベクトルを得ることができました。\n\n### Deep Knowledge-aware Network (DKN)\n\nDKN 自体は\n\n入力: 候補ニュースと、あるユーザの過去に見たニュースたち\n出力: クリック率\n\nとなるような CTR 予測モデルです。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/f64784da-f8b9-4620-c0b5-5a3db5640417.png)\n\n候補となるニュースの特徴量をベクトルとして得るために、通常であれば単語の embedding を RNN や CNN でまとめ上げて固定長のベクトルに変換します。\nDKN ではここに Knowledge Graph Embedding によって得た特徴量を加えます。\n出現する単語ごとに Knowledge Graph 上のエンティティを探し、もし見つかったならそのエンティティ自体の embedding + 周辺のエンティティ embedding の平均を context vector として単語レベルの embedding に concat します。\nもしエンティティが見つからなければ 0 埋めでサイズをあわせます。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/8e4f7cc4-89ee-5b3a-7343-245f33fa0b51.png)\n\n#### Attention-based User Interest Extraction\n\nつぎに、「ユーザが過去に見た記事」という情報をどのように活用するかを考えます。（＝ユーザの特徴をどのようにベクトル化するか）\n記事ごとのベクトルは ↑ で求められたので、単純に過去クリックした記事のベクトルの平均値を使うという方法が考えられますが、ユーザの興味は複数にまたがりうるので単純に平均を取るのは適しているとは言えません。\n（たとえば「プログラミング」「テニス」「ラーメン」の記事をクリックしたユーザに対して、「プログラミング」系の記事を推薦するのは多分良いはずだけど、平均をとってしまっているとその寄与が薄まる。）\n「今推薦の候補に考えている記事」について過去見た記事それぞれがどう関わっているかを表現できる方法でなければならないと言っています。\n\nそこで、 Attention Module をつかっています。\n候補の記事と過去に見た記事たちとの間の attention を計算し、過去に見た記事たちのベクトルの重み付き和をとることで、興味分野が複数にまたがっていても候補記事との関連をうまく見出したベクトルが作り出せます。\nAttention Module の入力は「候補記事のベクトル」と「過去に見た記事のベクトル」で、出力はその記事の寄与度になります。過去に見たすべての記事に対してそれぞれ network に入れて寄与度を計算し、softmax にかけたうで記事ベクトルの重み付き和をとっています。\n\n## 感想\n\nニュースタイトルは単語数が少なく固有名詞も多いので、単純な単語の embedding ではなかなか扱いづらいという問題を抱えていたので、 knowledge graph を使うというのはすごく納得の行く選択だなと思いました。\nただ、結果を見てみると Gain に対して複雑さや Knowledge Graph 自体を用意するコストが見合うかというとやはり厳しいかなという印象があります。（Microsoft はすでに自前の knowledge graph を持っているので...）\n\nKnowledge Graph Embedding については全く知らなかったのですが、面白い問題設定ですね。\n色々工夫されているようですが、 `h + r = t` というわかりやすく単純な方法でもそれなりに上手く行っていて面白かったです。\n\nまた、ユーザごとのベクトル表現の作り方の部分は Knowledge Graph の活用部分よりも簡単かつ一般的なので、この部分だけでも応用できそうだなと思いました。\n","contentMarkdown":"\nニュースの推薦に \"Knowledge Graph\" を活用する論文です。\nMicrosoft Research Asia のチームが WWW 2018 に投稿しています。\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Reference\n\n- DKN: Deep Knowledge-Aware Network for News Recommendation\n  - Hongwei Wang, Fuzheng Zhang, Xing Xie and Minyi Guo, et al., WWW 2018\n  - https://www2018.thewebconf.org/proceedings/#indus-922\n\n文中の図表は論文より引用しています。\n\n### 概要\n\n一般にニュース中の言葉は、常識的知識を仮定していて凝縮された文章になっています。\n一方で推薦系の既存手法は ニュース中に現れない知識を取り扱えておらず、潜在的なニュース間の関係を活かした探索が出来ていないという問題がありました。\n\nこの論文は、knowledge graph を活用した content-based な recommendation framework である _deep knowledge-aware network_ (DKN) を提案しています。\n\nknowledge graph とは、様々なエンティティを様々なエッジでつないだ heterogeneous なグラフで、たとえば \"モナリザ -[の作者」-\u003e ダ・ヴィンチ\" のような情報を溜め込んだ巨大なグラフです。\nGoogle Search の裏でも活躍しているらしく、一般的な「知識」を構造化された形で表現する方法としてよく使われています。\nknowledge graph を使うことで、 \"Donald Trump\" という単語そのものだけからはわからない、 \"United States\" という単語との関連、\"Politician\" という単語との関連などを導くことができます。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/6967d5d1-0708-7e59-51c8-db107866ea63.png)\n\n### 何が難しいか\n\nこの論文では、ニュース推薦の難しさとして以下のようなものを挙げています。\n\n- news の推薦は movie などと違って、リアルタイム性が高い問題（いつ publish されたニュースかが重要）であり、news 間の関係性もすぐにダメになる。\n  - なので ID ベースの既存手法（協調フィルタリングなど）は効果が弱い\n- news はユーザによって興味範囲が違うし、ユーザは複数の興味範囲を持っていることがほとんど。\n- news の文言は凝縮されている。\n  - 常識、大量の既知の entity を仮定している。\n  - “Boris Johnson Has Warned Donald Trump To Stick To The Iran Nuclear Deal\" というニュースは “Boris Johnson”, “Donald Trump”, “Iran\", “Nuclear” を知っている前提で書かれている\n  - ↑ に興味のあるユーザはきっと “North Korean EMP Attack Would Cause Mass U.S. Starvation, Says Congressional Report” にも興味があるが、単語レベルでの関係性はほぼ無い\n\nこれらを Knowledge Graph を活用しつつ解決していきます。\n\n### Knowledge Graph Embedding\n\nKnowledge Graph Embedding 自体はこの研究の contribution ではありませんが重要なので簡単に紹介します。\nKnowledge Graph Embedding は、通常の network embedding に近い問題設定で、 knowledge graph における各エンティティとエッジの低次元な embedding を求めるという問題です。\n`(head, relation, trail)` という triplet 構造をなるべく維持したまま、`h, r, t` それぞれを低次元空間で表現することが目標です。\nDKN は translation-based knowledge graph embedding というのを使っています。\n一番簡単な手法は `h + r = t` になるように embedding を定める手法です。\n（他にもいくつか紹介、実験されているけど大体発想は同じなので省略。）\nまずランダムな値で各エンティティ、エッジの embedding を初期化し、 `h + r = t` を満たすように gradient descent で embedding を微調整していきます。\nこれによって、エンティティやエッジ（＝関係性）の低次元なベクトルを得ることができました。\n\n### Deep Knowledge-aware Network (DKN)\n\nDKN 自体は\n\n入力: 候補ニュースと、あるユーザの過去に見たニュースたち\n出力: クリック率\n\nとなるような CTR 予測モデルです。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/f64784da-f8b9-4620-c0b5-5a3db5640417.png)\n\n候補となるニュースの特徴量をベクトルとして得るために、通常であれば単語の embedding を RNN や CNN でまとめ上げて固定長のベクトルに変換します。\nDKN ではここに Knowledge Graph Embedding によって得た特徴量を加えます。\n出現する単語ごとに Knowledge Graph 上のエンティティを探し、もし見つかったならそのエンティティ自体の embedding + 周辺のエンティティ embedding の平均を context vector として単語レベルの embedding に concat します。\nもしエンティティが見つからなければ 0 埋めでサイズをあわせます。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/8e4f7cc4-89ee-5b3a-7343-245f33fa0b51.png)\n\n#### Attention-based User Interest Extraction\n\nつぎに、「ユーザが過去に見た記事」という情報をどのように活用するかを考えます。（＝ユーザの特徴をどのようにベクトル化するか）\n記事ごとのベクトルは ↑ で求められたので、単純に過去クリックした記事のベクトルの平均値を使うという方法が考えられますが、ユーザの興味は複数にまたがりうるので単純に平均を取るのは適しているとは言えません。\n（たとえば「プログラミング」「テニス」「ラーメン」の記事をクリックしたユーザに対して、「プログラミング」系の記事を推薦するのは多分良いはずだけど、平均をとってしまっているとその寄与が薄まる。）\n「今推薦の候補に考えている記事」について過去見た記事それぞれがどう関わっているかを表現できる方法でなければならないと言っています。\n\nそこで、 Attention Module をつかっています。\n候補の記事と過去に見た記事たちとの間の attention を計算し、過去に見た記事たちのベクトルの重み付き和をとることで、興味分野が複数にまたがっていても候補記事との関連をうまく見出したベクトルが作り出せます。\nAttention Module の入力は「候補記事のベクトル」と「過去に見た記事のベクトル」で、出力はその記事の寄与度になります。過去に見たすべての記事に対してそれぞれ network に入れて寄与度を計算し、softmax にかけたうで記事ベクトルの重み付き和をとっています。\n\n## 感想\n\nニュースタイトルは単語数が少なく固有名詞も多いので、単純な単語の embedding ではなかなか扱いづらいという問題を抱えていたので、 knowledge graph を使うというのはすごく納得の行く選択だなと思いました。\nただ、結果を見てみると Gain に対して複雑さや Knowledge Graph 自体を用意するコストが見合うかというとやはり厳しいかなという印象があります。（Microsoft はすでに自前の knowledge graph を持っているので...）\n\nKnowledge Graph Embedding については全く知らなかったのですが、面白い問題設定ですね。\n色々工夫されているようですが、 `h + r = t` というわかりやすく単純な方法でもそれなりに上手く行っていて面白かったです。\n\nまた、ユーザごとのベクトル表現の作り方の部分は Knowledge Graph の活用部分よりも簡単かつ一般的なので、この部分だけでも応用できそうだなと思いました。\n","slug":"DKN:_Deep_Knowledge-Aware_Network_for_News_Recommendation","title":"DKN: Deep Knowledge-Aware Network for News Recommendation","timestamp":1545220940000,"tags":["DeepLearning","WWW","Recommendation","論文読み"]},{"rawMarkdown":"---\ntitle: \"ILSVRC 2017 画像分類 Top の手法 Squeeze-and-Excitation Networks\"\ndate: 2018-12-13T22:25:45+09:00\ntags: [\"画像処理\", \"ComputerVision\", \"MachineLearning\", \"DeepLearning\", \"CNN\"]\nurl: https://qiita.com/agatan/items/8cf2566908228eaa5450\n---\n\nILSVRC 2017 の画像分類タスクでは Squeeze-and-Excitation という手法が 1 位を記録しました。\nシンプルなアイディア・実装で、既存モデルの拡張にも利用できるうえ、精度も 2016 年の top 1 と比べてエラー率を約 25% 減らすという大きな成果をあげています。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/20b939b8-c65b-ce06-4525-37ccfe19c7a2.png)\n\n### Reference\n\n- Jie Hu, et al., https://arxiv.org/pdf/1709.01507.pdf\n\n文中の図表は論文から引用しています。\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Squeeze and Excitation\n\nこの論文では、SE block というブロックを提案しています。\nSE block は特定のネットワーク全体の設計の提案ではなく、ネットワーク中の 1 component として振る舞うものです。\nSE block を既存のいろいろなネットワークやモジュール（ResNet、Inception、...）に組み込むことで精度が向上することを実験で確かめています。\n\nSE block は非常に実装が簡単なので先に実装を見てしまったほうがわかりやすいかもしれません。\n\n```python\ndef se_block(input, channels):\n    \"\"\"\n    Args:\n        input: (N, H, W, C)\n        channels: C\n    Returns:\n        tensor: (N, H, W, C)\n    \"\"\"\n    # Squeeze\n    x = GlobalAveragePooling2D()(input)  # (N, C)\n    # Excitation\n    x = Dense(channels // 16, activation='relu')(x)\n    x = Dense(channels, activation='sigmoid')(x) # (N, C)\n    return Multiply()([input, x])\n```\n\nSE block は、通常の convolution の出力をそのまま使うのではなく、 **各 channel の出力を重み付けして使う** ようにすることで、チャンネル間の関係性の学習を可能にするブロックです。\n\n### Squeeze\n\n既存のモデルは、convolution と activation を重ねることで、局所的な特徴を獲得していきます。\n層が深くなったり pooling したりすると、局所的といいつつも広い視野を持っていくことになりますが、視野を一歩こえた先の情報などはまったく考慮できず、画像全体におけるチャンネル間の関係性を表すことはできません。\nそこで、画像全体の特徴を活用するために、 global average pooling を利用します。（Spatial Squeeze）\n\n### Excitation\n\nそうして得た「画像全体のチャンネルの状況」をいくつかの layer に通したのち、sigmoid に通します。\n最後にブロックに入力されてきた値 `input` に、 sigmoid 関数を通して 0~1 の範囲に収めた「各チャンネルの重み」を掛けて出力しています。\nこの部分が Excitation とよばれる部分です。\n\n## 既存モデルへの組み込み\n\nSE block は既存のモデルへの組み込みが容易であることも大きな強みです。\nいくつかの組み込み方が提案・実験されています。\n\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd\u003e\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/76082379-9db4-4f02-7236-355f6804908b.png\"\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/4c3fa967-234c-57ee-36a9-1c15fca7c603.png\"\u003e\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\n組み込み方もシンプルで簡単に試せるのですばらしいですね。\n\n## まとめと感想\n\nかなりいろんなセットアップで実験をしているので、詳細は論文を参照ください。\nWantedly People で使われているモデルにも実験的に組みこんでみたところ、確かに数%の改善が確認できました。\nこの論文の続編的なものとして、segmentation タスクなどの fully convolutional networks 用の SE block 亜種が提案されています。\nこの advent calendar のどこかでそちらの紹介もできればと思います。\n","contentMarkdown":"\nILSVRC 2017 の画像分類タスクでは Squeeze-and-Excitation という手法が 1 位を記録しました。\nシンプルなアイディア・実装で、既存モデルの拡張にも利用できるうえ、精度も 2016 年の top 1 と比べてエラー率を約 25% 減らすという大きな成果をあげています。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/20b939b8-c65b-ce06-4525-37ccfe19c7a2.png)\n\n### Reference\n\n- Jie Hu, et al., https://arxiv.org/pdf/1709.01507.pdf\n\n文中の図表は論文から引用しています。\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Squeeze and Excitation\n\nこの論文では、SE block というブロックを提案しています。\nSE block は特定のネットワーク全体の設計の提案ではなく、ネットワーク中の 1 component として振る舞うものです。\nSE block を既存のいろいろなネットワークやモジュール（ResNet、Inception、...）に組み込むことで精度が向上することを実験で確かめています。\n\nSE block は非常に実装が簡単なので先に実装を見てしまったほうがわかりやすいかもしれません。\n\n```python\ndef se_block(input, channels):\n    \"\"\"\n    Args:\n        input: (N, H, W, C)\n        channels: C\n    Returns:\n        tensor: (N, H, W, C)\n    \"\"\"\n    # Squeeze\n    x = GlobalAveragePooling2D()(input)  # (N, C)\n    # Excitation\n    x = Dense(channels // 16, activation='relu')(x)\n    x = Dense(channels, activation='sigmoid')(x) # (N, C)\n    return Multiply()([input, x])\n```\n\nSE block は、通常の convolution の出力をそのまま使うのではなく、 **各 channel の出力を重み付けして使う** ようにすることで、チャンネル間の関係性の学習を可能にするブロックです。\n\n### Squeeze\n\n既存のモデルは、convolution と activation を重ねることで、局所的な特徴を獲得していきます。\n層が深くなったり pooling したりすると、局所的といいつつも広い視野を持っていくことになりますが、視野を一歩こえた先の情報などはまったく考慮できず、画像全体におけるチャンネル間の関係性を表すことはできません。\nそこで、画像全体の特徴を活用するために、 global average pooling を利用します。（Spatial Squeeze）\n\n### Excitation\n\nそうして得た「画像全体のチャンネルの状況」をいくつかの layer に通したのち、sigmoid に通します。\n最後にブロックに入力されてきた値 `input` に、 sigmoid 関数を通して 0~1 の範囲に収めた「各チャンネルの重み」を掛けて出力しています。\nこの部分が Excitation とよばれる部分です。\n\n## 既存モデルへの組み込み\n\nSE block は既存のモデルへの組み込みが容易であることも大きな強みです。\nいくつかの組み込み方が提案・実験されています。\n\n\u003ctable\u003e\n\u003ctr\u003e\n\u003ctd\u003e\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/76082379-9db4-4f02-7236-355f6804908b.png\"\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/4c3fa967-234c-57ee-36a9-1c15fca7c603.png\"\u003e\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\n組み込み方もシンプルで簡単に試せるのですばらしいですね。\n\n## まとめと感想\n\nかなりいろんなセットアップで実験をしているので、詳細は論文を参照ください。\nWantedly People で使われているモデルにも実験的に組みこんでみたところ、確かに数%の改善が確認できました。\nこの論文の続編的なものとして、segmentation タスクなどの fully convolutional networks 用の SE block 亜種が提案されています。\nこの advent calendar のどこかでそちらの紹介もできればと思います。\n","slug":"ILSVRC_2017_画像分類_Top_の手法_Squeeze-and-Excitation_Networks","title":"ILSVRC 2017 画像分類 Top の手法 Squeeze-and-Excitation Networks","timestamp":1544707545000,"tags":["画像処理","ComputerVision","MachineLearning","DeepLearning","CNN"]},{"rawMarkdown":"---\ntitle: \"Object 間の関係を使って後処理 0 の物体検出を実現する: Relation Networks for Object Detection\"\ndate: 2018-12-10T23:35:40+09:00\ntags: [\"画像処理\", \"DeepLearning\", \"論文読み\", \"物体検出\"]\nurl: https://qiita.com/agatan/items/1c2cadeaabfc9f122f6f\n---\n\nObject Detection は、一枚の画像中の「どこに」「なにが」うつっているかを当てるタスクです。\n典型的な手法では、オブジェクトごとの bounding box を予測し、それぞれがどのクラスに分類されるかを**個別で**予測します。\nまた、ひとつのオブジェクトに対してすこしずつ座標のずれた box を複数予測してしまう可能性があるという問題があり、1 object 1 box になるように重複を削除しなければなりません。\nこれには nox maximum supression という方法を使うことが多いですが、これはヒューリスティックに基づく後処理になってしまっています。\n\nこの論文では、予測した box 間の関係に着目することで、分類精度を向上し、後処理 0 の完全 End-to-End での物体検出ネットワークを構築しています。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/9b80d772-3b27-5b14-2eac-2d1c1275492e.png)\n\n（青い box について分類する際に、オレンジの box との関連が強く活用されている）\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Reference\n\n- Relation Networks for Object Detection\n  - Han Hu, Jiayuan Gu, Zheng Zhang, Jifeng Dai, Yichen Wei, et al., CVPR 2018\n- https://arxiv.org/abs/1711.11575\n\n文中の図表は論文より引用しています。\n\n## モチベーション\n\n自然言語処理の世界では、Attention module が非常に強力な武器として大活躍しており、特に Transformer[^1] 以降の SoTA モデルたちは大体 Attention の仕組みを組み込んでいるといっても良いくらいの活躍ぶりです。\n[^1]: https://arxiv.org/abs/1706.03762\n雑に言えば Attention は、ある entity と他の entity の関係性を 0~1 で出力し、その値をもとに entity を表す何らかのベクトルの加重和をとるといった操作をします。関係性を表す 0~1 を計算するためのパラメータも学習されます。\nまた画像に対応するタイトルを自動生成する Image Captioning の世界でも Attention は活躍しており、活用されるフィールドがどんどん増してきています。\n\nそこで、Attention を Object Detection の世界にもってこよう、というのがこの論文です。\nAttention module を用いて box 間の関係性を表し、object detection の精度向上を達成しています。\n\n## End-to-End\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/4c30de7e-8f64-60fb-0bd6-712c33a990df.png)\n\n概観でいうと Region Proposal network + RoI Pooling + relation module という構造を採用しています。\nrelation module は box 間の attention をとる module です。\n\n完全に後処理をなくすためには、大量の box のなかから採用すべき box だけを残す必要があります。（通常は non maximum supression で、スコアの高い box を優先的に残しつつ、重複した領域の大きい box はすてる）\nそこでこの論文では、Attention module をいくつか通したのち、box ごとに 0~1 の値を出力し、残すべき box は 1 になり捨てるべき box は 0 になるように学習します。\n\n## Object Relation Module\n\n物体間の関係には 2 つの意味があります。1 つは意味的な関連で、もう一つは座標的な関連です。\nボールっぽいものとバットっぽいものがあったとしても、ものすごく離れた場所にあるのであれば無関係かもしれないですが、近くにあればきっとボールとバットのペアと予測するのが正しそうです。\nしかし、通常の attention は、意味的な関連しか扱えていません。すべての box をなんらかの vector にしてしまっていますし、convolution や pooling は座標に依存しない操作なのでその vector に座標そのものの情報は埋め込まれません。\n\nそこでこの論文ではふつうの Attention をちょっといじった object relation module というものを提案しています。\n\n物体 m, n 間の attention を算出する式を見てみます。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/2e19515d-72ea-f065-e517-f8c7fe466fb8.png\" width=\"50%\"\u003e\n\n$\\omega_A^{mn}$ は通常の Attention と同じで、object m と n を表すベクトル（を線形変換したもの）の内積です。\n$\\omega_G$ の部分を無視すれば、この式は単に各 object ごとに内積をとったものを softmax にかけている = ふつうの Attention の計算式と一致します。\n\n$\\omega_G$ は、座標的な関係を考慮するためのパラメータです。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/9a24daf8-38cc-a765-af2f-7efa141cdad9.png\" width=\"50%\"\u003e\n\n$f_G^m$ は object m の座標情報 (x,y, w, h) を表します。\n$\\varepsilon_G$ はふたつの object の座標情報からそれらの座標的関係を計算する関数です。\n\n```math\n\\varepsilon(f_G^m, f_G^n) = (\\log(\\frac{|x_m - x_n|}{w_m}), \\log(\\frac{|y_m - y_n|}{h_m}), \\log(\\frac{w_n}{w_m}), \\log(\\frac{h_n}{h_m}))\n```\n\nさらに、 $max{0, ...}$ をとることで、ReLU 的な働きをし、まったく座標的に関係のない object からの影響を 0 にしています。\n\n## まとめと感想\n\n実験と結果はもと論文を読むのが一番くわしいのでそちらを参照ください。\n「一枚の画像から X を取得したいが、画像の主体となるような X だけを取りたい」といったケースにも応用できる手法かなと思っていて、実験してみたいと思いつつ、本当に end-to-end でやるのはちょっと大変そうすぎるという印象もあります。\n（また論文中には end-to-end が 0 から学習する際の問題にも触れられています。）\nとはいえ完全に end-to-end というのはやっぱり夢があって好きです。\n","contentMarkdown":"\nObject Detection は、一枚の画像中の「どこに」「なにが」うつっているかを当てるタスクです。\n典型的な手法では、オブジェクトごとの bounding box を予測し、それぞれがどのクラスに分類されるかを**個別で**予測します。\nまた、ひとつのオブジェクトに対してすこしずつ座標のずれた box を複数予測してしまう可能性があるという問題があり、1 object 1 box になるように重複を削除しなければなりません。\nこれには nox maximum supression という方法を使うことが多いですが、これはヒューリスティックに基づく後処理になってしまっています。\n\nこの論文では、予測した box 間の関係に着目することで、分類精度を向上し、後処理 0 の完全 End-to-End での物体検出ネットワークを構築しています。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/9b80d772-3b27-5b14-2eac-2d1c1275492e.png)\n\n（青い box について分類する際に、オレンジの box との関連が強く活用されている）\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Reference\n\n- Relation Networks for Object Detection\n  - Han Hu, Jiayuan Gu, Zheng Zhang, Jifeng Dai, Yichen Wei, et al., CVPR 2018\n- https://arxiv.org/abs/1711.11575\n\n文中の図表は論文より引用しています。\n\n## モチベーション\n\n自然言語処理の世界では、Attention module が非常に強力な武器として大活躍しており、特に Transformer[^1] 以降の SoTA モデルたちは大体 Attention の仕組みを組み込んでいるといっても良いくらいの活躍ぶりです。\n[^1]: https://arxiv.org/abs/1706.03762\n雑に言えば Attention は、ある entity と他の entity の関係性を 0~1 で出力し、その値をもとに entity を表す何らかのベクトルの加重和をとるといった操作をします。関係性を表す 0~1 を計算するためのパラメータも学習されます。\nまた画像に対応するタイトルを自動生成する Image Captioning の世界でも Attention は活躍しており、活用されるフィールドがどんどん増してきています。\n\nそこで、Attention を Object Detection の世界にもってこよう、というのがこの論文です。\nAttention module を用いて box 間の関係性を表し、object detection の精度向上を達成しています。\n\n## End-to-End\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/4c30de7e-8f64-60fb-0bd6-712c33a990df.png)\n\n概観でいうと Region Proposal network + RoI Pooling + relation module という構造を採用しています。\nrelation module は box 間の attention をとる module です。\n\n完全に後処理をなくすためには、大量の box のなかから採用すべき box だけを残す必要があります。（通常は non maximum supression で、スコアの高い box を優先的に残しつつ、重複した領域の大きい box はすてる）\nそこでこの論文では、Attention module をいくつか通したのち、box ごとに 0~1 の値を出力し、残すべき box は 1 になり捨てるべき box は 0 になるように学習します。\n\n## Object Relation Module\n\n物体間の関係には 2 つの意味があります。1 つは意味的な関連で、もう一つは座標的な関連です。\nボールっぽいものとバットっぽいものがあったとしても、ものすごく離れた場所にあるのであれば無関係かもしれないですが、近くにあればきっとボールとバットのペアと予測するのが正しそうです。\nしかし、通常の attention は、意味的な関連しか扱えていません。すべての box をなんらかの vector にしてしまっていますし、convolution や pooling は座標に依存しない操作なのでその vector に座標そのものの情報は埋め込まれません。\n\nそこでこの論文ではふつうの Attention をちょっといじった object relation module というものを提案しています。\n\n物体 m, n 間の attention を算出する式を見てみます。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/2e19515d-72ea-f065-e517-f8c7fe466fb8.png\" width=\"50%\"\u003e\n\n$\\omega_A^{mn}$ は通常の Attention と同じで、object m と n を表すベクトル（を線形変換したもの）の内積です。\n$\\omega_G$ の部分を無視すれば、この式は単に各 object ごとに内積をとったものを softmax にかけている = ふつうの Attention の計算式と一致します。\n\n$\\omega_G$ は、座標的な関係を考慮するためのパラメータです。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/9a24daf8-38cc-a765-af2f-7efa141cdad9.png\" width=\"50%\"\u003e\n\n$f_G^m$ は object m の座標情報 (x,y, w, h) を表します。\n$\\varepsilon_G$ はふたつの object の座標情報からそれらの座標的関係を計算する関数です。\n\n```math\n\\varepsilon(f_G^m, f_G^n) = (\\log(\\frac{|x_m - x_n|}{w_m}), \\log(\\frac{|y_m - y_n|}{h_m}), \\log(\\frac{w_n}{w_m}), \\log(\\frac{h_n}{h_m}))\n```\n\nさらに、 $max{0, ...}$ をとることで、ReLU 的な働きをし、まったく座標的に関係のない object からの影響を 0 にしています。\n\n## まとめと感想\n\n実験と結果はもと論文を読むのが一番くわしいのでそちらを参照ください。\n「一枚の画像から X を取得したいが、画像の主体となるような X だけを取りたい」といったケースにも応用できる手法かなと思っていて、実験してみたいと思いつつ、本当に end-to-end でやるのはちょっと大変そうすぎるという印象もあります。\n（また論文中には end-to-end が 0 から学習する際の問題にも触れられています。）\nとはいえ完全に end-to-end というのはやっぱり夢があって好きです。\n","slug":"Object_間の関係を使って後処理_0_の物体検出を実現する:_Relation_Networks_for_Object_Detection","title":"Object 間の関係を使って後処理 0 の物体検出を実現する: Relation Networks for Object Detection","timestamp":1544452540000,"tags":["画像処理","DeepLearning","論文読み","物体検出"]},{"rawMarkdown":"---\ntitle: \"簡単な問題は省エネで解き、難しい問題には全力を出すネットワーク: Multi-Scale Dense Networks\"\ndate: 2018-12-07T22:34:37+09:00\ntags: [\"DeepLearning\", \"論文読み\"]\nurl: https://qiita.com/agatan/items/9ea14206bf7a3881ed6d\n---\n\nCNN による画像分類を現実のアプリケーションで使う際には、限られた計算資源で推論をする必要があります。\n推論を待って処理するような場合は latency が重要になり、バッチ処理でも throughput を最大化したいという要求があります。\n\n各タスクで SoTA を達成しているようなモデルはとても Deep であり、毎回走らせるには大きすぎます。\nとはいえ浅いネットワークでは精度に限界もあるので、速度と精度のトレードオフを常に考える必要があります。\n計算量を抑えつつ精度を向上するネットワークを設計する、という方向で MobileNet や SqueezeNet などが提案されています。\n\n今回紹介する論文は、ちょっと別のアプローチで計算資源の問題に立ち向かっています。\nひとことでまとめると **分類が十分に簡単だった場合は早期 exit し、難しいケースだけ深く計算する** という構造をとります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/763043e9-c89d-1521-011a-2ae6905eb2fe.png)\n\n（この図の \"easy\" と書かれている行の画像は省エネで、 \"hard\" と書かれている行の画像は全力で予測する）\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n### Reference\n\n- Multi-Scale Dense Networks for Resource Efficient Image Classification - Gao Huang, Danlu Chen, Tianhong Li, Felix Wu, Laurens van der Maaten, Kilian Q. Weinberger, et al., ICLR 2018\n- https://arxiv.org/abs/1703.09844\n\n文中の図表は論文より引用しています。\n\n### モチベーション\n\n先にも書きましたが、DNN は計算量の大きなアルゴリズムであり、実際に利用するケースを考えると、その速度や計算効率が気になってきます。\n現実の入力画像は様々な難易度のものがあるので、簡単な画像は浅いネットワークで解きたくなりますし、難しい画像は深いネットワークで解きたくなります。\n\nこう表現すると単純そうに見えますが、これを実現するためには「この画像は簡単か（浅いネットワークで解くべきか）、難しいか（深いネットワークで解くべきか）」を決定しなければなりません。\n実際に解く前に難易度を推定するのは難しく、事前に 2 つの model を定義しておく方法ではうまくいきません。\n\nMulti-Scale Dense Networks は、ひとつのモデルで逐次的に推論結果を出しつつ、十分に精度が出せそうであれば早期に Exit し、それ以降の計算を省略します。\n\n### アーキテクチャ\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/c6304ac6-1ccc-369b-0de0-2654fe5cef8d.png)\n↑ がモデルのイメージです。\n`classifier` と書かれた module が複数回出てきているように、それぞれが逐次的な推論結果を出す module になります。\n\nこのような構造を単純にとると以下の２点が問題になります。\n\n1. 粒度の大きい特徴を捉えづらい\n2. 浅い層の classifier が深い層の classifier の精度を下げてしまう\n\n#### 粒度の大きい特徴を捉えづらい\n\n典型的な画像分類のネットワークでは、浅い層で細かい粒度の特徴を獲得し、多くの Convolution や Pooling を経たあとの深い層で荒い粒度の特徴を獲得しています。\n浅い層で分類をやってしまうと解像度の大きい特徴を獲得することができていないため、エラー率が高くなってしまいます。\n次の図は、 ResNet や DenseNet の浅い層に分類器をつけて学習させた場合のエラー率をプロットしています。（損失関数は最終層の分類器の損失と浅い層の分類器の損失の和です。）\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/f0488839-0129-0b45-74c4-159779694ade.png\" width=\"60%\"\u003e\n\n横軸は全体の深さに対して「どの深さに分類器をつけるか」を表しています。\n浅い層につけた分類器ほどエラー率が高くなっていることがわかります。\n\nreceptive field を大きく取った視野の広い特徴を効率的に獲得するためには feature map の解像度を下げる operation （2x2, stride 2 の convolution や pooling など）がよく使われますが、浅いうちにそれらの operation をやってしまうと、細かい粒度の特徴を獲得しづらくなってしまいます。\n\n##### 解決策\n\nMulti-Scale Dense Networks では、複数の解像度の feature map を各深さごとに用意するという解決方法をとっています。\nアーキテクチャの全体像の図で縦に 3 種類のスケールの feature map が並んでいます。\n各層では、以下の２つの operation の concatenate を分類器につなげます。\n\n1. 一つ前の層のもっとも解像度の低い feature map\n2. 一つ前の層の一段細かい feature map を畳み込んで解像度を荒くしたもの\n\nこれによって、細かい粒度の特徴の獲得を維持しつつ、視野の広い特徴を分類器に流すことを可能にしています。\n\n#### 浅い層の classifier が深い層の classifier の精度を下げてしまう\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/9dd54945-ba86-d438-882b-9636fced2451.png\" width=\"60%\"\u003e\n\nこのグラフは ResNet や DenseNet の浅い層に分類器をつけたときの **最終層の分類器の精度** を表したものです。\n縦軸は最終層の分類器のみで学習したときの精度の相対精度です。\n特に ResNet で顕著ですが、浅い層に分類器をつけてしまうと **最終層の分類器の精度が悪くなる** ことがわかります。\n浅い層の分類器を最適化するために、細かい粒度の特徴が失われ、深い層にその特徴が伝わらないことが問題になっています。\n\n##### 解決策\n\n**Dense connectivity** によってこの問題を解決しています。\nDense connectiviy は DenseNet で提案されたもので、あるブロック内の中間層をすべて concatenate するブロックです。\nResNet で提案された Residual Module は、入力とそれを convolution などに通したものを足し合わせるというものでしたが、更にその考えを推し進めたのが DenseNet です。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/d19184ee-8412-8705-e8a6-b92f1ab00108.png)\n\nこれによって、浅い層の結果がそのまま深い層に直結するため、一度細かい特徴を失っても浅い層の出力で recovery することができます。\n\n### まとめと感想\n\n僕らも Wantedly People というスマートフォンのカメラを使ったアプリケーションを提供しているので、モバイル上での推論をしたいというモチベーションがあって読んだ論文でした。\nDenseNet の特徴をきれいに活用していて面白い論文だなと思いました。\nDenseBlock の有効性をちゃんと検証していてこの論文の提案のいいところがわかりやすいのも好きなところです。\n","contentMarkdown":"\nCNN による画像分類を現実のアプリケーションで使う際には、限られた計算資源で推論をする必要があります。\n推論を待って処理するような場合は latency が重要になり、バッチ処理でも throughput を最大化したいという要求があります。\n\n各タスクで SoTA を達成しているようなモデルはとても Deep であり、毎回走らせるには大きすぎます。\nとはいえ浅いネットワークでは精度に限界もあるので、速度と精度のトレードオフを常に考える必要があります。\n計算量を抑えつつ精度を向上するネットワークを設計する、という方向で MobileNet や SqueezeNet などが提案されています。\n\n今回紹介する論文は、ちょっと別のアプローチで計算資源の問題に立ち向かっています。\nひとことでまとめると **分類が十分に簡単だった場合は早期 exit し、難しいケースだけ深く計算する** という構造をとります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/763043e9-c89d-1521-011a-2ae6905eb2fe.png)\n\n（この図の \"easy\" と書かれている行の画像は省エネで、 \"hard\" と書かれている行の画像は全力で予測する）\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n### Reference\n\n- Multi-Scale Dense Networks for Resource Efficient Image Classification - Gao Huang, Danlu Chen, Tianhong Li, Felix Wu, Laurens van der Maaten, Kilian Q. Weinberger, et al., ICLR 2018\n- https://arxiv.org/abs/1703.09844\n\n文中の図表は論文より引用しています。\n\n### モチベーション\n\n先にも書きましたが、DNN は計算量の大きなアルゴリズムであり、実際に利用するケースを考えると、その速度や計算効率が気になってきます。\n現実の入力画像は様々な難易度のものがあるので、簡単な画像は浅いネットワークで解きたくなりますし、難しい画像は深いネットワークで解きたくなります。\n\nこう表現すると単純そうに見えますが、これを実現するためには「この画像は簡単か（浅いネットワークで解くべきか）、難しいか（深いネットワークで解くべきか）」を決定しなければなりません。\n実際に解く前に難易度を推定するのは難しく、事前に 2 つの model を定義しておく方法ではうまくいきません。\n\nMulti-Scale Dense Networks は、ひとつのモデルで逐次的に推論結果を出しつつ、十分に精度が出せそうであれば早期に Exit し、それ以降の計算を省略します。\n\n### アーキテクチャ\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/c6304ac6-1ccc-369b-0de0-2654fe5cef8d.png)\n↑ がモデルのイメージです。\n`classifier` と書かれた module が複数回出てきているように、それぞれが逐次的な推論結果を出す module になります。\n\nこのような構造を単純にとると以下の２点が問題になります。\n\n1. 粒度の大きい特徴を捉えづらい\n2. 浅い層の classifier が深い層の classifier の精度を下げてしまう\n\n#### 粒度の大きい特徴を捉えづらい\n\n典型的な画像分類のネットワークでは、浅い層で細かい粒度の特徴を獲得し、多くの Convolution や Pooling を経たあとの深い層で荒い粒度の特徴を獲得しています。\n浅い層で分類をやってしまうと解像度の大きい特徴を獲得することができていないため、エラー率が高くなってしまいます。\n次の図は、 ResNet や DenseNet の浅い層に分類器をつけて学習させた場合のエラー率をプロットしています。（損失関数は最終層の分類器の損失と浅い層の分類器の損失の和です。）\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/f0488839-0129-0b45-74c4-159779694ade.png\" width=\"60%\"\u003e\n\n横軸は全体の深さに対して「どの深さに分類器をつけるか」を表しています。\n浅い層につけた分類器ほどエラー率が高くなっていることがわかります。\n\nreceptive field を大きく取った視野の広い特徴を効率的に獲得するためには feature map の解像度を下げる operation （2x2, stride 2 の convolution や pooling など）がよく使われますが、浅いうちにそれらの operation をやってしまうと、細かい粒度の特徴を獲得しづらくなってしまいます。\n\n##### 解決策\n\nMulti-Scale Dense Networks では、複数の解像度の feature map を各深さごとに用意するという解決方法をとっています。\nアーキテクチャの全体像の図で縦に 3 種類のスケールの feature map が並んでいます。\n各層では、以下の２つの operation の concatenate を分類器につなげます。\n\n1. 一つ前の層のもっとも解像度の低い feature map\n2. 一つ前の層の一段細かい feature map を畳み込んで解像度を荒くしたもの\n\nこれによって、細かい粒度の特徴の獲得を維持しつつ、視野の広い特徴を分類器に流すことを可能にしています。\n\n#### 浅い層の classifier が深い層の classifier の精度を下げてしまう\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/9dd54945-ba86-d438-882b-9636fced2451.png\" width=\"60%\"\u003e\n\nこのグラフは ResNet や DenseNet の浅い層に分類器をつけたときの **最終層の分類器の精度** を表したものです。\n縦軸は最終層の分類器のみで学習したときの精度の相対精度です。\n特に ResNet で顕著ですが、浅い層に分類器をつけてしまうと **最終層の分類器の精度が悪くなる** ことがわかります。\n浅い層の分類器を最適化するために、細かい粒度の特徴が失われ、深い層にその特徴が伝わらないことが問題になっています。\n\n##### 解決策\n\n**Dense connectivity** によってこの問題を解決しています。\nDense connectiviy は DenseNet で提案されたもので、あるブロック内の中間層をすべて concatenate するブロックです。\nResNet で提案された Residual Module は、入力とそれを convolution などに通したものを足し合わせるというものでしたが、更にその考えを推し進めたのが DenseNet です。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/d19184ee-8412-8705-e8a6-b92f1ab00108.png)\n\nこれによって、浅い層の結果がそのまま深い層に直結するため、一度細かい特徴を失っても浅い層の出力で recovery することができます。\n\n### まとめと感想\n\n僕らも Wantedly People というスマートフォンのカメラを使ったアプリケーションを提供しているので、モバイル上での推論をしたいというモチベーションがあって読んだ論文でした。\nDenseNet の特徴をきれいに活用していて面白い論文だなと思いました。\nDenseBlock の有効性をちゃんと検証していてこの論文の提案のいいところがわかりやすいのも好きなところです。\n","slug":"簡単な問題は省エネで解き、難しい問題には全力を出すネットワーク:_Multi-Scale_Dense_Networks","title":"簡単な問題は省エネで解き、難しい問題には全力を出すネットワーク: Multi-Scale Dense Networks","timestamp":1544189677000,"tags":["DeepLearning","論文読み"]},{"rawMarkdown":"---\ntitle: \"[論文紹介] Focal Loss for Dense Object Detection\"\ndate: 2018-12-03\ntags:\n  - MachineLearning\n  - paper\n---\n\n高速かつ高精度に物体検出を行う RetinaNet に使われている **Focal Loss** という損失関数を提案した論文を読んだので紹介します。\nFAIR(Facebook AI Research) が書いた論文で ICCV 2017 に採択されています。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/38ab1ef6-c4c5-fd78-d903-0954479143a6.png\" width=\"60%\"\u003e\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n#### Reference\n\n- Focal Loss for Dense Object Detection [Tsung-Yi Lin, Priya Goyal, Ross Girshick, Kaiming He, Piotr Dollár @ ICCV 2017]\n- https://arxiv.org/abs/1708.02002\n\n（文中の図表は論文より引用）\n\n### モチベーション\n\n精度の良い object detector の多くは R-CNN[^1] ベースの two-stage object detector の構成を取っています。\n[^1]: [Rich feature hierarchies for accurate object detection and semantic segmentation](https://arxiv.org/abs/1311.2524) [Ross Girshick, et al.]\nR-CNN は、 まず物体のある bounding box の候補集合を提案し、その後 2nd stage で提案された各 box について classification を行うという構成になっています。\ntwo-stage object detector は高い精度を記録していますが、一方で複雑さと推論速度に問題がありました。\n\nそこで、 YOLO[^2][^3] や SSD[^4][^5] のような one-stage で高速に物体検出を行うネットワークが提案されてきました。\n[^2]: [You Only Look Once: Unified, Real-Time Object Detection](https://arxiv.org/abs/1506.02640) [J. Redmon, et al.]\n[^3]: [YOLO9000: Better, Faster, Stronger](https://arxiv.org/abs/1612.08242) [J. Redmon, et al.]\n[^4]: [SSD: Single Shot MultiBox Detector](https://arxiv.org/abs/1512.02325) [W. Liu, et al.]\n[^5]: [DSSD : Deconvolutional Single Shot Detector](https://arxiv.org/abs/1701.06659) [C.-Y. Fu, et al.]\n\nしかし、これらの one-stage detector は高速な一方で（当時の） state-of-the-art methods と比べると精度は劣るという課題がありました。\n\nこの論文では one-stage detector が two-stage detector と並ぶ精度を出せないのは「クラス間の不均衡」が原因であるという仮説をたてています。\n画像のほとんどの pixel は background であり、foreground（背景以外のクラス）に属する pixel の数と比べると圧倒的な不均衡があるため、学習のほとんどが簡単な background 判定に支配されてしまいます。\n（two-stage の場合は 1st stage で注目すべき部分を限定しているため、background の多くは 1st stage でフィルタリングされ、2nd stage は不均衡が解決された状態で学習することができます。）\n\nそこで登場するのが **Focal Loss** です。\n\n### Focal Loss\n\nFocal Loss は通常の cross entropy loss (CE) を動的に scaling させる損失関数です。\n通常の CE と比較したのが次の図です。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/77bb8c08-0a47-d77a-fed7-17038e29a8cf.png\" width=\"60%\"\u003e\n\n通常の CE は以下のようなものです(binary cross entropy の場合）。\n\n```math\n{\\rm CE}(p_t) = -{\\rm log}(p_t).  \\\\\n\np_t = \\left\\{\n\\begin{array}{ll}\np \u0026 {\\rm if}\\: y = 1 \\\\\n1 - p \u0026 {\\rm otherwise.} \\\\\n\\end{array}\n\\right.\n```\n\nさきほどの図の `γ = 0` の青い曲線は通常の CE を `p` を x 軸にグラフにしたものです。\n図からわかるように、 0.6 といった十分に分類できている probability を出力したとしても、損失は無視できない値になっています。\nそのため、簡単に background と分類できていても大量の exmaple が積み重なって、 foreground の損失よりも強くなってしまいます。\n\nFocal Loss は、easy example （簡単に分類に成功している example）の損失を小さく scale します。\n\n```math\n{\\rm FL}(p_t) = -(1 - p_t) ^ \\gamma {\\rm log} (p_t).\n```\n\n`γ` はパラメータで、どのくらい easy example の損失を decay するかを決定します。\n簡単に分類に成功している example では\n\n```math\n(1 - p_t) ^ \\gamma\n```\n\nが小さい値になるため、損失への寄与が小さくなります。\nこれによって、より難しい focus すべき example が学習に強く寄与できるようになります。\n（論文中の実験では `γ = 2` を採用しています。）\n\nこの論文では RetinaNet というアーキテクチャを設計し Focal Loss を用いて学習させています。\nRetinaNet の設計の詳細は省きますが、精度を既存の object detector と比較したのが冒頭の図と次の表です。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/d711797c-f160-08c3-97b8-027f34bbf373.png)\n\ntwo-stage detector と同等（以上）の精度を達成しています。\n\n### 感想\n\nアイディアがシンプルで、 object detection 以外のタスクに対しても応用可能な手法ですごく好きな論文です。\n実装も簡単なので試しやすく良い結果がでたので、何度かお世話になっています。\n\nちなみにこの論文のあとに書かれた YOLOv3[^6] では Focal Loss を採用していませんが、 RetinaNet と精度・速度を比較していて Focal Loss に関する考察も書かれています。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/d2caf698-0c58-c03d-4fa4-085e63ccb24c.png\" width=\"60%\"\u003e\n\n[^6]: [YOLOv3: An Incremental Improvement](https://arxiv.org/abs/1804.02767) [J. Redmon, et al.]\n\nまた、facebook が公開している [Detectron](https://github.com/facebookresearch/Detectron) にも RetineNet の実装が含まれているので簡単に利用することもできそうです。\n","contentMarkdown":"\n高速かつ高精度に物体検出を行う RetinaNet に使われている **Focal Loss** という損失関数を提案した論文を読んだので紹介します。\nFAIR(Facebook AI Research) が書いた論文で ICCV 2017 に採択されています。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/38ab1ef6-c4c5-fd78-d903-0954479143a6.png\" width=\"60%\"\u003e\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n#### Reference\n\n- Focal Loss for Dense Object Detection [Tsung-Yi Lin, Priya Goyal, Ross Girshick, Kaiming He, Piotr Dollár @ ICCV 2017]\n- https://arxiv.org/abs/1708.02002\n\n（文中の図表は論文より引用）\n\n### モチベーション\n\n精度の良い object detector の多くは R-CNN[^1] ベースの two-stage object detector の構成を取っています。\n[^1]: [Rich feature hierarchies for accurate object detection and semantic segmentation](https://arxiv.org/abs/1311.2524) [Ross Girshick, et al.]\nR-CNN は、 まず物体のある bounding box の候補集合を提案し、その後 2nd stage で提案された各 box について classification を行うという構成になっています。\ntwo-stage object detector は高い精度を記録していますが、一方で複雑さと推論速度に問題がありました。\n\nそこで、 YOLO[^2][^3] や SSD[^4][^5] のような one-stage で高速に物体検出を行うネットワークが提案されてきました。\n[^2]: [You Only Look Once: Unified, Real-Time Object Detection](https://arxiv.org/abs/1506.02640) [J. Redmon, et al.]\n[^3]: [YOLO9000: Better, Faster, Stronger](https://arxiv.org/abs/1612.08242) [J. Redmon, et al.]\n[^4]: [SSD: Single Shot MultiBox Detector](https://arxiv.org/abs/1512.02325) [W. Liu, et al.]\n[^5]: [DSSD : Deconvolutional Single Shot Detector](https://arxiv.org/abs/1701.06659) [C.-Y. Fu, et al.]\n\nしかし、これらの one-stage detector は高速な一方で（当時の） state-of-the-art methods と比べると精度は劣るという課題がありました。\n\nこの論文では one-stage detector が two-stage detector と並ぶ精度を出せないのは「クラス間の不均衡」が原因であるという仮説をたてています。\n画像のほとんどの pixel は background であり、foreground（背景以外のクラス）に属する pixel の数と比べると圧倒的な不均衡があるため、学習のほとんどが簡単な background 判定に支配されてしまいます。\n（two-stage の場合は 1st stage で注目すべき部分を限定しているため、background の多くは 1st stage でフィルタリングされ、2nd stage は不均衡が解決された状態で学習することができます。）\n\nそこで登場するのが **Focal Loss** です。\n\n### Focal Loss\n\nFocal Loss は通常の cross entropy loss (CE) を動的に scaling させる損失関数です。\n通常の CE と比較したのが次の図です。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/77bb8c08-0a47-d77a-fed7-17038e29a8cf.png\" width=\"60%\"\u003e\n\n通常の CE は以下のようなものです(binary cross entropy の場合）。\n\n```math\n{\\rm CE}(p_t) = -{\\rm log}(p_t).  \\\\\n\np_t = \\left\\{\n\\begin{array}{ll}\np \u0026 {\\rm if}\\: y = 1 \\\\\n1 - p \u0026 {\\rm otherwise.} \\\\\n\\end{array}\n\\right.\n```\n\nさきほどの図の `γ = 0` の青い曲線は通常の CE を `p` を x 軸にグラフにしたものです。\n図からわかるように、 0.6 といった十分に分類できている probability を出力したとしても、損失は無視できない値になっています。\nそのため、簡単に background と分類できていても大量の exmaple が積み重なって、 foreground の損失よりも強くなってしまいます。\n\nFocal Loss は、easy example （簡単に分類に成功している example）の損失を小さく scale します。\n\n```math\n{\\rm FL}(p_t) = -(1 - p_t) ^ \\gamma {\\rm log} (p_t).\n```\n\n`γ` はパラメータで、どのくらい easy example の損失を decay するかを決定します。\n簡単に分類に成功している example では\n\n```math\n(1 - p_t) ^ \\gamma\n```\n\nが小さい値になるため、損失への寄与が小さくなります。\nこれによって、より難しい focus すべき example が学習に強く寄与できるようになります。\n（論文中の実験では `γ = 2` を採用しています。）\n\nこの論文では RetinaNet というアーキテクチャを設計し Focal Loss を用いて学習させています。\nRetinaNet の設計の詳細は省きますが、精度を既存の object detector と比較したのが冒頭の図と次の表です。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/d711797c-f160-08c3-97b8-027f34bbf373.png)\n\ntwo-stage detector と同等（以上）の精度を達成しています。\n\n### 感想\n\nアイディアがシンプルで、 object detection 以外のタスクに対しても応用可能な手法ですごく好きな論文です。\n実装も簡単なので試しやすく良い結果がでたので、何度かお世話になっています。\n\nちなみにこの論文のあとに書かれた YOLOv3[^6] では Focal Loss を採用していませんが、 RetinaNet と精度・速度を比較していて Focal Loss に関する考察も書かれています。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/d2caf698-0c58-c03d-4fa4-085e63ccb24c.png\" width=\"60%\"\u003e\n\n[^6]: [YOLOv3: An Incremental Improvement](https://arxiv.org/abs/1804.02767) [J. Redmon, et al.]\n\nまた、facebook が公開している [Detectron](https://github.com/facebookresearch/Detectron) にも RetineNet の実装が含まれているので簡単に利用することもできそうです。\n","slug":"focal-loss","title":"[論文紹介] Focal Loss for Dense Object Detection","timestamp":1543795200000,"tags":["MachineLearning","paper"]},{"rawMarkdown":"---\ntitle: \"[論文紹介] Focal Loss for Dense Object Detection\"\ndate: 2018-12-02T18:41:00+09:00\ntags: [\"DeepLearning\", \"論文読み\", \"ICCV\"]\nurl: https://qiita.com/agatan/items/53fe8d21f2147b0ac982\n---\n\n高速かつ高精度に物体検出を行う RetinaNet に使われている **Focal Loss** という損失関数を提案した論文を読んだので紹介します。\nFAIR(Facebook AI Research) が書いた論文で ICCV 2017 に採択されています。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/38ab1ef6-c4c5-fd78-d903-0954479143a6.png\" width=\"60%\"\u003e\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n#### Reference\n\n- Focal Loss for Dense Object Detection [Tsung-Yi Lin, Priya Goyal, Ross Girshick, Kaiming He, Piotr Dollár @ ICCV 2017]\n- https://arxiv.org/abs/1708.02002\n\n（文中の図表は論文より引用）\n\n### モチベーション\n\n精度の良い object detector の多くは R-CNN[^1] ベースの two-stage object detector の構成を取っています。\n[^1]: [Rich feature hierarchies for accurate object detection and semantic segmentation](https://arxiv.org/abs/1311.2524) [Ross Girshick, et al.]\nR-CNN は、 まず物体のある bounding box の候補集合を提案し、その後 2nd stage で提案された各 box について classification を行うという構成になっています。\ntwo-stage object detector は高い精度を記録していますが、一方で複雑さと推論速度に問題がありました。\n\nそこで、 YOLO[^2][^3] や SSD[^4][^5] のような one-stage で高速に物体検出を行うネットワークが提案されてきました。\n[^2]: [You Only Look Once: Unified, Real-Time Object Detection](https://arxiv.org/abs/1506.02640) [J. Redmon, et al.]\n[^3]: [YOLO9000: Better, Faster, Stronger](https://arxiv.org/abs/1612.08242) [J. Redmon, et al.]\n[^4]: [SSD: Single Shot MultiBox Detector](https://arxiv.org/abs/1512.02325) [W. Liu, et al.]\n[^5]: [DSSD : Deconvolutional Single Shot Detector](https://arxiv.org/abs/1701.06659) [C.-Y. Fu, et al.]\n\nしかし、これらの one-stage detector は高速な一方で（当時の） state-of-the-art methods と比べると精度は劣るという課題がありました。\n\nこの論文では one-stage detector が two-stage detector と並ぶ精度を出せないのは「クラス間の不均衡」が原因であるという仮説をたてています。\n画像のほとんどの pixel は background であり、foreground（背景以外のクラス）に属する pixel の数と比べると圧倒的な不均衡があるため、学習のほとんどが簡単な background 判定に支配されてしまいます。\n（two-stage の場合は 1st stage で注目すべき部分を限定しているため、background の多くは 1st stage でフィルタリングされ、2nd stage は不均衡が解決された状態で学習することができます。）\n\nそこで登場するのが **Focal Loss** です。\n\n### Focal Loss\n\nFocal Loss は通常の cross entropy loss (CE) を動的に scaling させる損失関数です。\n通常の CE と比較したのが次の図です。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/77bb8c08-0a47-d77a-fed7-17038e29a8cf.png\" width=\"60%\"\u003e\n\n通常の CE は以下のようなものです(binary cross entropy の場合）。\n\n```math\n{\\rm CE}(p_t) = -{\\rm log}(p_t).  \\\\\n\np_t = \\left\\{\n\\begin{array}{ll}\np \u0026 {\\rm if}\\: y = 1 \\\\\n1 - p \u0026 {\\rm otherwise.} \\\\\n\\end{array}\n\\right.\n```\n\nさきほどの図の `γ = 0` の青い曲線は通常の CE を `p` を x 軸にグラフにしたものです。\n図からわかるように、 0.6 といった十分に分類できている probability を出力したとしても、損失は無視できない値になっています。\nそのため、簡単に background と分類できていても大量の exmaple が積み重なって、 foreground の損失よりも強くなってしまいます。\n\nFocal Loss は、easy example （簡単に分類に成功している example）の損失を小さく scale します。\n\n```math\n{\\rm FL}(p_t) = -(1 - p_t) ^ \\gamma {\\rm log} (p_t).\n```\n\n`γ` はパラメータで、どのくらい easy example の損失を decay するかを決定します。\n簡単に分類に成功している example では\n\n```math\n(1 - p_t) ^ \\gamma\n```\n\nが小さい値になるため、損失への寄与が小さくなります。\nこれによって、より難しい focus すべき example が学習に強く寄与できるようになります。\n（論文中の実験では `γ = 2` を採用しています。）\n\nこの論文では RetinaNet というアーキテクチャを設計し Focal Loss を用いて学習させています。\nRetinaNet の設計の詳細は省きますが、精度を既存の object detector と比較したのが冒頭の図と次の表です。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/d711797c-f160-08c3-97b8-027f34bbf373.png)\n\ntwo-stage detector と同等（以上）の精度を達成しています。\n\n### 感想\n\nアイディアがシンプルで、 object detection 以外のタスクに対しても応用可能な手法ですごく好きな論文です。\n実装も簡単なので試しやすく良い結果がでたので、何度かお世話になっています。\n\nちなみにこの論文のあとに書かれた YOLOv3[^6] では Focal Loss を採用していませんが、 RetinaNet と精度・速度を比較していて Focal Loss に関する考察も書かれています。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/d2caf698-0c58-c03d-4fa4-085e63ccb24c.png\" width=\"60%\"\u003e\n\n[^6]: [YOLOv3: An Incremental Improvement](https://arxiv.org/abs/1804.02767) [J. Redmon, et al.]\n\nまた、facebook が公開している [Detectron](https://github.com/facebookresearch/Detectron) にも RetineNet の実装が含まれているので簡単に利用することもできそうです。\n","contentMarkdown":"\n高速かつ高精度に物体検出を行う RetinaNet に使われている **Focal Loss** という損失関数を提案した論文を読んだので紹介します。\nFAIR(Facebook AI Research) が書いた論文で ICCV 2017 に採択されています。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/38ab1ef6-c4c5-fd78-d903-0954479143a6.png\" width=\"60%\"\u003e\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n#### Reference\n\n- Focal Loss for Dense Object Detection [Tsung-Yi Lin, Priya Goyal, Ross Girshick, Kaiming He, Piotr Dollár @ ICCV 2017]\n- https://arxiv.org/abs/1708.02002\n\n（文中の図表は論文より引用）\n\n### モチベーション\n\n精度の良い object detector の多くは R-CNN[^1] ベースの two-stage object detector の構成を取っています。\n[^1]: [Rich feature hierarchies for accurate object detection and semantic segmentation](https://arxiv.org/abs/1311.2524) [Ross Girshick, et al.]\nR-CNN は、 まず物体のある bounding box の候補集合を提案し、その後 2nd stage で提案された各 box について classification を行うという構成になっています。\ntwo-stage object detector は高い精度を記録していますが、一方で複雑さと推論速度に問題がありました。\n\nそこで、 YOLO[^2][^3] や SSD[^4][^5] のような one-stage で高速に物体検出を行うネットワークが提案されてきました。\n[^2]: [You Only Look Once: Unified, Real-Time Object Detection](https://arxiv.org/abs/1506.02640) [J. Redmon, et al.]\n[^3]: [YOLO9000: Better, Faster, Stronger](https://arxiv.org/abs/1612.08242) [J. Redmon, et al.]\n[^4]: [SSD: Single Shot MultiBox Detector](https://arxiv.org/abs/1512.02325) [W. Liu, et al.]\n[^5]: [DSSD : Deconvolutional Single Shot Detector](https://arxiv.org/abs/1701.06659) [C.-Y. Fu, et al.]\n\nしかし、これらの one-stage detector は高速な一方で（当時の） state-of-the-art methods と比べると精度は劣るという課題がありました。\n\nこの論文では one-stage detector が two-stage detector と並ぶ精度を出せないのは「クラス間の不均衡」が原因であるという仮説をたてています。\n画像のほとんどの pixel は background であり、foreground（背景以外のクラス）に属する pixel の数と比べると圧倒的な不均衡があるため、学習のほとんどが簡単な background 判定に支配されてしまいます。\n（two-stage の場合は 1st stage で注目すべき部分を限定しているため、background の多くは 1st stage でフィルタリングされ、2nd stage は不均衡が解決された状態で学習することができます。）\n\nそこで登場するのが **Focal Loss** です。\n\n### Focal Loss\n\nFocal Loss は通常の cross entropy loss (CE) を動的に scaling させる損失関数です。\n通常の CE と比較したのが次の図です。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/77bb8c08-0a47-d77a-fed7-17038e29a8cf.png\" width=\"60%\"\u003e\n\n通常の CE は以下のようなものです(binary cross entropy の場合）。\n\n```math\n{\\rm CE}(p_t) = -{\\rm log}(p_t).  \\\\\n\np_t = \\left\\{\n\\begin{array}{ll}\np \u0026 {\\rm if}\\: y = 1 \\\\\n1 - p \u0026 {\\rm otherwise.} \\\\\n\\end{array}\n\\right.\n```\n\nさきほどの図の `γ = 0` の青い曲線は通常の CE を `p` を x 軸にグラフにしたものです。\n図からわかるように、 0.6 といった十分に分類できている probability を出力したとしても、損失は無視できない値になっています。\nそのため、簡単に background と分類できていても大量の exmaple が積み重なって、 foreground の損失よりも強くなってしまいます。\n\nFocal Loss は、easy example （簡単に分類に成功している example）の損失を小さく scale します。\n\n```math\n{\\rm FL}(p_t) = -(1 - p_t) ^ \\gamma {\\rm log} (p_t).\n```\n\n`γ` はパラメータで、どのくらい easy example の損失を decay するかを決定します。\n簡単に分類に成功している example では\n\n```math\n(1 - p_t) ^ \\gamma\n```\n\nが小さい値になるため、損失への寄与が小さくなります。\nこれによって、より難しい focus すべき example が学習に強く寄与できるようになります。\n（論文中の実験では `γ = 2` を採用しています。）\n\nこの論文では RetinaNet というアーキテクチャを設計し Focal Loss を用いて学習させています。\nRetinaNet の設計の詳細は省きますが、精度を既存の object detector と比較したのが冒頭の図と次の表です。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/d711797c-f160-08c3-97b8-027f34bbf373.png)\n\ntwo-stage detector と同等（以上）の精度を達成しています。\n\n### 感想\n\nアイディアがシンプルで、 object detection 以外のタスクに対しても応用可能な手法ですごく好きな論文です。\n実装も簡単なので試しやすく良い結果がでたので、何度かお世話になっています。\n\nちなみにこの論文のあとに書かれた YOLOv3[^6] では Focal Loss を採用していませんが、 RetinaNet と精度・速度を比較していて Focal Loss に関する考察も書かれています。\n\n\u003cimg src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/d2caf698-0c58-c03d-4fa4-085e63ccb24c.png\" width=\"60%\"\u003e\n\n[^6]: [YOLOv3: An Incremental Improvement](https://arxiv.org/abs/1804.02767) [J. Redmon, et al.]\n\nまた、facebook が公開している [Detectron](https://github.com/facebookresearch/Detectron) にも RetineNet の実装が含まれているので簡単に利用することもできそうです。\n","slug":"[論文紹介]_Focal_Loss_for_Dense_Object_Detection","title":"[論文紹介] Focal Loss for Dense Object Detection","timestamp":1543743660000,"tags":["DeepLearning","論文読み","ICCV"]},{"rawMarkdown":"---\ntitle: \"\u0026quot;Applying Deep Learning To Airbnb Search\u0026quot;  を読んだ\"\ndate: 2018-11-21T12:52:58.000Z\ntags: []\n---\n\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/1810.09591\"\u003e[1810.09591] Applying Deep Learning To Airbnb Search\u003c/a\u003e を読んだときのメモをそのまま出してみます。面白かった。\n本当にメモなので、詳細は原文を読んでください。\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/airbnb\"\u003eairbnb\u003c/a\u003e の search ranking に \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/deep%20learning\"\u003edeep learning\u003c/a\u003e を導入していく過程を論文っぽくしたもの。\u003c/p\u003e\n\n\u003cp\u003eおしゃれな\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E2%A5%C7%A5%EA%A5%F3%A5%B0\"\u003eモデリング\u003c/a\u003e手法の提案とかじゃなくて、現実の問題に対して NN を適用していくにあたって発見した良かったこと・悪かったことについてまとめた文章になっている。\u003c/p\u003e\n\n\u003ch2\u003eMotivation\u003c/h2\u003e\n\n\u003cp\u003eもともと Gradient Boosted Decision Tree でやっていて結構うまく行っていたが、gain が停滞してきたのでそれの突破口を探していた。\u003c/p\u003e\n\n\u003ch2\u003eModel Evolution\u003c/h2\u003e\n\n\u003cp\u003e評価指標は NDCG (Normalized Discounted Cumulative Gain) を使っている。\u003c/p\u003e\n\n\u003cp\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20181121/20181121214034.png\" alt=\"f:id:agtn:20181121214034p:plain\" title=\"f:id:agtn:20181121214034p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\"Convolutional Neural Networks for Visual Recognition\" を書いた A. Kaypathy が \"don't be a hero\" と言っている（複雑なモデルを扱えると思わないほうがいいよ、みたいな意味？）が、\"Why can't we be \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/heroes\"\u003eheroes\u003c/a\u003e?\" と言いながら複雑なモデルに爆進したらしい\u003c/p\u003e\n\n\u003cp\u003eその結果、無限に時間を持っていかれて全然うまくいかなかった。\u003c/p\u003e\n\n\u003cp\u003e結局、最初に production に入ったモデルはめちゃくちゃシンプルな NN だった。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003ea simple single hidden layer NN with 32 fully connected ReLU activations that proved booking neutral against the GBDT model.\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e入力や目的関数も GBDT と全く同じにしている。（booking するかしないかの L2 regression loss）\u003c/p\u003e\n\n\u003cp\u003eものすごく gain があったわけではないけれど、NN が production でうごく、live traffic をちゃんとさばけるという pipeline を整えるためにこの step 自体は良かったと言っている。\u003c/p\u003e\n\n\u003cp\u003eやりすぎないことで先に進むことはできたが、すごくよくもなっていなかった。つぎの breakthrough は LambdaRank + NN を組み合わせたことだった。LambdaRank は Learning to Rank の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\"\u003eアルゴリズム\u003c/a\u003eで、簡単にいえばロス関数に直接評価指標（ここでは NDCG）を組み込める（ここまでは learning to rank 的なアプローチはまったく取っていなかった。単にクリック率をよく予測し、それを上から出すことで NDCG を最適化していた）。\u003c/p\u003e\n\n\u003cp\u003eこれらをやりながらも Factorization Machine と GBDT は research を続けていて、NN と comparable な成果が出せることはわかっていた。comparable な成果が出ている一方で出力される list は全然別物だったので、組み合わせたらもっと良くなるのではということで、FM や GBDT の結果を特徴量に含む NN を学習させて利用することにした。\u003c/p\u003e\n\n\u003cp\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20181121/20181121214010.png\" alt=\"f:id:agtn:20181121214010p:plain\" title=\"f:id:agtn:20181121214010p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003eこの時点でもうモデルの複雑さは結構なものになっていて、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A1%B3%A3%B3%D8%BD%AC\"\u003e機械学習\u003c/a\u003eの技術的負債問題が顔をだしつつあった。そこで、 ensamble などをすべて捨てて、単に DNN を大量のデータ（いままでの 10x）で学習させるというシンプルな解法に舵を切った（DNN とはいえ 2 hidden layers）。入力の次元は 195 次元、1st hidden layer = 127, 2nd = 83 というモデル。入力の特徴量はシンプルなもので、価格、アメニティ、過去の booking 数、などなど。ほぼ feature engineering をせずに入力した（これが DNN にする目的だった）。\u003c/p\u003e\n\n\u003ch2\u003eFailed Models\u003c/h2\u003e\n\n\u003cp\u003e失敗についても言及してくれていてすごく嬉しい。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eID を使ったモデルは\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%E1%B3%D8%BD%AC\"\u003e過学習\u003c/a\u003eがひどくて使えなかった\n\n\u003cul\u003e\n\u003cli\u003e扱っているアイテムの都合上、ある ID に対してたくさんのデータが取れることがない\n\n\u003cul\u003e\n\u003cli\u003eどれだけ人気でも年間 365 までしかコンバージョンしない\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e詳細ページへの遷移は booking よりはるかに多いし dense なので、それを使うモデルも作ったがうまくいかなかった\n\n\u003cul\u003e\n\u003cli\u003emulti task 学習で、booking prediction と long view prediction を予測させた\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eあとは NN は特徴量を normalize したほうがいいよねとか、特徴量の distribution を観察しましょうとか、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e 上で TensorFlow のモデル動かすの大変でしたとか、いろいろ現実っぽい話が並ぶ。\nもっといろいろ言ってるけど、詳細は本文を読んだほうが良い。\u003c/p\u003e\n\n\u003cp\u003e画像とかじゃない領域で DNN を production にいれるにはこういうステップを経るんだなというのが伝わってくるし、この話から得るべき学びがかなりある。光景が目に浮かぶ良い文章だなと思いました。\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/1810.09591\"\u003e[1810.09591] Applying Deep Learning To Airbnb Search\u003c/a\u003e を読んだときのメモをそのまま出してみます。面白かった。\n本当にメモなので、詳細は原文を読んでください。\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/airbnb\"\u003eairbnb\u003c/a\u003e の search ranking に \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/deep%20learning\"\u003edeep learning\u003c/a\u003e を導入していく過程を論文っぽくしたもの。\u003c/p\u003e\n\n\u003cp\u003eおしゃれな\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E2%A5%C7%A5%EA%A5%F3%A5%B0\"\u003eモデリング\u003c/a\u003e手法の提案とかじゃなくて、現実の問題に対して NN を適用していくにあたって発見した良かったこと・悪かったことについてまとめた文章になっている。\u003c/p\u003e\n\n\u003ch2\u003eMotivation\u003c/h2\u003e\n\n\u003cp\u003eもともと Gradient Boosted Decision Tree でやっていて結構うまく行っていたが、gain が停滞してきたのでそれの突破口を探していた。\u003c/p\u003e\n\n\u003ch2\u003eModel Evolution\u003c/h2\u003e\n\n\u003cp\u003e評価指標は NDCG (Normalized Discounted Cumulative Gain) を使っている。\u003c/p\u003e\n\n\u003cp\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20181121/20181121214034.png\" alt=\"f:id:agtn:20181121214034p:plain\" title=\"f:id:agtn:20181121214034p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\"Convolutional Neural Networks for Visual Recognition\" を書いた A. Kaypathy が \"don't be a hero\" と言っている（複雑なモデルを扱えると思わないほうがいいよ、みたいな意味？）が、\"Why can't we be \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/heroes\"\u003eheroes\u003c/a\u003e?\" と言いながら複雑なモデルに爆進したらしい\u003c/p\u003e\n\n\u003cp\u003eその結果、無限に時間を持っていかれて全然うまくいかなかった。\u003c/p\u003e\n\n\u003cp\u003e結局、最初に production に入ったモデルはめちゃくちゃシンプルな NN だった。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003ea simple single hidden layer NN with 32 fully connected ReLU activations that proved booking neutral against the GBDT model.\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e入力や目的関数も GBDT と全く同じにしている。（booking するかしないかの L2 regression loss）\u003c/p\u003e\n\n\u003cp\u003eものすごく gain があったわけではないけれど、NN が production でうごく、live traffic をちゃんとさばけるという pipeline を整えるためにこの step 自体は良かったと言っている。\u003c/p\u003e\n\n\u003cp\u003eやりすぎないことで先に進むことはできたが、すごくよくもなっていなかった。つぎの breakthrough は LambdaRank + NN を組み合わせたことだった。LambdaRank は Learning to Rank の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\"\u003eアルゴリズム\u003c/a\u003eで、簡単にいえばロス関数に直接評価指標（ここでは NDCG）を組み込める（ここまでは learning to rank 的なアプローチはまったく取っていなかった。単にクリック率をよく予測し、それを上から出すことで NDCG を最適化していた）。\u003c/p\u003e\n\n\u003cp\u003eこれらをやりながらも Factorization Machine と GBDT は research を続けていて、NN と comparable な成果が出せることはわかっていた。comparable な成果が出ている一方で出力される list は全然別物だったので、組み合わせたらもっと良くなるのではということで、FM や GBDT の結果を特徴量に含む NN を学習させて利用することにした。\u003c/p\u003e\n\n\u003cp\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20181121/20181121214010.png\" alt=\"f:id:agtn:20181121214010p:plain\" title=\"f:id:agtn:20181121214010p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003eこの時点でもうモデルの複雑さは結構なものになっていて、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A1%B3%A3%B3%D8%BD%AC\"\u003e機械学習\u003c/a\u003eの技術的負債問題が顔をだしつつあった。そこで、 ensamble などをすべて捨てて、単に DNN を大量のデータ（いままでの 10x）で学習させるというシンプルな解法に舵を切った（DNN とはいえ 2 hidden layers）。入力の次元は 195 次元、1st hidden layer = 127, 2nd = 83 というモデル。入力の特徴量はシンプルなもので、価格、アメニティ、過去の booking 数、などなど。ほぼ feature engineering をせずに入力した（これが DNN にする目的だった）。\u003c/p\u003e\n\n\u003ch2\u003eFailed Models\u003c/h2\u003e\n\n\u003cp\u003e失敗についても言及してくれていてすごく嬉しい。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eID を使ったモデルは\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%E1%B3%D8%BD%AC\"\u003e過学習\u003c/a\u003eがひどくて使えなかった\n\n\u003cul\u003e\n\u003cli\u003e扱っているアイテムの都合上、ある ID に対してたくさんのデータが取れることがない\n\n\u003cul\u003e\n\u003cli\u003eどれだけ人気でも年間 365 までしかコンバージョンしない\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e詳細ページへの遷移は booking よりはるかに多いし dense なので、それを使うモデルも作ったがうまくいかなかった\n\n\u003cul\u003e\n\u003cli\u003emulti task 学習で、booking prediction と long view prediction を予測させた\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eあとは NN は特徴量を normalize したほうがいいよねとか、特徴量の distribution を観察しましょうとか、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e 上で TensorFlow のモデル動かすの大変でしたとか、いろいろ現実っぽい話が並ぶ。\nもっといろいろ言ってるけど、詳細は本文を読んだほうが良い。\u003c/p\u003e\n\n\u003cp\u003e画像とかじゃない領域で DNN を production にいれるにはこういうステップを経るんだなというのが伝わってくるし、この話から得るべき学びがかなりある。光景が目に浮かぶ良い文章だなと思いました。\u003c/p\u003e\n\n---\n\n---\n","slug":"applying-deeplearning-to-airbnb-search-papser","title":"\u0026quot;Applying Deep Learning To Airbnb Search\u0026quot;  を読んだ","timestamp":1542804778000,"tags":[]},{"rawMarkdown":"---\ntitle: \"個人のメモ・ノートを保存するサービス選び\"\ndate: 2018-01-19T09:13:16.000Z\ntags: []\n---\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dropbox\"\u003eDropbox\u003c/a\u003e Paper と \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Google\"\u003eGoogle\u003c/a\u003e Keep を併用してメモとかを取っていた．\n長期的な記録とか人に見せうるもの，長めの文章は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dropbox\"\u003eDropbox\u003c/a\u003e Paper に，\n一時的なメモとかリマインダ的なものは Keep に，\nと使い分けていた．\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dropbox\"\u003eDropbox\u003c/a\u003e Paper すごく好きだったんだけど，\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eなんか重い気がする\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/WYSIWYG\"\u003eWYSIWYG\u003c/a\u003e なので \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e で書いているつもりでもちょこちょこ変なことが起きる\n\n\u003cul\u003e\n\u003cli\u003eバッククオートをおした時の挙動とか\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eブラウザでしか開けない\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eというのが使いにくく感じてしまった．\n基本的にグループで使うものだと思うので，僕は使わない機能がいっぱいあるなぁという感じもした．\u003c/p\u003e\n\n\u003cp\u003eKeep は Keep で好きだし，使い分ければそんなに嫌なこともなかったので続投したい．\nその上で，長期的に残しておきたいメモやノートを書くサービスを探してみた．\u003c/p\u003e\n\n\u003ch1\u003eほしい要件\u003c/h1\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e で書ける\u003c/li\u003e\n\u003cli\u003e端末間同期\u003c/li\u003e\n\u003cli\u003e画像を D\u0026amp;D で貼れる \u0026amp; 保存できる\u003c/li\u003e\n\u003cli\u003eグループ分け．\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\"\u003eディレクト\u003c/a\u003eリを切るくらいの機能で十分\u003c/li\u003e\n\u003cli\u003eArchive\u003c/li\u003e\n\u003cli\u003e検索\u003c/li\u003e\n\u003cli\u003eブラウザ以外のアプリケーションとして閲覧できる\n\n\u003cul\u003e\n\u003cli\u003e別に Electron でもなんでも良いけど，ブラウザとは独立したアプリケーションとして動いて欲しい\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003emobile app\u003c/li\u003e\n\u003cli\u003e細かい一時的なメモを取るのは keep.\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/google\"\u003egoogle\u003c/a\u003e.com でやる\u003c/li\u003e\n\u003cli\u003eToDo もいらない\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1\u003e比較\u003c/h1\u003e\n\n\u003ch2\u003e\u003ca href=\"https://dropbox.com/paper\"\u003eDropbox Paper\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch3\u003ePros\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eサービスの大きさ・信頼性\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e + \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/WYSIWYG\"\u003eWYSIWYG\u003c/a\u003e なエディタであること\u003c/li\u003e\n\u003cli\u003e人にパッと見せられるくらいキレイにメモがとれる\u003c/li\u003e\n\u003cli\u003epresentation mode（個人で使ってたらあんまりいらないかも）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003eCons\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e重い...\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/WYSIWYG\"\u003eWYSIWYG\u003c/a\u003e であること\u003c/li\u003e\n\u003cli\u003eブラウザでしか開けない\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e で書いているのに \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e として export すると微妙に modify されている...\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003e\u003ca href=\"https://keep.google.com/\"\u003eGoogle Keep\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch3\u003ePros\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eさくさく\u003c/li\u003e\n\u003cli\u003eシンプル\u003c/li\u003e\n\u003cli\u003eリマインダとの連携とか\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003eCons\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e長期的に残しておきたいドキュメントとかノートを書くためのものではない\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e で書けない\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003e\u003ca href=\"https://evernote.com/\"\u003eevernote\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003eお金は払う前提で考える\u003c/p\u003e\n\n\u003ch3\u003ePros\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e圧倒的コミュニティ．連携の広さとか tips が転がりまくっている．\u003c/li\u003e\n\u003cli\u003eweb clip とかちょっとした pdf や画像をポンポンぶち込んでおける\u003c/li\u003e\n\u003cli\u003e短いメモみたいなものも躊躇なくいれておけそう\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003eCons\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e が使えない問題がでかい\u003c/li\u003e\n\u003cli\u003e長めの文章を書く感じじゃなさそう\u003c/li\u003e\n\u003cli\u003e機能が多すぎてごちゃつきそうというイメージもある\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003e\u003ca href=\"https://boostnote.io/\"\u003eBoostnote\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OSS\"\u003eOSS\u003c/a\u003e になっているエディタで，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/dropbox\"\u003edropbox\u003c/a\u003e みたいな外部\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%A6%A5%C9\"\u003eクラウド\u003c/a\u003eストレージを使って同期をはかるやつ．\u003c/p\u003e\n\n\u003ch3\u003ePros\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eUI\u003c/li\u003e\n\u003cli\u003e要件はほぼ満たしている\u003c/li\u003e\n\u003cli\u003e外部ストレージを使っているので，サービス停止のリスクは外部ストレージに依存する\n\n\u003cul\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/dropbox\"\u003edropbox\u003c/a\u003e / \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/google%20drive\"\u003egoogle drive\u003c/a\u003e / one drive とか代替も結構あるのでサービス停止を気にする必要がなさそう\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003eCons\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dropbox\"\u003eDropbox\u003c/a\u003e などのストレージを圧迫する\u003c/li\u003e\n\u003cli\u003eBoostnote 独自のフォーマット（フォーマットとしては cson だけど）で保存されるので，別に外部ストレージにそのまま md が吐かれるとかではない\n\n\u003cul\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e として export はできる\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003e\u003ca href=\"https://www.inkdrop.info/\"\u003eInkdrop\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch3\u003ePros\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eUI\u003c/li\u003e\n\u003cli\u003e要件は満たしている\u003c/li\u003e\n\u003cli\u003estatus と tag 機能は便利そう．\u003c/li\u003e\n\u003cli\u003e一番普通に整理が出来る構造になっている気がする\u003c/li\u003e\n\u003cli\u003eData \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Access\"\u003eAccess\u003c/a\u003e \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e が使える\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003eCons\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e個人開発なのでサービス停止がこわい\n\n\u003cul\u003e\n\u003cli\u003eとはいえ \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e なので移行は容易い\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1\u003e結論\u003c/h1\u003e\n\n\u003cp\u003e要件を満たしているといえるのは Inkdrop と Boostnote くらいだろうか．\nBoostnote よりも Inkdrop のほうが first impression では好みだった．\nとりあえず 60 日 free なので Inkdrop を使ってみる．\n今この文章も Inkdrop 上で書いている．普通に \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e を書けばいいのでまあ書くのは楽．\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dropbox\"\u003eDropbox\u003c/a\u003e Paper と \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Google\"\u003eGoogle\u003c/a\u003e Keep を併用してメモとかを取っていた．\n長期的な記録とか人に見せうるもの，長めの文章は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dropbox\"\u003eDropbox\u003c/a\u003e Paper に，\n一時的なメモとかリマインダ的なものは Keep に，\nと使い分けていた．\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dropbox\"\u003eDropbox\u003c/a\u003e Paper すごく好きだったんだけど，\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eなんか重い気がする\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/WYSIWYG\"\u003eWYSIWYG\u003c/a\u003e なので \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e で書いているつもりでもちょこちょこ変なことが起きる\n\n\u003cul\u003e\n\u003cli\u003eバッククオートをおした時の挙動とか\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eブラウザでしか開けない\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eというのが使いにくく感じてしまった．\n基本的にグループで使うものだと思うので，僕は使わない機能がいっぱいあるなぁという感じもした．\u003c/p\u003e\n\n\u003cp\u003eKeep は Keep で好きだし，使い分ければそんなに嫌なこともなかったので続投したい．\nその上で，長期的に残しておきたいメモやノートを書くサービスを探してみた．\u003c/p\u003e\n\n\u003ch1\u003eほしい要件\u003c/h1\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e で書ける\u003c/li\u003e\n\u003cli\u003e端末間同期\u003c/li\u003e\n\u003cli\u003e画像を D\u0026amp;D で貼れる \u0026amp; 保存できる\u003c/li\u003e\n\u003cli\u003eグループ分け．\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\"\u003eディレクト\u003c/a\u003eリを切るくらいの機能で十分\u003c/li\u003e\n\u003cli\u003eArchive\u003c/li\u003e\n\u003cli\u003e検索\u003c/li\u003e\n\u003cli\u003eブラウザ以外のアプリケーションとして閲覧できる\n\n\u003cul\u003e\n\u003cli\u003e別に Electron でもなんでも良いけど，ブラウザとは独立したアプリケーションとして動いて欲しい\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003emobile app\u003c/li\u003e\n\u003cli\u003e細かい一時的なメモを取るのは keep.\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/google\"\u003egoogle\u003c/a\u003e.com でやる\u003c/li\u003e\n\u003cli\u003eToDo もいらない\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1\u003e比較\u003c/h1\u003e\n\n\u003ch2\u003e\u003ca href=\"https://dropbox.com/paper\"\u003eDropbox Paper\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch3\u003ePros\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eサービスの大きさ・信頼性\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e + \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/WYSIWYG\"\u003eWYSIWYG\u003c/a\u003e なエディタであること\u003c/li\u003e\n\u003cli\u003e人にパッと見せられるくらいキレイにメモがとれる\u003c/li\u003e\n\u003cli\u003epresentation mode（個人で使ってたらあんまりいらないかも）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003eCons\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e重い...\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/WYSIWYG\"\u003eWYSIWYG\u003c/a\u003e であること\u003c/li\u003e\n\u003cli\u003eブラウザでしか開けない\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e で書いているのに \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e として export すると微妙に modify されている...\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003e\u003ca href=\"https://keep.google.com/\"\u003eGoogle Keep\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch3\u003ePros\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eさくさく\u003c/li\u003e\n\u003cli\u003eシンプル\u003c/li\u003e\n\u003cli\u003eリマインダとの連携とか\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003eCons\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e長期的に残しておきたいドキュメントとかノートを書くためのものではない\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e で書けない\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003e\u003ca href=\"https://evernote.com/\"\u003eevernote\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003eお金は払う前提で考える\u003c/p\u003e\n\n\u003ch3\u003ePros\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e圧倒的コミュニティ．連携の広さとか tips が転がりまくっている．\u003c/li\u003e\n\u003cli\u003eweb clip とかちょっとした pdf や画像をポンポンぶち込んでおける\u003c/li\u003e\n\u003cli\u003e短いメモみたいなものも躊躇なくいれておけそう\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003eCons\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e が使えない問題がでかい\u003c/li\u003e\n\u003cli\u003e長めの文章を書く感じじゃなさそう\u003c/li\u003e\n\u003cli\u003e機能が多すぎてごちゃつきそうというイメージもある\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003e\u003ca href=\"https://boostnote.io/\"\u003eBoostnote\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OSS\"\u003eOSS\u003c/a\u003e になっているエディタで，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/dropbox\"\u003edropbox\u003c/a\u003e みたいな外部\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%A6%A5%C9\"\u003eクラウド\u003c/a\u003eストレージを使って同期をはかるやつ．\u003c/p\u003e\n\n\u003ch3\u003ePros\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eUI\u003c/li\u003e\n\u003cli\u003e要件はほぼ満たしている\u003c/li\u003e\n\u003cli\u003e外部ストレージを使っているので，サービス停止のリスクは外部ストレージに依存する\n\n\u003cul\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/dropbox\"\u003edropbox\u003c/a\u003e / \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/google%20drive\"\u003egoogle drive\u003c/a\u003e / one drive とか代替も結構あるのでサービス停止を気にする必要がなさそう\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003eCons\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dropbox\"\u003eDropbox\u003c/a\u003e などのストレージを圧迫する\u003c/li\u003e\n\u003cli\u003eBoostnote 独自のフォーマット（フォーマットとしては cson だけど）で保存されるので，別に外部ストレージにそのまま md が吐かれるとかではない\n\n\u003cul\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e として export はできる\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003e\u003ca href=\"https://www.inkdrop.info/\"\u003eInkdrop\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch3\u003ePros\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eUI\u003c/li\u003e\n\u003cli\u003e要件は満たしている\u003c/li\u003e\n\u003cli\u003estatus と tag 機能は便利そう．\u003c/li\u003e\n\u003cli\u003e一番普通に整理が出来る構造になっている気がする\u003c/li\u003e\n\u003cli\u003eData \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Access\"\u003eAccess\u003c/a\u003e \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e が使える\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003eCons\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e個人開発なのでサービス停止がこわい\n\n\u003cul\u003e\n\u003cli\u003eとはいえ \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e なので移行は容易い\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1\u003e結論\u003c/h1\u003e\n\n\u003cp\u003e要件を満たしているといえるのは Inkdrop と Boostnote くらいだろうか．\nBoostnote よりも Inkdrop のほうが first impression では好みだった．\nとりあえず 60 日 free なので Inkdrop を使ってみる．\n今この文章も Inkdrop 上で書いている．普通に \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\"\u003emarkdown\u003c/a\u003e を書けばいいのでまあ書くのは楽．\u003c/p\u003e\n\n---\n\n---\n","slug":"個人のメモ・ノートを保存するサービス選び","title":"個人のメモ・ノートを保存するサービス選び","timestamp":1516353196000,"tags":[]},{"rawMarkdown":"---\ntitle: \"golang でテストのために時間を操作するライブラリ timejump\"\ndate: 2017-12-14T14:21:24.000Z\ntags: []\n---\n\n\u003cp\u003e現在時刻に依存するコードをテストするとき，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e で \u003ccode\u003etime.Now\u003c/code\u003e を普通に使っているとモックできずうまくテストが書けないという問題があります．\n時間の操作は time パッケージをそのまま使えば良いのですが，time.Now だけはモックできるようにしたいところです．\u003c/p\u003e\n\n\u003cp\u003e解決方法としては，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%ED%A1%BC%A5%D0%A5%EB%CA%D1%BF%F4\"\u003eグローバル変数\u003c/a\u003eに \u003ccode\u003evar NowFunc func() time.Time\u003c/code\u003e を置いておいて，テスト時に入れ替えるという方法があり，ORM である gorm などが実際にこれを行っています．\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/jinzhu/gorm/blob/2a1463811ee1dc85d168fd639a2d4251d030e6e5/utils.go#L21\"\u003egorm/utils.go at 2a1463811ee1dc85d168fd639a2d4251d030e6e5 \u0026middot; jinzhu/gorm \u0026middot; GitHub\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e例:\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003evar\u003c/span\u003e NowFunc = time.Now\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e Do() \u003cspan class=\"synType\"\u003estring\u003c/span\u003e {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e NowFunc().String()\n}\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e TestDo(t *testing.T) {\n    now := time.Date(\u003cspan class=\"synConstant\"\u003e2009\u003c/span\u003e, time.November, \u003cspan class=\"synConstant\"\u003e10\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e23\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e, time.UTC)\n    NowFunc = \u003cspan class=\"synType\"\u003efunc\u003c/span\u003e() time.Time {\n        \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e now\n    }\n    got := Do()\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e got != now.String() {\n        t.Fail()\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e の使用上，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\"\u003eRuby\u003c/a\u003e の timecop のようなことは出来ないので，こういう工夫をするしかありません．\u003c/p\u003e\n\n\u003cp\u003eなんとなく\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%ED%A1%BC%A5%D0%A5%EB%CA%D1%BF%F4\"\u003eグローバル変数\u003c/a\u003eをテストのために置いて書き換えるのが嫌なのと，なんにも考えずに \u003ccode\u003et.Parallel()\u003c/code\u003e を置けなくなるのがちょっと嫌だなと思っていました．\nまた，時間経過をシミュレーションしたい場合は，そういう \u003ccode\u003eNowFunc\u003c/code\u003e を毎回書く必要があり，結構面倒です．\nあとパッケージをまたぐと厄介だし毎回書くのも嫌．\u003c/p\u003e\n\n\u003cp\u003eそこで，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\"\u003eRuby\u003c/a\u003e の timecop のように現在時刻をいじくり回せるようにするライブラリを作ってみました．\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Ftimejump\" title=\"agatan/timejump\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://github.com/agatan/timejump\"\u003egithub.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgodoc.org%2Fgithub.com%2Fagatan%2Ftimejump\" title=\"Package timejump\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://godoc.org/github.com/agatan/timejump\"\u003egodoc.org\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003e使用する際は \u003ccode\u003etime.Now\u003c/code\u003e をすべて \u003ccode\u003etimejump.Now\u003c/code\u003e に置き換える必要があります．（ \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\"\u003eRuby\u003c/a\u003e と違って \u003ccode\u003etime.Now\u003c/code\u003e を直接上書きできないので...）\n普段は \u003ccode\u003etimejump.Now\u003c/code\u003e と \u003ccode\u003etime.Now\u003c/code\u003e は \u003ccode\u003eif !active { ... }\u003c/code\u003e が一段挟まるだけなのでパフォーマンスに影響はほとんどないはずです．\u003c/p\u003e\n\n\u003cp\u003eテスト時は，\u003ccode\u003etimejump.Now\u003c/code\u003e の挙動を変えたいテストの頭で\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e TestDo(t *testing.T) {\n    timejump.Activate()\n    \u003cspan class=\"synStatement\"\u003edefer\u003c/span\u003e timejump.Deactivate()\n    ...\n}\n\u003c/pre\u003e\n\n\u003cp\u003eとします．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003etimejump.Activate\u003c/code\u003e な\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B6%E8%B4%D6\"\u003e区間\u003c/a\u003eはロックをとっているので，テストを並列で走らせても並列に走らなくなります．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003etimejump.Stop()\u003c/code\u003e で時間停止，\u003ccode\u003etimejump.Jump\u003c/code\u003e で時間移動，\u003ccode\u003etimejump.Move\u003c/code\u003e で\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BF%A5%A4%A5%E0%A5%BE%A1%BC%A5%F3\"\u003eタイムゾーン\u003c/a\u003eの移動，\u003ccode\u003etimejump.Scale\u003c/code\u003e で時間の経過速度をいじれます．\u003c/p\u003e\n\n\u003cp\u003e時間を止めたいだけの場合は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%ED%A1%BC%A5%D0%A5%EB%CA%D1%BF%F4\"\u003eグローバル変数\u003c/a\u003eに \u003ccode\u003eNowFunc\u003c/code\u003e を持っておいて \u003ccode\u003et.Parallel\u003c/code\u003e を間違って置かないように気をつけるほうが正直楽だとは思いますが，時間経過をテストしたい場合にはちょっと楽になるはずです．\u003c/p\u003e\n\n\u003cp\u003eもともとあるパッケージのテストをするために書いたパッケージだったのですが，目的だったテストを書く前にテストしたいパッケージが御役御免になってしまったので，timejump も御役御免になってしまいました．\nいつか使う日が来る気がするので，ここに寝かせておきます．\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e現在時刻に依存するコードをテストするとき，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e で \u003ccode\u003etime.Now\u003c/code\u003e を普通に使っているとモックできずうまくテストが書けないという問題があります．\n時間の操作は time パッケージをそのまま使えば良いのですが，time.Now だけはモックできるようにしたいところです．\u003c/p\u003e\n\n\u003cp\u003e解決方法としては，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%ED%A1%BC%A5%D0%A5%EB%CA%D1%BF%F4\"\u003eグローバル変数\u003c/a\u003eに \u003ccode\u003evar NowFunc func() time.Time\u003c/code\u003e を置いておいて，テスト時に入れ替えるという方法があり，ORM である gorm などが実際にこれを行っています．\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/jinzhu/gorm/blob/2a1463811ee1dc85d168fd639a2d4251d030e6e5/utils.go#L21\"\u003egorm/utils.go at 2a1463811ee1dc85d168fd639a2d4251d030e6e5 \u0026middot; jinzhu/gorm \u0026middot; GitHub\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e例:\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003evar\u003c/span\u003e NowFunc = time.Now\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e Do() \u003cspan class=\"synType\"\u003estring\u003c/span\u003e {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e NowFunc().String()\n}\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e TestDo(t *testing.T) {\n    now := time.Date(\u003cspan class=\"synConstant\"\u003e2009\u003c/span\u003e, time.November, \u003cspan class=\"synConstant\"\u003e10\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e23\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e, time.UTC)\n    NowFunc = \u003cspan class=\"synType\"\u003efunc\u003c/span\u003e() time.Time {\n        \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e now\n    }\n    got := Do()\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e got != now.String() {\n        t.Fail()\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e の使用上，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\"\u003eRuby\u003c/a\u003e の timecop のようなことは出来ないので，こういう工夫をするしかありません．\u003c/p\u003e\n\n\u003cp\u003eなんとなく\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%ED%A1%BC%A5%D0%A5%EB%CA%D1%BF%F4\"\u003eグローバル変数\u003c/a\u003eをテストのために置いて書き換えるのが嫌なのと，なんにも考えずに \u003ccode\u003et.Parallel()\u003c/code\u003e を置けなくなるのがちょっと嫌だなと思っていました．\nまた，時間経過をシミュレーションしたい場合は，そういう \u003ccode\u003eNowFunc\u003c/code\u003e を毎回書く必要があり，結構面倒です．\nあとパッケージをまたぐと厄介だし毎回書くのも嫌．\u003c/p\u003e\n\n\u003cp\u003eそこで，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\"\u003eRuby\u003c/a\u003e の timecop のように現在時刻をいじくり回せるようにするライブラリを作ってみました．\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Ftimejump\" title=\"agatan/timejump\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://github.com/agatan/timejump\"\u003egithub.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgodoc.org%2Fgithub.com%2Fagatan%2Ftimejump\" title=\"Package timejump\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://godoc.org/github.com/agatan/timejump\"\u003egodoc.org\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003e使用する際は \u003ccode\u003etime.Now\u003c/code\u003e をすべて \u003ccode\u003etimejump.Now\u003c/code\u003e に置き換える必要があります．（ \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\"\u003eRuby\u003c/a\u003e と違って \u003ccode\u003etime.Now\u003c/code\u003e を直接上書きできないので...）\n普段は \u003ccode\u003etimejump.Now\u003c/code\u003e と \u003ccode\u003etime.Now\u003c/code\u003e は \u003ccode\u003eif !active { ... }\u003c/code\u003e が一段挟まるだけなのでパフォーマンスに影響はほとんどないはずです．\u003c/p\u003e\n\n\u003cp\u003eテスト時は，\u003ccode\u003etimejump.Now\u003c/code\u003e の挙動を変えたいテストの頭で\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e TestDo(t *testing.T) {\n    timejump.Activate()\n    \u003cspan class=\"synStatement\"\u003edefer\u003c/span\u003e timejump.Deactivate()\n    ...\n}\n\u003c/pre\u003e\n\n\u003cp\u003eとします．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003etimejump.Activate\u003c/code\u003e な\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B6%E8%B4%D6\"\u003e区間\u003c/a\u003eはロックをとっているので，テストを並列で走らせても並列に走らなくなります．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003etimejump.Stop()\u003c/code\u003e で時間停止，\u003ccode\u003etimejump.Jump\u003c/code\u003e で時間移動，\u003ccode\u003etimejump.Move\u003c/code\u003e で\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BF%A5%A4%A5%E0%A5%BE%A1%BC%A5%F3\"\u003eタイムゾーン\u003c/a\u003eの移動，\u003ccode\u003etimejump.Scale\u003c/code\u003e で時間の経過速度をいじれます．\u003c/p\u003e\n\n\u003cp\u003e時間を止めたいだけの場合は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%ED%A1%BC%A5%D0%A5%EB%CA%D1%BF%F4\"\u003eグローバル変数\u003c/a\u003eに \u003ccode\u003eNowFunc\u003c/code\u003e を持っておいて \u003ccode\u003et.Parallel\u003c/code\u003e を間違って置かないように気をつけるほうが正直楽だとは思いますが，時間経過をテストしたい場合にはちょっと楽になるはずです．\u003c/p\u003e\n\n\u003cp\u003eもともとあるパッケージのテストをするために書いたパッケージだったのですが，目的だったテストを書く前にテストしたいパッケージが御役御免になってしまったので，timejump も御役御免になってしまいました．\nいつか使う日が来る気がするので，ここに寝かせておきます．\u003c/p\u003e\n\n---\n\n---\n","slug":"golang_でテストのために時間を操作するライブラリ_timejump","title":"golang でテストのために時間を操作するライブラリ timejump","timestamp":1513261284000,"tags":[]},{"rawMarkdown":"---\ntitle: \"ISUCON 7 本戦出場してきました 「都営三田線東急目黒線直通急行日吉行」\"\ndate: 2017-11-26T05:18:59.000Z\ntags: []\n---\n\n\u003cp\u003eISUCON 7 お疲れ様でした！\u003c/p\u003e\n\n\u003cp\u003e僕らのチーム，「\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%D4%B1%C4%BB%B0%C5%C4%C0%FE\"\u003e都営三田線\u003c/a\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%EC%B5%DE%CC%DC%B9%F5%C0%FE\"\u003e東急目黒線\u003c/a\u003e直通急行日吉行」は学生枠 2 位，全体で 10 位という結果でした．\u003c/p\u003e\n\n\u003cp\u003e予選の結果が異常によかったので完全に調子に乗っていたんですが，本戦はやっぱり難しかったですね... 本戦でも社会人上位勢と戦えるくらいのスコアを出すのと学生枠優勝が目標だったのでやっぱりくやしい．\u003c/p\u003e\n\n\u003ch3\u003eやったこと\u003c/h3\u003e\n\n\u003cp\u003e結局テンパりすぎてスコア記録を残せていないので，なんとなく記憶を頼りに...\u003c/p\u003e\n\n\u003cp\u003eGo 実装でいきました．\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eroom 名から ws をつなぎに行くホストが一台に固定されるように\n\n\u003cul\u003e\n\u003cli\u003e同じルームの action は全部同じホストにいくように\u003c/li\u003e\n\u003cli\u003eこれでオンメモリに出来るようにした（結局ほとんどオンメモリにデータは持たなかった）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eルーム名から適当な\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%CF%A5%C3%A5%B7%A5%E5%C3%CD\"\u003eハッシュ値\u003c/a\u003eを計算してふるようにしていたけれど，ルームによってアクセス頻度とかがちがうっぽい？ことに気がつく\n\n\u003cul\u003e\n\u003cli\u003e3 台に振ってるはずなのに，CPU 使用率を見ると 2 台しか使われていないとか\u003c/li\u003e\n\u003cli\u003e負荷分散が\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%BF%A5%B2%A1%BC\"\u003e運ゲー\u003c/a\u003eになっていて改善の結果が見にくかったので，とりあえず 1 台しか使わないように\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eホストごとの接続数を redis に入れて，空いていそうなところに振り分けるように\n\n\u003cul\u003e\n\u003cli\u003e前段のサーバに nginx + app + redis を入れて，そこの redis に room -\u003e host の対応情報を入れた\u003c/li\u003e\n\u003cli\u003eCPU 使用率で振り分けたほうが良かったかもしれない\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eschedule の計算過程を最適化出来る気がしなかったので，結果をキャッシュしようと試みる\n\n\u003cul\u003e\n\u003cli\u003eどうやっても事後検証をパスできなかったので捨てることに...\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e部屋ごとにロックをとってすべての操作を直列にした\n\n\u003cul\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A5%E9%A5%F3%A5%B6%A5%AF%A5%B7%A5%E7%A5%F3\"\u003eトランザクション\u003c/a\u003eとかが複雑すぎていじれる気がしなかったので，一旦直列にして考えることを減らそうとした\u003c/li\u003e\n\u003cli\u003erollback 考えなくて良くなったのでこれ自体は良かった気がする\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e@izumin5210 が adding/buying を redis にいれたり，過去の adding をまとめてくれた\n\n\u003cul\u003e\n\u003cli\u003eここは完全におまかせしてしまった\u003c/li\u003e\n\u003cli\u003e最終的にまともに効いたのはこれだけだったのでは\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e終盤はベンチマーカに弾かれる原因をひたすら探していた\n\n\u003cul\u003e\n\u003cli\u003e安全側に倒そうということで，色んな所でひたすらロックを取るようにしてなんとかパスした\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eという感じで，最高スコアが 17000 くらい，最終スコアが 16700 で終了しました．\u003c/p\u003e\n\n\u003ch3\u003e反省\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eチーム名が長すぎた\n\n\u003cul\u003e\n\u003cli\u003e名札のチーム名部分のフォントが他のチームより小さかった気がする（ご迷惑おかけしていたらすみません...）\u003c/li\u003e\n\u003cli\u003e手書きで書くのがつらすぎる\u003c/li\u003e\n\u003cli\u003e来年は気をつけます\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eテストがせっかく用意されていたのにまったく使わなかった\n\n\u003cul\u003e\n\u003cli\u003eテスト使っていたらもうちょっと計算過程の最適化にも手を出せたかもしれない\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eなにも操作がなくても 500ms ごとに status を計算していたところの最適化を入れきることができなかった\n\n\u003cul\u003e\n\u003cli\u003eこの計算は room ごとに一回やれば良いはずなのにコネクション一個につき一回計算していた\u003c/li\u003e\n\u003cli\u003eroom ごとにひたすら status を計算し続ける goroutine を起動してそこから返す実装を書いていたが，終盤の fail 祭りにびびっていれられなかった...\u003c/li\u003e\n\u003cli\u003e意味があったかどうかはよくわからない．\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCPU profile をみて，bigint の計算がやばいことはわかっていたのに，手が出せなかった\n\n\u003cul\u003e\n\u003cli\u003eこの複雑さは結果をキャッシュしろってことだな！って勝手に思い込んでいたけど，結果のキャッシュも複雑で無理だった\u003c/li\u003e\n\u003cli\u003e他のチームの方の話を聞く限り，そんなに無茶な最適化じゃなくても地道に最適化していたらそれなりにスコアに効いたのかもと思った（これはやってみないとわからないけど）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e予選のときも練習のときも，「遅いのはわかっているけど複雑そうでやりたくない」部分を触らないとだめっていう教訓は得ていたはずなんだけど，結局そこでやられてしまったのが一番くやしいですね...\u003c/p\u003e\n\n\u003cp\u003e来年は学生枠ではなくなるのですが，社会人枠でも本戦にでて勝ちたいです！\u003c/p\u003e\n\n\u003cp\u003e去年に引き続き本戦に出られたのはほんとうに良かったし，またまた勉強になる良い経験でした！運営の皆様お疲れ様でした ＆ ありがとうございました！\u003c/p\u003e\n\n---\n\nCOMMENT:\nAUTHOR: davidcruise\nIP: 117.98.190.10\nDATE: 11/27/2017 21:25:12\n\u003ca href='https://www.kikforpcapp.com/kik-for-pc-windows-xp788-110-free-download/'\u003epc kik\u003c/a\u003e article on an innovative messaging amenity that is continually on, permanently linked with fast and unswerving than any added applications that are existing due to some of the following reasons.\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eISUCON 7 お疲れ様でした！\u003c/p\u003e\n\n\u003cp\u003e僕らのチーム，「\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%D4%B1%C4%BB%B0%C5%C4%C0%FE\"\u003e都営三田線\u003c/a\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%EC%B5%DE%CC%DC%B9%F5%C0%FE\"\u003e東急目黒線\u003c/a\u003e直通急行日吉行」は学生枠 2 位，全体で 10 位という結果でした．\u003c/p\u003e\n\n\u003cp\u003e予選の結果が異常によかったので完全に調子に乗っていたんですが，本戦はやっぱり難しかったですね... 本戦でも社会人上位勢と戦えるくらいのスコアを出すのと学生枠優勝が目標だったのでやっぱりくやしい．\u003c/p\u003e\n\n\u003ch3\u003eやったこと\u003c/h3\u003e\n\n\u003cp\u003e結局テンパりすぎてスコア記録を残せていないので，なんとなく記憶を頼りに...\u003c/p\u003e\n\n\u003cp\u003eGo 実装でいきました．\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eroom 名から ws をつなぎに行くホストが一台に固定されるように\n\n\u003cul\u003e\n\u003cli\u003e同じルームの action は全部同じホストにいくように\u003c/li\u003e\n\u003cli\u003eこれでオンメモリに出来るようにした（結局ほとんどオンメモリにデータは持たなかった）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eルーム名から適当な\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%CF%A5%C3%A5%B7%A5%E5%C3%CD\"\u003eハッシュ値\u003c/a\u003eを計算してふるようにしていたけれど，ルームによってアクセス頻度とかがちがうっぽい？ことに気がつく\n\n\u003cul\u003e\n\u003cli\u003e3 台に振ってるはずなのに，CPU 使用率を見ると 2 台しか使われていないとか\u003c/li\u003e\n\u003cli\u003e負荷分散が\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%BF%A5%B2%A1%BC\"\u003e運ゲー\u003c/a\u003eになっていて改善の結果が見にくかったので，とりあえず 1 台しか使わないように\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eホストごとの接続数を redis に入れて，空いていそうなところに振り分けるように\n\n\u003cul\u003e\n\u003cli\u003e前段のサーバに nginx + app + redis を入れて，そこの redis に room -\u003e host の対応情報を入れた\u003c/li\u003e\n\u003cli\u003eCPU 使用率で振り分けたほうが良かったかもしれない\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eschedule の計算過程を最適化出来る気がしなかったので，結果をキャッシュしようと試みる\n\n\u003cul\u003e\n\u003cli\u003eどうやっても事後検証をパスできなかったので捨てることに...\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e部屋ごとにロックをとってすべての操作を直列にした\n\n\u003cul\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A5%E9%A5%F3%A5%B6%A5%AF%A5%B7%A5%E7%A5%F3\"\u003eトランザクション\u003c/a\u003eとかが複雑すぎていじれる気がしなかったので，一旦直列にして考えることを減らそうとした\u003c/li\u003e\n\u003cli\u003erollback 考えなくて良くなったのでこれ自体は良かった気がする\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e@izumin5210 が adding/buying を redis にいれたり，過去の adding をまとめてくれた\n\n\u003cul\u003e\n\u003cli\u003eここは完全におまかせしてしまった\u003c/li\u003e\n\u003cli\u003e最終的にまともに効いたのはこれだけだったのでは\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e終盤はベンチマーカに弾かれる原因をひたすら探していた\n\n\u003cul\u003e\n\u003cli\u003e安全側に倒そうということで，色んな所でひたすらロックを取るようにしてなんとかパスした\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eという感じで，最高スコアが 17000 くらい，最終スコアが 16700 で終了しました．\u003c/p\u003e\n\n\u003ch3\u003e反省\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eチーム名が長すぎた\n\n\u003cul\u003e\n\u003cli\u003e名札のチーム名部分のフォントが他のチームより小さかった気がする（ご迷惑おかけしていたらすみません...）\u003c/li\u003e\n\u003cli\u003e手書きで書くのがつらすぎる\u003c/li\u003e\n\u003cli\u003e来年は気をつけます\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eテストがせっかく用意されていたのにまったく使わなかった\n\n\u003cul\u003e\n\u003cli\u003eテスト使っていたらもうちょっと計算過程の最適化にも手を出せたかもしれない\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eなにも操作がなくても 500ms ごとに status を計算していたところの最適化を入れきることができなかった\n\n\u003cul\u003e\n\u003cli\u003eこの計算は room ごとに一回やれば良いはずなのにコネクション一個につき一回計算していた\u003c/li\u003e\n\u003cli\u003eroom ごとにひたすら status を計算し続ける goroutine を起動してそこから返す実装を書いていたが，終盤の fail 祭りにびびっていれられなかった...\u003c/li\u003e\n\u003cli\u003e意味があったかどうかはよくわからない．\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCPU profile をみて，bigint の計算がやばいことはわかっていたのに，手が出せなかった\n\n\u003cul\u003e\n\u003cli\u003eこの複雑さは結果をキャッシュしろってことだな！って勝手に思い込んでいたけど，結果のキャッシュも複雑で無理だった\u003c/li\u003e\n\u003cli\u003e他のチームの方の話を聞く限り，そんなに無茶な最適化じゃなくても地道に最適化していたらそれなりにスコアに効いたのかもと思った（これはやってみないとわからないけど）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e予選のときも練習のときも，「遅いのはわかっているけど複雑そうでやりたくない」部分を触らないとだめっていう教訓は得ていたはずなんだけど，結局そこでやられてしまったのが一番くやしいですね...\u003c/p\u003e\n\n\u003cp\u003e来年は学生枠ではなくなるのですが，社会人枠でも本戦にでて勝ちたいです！\u003c/p\u003e\n\n\u003cp\u003e去年に引き続き本戦に出られたのはほんとうに良かったし，またまた勉強になる良い経験でした！運営の皆様お疲れ様でした ＆ ありがとうございました！\u003c/p\u003e\n\n---\n\nCOMMENT:\nAUTHOR: davidcruise\nIP: 117.98.190.10\nDATE: 11/27/2017 21:25:12\n\u003ca href='https://www.kikforpcapp.com/kik-for-pc-windows-xp788-110-free-download/'\u003epc kik\u003c/a\u003e article on an innovative messaging amenity that is continually on, permanently linked with fast and unswerving than any added applications that are existing due to some of the following reasons.\n\n---\n\n---\n","slug":"ISUCON_7_本戦出場してきました_「都営三田線東急目黒線直通急行日吉行」","title":"ISUCON 7 本戦出場してきました 「都営三田線東急目黒線直通急行日吉行」","timestamp":1511673539000,"tags":[]},{"rawMarkdown":"---\ntitle: \"ISUCON7予選1日目に「都営三田線」で参加して通過できた話\"\ndate: 2017-10-23T11:33:42.000Z\ntags: []\n---\n\n\u003cp\u003eISUCON7 予選お疲れ様でした！\nタイトルどおりですが，「\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%D4%B1%C4%BB%B0%C5%C4%C0%FE\"\u003e都営三田線\u003c/a\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%EC%B5%DE%CC%DC%B9%F5%C0%FE\"\u003e東急目黒線\u003c/a\u003e直通急行日吉行」という学生チームで参加し，1日目3位枠で通過することができました．\nチーム編成は，去年2人チームで参加したときの相方である \u003ca href=\"https://github.com/0gajun\"\u003e0gajun\u003c/a\u003e と，僕の内定先の同期の \u003ca href=\"https://github.com/izumin5210\"\u003eizumin\u003c/a\u003e の 3 人チームでした．\u003c/p\u003e\n\n\u003cp\u003e何をやったかとかスコアの変遷は別で記録したいと思います（僕一人で把握しきれていないので）が，とりあえず\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\"\u003eリポジトリ\u003c/a\u003eはここです．\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2FISUCON7-qualify\" title=\"agatan/isucon7-qualify\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://github.com/agatan/ISUCON7-qualify\"\u003egithub.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003e追記: タイムラインと詳細はこっちに書きました\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fwww.wantedly.com%2Fusers%2F17993775%2Fpost_articles%2F81190\" title=\"ISUCON7予選に学生チームで参加して1日目3位枠で突破しました！\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://www.wantedly.com/users/17993775/post_articles/81190\"\u003ewww.wantedly.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20171023/20171023153909.png\" alt=\"f:id:agtn:20171023153909p:plain\" title=\"f:id:agtn:20171023153909p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e去年2人で参加した時は学生枠で予選通過はできたものの，一般枠との圧倒的なスコア差にだいぶ打ちひしがれていました．\nもともと，「0gajun がインフラ，僕がインフラ寄りのアプリ」というチームだったので，アプリ側をがつがついじれる izumin が加わったことで，チームバランスが良くなった + 手数が圧倒的に増えたと思います．\u003c/p\u003e\n\n\u003cp\u003e去年とくらべてメンバーも増えたし学生とはいえ一年間で成長している（はず）というのもあったので，夢として「学生枠だけど一般枠と戦えるスコアを出したい」というのがありました．\n結果，予選1日目上位3チーム枠で本戦出場を決められて本当にうれしかったです．2日目の上位が圧倒的なスコアだったのでちょっと凹みましたが，全体でも 10 位くらいだったと思うので，目標は達成できたと思います．\nまた，無理やり ISUCON 特化な高速化を入れたりすることなく良いスコアを出せたと思うので，そこも良かったなと思っています．\n本戦でも良いスコアが出せるように頑張るぞー！\u003c/p\u003e\n\n\u003cp\u003e最後に，ISUCON 運営の皆様，本当にお疲れ様でした \u0026amp; ありがとうございました！\n予選から複数台構成で面食らいましたが，複数台は難しい分，楽しさも増すし勉強になることもたくさんありました！\n本戦も楽しみにしています！\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eISUCON7 予選お疲れ様でした！\nタイトルどおりですが，「\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%D4%B1%C4%BB%B0%C5%C4%C0%FE\"\u003e都営三田線\u003c/a\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%EC%B5%DE%CC%DC%B9%F5%C0%FE\"\u003e東急目黒線\u003c/a\u003e直通急行日吉行」という学生チームで参加し，1日目3位枠で通過することができました．\nチーム編成は，去年2人チームで参加したときの相方である \u003ca href=\"https://github.com/0gajun\"\u003e0gajun\u003c/a\u003e と，僕の内定先の同期の \u003ca href=\"https://github.com/izumin5210\"\u003eizumin\u003c/a\u003e の 3 人チームでした．\u003c/p\u003e\n\n\u003cp\u003e何をやったかとかスコアの変遷は別で記録したいと思います（僕一人で把握しきれていないので）が，とりあえず\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\"\u003eリポジトリ\u003c/a\u003eはここです．\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2FISUCON7-qualify\" title=\"agatan/isucon7-qualify\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://github.com/agatan/ISUCON7-qualify\"\u003egithub.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003e追記: タイムラインと詳細はこっちに書きました\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fwww.wantedly.com%2Fusers%2F17993775%2Fpost_articles%2F81190\" title=\"ISUCON7予選に学生チームで参加して1日目3位枠で突破しました！\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://www.wantedly.com/users/17993775/post_articles/81190\"\u003ewww.wantedly.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20171023/20171023153909.png\" alt=\"f:id:agtn:20171023153909p:plain\" title=\"f:id:agtn:20171023153909p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e去年2人で参加した時は学生枠で予選通過はできたものの，一般枠との圧倒的なスコア差にだいぶ打ちひしがれていました．\nもともと，「0gajun がインフラ，僕がインフラ寄りのアプリ」というチームだったので，アプリ側をがつがついじれる izumin が加わったことで，チームバランスが良くなった + 手数が圧倒的に増えたと思います．\u003c/p\u003e\n\n\u003cp\u003e去年とくらべてメンバーも増えたし学生とはいえ一年間で成長している（はず）というのもあったので，夢として「学生枠だけど一般枠と戦えるスコアを出したい」というのがありました．\n結果，予選1日目上位3チーム枠で本戦出場を決められて本当にうれしかったです．2日目の上位が圧倒的なスコアだったのでちょっと凹みましたが，全体でも 10 位くらいだったと思うので，目標は達成できたと思います．\nまた，無理やり ISUCON 特化な高速化を入れたりすることなく良いスコアを出せたと思うので，そこも良かったなと思っています．\n本戦でも良いスコアが出せるように頑張るぞー！\u003c/p\u003e\n\n\u003cp\u003e最後に，ISUCON 運営の皆様，本当にお疲れ様でした \u0026amp; ありがとうございました！\n予選から複数台構成で面食らいましたが，複数台は難しい分，楽しさも増すし勉強になることもたくさんありました！\n本戦も楽しみにしています！\u003c/p\u003e\n\n---\n\n---\n","slug":"ISUCON7予選1日目に「都営三田線」で参加して通過できた話","title":"ISUCON7予選1日目に「都営三田線」で参加して通過できた話","timestamp":1508758422000,"tags":[]},{"rawMarkdown":"---\ntitle: \"go generate する時のバイナリのバージョンを固定したい\"\ndate: 2017-08-05T16:58:13.000Z\ntags: []\n---\n\n\u003cp\u003e\u003ca href=\"https://github.com/golang/mock\"\u003ehttps://github.com/golang/mock\u003c/a\u003e は \u003ccode\u003emockgen\u003c/code\u003e というコマンドを提供しています．\nこれは，interface から mock を自動生成するコマンドで \u003ccode\u003ego generate\u003c/code\u003e と合わせて使うと interface に追従する mock がとても簡単に作れます．\u003c/p\u003e\n\n\u003cp\u003e他にも \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/yacc\"\u003eyacc\u003c/a\u003e とかリソースをバイナリに埋め込むとか，色々便利ツールがあり，\u003ccode\u003ego generate\u003c/code\u003e でコード生成をするのは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e のアプリケーションではよくあることだと思います．\u003c/p\u003e\n\n\u003cp\u003eしかし，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e の \u003ccode\u003evendor/\u003c/code\u003e の仕組みは基本的に package として使うことを考えて作られているので，プロジェクトごとに \u003ccode\u003emockgen\u003c/code\u003e などの生成コマンドのバージョンを固定するためには使えません．\u003c/p\u003e\n\n\u003cp\u003eここで，\u003ccode\u003ego generate\u003c/code\u003e で使うバイナリのバージョンが固定されていないと起こりうる問題として\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e生成されたコードに毎回 diff が出る\n\n\u003cul\u003e\n\u003cli\u003e気軽に \u003ccode\u003egit add .\u003c/code\u003e 出来ないし，コミット漏れや無駄コミットにつながる\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eバージョンAのコマンドとバージョンBのコマンドによって生成されたコードが混ざる\u003c/li\u003e\n\u003cli\u003eライブラリのバージョンと生成コマンドのバージョンが一致しないためバグる\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003egithub.com/golang/mock/mockgen\u003c/code\u003e は \u003ccode\u003egithub.com/golang/mock/gomock\u003c/code\u003e というライブラリとセットで使うので，\u003ccode\u003egomock\u003c/code\u003e package と \u003ccode\u003emockgen\u003c/code\u003e バイナリのバージョンは揃えたい\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eなどがあります．\u003c/p\u003e\n\n\u003cp\u003eこれ結構嫌な問題だと思ったのですが，パッとぐぐってみてもあまり困っている声を聞かないので普通どうやって解決しているのか気になっています．\n(もしかして僕が知らないだけで普通に解決されている問題だったりするのだろうか\u0026hellip;)\u003c/p\u003e\n\n\u003cp\u003eとりあえず \u003ccode\u003evendor\u003c/code\u003e 以下の package をビルドしたり固定されたバージョンのバイナリをぱぱっと実行するために\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fbindor\" title=\"agatan/bindor\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://github.com/agatan/bindor\"\u003egithub.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003eを作ってみました．\u003c/p\u003e\n\n\u003cp\u003eshell script で書けそうな単純な仕事しかしていませんが，go で実装されています．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ebindor build github.com/golang/mock/mockgen\u003c/code\u003e で \u003ccode\u003e./.bindor/mockgen\u003c/code\u003e というバイナリが出来ます．\n\u003ccode\u003ebindor exec command args...\u003c/code\u003e とやると \u003ccode\u003ePATH=./.bindor:$PATH\u003c/code\u003e した環境下で \u003ccode\u003ecommand args...\u003c/code\u003e を実行します．\u003c/p\u003e\n\n\u003cpre class=\"code lang-sh\" data-lang=\"sh\" data-unlink\u003e$ glide get github.com/golang/mock\n$ bindor build github.com/golang/mock/mockgen\n$ bindor \u003cspan class=\"synStatement\"\u003eexec\u003c/span\u003e which mockgen\n/path/to/current/.bindor/mockgen\n\u003c/pre\u003e\n\n\u003cp\u003eという感じです．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e//go:generate bindor mockgen\u003c/code\u003e としてもいいですが，\u003ccode\u003ebindor exec go generate\u003c/code\u003e とすれば\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\"\u003eソースコード\u003c/a\u003eを書き換えなくても \u003ccode\u003e.bindor\u003c/code\u003e 以下のバイナリを使うようになるはずです．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ebindor\u003c/code\u003e 自体にバージョンを固定する仕組みは入れていません．glide とかがやってくれている仕事を分散させても管理が面倒になるだけでメリットがなさそうだし，ライブラリとしても使う package の場合はどうせ glide で管理するので，\u003ccode\u003evendor\u003c/code\u003e 以下の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\"\u003eディレクト\u003c/a\u003eリの奪い合いになってしまいます．\u003c/p\u003e\n\n\u003cp\u003eというわけでバイナリを vendoring する \u003ccode\u003ebindor\u003c/code\u003e を作った話でした．もっといい解決方法があったら教えてください．\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e\u003ca href=\"https://github.com/golang/mock\"\u003ehttps://github.com/golang/mock\u003c/a\u003e は \u003ccode\u003emockgen\u003c/code\u003e というコマンドを提供しています．\nこれは，interface から mock を自動生成するコマンドで \u003ccode\u003ego generate\u003c/code\u003e と合わせて使うと interface に追従する mock がとても簡単に作れます．\u003c/p\u003e\n\n\u003cp\u003e他にも \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/yacc\"\u003eyacc\u003c/a\u003e とかリソースをバイナリに埋め込むとか，色々便利ツールがあり，\u003ccode\u003ego generate\u003c/code\u003e でコード生成をするのは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e のアプリケーションではよくあることだと思います．\u003c/p\u003e\n\n\u003cp\u003eしかし，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e の \u003ccode\u003evendor/\u003c/code\u003e の仕組みは基本的に package として使うことを考えて作られているので，プロジェクトごとに \u003ccode\u003emockgen\u003c/code\u003e などの生成コマンドのバージョンを固定するためには使えません．\u003c/p\u003e\n\n\u003cp\u003eここで，\u003ccode\u003ego generate\u003c/code\u003e で使うバイナリのバージョンが固定されていないと起こりうる問題として\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e生成されたコードに毎回 diff が出る\n\n\u003cul\u003e\n\u003cli\u003e気軽に \u003ccode\u003egit add .\u003c/code\u003e 出来ないし，コミット漏れや無駄コミットにつながる\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eバージョンAのコマンドとバージョンBのコマンドによって生成されたコードが混ざる\u003c/li\u003e\n\u003cli\u003eライブラリのバージョンと生成コマンドのバージョンが一致しないためバグる\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003egithub.com/golang/mock/mockgen\u003c/code\u003e は \u003ccode\u003egithub.com/golang/mock/gomock\u003c/code\u003e というライブラリとセットで使うので，\u003ccode\u003egomock\u003c/code\u003e package と \u003ccode\u003emockgen\u003c/code\u003e バイナリのバージョンは揃えたい\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eなどがあります．\u003c/p\u003e\n\n\u003cp\u003eこれ結構嫌な問題だと思ったのですが，パッとぐぐってみてもあまり困っている声を聞かないので普通どうやって解決しているのか気になっています．\n(もしかして僕が知らないだけで普通に解決されている問題だったりするのだろうか\u0026hellip;)\u003c/p\u003e\n\n\u003cp\u003eとりあえず \u003ccode\u003evendor\u003c/code\u003e 以下の package をビルドしたり固定されたバージョンのバイナリをぱぱっと実行するために\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fbindor\" title=\"agatan/bindor\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://github.com/agatan/bindor\"\u003egithub.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003eを作ってみました．\u003c/p\u003e\n\n\u003cp\u003eshell script で書けそうな単純な仕事しかしていませんが，go で実装されています．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ebindor build github.com/golang/mock/mockgen\u003c/code\u003e で \u003ccode\u003e./.bindor/mockgen\u003c/code\u003e というバイナリが出来ます．\n\u003ccode\u003ebindor exec command args...\u003c/code\u003e とやると \u003ccode\u003ePATH=./.bindor:$PATH\u003c/code\u003e した環境下で \u003ccode\u003ecommand args...\u003c/code\u003e を実行します．\u003c/p\u003e\n\n\u003cpre class=\"code lang-sh\" data-lang=\"sh\" data-unlink\u003e$ glide get github.com/golang/mock\n$ bindor build github.com/golang/mock/mockgen\n$ bindor \u003cspan class=\"synStatement\"\u003eexec\u003c/span\u003e which mockgen\n/path/to/current/.bindor/mockgen\n\u003c/pre\u003e\n\n\u003cp\u003eという感じです．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e//go:generate bindor mockgen\u003c/code\u003e としてもいいですが，\u003ccode\u003ebindor exec go generate\u003c/code\u003e とすれば\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\"\u003eソースコード\u003c/a\u003eを書き換えなくても \u003ccode\u003e.bindor\u003c/code\u003e 以下のバイナリを使うようになるはずです．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ebindor\u003c/code\u003e 自体にバージョンを固定する仕組みは入れていません．glide とかがやってくれている仕事を分散させても管理が面倒になるだけでメリットがなさそうだし，ライブラリとしても使う package の場合はどうせ glide で管理するので，\u003ccode\u003evendor\u003c/code\u003e 以下の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\"\u003eディレクト\u003c/a\u003eリの奪い合いになってしまいます．\u003c/p\u003e\n\n\u003cp\u003eというわけでバイナリを vendoring する \u003ccode\u003ebindor\u003c/code\u003e を作った話でした．もっといい解決方法があったら教えてください．\u003c/p\u003e\n\n---\n\n---\n","slug":"go_generate_する時のバイナリのバージョンを固定したい","title":"go generate する時のバイナリのバージョンを固定したい","timestamp":1501952293000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Rust で Unix のシグナルを channel 経由でキャッチする\"\ndate: 2017-07-10T11:59:04.000Z\ntags: []\n---\n\n\u003cp\u003eRust でシグナルハンドリングをする必要があったのですが，あまり自分の用途にあるライブラリがなかったので作りました．\n僕が \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Windows\"\u003eWindows\u003c/a\u003e のことをほとんどわからないので，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Windows\"\u003eWindows\u003c/a\u003e 未対応です．\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fsignal-notify\" title=\"agatan/signal-notify\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://github.com/agatan/signal-notify\"\u003egithub.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fdocs.rs%2Fsignal-notify%2F0.1.2%2Fsignal_notify%2F\" title=\"signal_notify - Rust\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://docs.rs/signal-notify/0.1.2/signal_notify/\"\u003edocs.rs\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://crates.io/crates/signal-notify\"\u003ehttps://crates.io/crates/signal-notify\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e の \u003ccode\u003esignal.Notify\u003c/code\u003e に寄せた \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e になっていて，標準ライブラリの \u003ccode\u003estd::sync::mpsc::{Sender, Receiver}\u003c/code\u003e 経由でシグナルを待ち受けることができます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003eextern\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ecrate\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003esignal_notify\u003c/span\u003e;\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003esignal_notify\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e{notify, Signal};\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003estd\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003esync\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003empsc\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eReceiver;\n\n\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e rx: Receiver\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eSignal\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003enotify\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003e[\u003cspan class=\"synPreProc\"\u003eSignal\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eINT, \u003cspan class=\"synPreProc\"\u003eSignal\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eUSR1]);\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e sig \u003cspan class=\"synStatement\"\u003ein\u003c/span\u003e rx.\u003cspan class=\"synIdentifier\"\u003eiter\u003c/span\u003e() {\n        \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e sig {\n            \u003cspan class=\"synPreProc\"\u003eSignal\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eINT \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e {\n                \u003cspan class=\"synPreProc\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e\u0026quot;Interrupted!\u0026quot;\u003c/span\u003e);\n                \u003cspan class=\"synStatement\"\u003ebreak\u003c/span\u003e;\n            }\n            \u003cspan class=\"synPreProc\"\u003eSignal\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eUSR1 \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e\u0026quot;Got SIGUSR1!\u0026quot;\u003c/span\u003e),\n        }\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eRust で \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Unix\"\u003eUnix\u003c/a\u003e シグナルを取るライブラリとしては \u003ca href=\"https://github.com/BurntSushi/chan-signal\"\u003eGitHub - BurntSushi/chan-signal: Respond to OS signals with channels.\u003c/a\u003e というのが有名です．\nこちらは標準ライブラリの \u003ccode\u003empsc::channel\u003c/code\u003e ではなく，\u003ccode\u003echan\u003c/code\u003e クレイトの \u003ccode\u003echannel\u003c/code\u003e を使っています．\n\u003ccode\u003echan\u003c/code\u003e クレイトはケースによってはかなり便利で，\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e複数の consumer を作れる (\u003ccode\u003ereceiver.clone()\u003c/code\u003e ができる)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003echan_select!\u003c/code\u003e マクロによって \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e の \u003ccode\u003eselect\u003c/code\u003e 的なことができる\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eという利点があります．\u003c/p\u003e\n\n\u003cp\u003e一方で複数 consumer にする必要がない \u0026amp; \u003ccode\u003echan_select!\u003c/code\u003e が必要ないケースでは，シグナルハンドリングのためだけに \u003ccode\u003echan\u003c/code\u003e にも依存するのもなんとなくはばかられるという気持ちがありました．\nまた，自分の目的として「\u003ccode\u003eSIGWINCH\u003c/code\u003e と \u003ccode\u003eSIGIO\u003c/code\u003e が取りたい」というのがあったのですが，\u003ccode\u003echan-signal\u003c/code\u003e の仕組みだとデフォルトで無視されるシグナルをキャッチできない(\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/macOS\"\u003emacOS\u003c/a\u003e だけ)という問題もありました．\n報告するときに方法を考えていたのですが，あまり自信がなかったのとほとんど完全に仕組みを書きなおす形になりそうだったので，自分の手元で \u003ccode\u003estd::sync::mpsc\u003c/code\u003e を使って実験してみたという経緯です．\u003c/p\u003e\n\n\u003ch2\u003e仕組み\u003c/h2\u003e\n\n\u003col\u003e\n\u003cli\u003e初期化時にパイプを作る\u003c/li\u003e\n\u003cli\u003eシグナルごとに通知すべき \u003ccode\u003eSender\u003c/code\u003e を覚えておく\u003c/li\u003e\n\u003cli\u003eシグナルごとに \u003ccode\u003esigaction\u003c/code\u003e でハンドラをセットする\n\n\u003cul\u003e\n\u003cli\u003eシグナルが来たらそれをパイプに \u003ccode\u003ewrite(2)\u003c/code\u003e する\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eシグナル待受＆通知用のスレッドを起動する\n\n\u003cul\u003e\n\u003cli\u003eパイプからシグナル番号を読んで，適切な \u003ccode\u003eSender\u003c/code\u003e に \u003ccode\u003esend\u003c/code\u003e する\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eという仕組みで動いています．\n自信がなかったのは，「シグナルハンドラでやっていいこと一覧」をちゃんと把握していないという点です．\n一応 \u003ccode\u003esigaction\u003c/code\u003e の man を見ると \u003ccode\u003ewrite\u003c/code\u003e は読んでもいい関数一覧にいる気がするし，実際動いてはいるのでセーフだろうと判断しました．\n（もしアウトだったら教えてください）\u003c/p\u003e\n\n\u003cp\u003eちなみに \u003ccode\u003echan-signal\u003c/code\u003e の方は，\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eシグナルごとに通知すべき \u003ccode\u003eSender\u003c/code\u003e を覚えておく\u003c/li\u003e\n\u003cli\u003e監視用スレッドを起動し，メインスレッドでは \u003ccode\u003epthread_sigmask\u003c/code\u003e を使ってシグナルをブロックする\n\n\u003cul\u003e\n\u003cli\u003eシグナルがすべて監視用スレッドに渡るようにする\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e監視用スレッドで \u003ccode\u003esigwait\u003c/code\u003e して適切な \u003ccode\u003eSender\u003c/code\u003e に \u003ccode\u003esend\u003c/code\u003e する\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eという仕組みで動いているようです．\n\u003ccode\u003esigwait\u003c/code\u003e は指定したシグナルが投げられるまでブロックします．\nただし，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/macOS\"\u003emacOS\u003c/a\u003e で \u003ccode\u003esigwait\u003c/code\u003e の man を見ると，\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eProcesses which call sigwait() on ignored signals will wait indefinitely. Ignored signals are dropped immediately by the system, before delivery to a waiting process.\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003eとあって，無視されるシグナルを \u003ccode\u003esigwait\u003c/code\u003e で待っても補足できないようです．\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Linux\"\u003eLinux\u003c/a\u003e の man を見るとそんなことは書いていないし，普通に動くっぽいです．\u003c/p\u003e\n\n\u003cp\u003e今の実装だと，シグナルを受け取る \u003ccode\u003eReceiver\u003c/code\u003e がすべて閉じても，監視スレッドは動き続けるしハンドラも残り続けるので，これはなんとかしたいなぁと思っています．\nアプリケーションの実行時間のうち，ある期間だけシグナルをとってそれ以外はスルーしたいというケースもそんなにないかなというのと，内部的な変更にしかならないので \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e が変わらないというのがあるので，この状態でとりあえず public にしました．\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLI\"\u003eCLI\u003c/a\u003e を書いていると意外と普通に \u003ccode\u003eSIGINT\u003c/code\u003e は取りたくなることがあると思うので，ぜひ使ってみてください．\nissue 報告等お待ちしています．\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eRust でシグナルハンドリングをする必要があったのですが，あまり自分の用途にあるライブラリがなかったので作りました．\n僕が \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Windows\"\u003eWindows\u003c/a\u003e のことをほとんどわからないので，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Windows\"\u003eWindows\u003c/a\u003e 未対応です．\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fsignal-notify\" title=\"agatan/signal-notify\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://github.com/agatan/signal-notify\"\u003egithub.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fdocs.rs%2Fsignal-notify%2F0.1.2%2Fsignal_notify%2F\" title=\"signal_notify - Rust\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://docs.rs/signal-notify/0.1.2/signal_notify/\"\u003edocs.rs\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://crates.io/crates/signal-notify\"\u003ehttps://crates.io/crates/signal-notify\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e の \u003ccode\u003esignal.Notify\u003c/code\u003e に寄せた \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e になっていて，標準ライブラリの \u003ccode\u003estd::sync::mpsc::{Sender, Receiver}\u003c/code\u003e 経由でシグナルを待ち受けることができます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003eextern\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ecrate\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003esignal_notify\u003c/span\u003e;\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003esignal_notify\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e{notify, Signal};\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003estd\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003esync\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003empsc\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eReceiver;\n\n\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e rx: Receiver\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eSignal\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003enotify\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003e[\u003cspan class=\"synPreProc\"\u003eSignal\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eINT, \u003cspan class=\"synPreProc\"\u003eSignal\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eUSR1]);\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e sig \u003cspan class=\"synStatement\"\u003ein\u003c/span\u003e rx.\u003cspan class=\"synIdentifier\"\u003eiter\u003c/span\u003e() {\n        \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e sig {\n            \u003cspan class=\"synPreProc\"\u003eSignal\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eINT \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e {\n                \u003cspan class=\"synPreProc\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e\u0026quot;Interrupted!\u0026quot;\u003c/span\u003e);\n                \u003cspan class=\"synStatement\"\u003ebreak\u003c/span\u003e;\n            }\n            \u003cspan class=\"synPreProc\"\u003eSignal\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eUSR1 \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e\u0026quot;Got SIGUSR1!\u0026quot;\u003c/span\u003e),\n        }\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eRust で \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Unix\"\u003eUnix\u003c/a\u003e シグナルを取るライブラリとしては \u003ca href=\"https://github.com/BurntSushi/chan-signal\"\u003eGitHub - BurntSushi/chan-signal: Respond to OS signals with channels.\u003c/a\u003e というのが有名です．\nこちらは標準ライブラリの \u003ccode\u003empsc::channel\u003c/code\u003e ではなく，\u003ccode\u003echan\u003c/code\u003e クレイトの \u003ccode\u003echannel\u003c/code\u003e を使っています．\n\u003ccode\u003echan\u003c/code\u003e クレイトはケースによってはかなり便利で，\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e複数の consumer を作れる (\u003ccode\u003ereceiver.clone()\u003c/code\u003e ができる)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003echan_select!\u003c/code\u003e マクロによって \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e の \u003ccode\u003eselect\u003c/code\u003e 的なことができる\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eという利点があります．\u003c/p\u003e\n\n\u003cp\u003e一方で複数 consumer にする必要がない \u0026amp; \u003ccode\u003echan_select!\u003c/code\u003e が必要ないケースでは，シグナルハンドリングのためだけに \u003ccode\u003echan\u003c/code\u003e にも依存するのもなんとなくはばかられるという気持ちがありました．\nまた，自分の目的として「\u003ccode\u003eSIGWINCH\u003c/code\u003e と \u003ccode\u003eSIGIO\u003c/code\u003e が取りたい」というのがあったのですが，\u003ccode\u003echan-signal\u003c/code\u003e の仕組みだとデフォルトで無視されるシグナルをキャッチできない(\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/macOS\"\u003emacOS\u003c/a\u003e だけ)という問題もありました．\n報告するときに方法を考えていたのですが，あまり自信がなかったのとほとんど完全に仕組みを書きなおす形になりそうだったので，自分の手元で \u003ccode\u003estd::sync::mpsc\u003c/code\u003e を使って実験してみたという経緯です．\u003c/p\u003e\n\n\u003ch2\u003e仕組み\u003c/h2\u003e\n\n\u003col\u003e\n\u003cli\u003e初期化時にパイプを作る\u003c/li\u003e\n\u003cli\u003eシグナルごとに通知すべき \u003ccode\u003eSender\u003c/code\u003e を覚えておく\u003c/li\u003e\n\u003cli\u003eシグナルごとに \u003ccode\u003esigaction\u003c/code\u003e でハンドラをセットする\n\n\u003cul\u003e\n\u003cli\u003eシグナルが来たらそれをパイプに \u003ccode\u003ewrite(2)\u003c/code\u003e する\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eシグナル待受＆通知用のスレッドを起動する\n\n\u003cul\u003e\n\u003cli\u003eパイプからシグナル番号を読んで，適切な \u003ccode\u003eSender\u003c/code\u003e に \u003ccode\u003esend\u003c/code\u003e する\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eという仕組みで動いています．\n自信がなかったのは，「シグナルハンドラでやっていいこと一覧」をちゃんと把握していないという点です．\n一応 \u003ccode\u003esigaction\u003c/code\u003e の man を見ると \u003ccode\u003ewrite\u003c/code\u003e は読んでもいい関数一覧にいる気がするし，実際動いてはいるのでセーフだろうと判断しました．\n（もしアウトだったら教えてください）\u003c/p\u003e\n\n\u003cp\u003eちなみに \u003ccode\u003echan-signal\u003c/code\u003e の方は，\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eシグナルごとに通知すべき \u003ccode\u003eSender\u003c/code\u003e を覚えておく\u003c/li\u003e\n\u003cli\u003e監視用スレッドを起動し，メインスレッドでは \u003ccode\u003epthread_sigmask\u003c/code\u003e を使ってシグナルをブロックする\n\n\u003cul\u003e\n\u003cli\u003eシグナルがすべて監視用スレッドに渡るようにする\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e監視用スレッドで \u003ccode\u003esigwait\u003c/code\u003e して適切な \u003ccode\u003eSender\u003c/code\u003e に \u003ccode\u003esend\u003c/code\u003e する\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eという仕組みで動いているようです．\n\u003ccode\u003esigwait\u003c/code\u003e は指定したシグナルが投げられるまでブロックします．\nただし，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/macOS\"\u003emacOS\u003c/a\u003e で \u003ccode\u003esigwait\u003c/code\u003e の man を見ると，\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eProcesses which call sigwait() on ignored signals will wait indefinitely. Ignored signals are dropped immediately by the system, before delivery to a waiting process.\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003eとあって，無視されるシグナルを \u003ccode\u003esigwait\u003c/code\u003e で待っても補足できないようです．\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Linux\"\u003eLinux\u003c/a\u003e の man を見るとそんなことは書いていないし，普通に動くっぽいです．\u003c/p\u003e\n\n\u003cp\u003e今の実装だと，シグナルを受け取る \u003ccode\u003eReceiver\u003c/code\u003e がすべて閉じても，監視スレッドは動き続けるしハンドラも残り続けるので，これはなんとかしたいなぁと思っています．\nアプリケーションの実行時間のうち，ある期間だけシグナルをとってそれ以外はスルーしたいというケースもそんなにないかなというのと，内部的な変更にしかならないので \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e が変わらないというのがあるので，この状態でとりあえず public にしました．\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLI\"\u003eCLI\u003c/a\u003e を書いていると意外と普通に \u003ccode\u003eSIGINT\u003c/code\u003e は取りたくなることがあると思うので，ぜひ使ってみてください．\nissue 報告等お待ちしています．\u003c/p\u003e\n\n---\n\n---\n","slug":"Rust_で_Unix_のシグナルを_channel_経由でキャッチする","title":"Rust で Unix のシグナルを channel 経由でキャッチする","timestamp":1499687944000,"tags":[]},{"rawMarkdown":"---\ntitle: \"BK-tree を golang で実装した\"\ndate: 2017-05-13T09:33:10.000Z\ntags: []\n---\n\n\u003cp\u003e先日はてぶに  \u003ca href=\"http://postd.cc/bk-tree/\"\u003e\u0026#x8208;\u0026#x5473;\u0026#x6DF1;\u0026#x3044;\u0026#x30C7;\u0026#x30FC;\u0026#x30BF;\u0026#x69CB;\u0026#x9020;\u0026#xFF1A;BK\u0026#x6728; | \u0026#x30D7;\u0026#x30ED;\u0026#x30B0;\u0026#x30E9;\u0026#x30DF;\u0026#x30F3;\u0026#x30B0; | POSTD\u003c/a\u003e という翻訳記事 ( 元記事 \u003ca href=\"http://signal-to-noise.xyz/post/bk-tree/\"\u003ehttp://signal-to-noise.xyz/post/bk-tree/\u003c/a\u003e) があがっているのをみて初めて BK-tree というものを知ったので，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e で実装してみました．\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"//hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fbktree\" title=\"agatan/bktree\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://github.com/agatan/bktree\"\u003egithub.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003ch2\u003eBK-tree とは\u003c/h2\u003e\n\n\u003cp\u003e先程の記事に全部書いてあるのですが\u0026hellip;\nBK-tree は，ある\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%F7%CE%A5%B6%F5%B4%D6\"\u003e距離空間\u003c/a\u003e内で近傍点探索を効率的に行えるデータ構造です．利用例としてはスペルチェックや類似画像検索などがあります．\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%F7%CE%A5%B6%F5%B4%D6\"\u003e距離空間\u003c/a\u003eとは，なにかしらの距離を計算することができる空間のことで，距離としてハミング距離やマンハッタン距離，レーベンシュタイン距離，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\"\u003eユークリッド\u003c/a\u003e距離などなどが挙げられます．\n例えば，いわゆる普通の 3 次元の空間は，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\"\u003eユークリッド\u003c/a\u003e距離を距離関数に持つ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%F7%CE%A5%B6%F5%B4%D6\"\u003e距離空間\u003c/a\u003eと考えられます．\u003c/p\u003e\n\n\u003cp\u003e近傍点探索は，要するにある点に対して，近くにある点を探すことです．\u003c/p\u003e\n\n\u003cp\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20170513/20170513183241.png\" alt=\"f:id:agtn:20170513183241p:plain\" title=\"f:id:agtn:20170513183241p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003eものすごく単純に近傍点探索をやろうと思うと，全要素を線形に探索して距離を計算していく必要があります．\nそこで BK-tree を使うともっと計算量が減らせるというわけなのです．(ちなみに僕は BK-tree を使った場合の計算量がよくわかっていません．実験的に速いことを確認しただけです．正確な計算量は考えてもよくわかりませんでした\u0026hellip;)\u003c/p\u003e\n\n\u003cp\u003e構造や仕組みは元記事などをご参照ください．\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e での bk-tree 実装は実はいくつかあったのですが，単純に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\"\u003eアルゴリズム\u003c/a\u003eを理解するために実装したかったのと，レーベンシュタイン距離を距離関数として使うことを前提にしていたりとちょっと自分の用途に合っていない気がしたので，別で作ってみました．\u003c/p\u003e\n\n\u003cp\u003eこのパッケージでは，スペルチェックそのものや距離関数を提供していません．BK-tree というデータ構造だけを提供しています．\u003c/p\u003e\n\n\u003ch2\u003e使用例\u003c/h2\u003e\n\n\u003cp\u003e16 bit 整数を要素，ハミング距離を距離関数とした例です．\u003c/p\u003e\n\n\u003cp\u003e要素となる型は \u003ccode\u003ebktree.Entry\u003c/code\u003e interface を満たす必要があります．これは \u003ccode\u003eDistance(Entry) int\u003c/code\u003e を要求する interface です．\u003cbr/\u003e\n本当は \u003ccode\u003edistance\u0026lt;T: Entry\u0026gt;(x: T) -\u0026gt; int\u003c/code\u003e みたいな形にしたいのですが，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e だと出来ないので，実装側で \u003ccode\u003ee.(hashValue)\u003c/code\u003e のように型\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%B5%A1%BC%A5%B7%A5%E7%A5%F3\"\u003eアサーション\u003c/a\u003eする必要があります．\u003cbr/\u003e\nここでは \u003ccode\u003euint16\u003c/code\u003e に戻してハミング距離を計算しています．\u003c/p\u003e\n\n\u003cp\u003e要素の追加は \u003ccode\u003eAdd(e Entry)\u003c/code\u003e です．\u003cbr/\u003e\nここでは 0 ~ 0xffff までを突っ込んでいます．\u003c/p\u003e\n\n\u003cp\u003e探索は \u003ccode\u003eSearch(e Entry, tolerance int) []*Result\u003c/code\u003e です．\n第一引数がキー，第二引数が許容する距離の最大値です．\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"synStatement\"\u003eimport\u003c/span\u003e (\n    \u003cspan class=\"synConstant\"\u003e\u0026quot;fmt\u0026quot;\u003c/span\u003e\n\n    \u003cspan class=\"synConstant\"\u003e\u0026quot;github.com/agatan/bktree\u0026quot;\u003c/span\u003e\n)\n\n\u003cspan class=\"synStatement\"\u003etype\u003c/span\u003e hashValue \u003cspan class=\"synType\"\u003euint16\u003c/span\u003e\n\n\u003cspan class=\"synComment\"\u003e// Distance calculates hamming distance.\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e (h hashValue) Distance(e bktree.Entry) \u003cspan class=\"synType\"\u003eint\u003c/span\u003e {\n    a := \u003cspan class=\"synType\"\u003euint16\u003c/span\u003e(h)\n    b := \u003cspan class=\"synType\"\u003euint16\u003c/span\u003e(e.(hashValue))\n\n    d := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003evar\u003c/span\u003e k \u003cspan class=\"synType\"\u003euint16\u003c/span\u003e = \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; \u003cspan class=\"synConstant\"\u003e16\u003c/span\u003e; i++ {\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e a\u0026amp;k != b\u0026amp;k {\n            d++\n        }\n        k \u0026lt;\u0026lt;= \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e d\n}\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e main() {\n    \u003cspan class=\"synStatement\"\u003evar\u003c/span\u003e tree bktree.BKTree\n\n    \u003cspan class=\"synComment\"\u003e// add 0x0000 to 0xffff to the tree.\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; \u003cspan class=\"synConstant\"\u003e0xffff\u003c/span\u003e; i++ {\n        tree.Add(hashValue(i))\n    }\n\n    \u003cspan class=\"synComment\"\u003e// search neighbors of 0x0000 whose distances are less than or equal to 1.\u003c/span\u003e\n    results := tree.Search(hashValue(\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e), \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e)\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e _, result := \u003cspan class=\"synStatement\"\u003erange\u003c/span\u003e results {\n        fmt.Printf(\u003cspan class=\"synConstant\"\u003e\u0026quot;%016b (distance: %d)\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e\\n\u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026quot;\u003c/span\u003e, result.Entry.(hashValue), result.Distance)\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eこれを実行すると，\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e0000000000000000 (distance: 0)\n0000000000000001 (distance: 1)\n0000000000000010 (distance: 1)\n0000000000000100 (distance: 1)\n0000000000001000 (distance: 1)\n0000000000010000 (distance: 1)\n0000000000100000 (distance: 1)\n0000000001000000 (distance: 1)\n0000000010000000 (distance: 1)\n0000000100000000 (distance: 1)\n0000001000000000 (distance: 1)\n0000010000000000 (distance: 1)\n0000100000000000 (distance: 1)\n0001000000000000 (distance: 1)\n0010000000000000 (distance: 1)\n0100000000000000 (distance: 1)\n1000000000000000 (distance: 1)\u003c/pre\u003e\n\n\u003cp\u003eという感じで 0x0000 とのハミング距離が 0 ~ 1 である要素がとれます．\u003c/p\u003e\n\n\u003ch2\u003eパフォーマンス\u003c/h2\u003e\n\n\u003cp\u003e単純な線形探索との比較をする\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\"\u003eベンチマーク\u003c/a\u003eをおいてあります．\u003cbr/\u003e\n64 bit 整数，距離関数はハミング距離，データ量 1,000,000 件での結果が以下のようになりました．\u003c/p\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left;\"\u003e \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\"\u003eベンチマーク\u003c/a\u003e \u003c/th\u003e\n\u003cth style=\"text-align:left;\"\u003e 実行時間 \u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e BK-tree (完全一致) \u003c/td\u003e\n\u003ctd style=\"text-align:left;\"\u003e                          1108 ns/op \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e BK-tree (fuzziness 1) \u003c/td\u003e\n\u003ctd style=\"text-align:left;\"\u003e          29468 ns/op \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e BK-tree (fuzziness 2) \u003c/td\u003e\n\u003ctd style=\"text-align:left;\"\u003e           328753 ns/op \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e BK-tree (fuzziness 4) \u003c/td\u003e\n\u003ctd style=\"text-align:left;\"\u003e 5490888 ns/op \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e BK-tree (fuzziness 8) \u003c/td\u003e\n\u003ctd style=\"text-align:left;\"\u003e     68182122 ns/op \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e BK-tree (fuzziness 32) \u003c/td\u003e\n\u003ctd style=\"text-align:left;\"\u003e         353715305 ns/op \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e Linear Search \u003c/td\u003e\n\u003ctd style=\"text-align:left;\"\u003e          4132926 ns/op \u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cp\u003efuzziness が小さければ小さいほど ( = tolerance が小さければ小さいほど ) 高速に探索できることが分かります．\u003c/p\u003e\n\n\u003cp\u003eまた，データ量が増えるほど Linear Search より有利になるので，距離に対してデータが十分に大量にある場合はかなり有効といえそうです．\u003c/p\u003e\n\n\u003ch2\u003eおまけ\u003c/h2\u003e\n\n\u003cp\u003etree の構築にかかるコストがそこそこ大きかったので pprof で見つつチューニングする必要がありました．\n学びとして，「map が重い」「interface が重い」というのがありました．\u003c/p\u003e\n\n\u003cp\u003e各ノードの部分木は，そのノードからの距離 d を key として，\u003ccode\u003emap[int]*Node\u003c/code\u003e としていました．\ntree を構築する際には，allocate + read + write をかなりの回数行うのですが，これがまぁ遅い．\u003cbr/\u003e\n最終的にこの部分はスライスでもっておいて，d を key として部分木をとりたい時は線形探索をするようにしました．\u003cbr/\u003e\n\u003ccode\u003enext, ok := n.children[d]\u003c/code\u003e としていた部分が\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003etype\u003c/span\u003e elem \u003cspan class=\"synStatement\"\u003estruct\u003c/span\u003e\n    distance \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\n    node *node\n}\n\n\u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e _, c := \u003cspan class=\"synStatement\"\u003erange\u003c/span\u003e n.children {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e c.distance == d {\n        \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e c.node\n    }\n}\n\u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synStatement\"\u003enil\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eという感じになります．あんまりきれいではないんですが，こっちの方がほとんどのケース倍以上速かったので，こちらを採用しました．\u003cbr/\u003e\n部分木の数が増えてくると，map のほうが速いと思われるのですが，ハミング距離の場合最大でも bit 数までしか部分木が増えないので．\u003cbr/\u003e\nレーベンシュタイン距離を用いたスペルチェックの場合でも，単語の最大文字数以上の距離にはなりません．\n2 次元 / 3 次元程度の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%F7%CE%A5%B6%F5%B4%D6\"\u003e距離空間\u003c/a\u003eなら kd-tree などもっと他に良い方法があるきがするので，レーベンシュタイン距離やハミング距離を使うケースをメインに考えました．\u003c/p\u003e\n\n\u003cp\u003eその結果，実行時間のかなりの割合が \u003ccode\u003eEntry\u003c/code\u003e interface を介した関数呼び出しのオーバヘッドとか，inteface の allocation になってしまいました．\u003cbr/\u003e\nデータ構造を \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e で提供する以上このオーバヘッドは避けられないです．( もちろん BK-tree そのものを，自分の利用形態に特化して作れば回避できますが\u0026hellip; )\u003cbr/\u003e\nちょっと Rust や \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e で書きたくなりました．十分速いし書きやすいので良いんですが\u0026hellip;\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e先日はてぶに  \u003ca href=\"http://postd.cc/bk-tree/\"\u003e\u0026#x8208;\u0026#x5473;\u0026#x6DF1;\u0026#x3044;\u0026#x30C7;\u0026#x30FC;\u0026#x30BF;\u0026#x69CB;\u0026#x9020;\u0026#xFF1A;BK\u0026#x6728; | \u0026#x30D7;\u0026#x30ED;\u0026#x30B0;\u0026#x30E9;\u0026#x30DF;\u0026#x30F3;\u0026#x30B0; | POSTD\u003c/a\u003e という翻訳記事 ( 元記事 \u003ca href=\"http://signal-to-noise.xyz/post/bk-tree/\"\u003ehttp://signal-to-noise.xyz/post/bk-tree/\u003c/a\u003e) があがっているのをみて初めて BK-tree というものを知ったので，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e で実装してみました．\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"//hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fbktree\" title=\"agatan/bktree\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://github.com/agatan/bktree\"\u003egithub.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003ch2\u003eBK-tree とは\u003c/h2\u003e\n\n\u003cp\u003e先程の記事に全部書いてあるのですが\u0026hellip;\nBK-tree は，ある\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%F7%CE%A5%B6%F5%B4%D6\"\u003e距離空間\u003c/a\u003e内で近傍点探索を効率的に行えるデータ構造です．利用例としてはスペルチェックや類似画像検索などがあります．\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%F7%CE%A5%B6%F5%B4%D6\"\u003e距離空間\u003c/a\u003eとは，なにかしらの距離を計算することができる空間のことで，距離としてハミング距離やマンハッタン距離，レーベンシュタイン距離，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\"\u003eユークリッド\u003c/a\u003e距離などなどが挙げられます．\n例えば，いわゆる普通の 3 次元の空間は，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\"\u003eユークリッド\u003c/a\u003e距離を距離関数に持つ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%F7%CE%A5%B6%F5%B4%D6\"\u003e距離空間\u003c/a\u003eと考えられます．\u003c/p\u003e\n\n\u003cp\u003e近傍点探索は，要するにある点に対して，近くにある点を探すことです．\u003c/p\u003e\n\n\u003cp\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20170513/20170513183241.png\" alt=\"f:id:agtn:20170513183241p:plain\" title=\"f:id:agtn:20170513183241p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003eものすごく単純に近傍点探索をやろうと思うと，全要素を線形に探索して距離を計算していく必要があります．\nそこで BK-tree を使うともっと計算量が減らせるというわけなのです．(ちなみに僕は BK-tree を使った場合の計算量がよくわかっていません．実験的に速いことを確認しただけです．正確な計算量は考えてもよくわかりませんでした\u0026hellip;)\u003c/p\u003e\n\n\u003cp\u003e構造や仕組みは元記事などをご参照ください．\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e での bk-tree 実装は実はいくつかあったのですが，単純に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\"\u003eアルゴリズム\u003c/a\u003eを理解するために実装したかったのと，レーベンシュタイン距離を距離関数として使うことを前提にしていたりとちょっと自分の用途に合っていない気がしたので，別で作ってみました．\u003c/p\u003e\n\n\u003cp\u003eこのパッケージでは，スペルチェックそのものや距離関数を提供していません．BK-tree というデータ構造だけを提供しています．\u003c/p\u003e\n\n\u003ch2\u003e使用例\u003c/h2\u003e\n\n\u003cp\u003e16 bit 整数を要素，ハミング距離を距離関数とした例です．\u003c/p\u003e\n\n\u003cp\u003e要素となる型は \u003ccode\u003ebktree.Entry\u003c/code\u003e interface を満たす必要があります．これは \u003ccode\u003eDistance(Entry) int\u003c/code\u003e を要求する interface です．\u003cbr/\u003e\n本当は \u003ccode\u003edistance\u0026lt;T: Entry\u0026gt;(x: T) -\u0026gt; int\u003c/code\u003e みたいな形にしたいのですが，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e だと出来ないので，実装側で \u003ccode\u003ee.(hashValue)\u003c/code\u003e のように型\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%B5%A1%BC%A5%B7%A5%E7%A5%F3\"\u003eアサーション\u003c/a\u003eする必要があります．\u003cbr/\u003e\nここでは \u003ccode\u003euint16\u003c/code\u003e に戻してハミング距離を計算しています．\u003c/p\u003e\n\n\u003cp\u003e要素の追加は \u003ccode\u003eAdd(e Entry)\u003c/code\u003e です．\u003cbr/\u003e\nここでは 0 ~ 0xffff までを突っ込んでいます．\u003c/p\u003e\n\n\u003cp\u003e探索は \u003ccode\u003eSearch(e Entry, tolerance int) []*Result\u003c/code\u003e です．\n第一引数がキー，第二引数が許容する距離の最大値です．\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"synStatement\"\u003eimport\u003c/span\u003e (\n    \u003cspan class=\"synConstant\"\u003e\u0026quot;fmt\u0026quot;\u003c/span\u003e\n\n    \u003cspan class=\"synConstant\"\u003e\u0026quot;github.com/agatan/bktree\u0026quot;\u003c/span\u003e\n)\n\n\u003cspan class=\"synStatement\"\u003etype\u003c/span\u003e hashValue \u003cspan class=\"synType\"\u003euint16\u003c/span\u003e\n\n\u003cspan class=\"synComment\"\u003e// Distance calculates hamming distance.\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e (h hashValue) Distance(e bktree.Entry) \u003cspan class=\"synType\"\u003eint\u003c/span\u003e {\n    a := \u003cspan class=\"synType\"\u003euint16\u003c/span\u003e(h)\n    b := \u003cspan class=\"synType\"\u003euint16\u003c/span\u003e(e.(hashValue))\n\n    d := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003evar\u003c/span\u003e k \u003cspan class=\"synType\"\u003euint16\u003c/span\u003e = \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; \u003cspan class=\"synConstant\"\u003e16\u003c/span\u003e; i++ {\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e a\u0026amp;k != b\u0026amp;k {\n            d++\n        }\n        k \u0026lt;\u0026lt;= \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e d\n}\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e main() {\n    \u003cspan class=\"synStatement\"\u003evar\u003c/span\u003e tree bktree.BKTree\n\n    \u003cspan class=\"synComment\"\u003e// add 0x0000 to 0xffff to the tree.\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; \u003cspan class=\"synConstant\"\u003e0xffff\u003c/span\u003e; i++ {\n        tree.Add(hashValue(i))\n    }\n\n    \u003cspan class=\"synComment\"\u003e// search neighbors of 0x0000 whose distances are less than or equal to 1.\u003c/span\u003e\n    results := tree.Search(hashValue(\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e), \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e)\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e _, result := \u003cspan class=\"synStatement\"\u003erange\u003c/span\u003e results {\n        fmt.Printf(\u003cspan class=\"synConstant\"\u003e\u0026quot;%016b (distance: %d)\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e\\n\u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026quot;\u003c/span\u003e, result.Entry.(hashValue), result.Distance)\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eこれを実行すると，\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e0000000000000000 (distance: 0)\n0000000000000001 (distance: 1)\n0000000000000010 (distance: 1)\n0000000000000100 (distance: 1)\n0000000000001000 (distance: 1)\n0000000000010000 (distance: 1)\n0000000000100000 (distance: 1)\n0000000001000000 (distance: 1)\n0000000010000000 (distance: 1)\n0000000100000000 (distance: 1)\n0000001000000000 (distance: 1)\n0000010000000000 (distance: 1)\n0000100000000000 (distance: 1)\n0001000000000000 (distance: 1)\n0010000000000000 (distance: 1)\n0100000000000000 (distance: 1)\n1000000000000000 (distance: 1)\u003c/pre\u003e\n\n\u003cp\u003eという感じで 0x0000 とのハミング距離が 0 ~ 1 である要素がとれます．\u003c/p\u003e\n\n\u003ch2\u003eパフォーマンス\u003c/h2\u003e\n\n\u003cp\u003e単純な線形探索との比較をする\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\"\u003eベンチマーク\u003c/a\u003eをおいてあります．\u003cbr/\u003e\n64 bit 整数，距離関数はハミング距離，データ量 1,000,000 件での結果が以下のようになりました．\u003c/p\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left;\"\u003e \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\"\u003eベンチマーク\u003c/a\u003e \u003c/th\u003e\n\u003cth style=\"text-align:left;\"\u003e 実行時間 \u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e BK-tree (完全一致) \u003c/td\u003e\n\u003ctd style=\"text-align:left;\"\u003e                          1108 ns/op \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e BK-tree (fuzziness 1) \u003c/td\u003e\n\u003ctd style=\"text-align:left;\"\u003e          29468 ns/op \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e BK-tree (fuzziness 2) \u003c/td\u003e\n\u003ctd style=\"text-align:left;\"\u003e           328753 ns/op \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e BK-tree (fuzziness 4) \u003c/td\u003e\n\u003ctd style=\"text-align:left;\"\u003e 5490888 ns/op \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e BK-tree (fuzziness 8) \u003c/td\u003e\n\u003ctd style=\"text-align:left;\"\u003e     68182122 ns/op \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e BK-tree (fuzziness 32) \u003c/td\u003e\n\u003ctd style=\"text-align:left;\"\u003e         353715305 ns/op \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e Linear Search \u003c/td\u003e\n\u003ctd style=\"text-align:left;\"\u003e          4132926 ns/op \u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cp\u003efuzziness が小さければ小さいほど ( = tolerance が小さければ小さいほど ) 高速に探索できることが分かります．\u003c/p\u003e\n\n\u003cp\u003eまた，データ量が増えるほど Linear Search より有利になるので，距離に対してデータが十分に大量にある場合はかなり有効といえそうです．\u003c/p\u003e\n\n\u003ch2\u003eおまけ\u003c/h2\u003e\n\n\u003cp\u003etree の構築にかかるコストがそこそこ大きかったので pprof で見つつチューニングする必要がありました．\n学びとして，「map が重い」「interface が重い」というのがありました．\u003c/p\u003e\n\n\u003cp\u003e各ノードの部分木は，そのノードからの距離 d を key として，\u003ccode\u003emap[int]*Node\u003c/code\u003e としていました．\ntree を構築する際には，allocate + read + write をかなりの回数行うのですが，これがまぁ遅い．\u003cbr/\u003e\n最終的にこの部分はスライスでもっておいて，d を key として部分木をとりたい時は線形探索をするようにしました．\u003cbr/\u003e\n\u003ccode\u003enext, ok := n.children[d]\u003c/code\u003e としていた部分が\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003etype\u003c/span\u003e elem \u003cspan class=\"synStatement\"\u003estruct\u003c/span\u003e\n    distance \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\n    node *node\n}\n\n\u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e _, c := \u003cspan class=\"synStatement\"\u003erange\u003c/span\u003e n.children {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e c.distance == d {\n        \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e c.node\n    }\n}\n\u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synStatement\"\u003enil\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eという感じになります．あんまりきれいではないんですが，こっちの方がほとんどのケース倍以上速かったので，こちらを採用しました．\u003cbr/\u003e\n部分木の数が増えてくると，map のほうが速いと思われるのですが，ハミング距離の場合最大でも bit 数までしか部分木が増えないので．\u003cbr/\u003e\nレーベンシュタイン距離を用いたスペルチェックの場合でも，単語の最大文字数以上の距離にはなりません．\n2 次元 / 3 次元程度の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%F7%CE%A5%B6%F5%B4%D6\"\u003e距離空間\u003c/a\u003eなら kd-tree などもっと他に良い方法があるきがするので，レーベンシュタイン距離やハミング距離を使うケースをメインに考えました．\u003c/p\u003e\n\n\u003cp\u003eその結果，実行時間のかなりの割合が \u003ccode\u003eEntry\u003c/code\u003e interface を介した関数呼び出しのオーバヘッドとか，inteface の allocation になってしまいました．\u003cbr/\u003e\nデータ構造を \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e で提供する以上このオーバヘッドは避けられないです．( もちろん BK-tree そのものを，自分の利用形態に特化して作れば回避できますが\u0026hellip; )\u003cbr/\u003e\nちょっと Rust や \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e で書きたくなりました．十分速いし書きやすいので良いんですが\u0026hellip;\u003c/p\u003e\n\n---\n\n---\n","slug":"BK-tree_を_golang_で実装した","title":"BK-tree を golang で実装した","timestamp":1494667990000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Rust でグラフ構造や木構造を作る\"\ndate: 2017-01-16T06:17:45.000Z\ntags: []\n---\n\n\u003cp\u003eプログラムを書いていると何かしら\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eっぽいものやグラフっぽいものを作りたい場面が多々あると思います．\nRust は所有権や \u003ccode\u003eSize\u003c/code\u003e の都合で，これらを作ろうと思うと地味にハマるのでまとめておきます．\u003c/p\u003e\n\n\u003ch3\u003eRust で\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003e\u003c/h3\u003e\n\n\u003cp\u003e最も単純な\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eは Rust だと\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003eenum\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eTree\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"synIdentifier\"\u003eLeaf\u003c/span\u003e(T),\n    \u003cspan class=\"synIdentifier\"\u003eNode\u003c/span\u003e(\u003cspan class=\"synType\"\u003eBox\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eTree\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e, \u003cspan class=\"synType\"\u003eBox\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eTree\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e),\n}\n\u003c/pre\u003e\n\n\u003cp\u003eといった形で表せます．\nRust では明示的に \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/boxing\"\u003eboxing\u003c/a\u003e してあげないと\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003e的なデータ構造は作れないのでちょっと複雑に見えるかもしれませんが，まぁ単純です．\u003c/p\u003e\n\n\u003cp\u003eこの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eを書き換えたい場合は，ownership をとって書き換えた値を返すこともできますし，\u003ccode\u003e\u0026amp;mut Tree\u0026lt;T\u0026gt;\u003c/code\u003e をとって in-place に書き換えることもできます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003einc\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e) {\n    \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e \u003cspan class=\"synType\"\u003e*\u003c/span\u003e\u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e {\n        \u003cspan class=\"synPreProc\"\u003eTree\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eLeaf\u003c/span\u003e(\u003cspan class=\"synType\"\u003eref\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e i) \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003e*\u003c/span\u003ei \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003e*\u003c/span\u003ei \u003cspan class=\"synStatement\"\u003e+\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e,\n        \u003cspan class=\"synPreProc\"\u003eTree\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eNode\u003c/span\u003e(\u003cspan class=\"synType\"\u003eref\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e left, \u003cspan class=\"synType\"\u003eref\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e right) \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e {\n            left.\u003cspan class=\"synIdentifier\"\u003einc\u003c/span\u003e();\n            right.\u003cspan class=\"synIdentifier\"\u003einc\u003c/span\u003e();\n        }\n    }\n}\n\n\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003einc2\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e Tree\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei32\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e {\n        \u003cspan class=\"synPreProc\"\u003eTree\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eLeaf\u003c/span\u003e(i) \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eTree\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eLeaf\u003c/span\u003e(i \u003cspan class=\"synStatement\"\u003e+\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e),\n        \u003cspan class=\"synPreProc\"\u003eTree\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eNode\u003c/span\u003e(left, right) \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eTree\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eNode\u003c/span\u003e(\u003cspan class=\"synType\"\u003eBox\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003enew\u003c/span\u003e(left.\u003cspan class=\"synIdentifier\"\u003einc2\u003c/span\u003e()), \u003cspan class=\"synType\"\u003eBox\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003enew\u003c/span\u003e(right.\u003cspan class=\"synIdentifier\"\u003einc2\u003c/span\u003e())),\n    }\n}\n\u003c/pre\u003e\n\n\u003ch3\u003eRust で有向非巡回グラフ\u003c/h3\u003e\n\n\u003cp\u003e有向非巡回グラフ構造は，グラフのエッジに向きがあり，かつ循環がない構造で，これは割りと単純に表現できます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003estruct\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eNode\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(T, \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eRc\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eNode\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u0026gt;\u003c/span\u003e);\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eNode\u003c/code\u003e は自身の値 \u003ccode\u003eT\u003c/code\u003e と，つながっているノードの \u003ccode\u003eVec\u003c/code\u003e を持ちます．(対象問題によっては \u003ccode\u003eVec\u003c/code\u003e ではなくて \u003ccode\u003eHashMap\u003c/code\u003e とか \u003ccode\u003eHashSet\u003c/code\u003e とか)\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eRc\u003c/code\u003e は参照カウント方式のスマートポインタです．\nグラフでは，\u003ccode\u003eNode\u003c/code\u003e は複数の \u003ccode\u003eNode\u003c/code\u003e から参照される可能性があるので， \u003ccode\u003eBox\u003c/code\u003e は使えません．\u003c/p\u003e\n\n\u003cp\u003eこれを変更可能にしたい場合はちょっと面倒ですが \u003ccode\u003eRefCell\u003c/code\u003e を使う必要があります．\u003c/p\u003e\n\n\u003cp\u003eRust では基本的に mutable borrow は常にひとつしか存在できず，mutable borrow が生きている間は immutable borrow もつくることができません．\n\u003ccode\u003eRc\u003c/code\u003e から mutable な参照を取り出すこともできません．\u003c/p\u003e\n\n\u003cp\u003eそこで \u003ccode\u003eRefCell\u003c/code\u003e を使うことで borrow check をランタイムに行うようにします．\n\u003ccode\u003eRefCell\u003c/code\u003e は immutable な参照から mutable な参照を取り出せるようにする働きをしますが，\nmutable な参照を取っている間に，さらに mutable な参照を作ろうとしたり immutable な参照を作ろうとすると，ランタイムに \u003ccode\u003epanic\u003c/code\u003e します．\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時検査ではなくランタイム検査になるので，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DE\"\u003eプログラマ\u003c/a\u003eの責任できちんと管理しないと死にます．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eRefCell\u003c/code\u003e 版がこちら\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003estruct\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eNode\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(T, \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eRc\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eRefCell\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eNode\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u003c/span\u003e);\n\n\u003cspan class=\"synStatement\"\u003eimpl\u003c/span\u003e Node\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei32\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003einc\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e) {\n        \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e+=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e;\n        \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e n \u003cspan class=\"synStatement\"\u003ein\u003c/span\u003e \u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e {\n            n.\u003cspan class=\"synIdentifier\"\u003eborrow_mut\u003c/span\u003e().\u003cspan class=\"synIdentifier\"\u003einc\u003c/span\u003e();\n        }\n    }\n}\n\u003c/pre\u003e\n\n\u003ch3\u003eRust で巡回有向グラフ\u003c/h3\u003e\n\n\u003cp\u003e循環がある場合は厄介です．\nRust で参照を共有するための \u003ccode\u003eRc\u003c/code\u003e は参照カウントなので，循環参照があるとリークします．\nしたがって循環のある構造を表すために \u003ccode\u003eRc\u003c/code\u003e は使えません．\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eで親を参照するポインタを子に持たせておきたいといったケースでは，親は子を \u003ccode\u003eRc\u003c/code\u003e で持ち，子は親を \u003ccode\u003eWeak\u003c/code\u003e で持つという形で対応できますが，\nグラフだとそういうわけにもいきません．\u003c/p\u003e\n\n\u003cp\u003eそこで出て来るのが \u003ccode\u003eArena\u003c/code\u003e という方法です．\u003c/p\u003e\n\n\u003cp\u003eオブジェクトの実体は \u003ccode\u003eArena\u003c/code\u003e の中に作り，グラフにはその ID を持たせて管理します．\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003etype\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eNodeId\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003eusize\u003c/span\u003e;\n\n\u003cspan class=\"synStatement\"\u003estruct\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eNodeArena\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n    arena: \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eNode\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e,\n}\n\n\u003cspan class=\"synStatement\"\u003eimpl\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e NodeArena {\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003ealloc\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e, value: T) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e NodeId {\n        \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e id \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.arena.\u003cspan class=\"synIdentifier\"\u003elen\u003c/span\u003e();\n        \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e node \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eNode\u003c/span\u003e(id, value, \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003enew\u003c/span\u003e());\n        \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.arena.\u003cspan class=\"synIdentifier\"\u003epush\u003c/span\u003e(node);\n        id\n    }\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eget\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e, id: NodeId) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003eNode\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.arena[id]\n    }\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eget_mut\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e, id: NodeId) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e Node\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.arena[id]\n    }\n}\n\n\u003cspan class=\"synStatement\"\u003estruct\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eNode\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(NodeId, T, \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eNodeId\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e);\n\u003c/pre\u003e\n\n\u003cp\u003eこんな感じです．\u003c/p\u003e\n\n\u003cp\u003eこうすることで\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時の borrow check を諦めることなくグラフ構造を作ることができます．\u003cbr/\u003e\n(\u003ccode\u003ei\u003c/code\u003e と \u003ccode\u003ei+1\u003c/code\u003e 番目のノードを同時に mutable に参照したいとかは苦しいですが)\u003c/p\u003e\n\n\u003cp\u003e欠点としては単純に間接的な表現でめんどくさいというのもありますが，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GC\"\u003eGC\u003c/a\u003e がないので参照されなくなったオブジェクトも \u003ccode\u003eArena\u003c/code\u003e 上で生き続けてしまうことです．\nそのため，動的に要素が生きたり死んだりするケースには使いにくいです．\u003c/p\u003e\n\n\u003cp\u003eノードグラフの構築が終わったら \u003ccode\u003eArena\u003c/code\u003e をリフレッシュするみたいなことをすると良いのかもしれません．\n(構築中は \u003ccode\u003eVec\u003c/code\u003e で \u003ccode\u003eArena\u003c/code\u003e を表現して，構造が固まったら \u003ccode\u003eHashMap\u003c/code\u003e を使った \u003ccode\u003eArena\u003c/code\u003e に切り替えて参照されているidだけを残すみたいな)\u003cbr/\u003e\nそれでも構築中はオブジェクトがあまりまくるので辛いですね...\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eプログラムを書いていると何かしら\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eっぽいものやグラフっぽいものを作りたい場面が多々あると思います．\nRust は所有権や \u003ccode\u003eSize\u003c/code\u003e の都合で，これらを作ろうと思うと地味にハマるのでまとめておきます．\u003c/p\u003e\n\n\u003ch3\u003eRust で\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003e\u003c/h3\u003e\n\n\u003cp\u003e最も単純な\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eは Rust だと\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003eenum\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eTree\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"synIdentifier\"\u003eLeaf\u003c/span\u003e(T),\n    \u003cspan class=\"synIdentifier\"\u003eNode\u003c/span\u003e(\u003cspan class=\"synType\"\u003eBox\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eTree\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e, \u003cspan class=\"synType\"\u003eBox\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eTree\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e),\n}\n\u003c/pre\u003e\n\n\u003cp\u003eといった形で表せます．\nRust では明示的に \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/boxing\"\u003eboxing\u003c/a\u003e してあげないと\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003e的なデータ構造は作れないのでちょっと複雑に見えるかもしれませんが，まぁ単純です．\u003c/p\u003e\n\n\u003cp\u003eこの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eを書き換えたい場合は，ownership をとって書き換えた値を返すこともできますし，\u003ccode\u003e\u0026amp;mut Tree\u0026lt;T\u0026gt;\u003c/code\u003e をとって in-place に書き換えることもできます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003einc\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e) {\n    \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e \u003cspan class=\"synType\"\u003e*\u003c/span\u003e\u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e {\n        \u003cspan class=\"synPreProc\"\u003eTree\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eLeaf\u003c/span\u003e(\u003cspan class=\"synType\"\u003eref\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e i) \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003e*\u003c/span\u003ei \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003e*\u003c/span\u003ei \u003cspan class=\"synStatement\"\u003e+\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e,\n        \u003cspan class=\"synPreProc\"\u003eTree\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eNode\u003c/span\u003e(\u003cspan class=\"synType\"\u003eref\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e left, \u003cspan class=\"synType\"\u003eref\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e right) \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e {\n            left.\u003cspan class=\"synIdentifier\"\u003einc\u003c/span\u003e();\n            right.\u003cspan class=\"synIdentifier\"\u003einc\u003c/span\u003e();\n        }\n    }\n}\n\n\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003einc2\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e Tree\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei32\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e {\n        \u003cspan class=\"synPreProc\"\u003eTree\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eLeaf\u003c/span\u003e(i) \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eTree\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eLeaf\u003c/span\u003e(i \u003cspan class=\"synStatement\"\u003e+\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e),\n        \u003cspan class=\"synPreProc\"\u003eTree\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eNode\u003c/span\u003e(left, right) \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eTree\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eNode\u003c/span\u003e(\u003cspan class=\"synType\"\u003eBox\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003enew\u003c/span\u003e(left.\u003cspan class=\"synIdentifier\"\u003einc2\u003c/span\u003e()), \u003cspan class=\"synType\"\u003eBox\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003enew\u003c/span\u003e(right.\u003cspan class=\"synIdentifier\"\u003einc2\u003c/span\u003e())),\n    }\n}\n\u003c/pre\u003e\n\n\u003ch3\u003eRust で有向非巡回グラフ\u003c/h3\u003e\n\n\u003cp\u003e有向非巡回グラフ構造は，グラフのエッジに向きがあり，かつ循環がない構造で，これは割りと単純に表現できます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003estruct\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eNode\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(T, \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eRc\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eNode\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u0026gt;\u003c/span\u003e);\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eNode\u003c/code\u003e は自身の値 \u003ccode\u003eT\u003c/code\u003e と，つながっているノードの \u003ccode\u003eVec\u003c/code\u003e を持ちます．(対象問題によっては \u003ccode\u003eVec\u003c/code\u003e ではなくて \u003ccode\u003eHashMap\u003c/code\u003e とか \u003ccode\u003eHashSet\u003c/code\u003e とか)\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eRc\u003c/code\u003e は参照カウント方式のスマートポインタです．\nグラフでは，\u003ccode\u003eNode\u003c/code\u003e は複数の \u003ccode\u003eNode\u003c/code\u003e から参照される可能性があるので， \u003ccode\u003eBox\u003c/code\u003e は使えません．\u003c/p\u003e\n\n\u003cp\u003eこれを変更可能にしたい場合はちょっと面倒ですが \u003ccode\u003eRefCell\u003c/code\u003e を使う必要があります．\u003c/p\u003e\n\n\u003cp\u003eRust では基本的に mutable borrow は常にひとつしか存在できず，mutable borrow が生きている間は immutable borrow もつくることができません．\n\u003ccode\u003eRc\u003c/code\u003e から mutable な参照を取り出すこともできません．\u003c/p\u003e\n\n\u003cp\u003eそこで \u003ccode\u003eRefCell\u003c/code\u003e を使うことで borrow check をランタイムに行うようにします．\n\u003ccode\u003eRefCell\u003c/code\u003e は immutable な参照から mutable な参照を取り出せるようにする働きをしますが，\nmutable な参照を取っている間に，さらに mutable な参照を作ろうとしたり immutable な参照を作ろうとすると，ランタイムに \u003ccode\u003epanic\u003c/code\u003e します．\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時検査ではなくランタイム検査になるので，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DE\"\u003eプログラマ\u003c/a\u003eの責任できちんと管理しないと死にます．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eRefCell\u003c/code\u003e 版がこちら\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003estruct\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eNode\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(T, \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eRc\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eRefCell\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eNode\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u003c/span\u003e);\n\n\u003cspan class=\"synStatement\"\u003eimpl\u003c/span\u003e Node\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei32\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003einc\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e) {\n        \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e+=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e;\n        \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e n \u003cspan class=\"synStatement\"\u003ein\u003c/span\u003e \u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e {\n            n.\u003cspan class=\"synIdentifier\"\u003eborrow_mut\u003c/span\u003e().\u003cspan class=\"synIdentifier\"\u003einc\u003c/span\u003e();\n        }\n    }\n}\n\u003c/pre\u003e\n\n\u003ch3\u003eRust で巡回有向グラフ\u003c/h3\u003e\n\n\u003cp\u003e循環がある場合は厄介です．\nRust で参照を共有するための \u003ccode\u003eRc\u003c/code\u003e は参照カウントなので，循環参照があるとリークします．\nしたがって循環のある構造を表すために \u003ccode\u003eRc\u003c/code\u003e は使えません．\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eで親を参照するポインタを子に持たせておきたいといったケースでは，親は子を \u003ccode\u003eRc\u003c/code\u003e で持ち，子は親を \u003ccode\u003eWeak\u003c/code\u003e で持つという形で対応できますが，\nグラフだとそういうわけにもいきません．\u003c/p\u003e\n\n\u003cp\u003eそこで出て来るのが \u003ccode\u003eArena\u003c/code\u003e という方法です．\u003c/p\u003e\n\n\u003cp\u003eオブジェクトの実体は \u003ccode\u003eArena\u003c/code\u003e の中に作り，グラフにはその ID を持たせて管理します．\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003etype\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eNodeId\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003eusize\u003c/span\u003e;\n\n\u003cspan class=\"synStatement\"\u003estruct\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eNodeArena\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n    arena: \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eNode\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e,\n}\n\n\u003cspan class=\"synStatement\"\u003eimpl\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e NodeArena {\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003ealloc\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e, value: T) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e NodeId {\n        \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e id \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.arena.\u003cspan class=\"synIdentifier\"\u003elen\u003c/span\u003e();\n        \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e node \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eNode\u003c/span\u003e(id, value, \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003enew\u003c/span\u003e());\n        \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.arena.\u003cspan class=\"synIdentifier\"\u003epush\u003c/span\u003e(node);\n        id\n    }\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eget\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e, id: NodeId) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003eNode\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.arena[id]\n    }\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eget_mut\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e, id: NodeId) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e Node\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.arena[id]\n    }\n}\n\n\u003cspan class=\"synStatement\"\u003estruct\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eNode\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(NodeId, T, \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eNodeId\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e);\n\u003c/pre\u003e\n\n\u003cp\u003eこんな感じです．\u003c/p\u003e\n\n\u003cp\u003eこうすることで\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時の borrow check を諦めることなくグラフ構造を作ることができます．\u003cbr/\u003e\n(\u003ccode\u003ei\u003c/code\u003e と \u003ccode\u003ei+1\u003c/code\u003e 番目のノードを同時に mutable に参照したいとかは苦しいですが)\u003c/p\u003e\n\n\u003cp\u003e欠点としては単純に間接的な表現でめんどくさいというのもありますが，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GC\"\u003eGC\u003c/a\u003e がないので参照されなくなったオブジェクトも \u003ccode\u003eArena\u003c/code\u003e 上で生き続けてしまうことです．\nそのため，動的に要素が生きたり死んだりするケースには使いにくいです．\u003c/p\u003e\n\n\u003cp\u003eノードグラフの構築が終わったら \u003ccode\u003eArena\u003c/code\u003e をリフレッシュするみたいなことをすると良いのかもしれません．\n(構築中は \u003ccode\u003eVec\u003c/code\u003e で \u003ccode\u003eArena\u003c/code\u003e を表現して，構造が固まったら \u003ccode\u003eHashMap\u003c/code\u003e を使った \u003ccode\u003eArena\u003c/code\u003e に切り替えて参照されているidだけを残すみたいな)\u003cbr/\u003e\nそれでも構築中はオブジェクトがあまりまくるので辛いですね...\u003c/p\u003e\n\n---\n\n---\n","slug":"Rust_でグラフ構造や木構造を作る","title":"Rust でグラフ構造や木構造を作る","timestamp":1484547465000,"tags":[]},{"rawMarkdown":"---\ntitle: \"mio で echo サーバメモ\"\ndate: 2017-01-07T06:14:55.000Z\ntags: []\n---\n\n\u003cp\u003eRust の非同期 IO ライブラリのなかでももっとも低レベルなレイヤーを担っている \u003ca href=\"https://github.com/carllerche/mio\"\u003emio\u003c/a\u003e を使ってecho サーバを書いた。\necho サーバばっかり書いているような気がするけど，echo サーバやっておくと簡単な割にライブラリの使い方とかがちゃんと分かる気がするので好きです。\u003c/p\u003e\n\n\u003ch3\u003eコード\u003c/h3\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003eextern\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ecrate\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003emio\u003c/span\u003e;\n\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003estd\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003eio\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003eprelude\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synType\"\u003e*\u003c/span\u003e;\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003estd\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003ecollections\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eHashMap;\n\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003emio\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synType\"\u003e*\u003c/span\u003e;\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003emio\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003etcp\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e{TcpListener, TcpStream};\n\n\u003cspan class=\"synPreProc\"\u003e#[derive(\u003c/span\u003e\u003cspan class=\"synType\"\u003eDebug\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e)]\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003estruct\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eClientsHolder\u003c/span\u003e {\n    table: HashMap\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eToken, TcpStream\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e,\n    free_token: \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eToken\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e,\n    next_max_token: Token,\n}\n\n\u003cspan class=\"synStatement\"\u003eimpl\u003c/span\u003e ClientsHolder {\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003enew_from\u003c/span\u003e(start_token: Token) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003eSelf\u003c/span\u003e {\n        ClientsHolder {\n            table: \u003cspan class=\"synPreProc\"\u003eHashMap\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003enew\u003c/span\u003e(),\n            free_token: \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003enew\u003c/span\u003e(),\n            next_max_token: start_token,\n        }\n    }\n\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003enext_token\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e Token {\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eSome\u003c/span\u003e(tok) \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.free_token.\u003cspan class=\"synIdentifier\"\u003epop\u003c/span\u003e() {\n            \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e tok;\n        }\n        \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e tok \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.next_max_token;\n        \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.next_max_token \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eToken\u003c/span\u003e(tok.\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e+\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e);\n        tok\n    }\n\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eregister\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e, tok: Token, client: TcpStream) {\n        \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.table.\u003cspan class=\"synIdentifier\"\u003einsert\u003c/span\u003e(tok, client);\n    }\n\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eget_mut\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e, tok: Token) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003eOption\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e TcpStream\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.table.\u003cspan class=\"synIdentifier\"\u003eget_mut\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003etok)\n    }\n\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eremove\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e, tok: Token) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003eOption\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eTcpStream\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e result \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.table.\u003cspan class=\"synIdentifier\"\u003eremove\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003etok);\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e result.\u003cspan class=\"synIdentifier\"\u003eis_some\u003c/span\u003e() {\n            \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.free_token.\u003cspan class=\"synIdentifier\"\u003epush\u003c/span\u003e(tok);\n        }\n        result\n    }\n}\n\n\u003cspan class=\"synComment\"\u003e// Setup some tokens to allow us to identify which event is\u003c/span\u003e\n\u003cspan class=\"synComment\"\u003e// for which socket.\u003c/span\u003e\n\u003cspan class=\"synType\"\u003econst\u003c/span\u003e SERVER: Token \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eToken\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e);\n\n\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003emain\u003c/span\u003e() {\n\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e addr \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;127.0.0.1:13265\u0026quot;\u003c/span\u003e.\u003cspan class=\"synIdentifier\"\u003eparse\u003c/span\u003e().\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n\n    \u003cspan class=\"synComment\"\u003e// Setup the server socket\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e server \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eTcpListener\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003ebind\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003eaddr).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n\n    \u003cspan class=\"synComment\"\u003e// Create an poll instance\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e poll \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003ePoll\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003enew\u003c/span\u003e().\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n\n    \u003cspan class=\"synComment\"\u003e// Start listening for incoming connections\u003c/span\u003e\n    poll.\u003cspan class=\"synIdentifier\"\u003eregister\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003eserver, SERVER, \u003cspan class=\"synPreProc\"\u003eReady\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003ereadable\u003c/span\u003e(), \u003cspan class=\"synPreProc\"\u003ePollOpt\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eedge\u003c/span\u003e())\n        .\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n\n    \u003cspan class=\"synComment\"\u003e// Create storage for events\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e events \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eEvents\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003ewith_capacity\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e1024\u003c/span\u003e);\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e clients \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eClientsHolder\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003enew_from\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eToken\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e));\n\n    \u003cspan class=\"synStatement\"\u003eloop\u003c/span\u003e {\n        poll.\u003cspan class=\"synIdentifier\"\u003epoll\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e events, \u003cspan class=\"synConstant\"\u003eNone\u003c/span\u003e).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n\n        \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e event \u003cspan class=\"synStatement\"\u003ein\u003c/span\u003e events.\u003cspan class=\"synIdentifier\"\u003eiter\u003c/span\u003e() {\n            \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e event.\u003cspan class=\"synIdentifier\"\u003etoken\u003c/span\u003e() {\n                SERVER \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e {\n                    \u003cspan class=\"synComment\"\u003e// Accept and drop the socket immediately, this will close\u003c/span\u003e\n                    \u003cspan class=\"synComment\"\u003e// the socket and notify the client of the EOF.\u003c/span\u003e\n                    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e (stream, _) \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e server.\u003cspan class=\"synIdentifier\"\u003eaccept\u003c/span\u003e().\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n                    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e tok \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e clients.\u003cspan class=\"synIdentifier\"\u003enext_token\u003c/span\u003e();\n                    poll.\u003cspan class=\"synIdentifier\"\u003eregister\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003estream, tok, \u003cspan class=\"synPreProc\"\u003eReady\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003ereadable\u003c/span\u003e(), \u003cspan class=\"synPreProc\"\u003ePollOpt\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eedge\u003c/span\u003e()).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n                    clients.\u003cspan class=\"synIdentifier\"\u003eregister\u003c/span\u003e(tok, stream);\n                }\n                tok \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e {\n                    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e close \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003efalse\u003c/span\u003e;\n                    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eSome\u003c/span\u003e(\u003cspan class=\"synType\"\u003emut\u003c/span\u003e stream) \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e clients.\u003cspan class=\"synIdentifier\"\u003eget_mut\u003c/span\u003e(tok) {\n                        \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e buf \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e [\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; \u003cspan class=\"synConstant\"\u003e1024\u003c/span\u003e];\n                        \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e n \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e stream.\u003cspan class=\"synIdentifier\"\u003eread\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e buf).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n                        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e n \u003cspan class=\"synStatement\"\u003e==\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e {\n                            poll.\u003cspan class=\"synIdentifier\"\u003ederegister\u003c/span\u003e(stream).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n                            close \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003etrue\u003c/span\u003e;\n                        } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n                            stream.\u003cspan class=\"synIdentifier\"\u003ewrite\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003ebuf[\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e..n]).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n                        }\n                    }\n                    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e close {\n                        clients.\u003cspan class=\"synIdentifier\"\u003eremove\u003c/span\u003e(tok);\n                    }\n                }\n            }\n        }\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003e面倒だったので \u003ccode\u003eunwrap\u003c/code\u003e まみれですが。\u003c/p\u003e\n\n\u003ch2\u003eやったこと\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode\u003emio\u003c/code\u003e の全体の流れとしては，\u003ccode\u003ePoll\u003c/code\u003e 型の値がイベントを監視する役割を担います．\n\u003ccode\u003ePoll\u003c/code\u003e に監視対象を登録していき，\u003ccode\u003ePoll::poll\u003c/code\u003e でイベントの発火を待ちます．\n発火したイベント一覧が \u003ccode\u003eEvents\u003c/code\u003e 型の \u003ccode\u003eEvents::iter\u003c/code\u003e で取れるので，対応していけばよいです．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003emio\u003c/code\u003e では \u003ccode\u003eToken\u003c/code\u003e という型の値を使って監視対象を識別しています．\n監視対象には \u003ccode\u003eTcpListener\u003c/code\u003e ，\u003ccode\u003eTcpStream\u003c/code\u003e，\u003ccode\u003eSender\u003c/code\u003e，などなどいろんなものがあるので，統一的に扱うために \u003ccode\u003ePoll\u003c/code\u003e は \u003ccode\u003eToken\u003c/code\u003e だけを保持します．\n\u003ccode\u003eToken\u003c/code\u003e と監視対象の紐付けはユーザ側の責任でやってくれという感じみたいです．\u003c/p\u003e\n\n\u003cp\u003eecho サーバではクライアントの数は不特定なので，「空いている \u003ccode\u003eToken\u003c/code\u003e を探す」と「\u003ccode\u003eToken\u003c/code\u003e に対応するクライアント (\u003ccode\u003eTcpStream\u003c/code\u003e) を探す」がうまくできる必要があります．\nそこで，\u003ccode\u003eClientsHolder\u003c/code\u003e を定義しました．\nこいつが，空いている \u003ccode\u003eToken\u003c/code\u003e を返すのと \u003ccode\u003eToken\u003c/code\u003e をキーに \u003ccode\u003eTcpStream\u003c/code\u003e を返す仕事をします．\n\u003ccode\u003eremove\u003c/code\u003e されたらその \u003ccode\u003eToken\u003c/code\u003e は再利用します．\u003c/p\u003e\n\n\u003ch2\u003e気になるところ\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode\u003emio\u003c/code\u003e はファイルに対する抽象化は提供しない方針のようです．\n\u003ccode\u003eSTDIN\u003c/code\u003e / \u003ccode\u003eSTDOUT\u003c/code\u003e も同様です．\u003c/p\u003e\n\n\u003cp\u003eファイル IO もノン\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D6%A5%ED%A5%C3%A5%AD%A5%F3%A5%B0\"\u003eブロッキング\u003c/a\u003eにしたい場合はどうしたらいいんでしょう？よくわかっていない．\n\u003ccode\u003emio::unix\u003c/code\u003e 以下に \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UNIX\"\u003eUNIX\u003c/a\u003e 限定の拡張がおいてあって，\u003ccode\u003eEventedFd\u003c/code\u003e という file descriptor を扱う実装はあるので，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UNIX\"\u003eUNIX\u003c/a\u003e 限定なら力技でなんとかなるのかもしれない．\u003c/p\u003e\n\n\u003cp\u003eあと \u003ccode\u003emio\u003c/code\u003e は関係ないんですが，実装の部分で，\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e close \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003efalse\u003c/span\u003e;\n\u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eSome\u003c/span\u003e(\u003cspan class=\"synType\"\u003emut\u003c/span\u003e stream) \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e clients.\u003cspan class=\"synIdentifier\"\u003eget_mut\u003c/span\u003e(tok) {\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e buf \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e [\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; \u003cspan class=\"synConstant\"\u003e1024\u003c/span\u003e];\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e n \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e stream.\u003cspan class=\"synIdentifier\"\u003eread\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e buf).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e n \u003cspan class=\"synStatement\"\u003e==\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e {\n        poll.\u003cspan class=\"synIdentifier\"\u003ederegister\u003c/span\u003e(stream).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n        close \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003etrue\u003c/span\u003e;\n    } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n        stream.\u003cspan class=\"synIdentifier\"\u003ewrite\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003ebuf[\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e..n]).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n    }\n}\n\u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e close {\n    clients.\u003cspan class=\"synIdentifier\"\u003eremove\u003c/span\u003e(tok);\n}\n\u003c/pre\u003e\n\n\u003cp\u003eというのがあるんですが，これどうやったらスマートなんでしょう．\n\u003ccode\u003eclose = true\u003c/code\u003e としている部分で \u003ccode\u003eclients.remove(tok);\u003c/code\u003e をやるのが普通だと思うんですが，\u003ccode\u003eif let Some(mut stream) = clients.get_mut(tok) {\u003c/code\u003e のところで \u003ccode\u003eclients\u003c/code\u003e は borrow されているから mutable borrow はこれ以上作れないのです．\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eRust の非同期 IO ライブラリのなかでももっとも低レベルなレイヤーを担っている \u003ca href=\"https://github.com/carllerche/mio\"\u003emio\u003c/a\u003e を使ってecho サーバを書いた。\necho サーバばっかり書いているような気がするけど，echo サーバやっておくと簡単な割にライブラリの使い方とかがちゃんと分かる気がするので好きです。\u003c/p\u003e\n\n\u003ch3\u003eコード\u003c/h3\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003eextern\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ecrate\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003emio\u003c/span\u003e;\n\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003estd\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003eio\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003eprelude\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synType\"\u003e*\u003c/span\u003e;\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003estd\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003ecollections\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eHashMap;\n\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003emio\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synType\"\u003e*\u003c/span\u003e;\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003emio\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003etcp\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e{TcpListener, TcpStream};\n\n\u003cspan class=\"synPreProc\"\u003e#[derive(\u003c/span\u003e\u003cspan class=\"synType\"\u003eDebug\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e)]\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003estruct\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eClientsHolder\u003c/span\u003e {\n    table: HashMap\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eToken, TcpStream\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e,\n    free_token: \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eToken\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e,\n    next_max_token: Token,\n}\n\n\u003cspan class=\"synStatement\"\u003eimpl\u003c/span\u003e ClientsHolder {\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003enew_from\u003c/span\u003e(start_token: Token) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003eSelf\u003c/span\u003e {\n        ClientsHolder {\n            table: \u003cspan class=\"synPreProc\"\u003eHashMap\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003enew\u003c/span\u003e(),\n            free_token: \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003enew\u003c/span\u003e(),\n            next_max_token: start_token,\n        }\n    }\n\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003enext_token\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e Token {\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eSome\u003c/span\u003e(tok) \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.free_token.\u003cspan class=\"synIdentifier\"\u003epop\u003c/span\u003e() {\n            \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e tok;\n        }\n        \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e tok \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.next_max_token;\n        \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.next_max_token \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eToken\u003c/span\u003e(tok.\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e+\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e);\n        tok\n    }\n\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eregister\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e, tok: Token, client: TcpStream) {\n        \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.table.\u003cspan class=\"synIdentifier\"\u003einsert\u003c/span\u003e(tok, client);\n    }\n\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eget_mut\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e, tok: Token) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003eOption\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e TcpStream\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.table.\u003cspan class=\"synIdentifier\"\u003eget_mut\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003etok)\n    }\n\n    \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eremove\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e, tok: Token) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003eOption\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eTcpStream\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e result \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.table.\u003cspan class=\"synIdentifier\"\u003eremove\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003etok);\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e result.\u003cspan class=\"synIdentifier\"\u003eis_some\u003c/span\u003e() {\n            \u003cspan class=\"synConstant\"\u003eself\u003c/span\u003e.free_token.\u003cspan class=\"synIdentifier\"\u003epush\u003c/span\u003e(tok);\n        }\n        result\n    }\n}\n\n\u003cspan class=\"synComment\"\u003e// Setup some tokens to allow us to identify which event is\u003c/span\u003e\n\u003cspan class=\"synComment\"\u003e// for which socket.\u003c/span\u003e\n\u003cspan class=\"synType\"\u003econst\u003c/span\u003e SERVER: Token \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eToken\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e);\n\n\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003emain\u003c/span\u003e() {\n\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e addr \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;127.0.0.1:13265\u0026quot;\u003c/span\u003e.\u003cspan class=\"synIdentifier\"\u003eparse\u003c/span\u003e().\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n\n    \u003cspan class=\"synComment\"\u003e// Setup the server socket\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e server \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eTcpListener\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003ebind\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003eaddr).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n\n    \u003cspan class=\"synComment\"\u003e// Create an poll instance\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e poll \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003ePoll\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003enew\u003c/span\u003e().\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n\n    \u003cspan class=\"synComment\"\u003e// Start listening for incoming connections\u003c/span\u003e\n    poll.\u003cspan class=\"synIdentifier\"\u003eregister\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003eserver, SERVER, \u003cspan class=\"synPreProc\"\u003eReady\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003ereadable\u003c/span\u003e(), \u003cspan class=\"synPreProc\"\u003ePollOpt\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eedge\u003c/span\u003e())\n        .\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n\n    \u003cspan class=\"synComment\"\u003e// Create storage for events\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e events \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eEvents\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003ewith_capacity\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e1024\u003c/span\u003e);\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e clients \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eClientsHolder\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003enew_from\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eToken\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e));\n\n    \u003cspan class=\"synStatement\"\u003eloop\u003c/span\u003e {\n        poll.\u003cspan class=\"synIdentifier\"\u003epoll\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e events, \u003cspan class=\"synConstant\"\u003eNone\u003c/span\u003e).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n\n        \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e event \u003cspan class=\"synStatement\"\u003ein\u003c/span\u003e events.\u003cspan class=\"synIdentifier\"\u003eiter\u003c/span\u003e() {\n            \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e event.\u003cspan class=\"synIdentifier\"\u003etoken\u003c/span\u003e() {\n                SERVER \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e {\n                    \u003cspan class=\"synComment\"\u003e// Accept and drop the socket immediately, this will close\u003c/span\u003e\n                    \u003cspan class=\"synComment\"\u003e// the socket and notify the client of the EOF.\u003c/span\u003e\n                    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e (stream, _) \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e server.\u003cspan class=\"synIdentifier\"\u003eaccept\u003c/span\u003e().\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n                    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e tok \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e clients.\u003cspan class=\"synIdentifier\"\u003enext_token\u003c/span\u003e();\n                    poll.\u003cspan class=\"synIdentifier\"\u003eregister\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003estream, tok, \u003cspan class=\"synPreProc\"\u003eReady\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003ereadable\u003c/span\u003e(), \u003cspan class=\"synPreProc\"\u003ePollOpt\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eedge\u003c/span\u003e()).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n                    clients.\u003cspan class=\"synIdentifier\"\u003eregister\u003c/span\u003e(tok, stream);\n                }\n                tok \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e {\n                    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e close \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003efalse\u003c/span\u003e;\n                    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eSome\u003c/span\u003e(\u003cspan class=\"synType\"\u003emut\u003c/span\u003e stream) \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e clients.\u003cspan class=\"synIdentifier\"\u003eget_mut\u003c/span\u003e(tok) {\n                        \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e buf \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e [\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; \u003cspan class=\"synConstant\"\u003e1024\u003c/span\u003e];\n                        \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e n \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e stream.\u003cspan class=\"synIdentifier\"\u003eread\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e buf).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n                        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e n \u003cspan class=\"synStatement\"\u003e==\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e {\n                            poll.\u003cspan class=\"synIdentifier\"\u003ederegister\u003c/span\u003e(stream).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n                            close \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003etrue\u003c/span\u003e;\n                        } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n                            stream.\u003cspan class=\"synIdentifier\"\u003ewrite\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003ebuf[\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e..n]).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n                        }\n                    }\n                    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e close {\n                        clients.\u003cspan class=\"synIdentifier\"\u003eremove\u003c/span\u003e(tok);\n                    }\n                }\n            }\n        }\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003e面倒だったので \u003ccode\u003eunwrap\u003c/code\u003e まみれですが。\u003c/p\u003e\n\n\u003ch2\u003eやったこと\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode\u003emio\u003c/code\u003e の全体の流れとしては，\u003ccode\u003ePoll\u003c/code\u003e 型の値がイベントを監視する役割を担います．\n\u003ccode\u003ePoll\u003c/code\u003e に監視対象を登録していき，\u003ccode\u003ePoll::poll\u003c/code\u003e でイベントの発火を待ちます．\n発火したイベント一覧が \u003ccode\u003eEvents\u003c/code\u003e 型の \u003ccode\u003eEvents::iter\u003c/code\u003e で取れるので，対応していけばよいです．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003emio\u003c/code\u003e では \u003ccode\u003eToken\u003c/code\u003e という型の値を使って監視対象を識別しています．\n監視対象には \u003ccode\u003eTcpListener\u003c/code\u003e ，\u003ccode\u003eTcpStream\u003c/code\u003e，\u003ccode\u003eSender\u003c/code\u003e，などなどいろんなものがあるので，統一的に扱うために \u003ccode\u003ePoll\u003c/code\u003e は \u003ccode\u003eToken\u003c/code\u003e だけを保持します．\n\u003ccode\u003eToken\u003c/code\u003e と監視対象の紐付けはユーザ側の責任でやってくれという感じみたいです．\u003c/p\u003e\n\n\u003cp\u003eecho サーバではクライアントの数は不特定なので，「空いている \u003ccode\u003eToken\u003c/code\u003e を探す」と「\u003ccode\u003eToken\u003c/code\u003e に対応するクライアント (\u003ccode\u003eTcpStream\u003c/code\u003e) を探す」がうまくできる必要があります．\nそこで，\u003ccode\u003eClientsHolder\u003c/code\u003e を定義しました．\nこいつが，空いている \u003ccode\u003eToken\u003c/code\u003e を返すのと \u003ccode\u003eToken\u003c/code\u003e をキーに \u003ccode\u003eTcpStream\u003c/code\u003e を返す仕事をします．\n\u003ccode\u003eremove\u003c/code\u003e されたらその \u003ccode\u003eToken\u003c/code\u003e は再利用します．\u003c/p\u003e\n\n\u003ch2\u003e気になるところ\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode\u003emio\u003c/code\u003e はファイルに対する抽象化は提供しない方針のようです．\n\u003ccode\u003eSTDIN\u003c/code\u003e / \u003ccode\u003eSTDOUT\u003c/code\u003e も同様です．\u003c/p\u003e\n\n\u003cp\u003eファイル IO もノン\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D6%A5%ED%A5%C3%A5%AD%A5%F3%A5%B0\"\u003eブロッキング\u003c/a\u003eにしたい場合はどうしたらいいんでしょう？よくわかっていない．\n\u003ccode\u003emio::unix\u003c/code\u003e 以下に \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UNIX\"\u003eUNIX\u003c/a\u003e 限定の拡張がおいてあって，\u003ccode\u003eEventedFd\u003c/code\u003e という file descriptor を扱う実装はあるので，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UNIX\"\u003eUNIX\u003c/a\u003e 限定なら力技でなんとかなるのかもしれない．\u003c/p\u003e\n\n\u003cp\u003eあと \u003ccode\u003emio\u003c/code\u003e は関係ないんですが，実装の部分で，\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e close \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003efalse\u003c/span\u003e;\n\u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eSome\u003c/span\u003e(\u003cspan class=\"synType\"\u003emut\u003c/span\u003e stream) \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e clients.\u003cspan class=\"synIdentifier\"\u003eget_mut\u003c/span\u003e(tok) {\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synType\"\u003emut\u003c/span\u003e buf \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e [\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; \u003cspan class=\"synConstant\"\u003e1024\u003c/span\u003e];\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e n \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e stream.\u003cspan class=\"synIdentifier\"\u003eread\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;mut\u003c/span\u003e buf).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e n \u003cspan class=\"synStatement\"\u003e==\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e {\n        poll.\u003cspan class=\"synIdentifier\"\u003ederegister\u003c/span\u003e(stream).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n        close \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synConstant\"\u003etrue\u003c/span\u003e;\n    } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n        stream.\u003cspan class=\"synIdentifier\"\u003ewrite\u003c/span\u003e(\u003cspan class=\"synType\"\u003e\u0026amp;\u003c/span\u003ebuf[\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e..n]).\u003cspan class=\"synIdentifier\"\u003eunwrap\u003c/span\u003e();\n    }\n}\n\u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e close {\n    clients.\u003cspan class=\"synIdentifier\"\u003eremove\u003c/span\u003e(tok);\n}\n\u003c/pre\u003e\n\n\u003cp\u003eというのがあるんですが，これどうやったらスマートなんでしょう．\n\u003ccode\u003eclose = true\u003c/code\u003e としている部分で \u003ccode\u003eclients.remove(tok);\u003c/code\u003e をやるのが普通だと思うんですが，\u003ccode\u003eif let Some(mut stream) = clients.get_mut(tok) {\u003c/code\u003e のところで \u003ccode\u003eclients\u003c/code\u003e は borrow されているから mutable borrow はこれ以上作れないのです．\u003c/p\u003e\n\n---\n\n---\n","slug":"mio_で_echo_サーバメモ","title":"mio で echo サーバメモ","timestamp":1483769695000,"tags":[]},{"rawMarkdown":"---\ntitle: \"NCurses の Crystal binding を作った\"\ndate: 2016-12-08T13:33:17.000Z\ntags: []\n---\n\n\u003cp\u003eこの記事は、 Crystal Advent Calendar 2016 の８日目の記事です。\n\u003ciframe src=\"//hatenablog-parts.com/embed?url=http%3A%2F%2Fqiita.com%2Fadvent-calendar%2F2016%2Fcrystal\" title=\"Crystal Advent Calendar 2016 - Qiita\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"http://qiita.com/advent-calendar/2016/crystal\"\u003eqiita.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003encurses という \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CUI\"\u003eCUI\u003c/a\u003e を作るためにスクリーンやキー入力を扱う有名なライブラリの Crystal binding を作りました。\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"//hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fncurses.cr\" title=\"agatan/ncurses.cr\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://github.com/agatan/ncurses.cr\"\u003egithub.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003eほとんど C の ncurses と同じ感じで使えるようになっていると思います．\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\"\u003eRuby\u003c/a\u003e や \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\"\u003ePython\u003c/a\u003e の \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/curses\"\u003ecurses\u003c/a\u003e ライブラリを参考にしつつ，なるべく使用感がかわらないようにしています．\u003c/p\u003e\n\n\u003ch2\u003eexamples\u003c/h2\u003e\n\n\u003cpre class=\"code lang-crystal\" data-lang=\"crystal\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003erequire\u003c/span\u003e “ncurses”\n\n\u003cspan class=\"synType\"\u003eNCurses\u003c/span\u003e.open \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n  \u003cspan class=\"synType\"\u003eNCurses\u003c/span\u003e.cbreak\n  \u003cspan class=\"synType\"\u003eNCurses\u003c/span\u003e.noecho\n  \u003cspan class=\"synType\"\u003eNCurses\u003c/span\u003e.move(\u003cspan class=\"synConstant\"\u003ex\u003c/span\u003e: \u003cspan class=\"synConstant\"\u003e30\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003ey\u003c/span\u003e: \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e)\n  \u003cspan class=\"synType\"\u003eNCurses\u003c/span\u003e.addstr(“\u003cspan class=\"synType\"\u003eHello\u003c/span\u003e, world!”)\n  \u003cspan class=\"synType\"\u003eNCurses\u003c/span\u003e.refresh\n\n  \u003cspan class=\"synType\"\u003eNCurses\u003c/span\u003e.notimeout(\u003cspan class=\"synConstant\"\u003etrue\u003c/span\u003e)\n  \u003cspan class=\"synType\"\u003eNCurses\u003c/span\u003e.getch\n\u003cspan class=\"synStatement\"\u003eend\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eNCurses.addstr\u003c/code\u003e とか \u003ccode\u003eNCurses.move\u003c/code\u003e とかは ncurses で言う \u003ccode\u003eaddstr\u003c/code\u003e や \u003ccode\u003emove\u003c/code\u003e に当たる関数で，\u003ccode\u003estdscr\u003c/code\u003e に対して \u003ccode\u003ewaddstr\u003c/code\u003e とか \u003ccode\u003ewmove\u003c/code\u003e するやつです．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ew = NCurses::Window.new(height: height, width: width)\u003c/code\u003e とすることで subwindow が作れます．\n\u003ccode\u003ew.addstr\u003c/code\u003e や \u003ccode\u003ew.move\u003c/code\u003e という形で \u003ccode\u003ew\u003c/code\u003e prefix な関数たちが呼べるようになっています．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003epad\u003c/code\u003e や \u003ccode\u003eattron\u003c/code\u003e / \u003ccode\u003eattroff\u003c/code\u003e などなども使えます．\u003c/p\u003e\n\n\u003cp\u003e詳細な例は \u003ccode\u003eexample/\u003c/code\u003e 以下のにおいてあります\u003c/p\u003e\n\n\u003ch2\u003eなぜ作ったのか\u003c/h2\u003e\n\n\u003cp\u003e実は ncurses bindings for Crystal はすでにあります．(\u003ca href=\"https://github.com/jreinert/ncurses-crystal\"\u003ehttps://github.com/jreinert/ncurses-crystal\u003c/a\u003e)\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/curses\"\u003ecurses\u003c/a\u003e が Crystal の標準ライブラリから外されることが決まったときの \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CHANGELOG\"\u003eCHANGELOG\u003c/a\u003e を見ると，今後はそっちを使ってねと書いてあったりします．\u003c/p\u003e\n\n\u003cp\u003eじゃあなんでわざわざ別で作ったのかという話ですが，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e が足りない \u0026amp; 提供する \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e の形を変えたいと思ったからです．\u003c/p\u003e\n\n\u003cp\u003e単純に bind されている \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e が少なくてやりたいことができなかったので，最初は追加して PR を出そうと思っていたのですが，すでに提供されている \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e が割と高級になっていて 1 : 1 で C \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e と対応していない感じでした．\n個人的には C library の wrapper にはなるべく薄くなっていてもらって基本的な \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e は覚え直さないでも使えるようになっていてほしいというふうに思ったので，C \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e と 1 : 1 で対応した形の \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e を提供する wrapper を作ってみようという経緯で新しく作ることにしました．\u003c/p\u003e\n\n\u003ch2\u003eおまけ\u003c/h2\u003e\n\n\u003cp\u003eC bindings を書くときに，wrapper \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e として \u003ccode\u003eLibC::Int\u003c/code\u003e が登場しちゃうのがなんとなく嫌で，\u003ccode\u003eLibC::Int\u003c/code\u003e を C が要求してくる関数を呼ぶ wrapper 関数には型指定をあえてしないという選択をしたんですがどうなんでしょう．\u003c/p\u003e\n\n\u003cpre class=\"code lang-crystal\" data-lang=\"crystal\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003elib\u003c/span\u003e \u003cspan class=\"synType\"\u003eLibNCurses\u003c/span\u003e\n  \u003cspan class=\"synPreProc\"\u003efun\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003ewmove\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003ew\u003c/span\u003e : \u003cspan class=\"synType\"\u003eWindow\u003c/span\u003e, y : \u003cspan class=\"synType\"\u003eLibC\u003c/span\u003e::\u003cspan class=\"synType\"\u003eInt\u003c/span\u003e, x : \u003cspan class=\"synType\"\u003eLibC\u003c/span\u003e::\u003cspan class=\"synType\"\u003eInt\u003c/span\u003e) : \u003cspan class=\"synType\"\u003eResult\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003eend\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cpre class=\"code lang-crystal\" data-lang=\"crystal\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003eclass\u003c/span\u003e \u003cspan class=\"synType\"\u003eWindow\u003c/span\u003e\n  \u003cspan class=\"synPreProc\"\u003edef\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003emove\u003c/span\u003e(y, x)\n     \u003cspan class=\"synType\"\u003eLibNCurses\u003c/span\u003e.wmove(\u003cspan class=\"synIdentifier\"\u003e@win\u003c/span\u003e, y, x)\n  \u003cspan class=\"synPreProc\"\u003eend\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003eend\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eみたいな感じです．（多少簡略化しています）\u003c/p\u003e\n\n\u003cp\u003eこれどうなんですかね．なるべく外に見せる \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e には型を明記するようにしたかったのですが，\u003ccode\u003eLibC:Int\u003c/code\u003e 系は環境によって異なるのでそういうわけにも行かず…\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ey : LibC::Int, x : LibC::Int\u003c/code\u003e とかは別に良いんですが，ncurses は文字と属性をくっつけた \u003ccode\u003echtype\u003c/code\u003e なる型を持っていてこれが結構厄介というか混乱を招くのではと思っています．\n\u003ccode\u003echtype\u003c/code\u003e は \u003ccode\u003echar\u003c/code\u003e ではなく \u003ccode\u003eunsigned int\u003c/code\u003e で，文字と属性を bitor でくっつけたものになっています．\u003ccode\u003eaddch\u003c/code\u003e のように \u003ccode\u003echar\u003c/code\u003e をとることを連想させる関数の引数が実は \u003ccode\u003echtype = unsigned int\u003c/code\u003e でしかも Crystal の文字型 \u003ccode\u003eChar\u003c/code\u003e は 32bit なのでものすごく混乱します…\u003c/p\u003e\n\n\u003cp\u003eC は型変換を勝手にやってくれるので，\u003ccode\u003eunsigned int\u003c/code\u003e を返す関数から受け取った値を \u003ccode\u003eshort\u003c/code\u003e を受け取る関数に渡すみたいなことをよくやっていて，Crystal のような型変換を暗黙にやらない言語から使おうとすると難しいんだなぁと思いました．\nなにか良い方法があればぜひ知りたいです．\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eこの記事は、 Crystal Advent Calendar 2016 の８日目の記事です。\n\u003ciframe src=\"//hatenablog-parts.com/embed?url=http%3A%2F%2Fqiita.com%2Fadvent-calendar%2F2016%2Fcrystal\" title=\"Crystal Advent Calendar 2016 - Qiita\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"http://qiita.com/advent-calendar/2016/crystal\"\u003eqiita.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003encurses という \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CUI\"\u003eCUI\u003c/a\u003e を作るためにスクリーンやキー入力を扱う有名なライブラリの Crystal binding を作りました。\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"//hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fncurses.cr\" title=\"agatan/ncurses.cr\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://github.com/agatan/ncurses.cr\"\u003egithub.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003eほとんど C の ncurses と同じ感じで使えるようになっていると思います．\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\"\u003eRuby\u003c/a\u003e や \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\"\u003ePython\u003c/a\u003e の \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/curses\"\u003ecurses\u003c/a\u003e ライブラリを参考にしつつ，なるべく使用感がかわらないようにしています．\u003c/p\u003e\n\n\u003ch2\u003eexamples\u003c/h2\u003e\n\n\u003cpre class=\"code lang-crystal\" data-lang=\"crystal\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003erequire\u003c/span\u003e “ncurses”\n\n\u003cspan class=\"synType\"\u003eNCurses\u003c/span\u003e.open \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n  \u003cspan class=\"synType\"\u003eNCurses\u003c/span\u003e.cbreak\n  \u003cspan class=\"synType\"\u003eNCurses\u003c/span\u003e.noecho\n  \u003cspan class=\"synType\"\u003eNCurses\u003c/span\u003e.move(\u003cspan class=\"synConstant\"\u003ex\u003c/span\u003e: \u003cspan class=\"synConstant\"\u003e30\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003ey\u003c/span\u003e: \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e)\n  \u003cspan class=\"synType\"\u003eNCurses\u003c/span\u003e.addstr(“\u003cspan class=\"synType\"\u003eHello\u003c/span\u003e, world!”)\n  \u003cspan class=\"synType\"\u003eNCurses\u003c/span\u003e.refresh\n\n  \u003cspan class=\"synType\"\u003eNCurses\u003c/span\u003e.notimeout(\u003cspan class=\"synConstant\"\u003etrue\u003c/span\u003e)\n  \u003cspan class=\"synType\"\u003eNCurses\u003c/span\u003e.getch\n\u003cspan class=\"synStatement\"\u003eend\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eNCurses.addstr\u003c/code\u003e とか \u003ccode\u003eNCurses.move\u003c/code\u003e とかは ncurses で言う \u003ccode\u003eaddstr\u003c/code\u003e や \u003ccode\u003emove\u003c/code\u003e に当たる関数で，\u003ccode\u003estdscr\u003c/code\u003e に対して \u003ccode\u003ewaddstr\u003c/code\u003e とか \u003ccode\u003ewmove\u003c/code\u003e するやつです．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ew = NCurses::Window.new(height: height, width: width)\u003c/code\u003e とすることで subwindow が作れます．\n\u003ccode\u003ew.addstr\u003c/code\u003e や \u003ccode\u003ew.move\u003c/code\u003e という形で \u003ccode\u003ew\u003c/code\u003e prefix な関数たちが呼べるようになっています．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003epad\u003c/code\u003e や \u003ccode\u003eattron\u003c/code\u003e / \u003ccode\u003eattroff\u003c/code\u003e などなども使えます．\u003c/p\u003e\n\n\u003cp\u003e詳細な例は \u003ccode\u003eexample/\u003c/code\u003e 以下のにおいてあります\u003c/p\u003e\n\n\u003ch2\u003eなぜ作ったのか\u003c/h2\u003e\n\n\u003cp\u003e実は ncurses bindings for Crystal はすでにあります．(\u003ca href=\"https://github.com/jreinert/ncurses-crystal\"\u003ehttps://github.com/jreinert/ncurses-crystal\u003c/a\u003e)\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/curses\"\u003ecurses\u003c/a\u003e が Crystal の標準ライブラリから外されることが決まったときの \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CHANGELOG\"\u003eCHANGELOG\u003c/a\u003e を見ると，今後はそっちを使ってねと書いてあったりします．\u003c/p\u003e\n\n\u003cp\u003eじゃあなんでわざわざ別で作ったのかという話ですが，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e が足りない \u0026amp; 提供する \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e の形を変えたいと思ったからです．\u003c/p\u003e\n\n\u003cp\u003e単純に bind されている \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e が少なくてやりたいことができなかったので，最初は追加して PR を出そうと思っていたのですが，すでに提供されている \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e が割と高級になっていて 1 : 1 で C \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e と対応していない感じでした．\n個人的には C library の wrapper にはなるべく薄くなっていてもらって基本的な \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e は覚え直さないでも使えるようになっていてほしいというふうに思ったので，C \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e と 1 : 1 で対応した形の \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e を提供する wrapper を作ってみようという経緯で新しく作ることにしました．\u003c/p\u003e\n\n\u003ch2\u003eおまけ\u003c/h2\u003e\n\n\u003cp\u003eC bindings を書くときに，wrapper \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e として \u003ccode\u003eLibC::Int\u003c/code\u003e が登場しちゃうのがなんとなく嫌で，\u003ccode\u003eLibC::Int\u003c/code\u003e を C が要求してくる関数を呼ぶ wrapper 関数には型指定をあえてしないという選択をしたんですがどうなんでしょう．\u003c/p\u003e\n\n\u003cpre class=\"code lang-crystal\" data-lang=\"crystal\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003elib\u003c/span\u003e \u003cspan class=\"synType\"\u003eLibNCurses\u003c/span\u003e\n  \u003cspan class=\"synPreProc\"\u003efun\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003ewmove\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003ew\u003c/span\u003e : \u003cspan class=\"synType\"\u003eWindow\u003c/span\u003e, y : \u003cspan class=\"synType\"\u003eLibC\u003c/span\u003e::\u003cspan class=\"synType\"\u003eInt\u003c/span\u003e, x : \u003cspan class=\"synType\"\u003eLibC\u003c/span\u003e::\u003cspan class=\"synType\"\u003eInt\u003c/span\u003e) : \u003cspan class=\"synType\"\u003eResult\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003eend\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cpre class=\"code lang-crystal\" data-lang=\"crystal\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003eclass\u003c/span\u003e \u003cspan class=\"synType\"\u003eWindow\u003c/span\u003e\n  \u003cspan class=\"synPreProc\"\u003edef\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003emove\u003c/span\u003e(y, x)\n     \u003cspan class=\"synType\"\u003eLibNCurses\u003c/span\u003e.wmove(\u003cspan class=\"synIdentifier\"\u003e@win\u003c/span\u003e, y, x)\n  \u003cspan class=\"synPreProc\"\u003eend\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003eend\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eみたいな感じです．（多少簡略化しています）\u003c/p\u003e\n\n\u003cp\u003eこれどうなんですかね．なるべく外に見せる \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003e には型を明記するようにしたかったのですが，\u003ccode\u003eLibC:Int\u003c/code\u003e 系は環境によって異なるのでそういうわけにも行かず…\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ey : LibC::Int, x : LibC::Int\u003c/code\u003e とかは別に良いんですが，ncurses は文字と属性をくっつけた \u003ccode\u003echtype\u003c/code\u003e なる型を持っていてこれが結構厄介というか混乱を招くのではと思っています．\n\u003ccode\u003echtype\u003c/code\u003e は \u003ccode\u003echar\u003c/code\u003e ではなく \u003ccode\u003eunsigned int\u003c/code\u003e で，文字と属性を bitor でくっつけたものになっています．\u003ccode\u003eaddch\u003c/code\u003e のように \u003ccode\u003echar\u003c/code\u003e をとることを連想させる関数の引数が実は \u003ccode\u003echtype = unsigned int\u003c/code\u003e でしかも Crystal の文字型 \u003ccode\u003eChar\u003c/code\u003e は 32bit なのでものすごく混乱します…\u003c/p\u003e\n\n\u003cp\u003eC は型変換を勝手にやってくれるので，\u003ccode\u003eunsigned int\u003c/code\u003e を返す関数から受け取った値を \u003ccode\u003eshort\u003c/code\u003e を受け取る関数に渡すみたいなことをよくやっていて，Crystal のような型変換を暗黙にやらない言語から使おうとすると難しいんだなぁと思いました．\nなにか良い方法があればぜひ知りたいです．\u003c/p\u003e\n\n---\n\n---\n","slug":"NCurses_の_Crystal_binding_を作った","title":"NCurses の Crystal binding を作った","timestamp":1481203997000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Rust で Box に包まれた構造体の所有権分解\"\ndate: 2016-12-04T07:45:12.000Z\ntags: []\n---\n\n\u003cp\u003eちょっとはまったのでメモ\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003estruct\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eA\u003c/span\u003e {\n    foo: \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei32\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e,\n    bar: \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e,\n}\n\u003c/pre\u003e\n\n\u003cp\u003eこんな構造体があったとする。\n普通、\u003ccode\u003eA\u003c/code\u003e の所有権を分解して \u003ccode\u003efoo\u003c/code\u003e と \u003ccode\u003ebar\u003c/code\u003e にしたいときは\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003exxx\u003c/span\u003e(x: A) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e (\u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei32\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e, \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) {\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e A { foo, bar } \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e x;\n    (foo, bar)\n}\n\u003c/pre\u003e\n\n\u003cp\u003eとやれば良い（この例だともっと簡単に書ける気もするけど）\u003c/p\u003e\n\n\u003cp\u003e一方、\u003ccode\u003eBox\u0026lt;A\u0026gt;\u003c/code\u003e から \u003ccode\u003efoo\u003c/code\u003e と \u003ccode\u003ebar\u003c/code\u003e に分解したい場合は話が変わってくる。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003efn error1(x: Box\u0026lt;A\u0026gt;) -\u0026gt; (Vec\u0026lt;i32\u0026gt;, Vec\u0026lt;bool\u0026gt;) {\n    (x.foo, x.bar)\n}\n\nfn error2(x: Box\u0026lt;A\u0026gt;) -\u0026gt; (Vec\u0026lt;i32\u0026gt;, Vec\u0026lt;bool\u0026gt;) {\n    let A { foo, bar } = *x;\n    (foo, bar)\n}\u003c/pre\u003e\n\n\u003cp\u003eこれらは両方共\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eできない。\n人間から見ると，\u003ccode\u003eBox\u0026lt;A\u0026gt;\u003c/code\u003e は \u003ccode\u003eA\u003c/code\u003e の所有権を持っているのだから、\u003ccode\u003eA\u003c/code\u003e -\u003e \u003ccode\u003efoo/bar\u003c/code\u003e に分解できるなら \u003ccode\u003eBox\u0026lt;A\u0026gt;\u003c/code\u003e も同様にできる気がする。\u003c/p\u003e\n\n\u003cp\u003e実際にはこのようにすると\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eが通る。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003efn success(x: Box\u0026lt;A\u0026gt;) -\u0026gt; (Vec\u0026lt;i32\u0026gt;, Vec\u0026lt;bool\u0026gt;) {\n    let x = *x;\n    let A { foo, bar } = x;\n    (foo, bar)\n}\u003c/pre\u003e\n\n\u003cp\u003eうーん、エラーになるケースだと \u003ccode\u003eDeref\u003c/code\u003e トレイトの機能を経由している感じになるのかな？\n\u003ccode\u003eDeref\u003c/code\u003e 経由で \u003ccode\u003efoo\u003c/code\u003e の所有権をとるとその時点で \u003ccode\u003eBox\u0026lt;A\u0026gt;\u003c/code\u003e の所有権は奪われちゃうから \u003ccode\u003ebar\u003c/code\u003e の所有権が取れないということなのだと想像した。\n\u003ccode\u003esuccess\u003c/code\u003e のようなコードが突然出てきたら混乱しそうだ。\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eちょっとはまったのでメモ\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003estruct\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eA\u003c/span\u003e {\n    foo: \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei32\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e,\n    bar: \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e,\n}\n\u003c/pre\u003e\n\n\u003cp\u003eこんな構造体があったとする。\n普通、\u003ccode\u003eA\u003c/code\u003e の所有権を分解して \u003ccode\u003efoo\u003c/code\u003e と \u003ccode\u003ebar\u003c/code\u003e にしたいときは\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003exxx\u003c/span\u003e(x: A) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e (\u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei32\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e, \u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) {\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e A { foo, bar } \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e x;\n    (foo, bar)\n}\n\u003c/pre\u003e\n\n\u003cp\u003eとやれば良い（この例だともっと簡単に書ける気もするけど）\u003c/p\u003e\n\n\u003cp\u003e一方、\u003ccode\u003eBox\u0026lt;A\u0026gt;\u003c/code\u003e から \u003ccode\u003efoo\u003c/code\u003e と \u003ccode\u003ebar\u003c/code\u003e に分解したい場合は話が変わってくる。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003efn error1(x: Box\u0026lt;A\u0026gt;) -\u0026gt; (Vec\u0026lt;i32\u0026gt;, Vec\u0026lt;bool\u0026gt;) {\n    (x.foo, x.bar)\n}\n\nfn error2(x: Box\u0026lt;A\u0026gt;) -\u0026gt; (Vec\u0026lt;i32\u0026gt;, Vec\u0026lt;bool\u0026gt;) {\n    let A { foo, bar } = *x;\n    (foo, bar)\n}\u003c/pre\u003e\n\n\u003cp\u003eこれらは両方共\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eできない。\n人間から見ると，\u003ccode\u003eBox\u0026lt;A\u0026gt;\u003c/code\u003e は \u003ccode\u003eA\u003c/code\u003e の所有権を持っているのだから、\u003ccode\u003eA\u003c/code\u003e -\u003e \u003ccode\u003efoo/bar\u003c/code\u003e に分解できるなら \u003ccode\u003eBox\u0026lt;A\u0026gt;\u003c/code\u003e も同様にできる気がする。\u003c/p\u003e\n\n\u003cp\u003e実際にはこのようにすると\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eが通る。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003efn success(x: Box\u0026lt;A\u0026gt;) -\u0026gt; (Vec\u0026lt;i32\u0026gt;, Vec\u0026lt;bool\u0026gt;) {\n    let x = *x;\n    let A { foo, bar } = x;\n    (foo, bar)\n}\u003c/pre\u003e\n\n\u003cp\u003eうーん、エラーになるケースだと \u003ccode\u003eDeref\u003c/code\u003e トレイトの機能を経由している感じになるのかな？\n\u003ccode\u003eDeref\u003c/code\u003e 経由で \u003ccode\u003efoo\u003c/code\u003e の所有権をとるとその時点で \u003ccode\u003eBox\u0026lt;A\u0026gt;\u003c/code\u003e の所有権は奪われちゃうから \u003ccode\u003ebar\u003c/code\u003e の所有権が取れないということなのだと想像した。\n\u003ccode\u003esuccess\u003c/code\u003e のようなコードが突然出てきたら混乱しそうだ。\u003c/p\u003e\n\n---\n\n---\n","slug":"Rust_で_Box_に包まれた構造体の所有権分解","title":"Rust で Box に包まれた構造体の所有権分解","timestamp":1480837512000,"tags":[]},{"rawMarkdown":"---\ntitle: \"日本語の改行を適当にいい感じにするツールを作りました\"\ndate: 2016-10-29T04:24:49.000Z\ntags: []\n---\n\n\u003cp\u003e必要に迫られて、HTML ページ内の改行位置をいい感じにするツールを作ってみました。\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"//hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fjapawrap\" title=\"agatan/japawrap\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://github.com/agatan/japawrap\"\u003egithub.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003eHTMLに長文を書くと、親 DOM のサイズの制約上、適宜改行がぶちこまれます。\nしかし、改行位置は文節を考慮などせずにごりっと挿入されるので、多くの問題が生じることが報告されています。\n最も有名な問題として、今すぐダウンロー\u003cbr\u003e\nド問題が挙げられます。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ejapawrap\u003c/code\u003e を使うと、それっぽく日本語を解釈して \u003ccode\u003e\u0026lt;span\u0026gt;\u003c/code\u003e でくくるみたいなことができます。\u003ccode\u003einline-block\u003c/code\u003e を適用すれば改行がそれっぽく入るようにできます。\u003c/p\u003e\n\n\u003ch2\u003eInstall\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode\u003ego get github.com/agatan/japawrap/...\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eで \u003ccode\u003ejapawrap\u003c/code\u003e コマンドが使えるようになります。\u003c/p\u003e\n\n\u003ch2\u003eUsage\u003c/h2\u003e\n\n\u003ch3\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLI\"\u003eCLI\u003c/a\u003e\u003c/h3\u003e\n\n\u003cp\u003eファイル名を指定するか標準入力から流し込みます。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e$ echo \u0026#34;今日も元気です\u0026#34; | japawrap\n\u0026lt;span class=\u0026#34;wordwrap\u0026#34;\u0026gt;今日も\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;wordwrap\u0026#34;\u0026gt;元気です\u0026lt;/span\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003eこのように適宜いい感じに wrap してくれます。\u003c/p\u003e\n\n\u003cp\u003eオプションとして \u003ccode\u003e-open string\u003c/code\u003e と \u003ccode\u003e-close string\u003c/code\u003e をサポートしているので、\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e$ echo \u0026#34;今日も元気です\u0026#34; | japawrap -open \u0026#39;\u0026lt;span style=\u0026#34;display: inline-block;\u0026#34;\u0026gt;\u0026#39; -close \u0026#34;\u0026lt;/span\u0026gt;\u0026#34; \n\u0026lt;span style=\u0026#34;display: inline-block;\u0026#34;\u0026gt;今日も\u0026lt;/span\u0026gt;\u0026lt;span style=\u0026#34;display: inline-block;\u0026#34;\u0026gt;元気です\u0026lt;/span\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003eみたいなことができます。\u003c/p\u003e\n\n\u003ch3\u003eLibrary\u003c/h3\u003e\n\n\u003cp\u003e一応 \u003ccode\u003ejapawrap\u003c/code\u003e はライブラリとしても使用できるようになっています。\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003ew := japawrap.New(open, \u003cspan class=\"synStatement\"\u003eclose\u003c/span\u003e)\ns := \u003cspan class=\"synConstant\"\u003e\u0026quot;今日も元気です\u0026quot;\u003c/span\u003e\nfmt.Println(\u003cspan class=\"synConstant\"\u003e\u0026quot;%s =\u0026gt; %s\u0026quot;\u003c/span\u003e, s, w.Do(s))\n\u003c/pre\u003e\n\n\u003cp\u003eこれだけです。\u003c/p\u003e\n\n\u003ch2\u003eExample\u003c/h2\u003e\n\n\u003cp\u003eでは実際に使った結果を下に記したいと思います。\n文章は、上の方に自分で書いた文章をそのまま使います。\u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003ch4\u003ebefore\u003c/h4\u003e\n\n\u003cp\u003eHTMLに長文を書くと、親DOM のサイズの制約上、適宜改行がぶちこまれます。\nしかし、改行位置は文節を考慮などせずにごりっと挿入されるので、多くの問題が生じることが報告されています。\n最も有名な問題として、今すぐダウンロード問題が挙げられます。\u003c/p\u003e\n\n\u003ch4\u003eafter\u003c/h4\u003e\n\n\u003cp\u003e\u003cspan style=\"display: inline-block;\"\u003eHTMLに\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e長文を\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e書くと、\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e親 \u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003eDOM の\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003eサイズの\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e制約上、\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e適宜改行が\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003eぶちこまれます。\u003c/span\u003e\n\u003cspan style=\"display: inline-block;\"\u003eしかし、\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e改行位置は\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e文節を\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e考慮など\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003eせず\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003eにごりっと\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e挿入されるので、\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e多くの\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e問題が\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e生じる\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003eことが\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e報告されて\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003eいます。\u003c/span\u003e\n\u003cspan style=\"display: inline-block;\"\u003e最も\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e有名な\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e問題として、\u003cspan style=\"display: inline-block;\"\u003e今すぐ\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003eダウンロード問題が\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e挙げられます。\u003c/span\u003e\u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003eこんな感じになります。猛烈に効果がわかりにくくて驚いていますが、一応効果はちゃんと出ているのではないでしょうか？\nHTMLを直接見ていただければどうなっているかはわかると思います。\u003c/p\u003e\n\n\u003cp\u003e次に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%C4%B6%F5%CA%B8%B8%CB\"\u003e青空文庫\u003c/a\u003eから\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%C6%CC%DC%DE%FB%C0%D0\"\u003e夏目漱石\u003c/a\u003e「こころ」の序文を抜粋してみたのが下の画像たちです。\u003c/p\u003e\n\n\u003cp\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20161029/20161029131814.png\" alt=\"f:id:agtn:20161029131814p:plain\" title=\"f:id:agtn:20161029131814p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20161029/20161029131817.png\" alt=\"f:id:agtn:20161029131817p:plain\" title=\"f:id:agtn:20161029131817p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20161029/20161029131820.png\" alt=\"f:id:agtn:20161029131820p:plain\" title=\"f:id:agtn:20161029131820p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003eレスポンシブ！それなりになっている気がします。\u003c/p\u003e\n\n\u003ch4\u003eあとがき\u003c/h4\u003e\n\n\u003cp\u003eこの問題へのアプローチとして、\u003ca href=\"https://github.com/google/budou\"\u003ehttps://github.com/google/budou\u003c/a\u003e が有名だと思います。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ebudou\u003c/code\u003e は　\u003ca href=\"https://cloud.google.com/natural-language/\"\u003eCloud Natural Language API\u003c/a\u003e を内部で使っていて、しっかり日本語の文章を\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eしているようです。\nなので非常に精度は高いと思うのですが、今僕の \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GCP\"\u003eGCP\u003c/a\u003e アカウントがごにょごにょしていてぱぱっと試せる状況ではなかったので自作しました。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ebudou\u003c/code\u003e と違ってしっかり\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eなどはしていなくて、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%C1%C2%D6%C1%C7%B2%F2%C0%CF\"\u003e形態素解析\u003c/a\u003eした後、それっぽく分割しているだけです。なので精度は落ちると思います。\n一方、\u003ccode\u003ebudou\u003c/code\u003e は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GCP\"\u003eGCP\u003c/a\u003e の credentails が必要だったりと準備が必要になるので、お手軽に試せるというのは悪くないかなと思っています。\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e必要に迫られて、HTML ページ内の改行位置をいい感じにするツールを作ってみました。\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"//hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fjapawrap\" title=\"agatan/japawrap\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"https://github.com/agatan/japawrap\"\u003egithub.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003eHTMLに長文を書くと、親 DOM のサイズの制約上、適宜改行がぶちこまれます。\nしかし、改行位置は文節を考慮などせずにごりっと挿入されるので、多くの問題が生じることが報告されています。\n最も有名な問題として、今すぐダウンロー\u003cbr\u003e\nド問題が挙げられます。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ejapawrap\u003c/code\u003e を使うと、それっぽく日本語を解釈して \u003ccode\u003e\u0026lt;span\u0026gt;\u003c/code\u003e でくくるみたいなことができます。\u003ccode\u003einline-block\u003c/code\u003e を適用すれば改行がそれっぽく入るようにできます。\u003c/p\u003e\n\n\u003ch2\u003eInstall\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode\u003ego get github.com/agatan/japawrap/...\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eで \u003ccode\u003ejapawrap\u003c/code\u003e コマンドが使えるようになります。\u003c/p\u003e\n\n\u003ch2\u003eUsage\u003c/h2\u003e\n\n\u003ch3\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLI\"\u003eCLI\u003c/a\u003e\u003c/h3\u003e\n\n\u003cp\u003eファイル名を指定するか標準入力から流し込みます。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e$ echo \u0026#34;今日も元気です\u0026#34; | japawrap\n\u0026lt;span class=\u0026#34;wordwrap\u0026#34;\u0026gt;今日も\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;wordwrap\u0026#34;\u0026gt;元気です\u0026lt;/span\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003eこのように適宜いい感じに wrap してくれます。\u003c/p\u003e\n\n\u003cp\u003eオプションとして \u003ccode\u003e-open string\u003c/code\u003e と \u003ccode\u003e-close string\u003c/code\u003e をサポートしているので、\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e$ echo \u0026#34;今日も元気です\u0026#34; | japawrap -open \u0026#39;\u0026lt;span style=\u0026#34;display: inline-block;\u0026#34;\u0026gt;\u0026#39; -close \u0026#34;\u0026lt;/span\u0026gt;\u0026#34; \n\u0026lt;span style=\u0026#34;display: inline-block;\u0026#34;\u0026gt;今日も\u0026lt;/span\u0026gt;\u0026lt;span style=\u0026#34;display: inline-block;\u0026#34;\u0026gt;元気です\u0026lt;/span\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003eみたいなことができます。\u003c/p\u003e\n\n\u003ch3\u003eLibrary\u003c/h3\u003e\n\n\u003cp\u003e一応 \u003ccode\u003ejapawrap\u003c/code\u003e はライブラリとしても使用できるようになっています。\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003ew := japawrap.New(open, \u003cspan class=\"synStatement\"\u003eclose\u003c/span\u003e)\ns := \u003cspan class=\"synConstant\"\u003e\u0026quot;今日も元気です\u0026quot;\u003c/span\u003e\nfmt.Println(\u003cspan class=\"synConstant\"\u003e\u0026quot;%s =\u0026gt; %s\u0026quot;\u003c/span\u003e, s, w.Do(s))\n\u003c/pre\u003e\n\n\u003cp\u003eこれだけです。\u003c/p\u003e\n\n\u003ch2\u003eExample\u003c/h2\u003e\n\n\u003cp\u003eでは実際に使った結果を下に記したいと思います。\n文章は、上の方に自分で書いた文章をそのまま使います。\u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003ch4\u003ebefore\u003c/h4\u003e\n\n\u003cp\u003eHTMLに長文を書くと、親DOM のサイズの制約上、適宜改行がぶちこまれます。\nしかし、改行位置は文節を考慮などせずにごりっと挿入されるので、多くの問題が生じることが報告されています。\n最も有名な問題として、今すぐダウンロード問題が挙げられます。\u003c/p\u003e\n\n\u003ch4\u003eafter\u003c/h4\u003e\n\n\u003cp\u003e\u003cspan style=\"display: inline-block;\"\u003eHTMLに\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e長文を\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e書くと、\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e親 \u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003eDOM の\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003eサイズの\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e制約上、\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e適宜改行が\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003eぶちこまれます。\u003c/span\u003e\n\u003cspan style=\"display: inline-block;\"\u003eしかし、\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e改行位置は\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e文節を\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e考慮など\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003eせず\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003eにごりっと\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e挿入されるので、\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e多くの\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e問題が\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e生じる\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003eことが\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e報告されて\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003eいます。\u003c/span\u003e\n\u003cspan style=\"display: inline-block;\"\u003e最も\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e有名な\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e問題として、\u003cspan style=\"display: inline-block;\"\u003e今すぐ\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003eダウンロード問題が\u003c/span\u003e\u003cspan style=\"display: inline-block;\"\u003e挙げられます。\u003c/span\u003e\u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003eこんな感じになります。猛烈に効果がわかりにくくて驚いていますが、一応効果はちゃんと出ているのではないでしょうか？\nHTMLを直接見ていただければどうなっているかはわかると思います。\u003c/p\u003e\n\n\u003cp\u003e次に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%C4%B6%F5%CA%B8%B8%CB\"\u003e青空文庫\u003c/a\u003eから\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%C6%CC%DC%DE%FB%C0%D0\"\u003e夏目漱石\u003c/a\u003e「こころ」の序文を抜粋してみたのが下の画像たちです。\u003c/p\u003e\n\n\u003cp\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20161029/20161029131814.png\" alt=\"f:id:agtn:20161029131814p:plain\" title=\"f:id:agtn:20161029131814p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20161029/20161029131817.png\" alt=\"f:id:agtn:20161029131817p:plain\" title=\"f:id:agtn:20161029131817p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20161029/20161029131820.png\" alt=\"f:id:agtn:20161029131820p:plain\" title=\"f:id:agtn:20161029131820p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003eレスポンシブ！それなりになっている気がします。\u003c/p\u003e\n\n\u003ch4\u003eあとがき\u003c/h4\u003e\n\n\u003cp\u003eこの問題へのアプローチとして、\u003ca href=\"https://github.com/google/budou\"\u003ehttps://github.com/google/budou\u003c/a\u003e が有名だと思います。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ebudou\u003c/code\u003e は　\u003ca href=\"https://cloud.google.com/natural-language/\"\u003eCloud Natural Language API\u003c/a\u003e を内部で使っていて、しっかり日本語の文章を\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eしているようです。\nなので非常に精度は高いと思うのですが、今僕の \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GCP\"\u003eGCP\u003c/a\u003e アカウントがごにょごにょしていてぱぱっと試せる状況ではなかったので自作しました。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ebudou\u003c/code\u003e と違ってしっかり\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eなどはしていなくて、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%C1%C2%D6%C1%C7%B2%F2%C0%CF\"\u003e形態素解析\u003c/a\u003eした後、それっぽく分割しているだけです。なので精度は落ちると思います。\n一方、\u003ccode\u003ebudou\u003c/code\u003e は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GCP\"\u003eGCP\u003c/a\u003e の credentails が必要だったりと準備が必要になるので、お手軽に試せるというのは悪くないかなと思っています。\u003c/p\u003e\n\n---\n\n---\n","slug":"日本語の改行を適当にいい感じにするツールを作りました","title":"日本語の改行を適当にいい感じにするツールを作りました","timestamp":1477715089000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Rust の Result と Iterator\"\ndate: 2016-09-05T14:47:25.000Z\ntags: []\n---\n\n\u003cp\u003eRust には失敗するかもしれない値を表す \u003ccode\u003eResult\u0026lt;T, E\u0026gt;\u003c/code\u003e という型があります。\n\u003ca href=\"https://doc.rust-lang.org/std/result/enum.Result.html\"\u003estd::result::Result\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eそして iterate できることを表す \u003ccode\u003eIterator\u003c/code\u003e という trait があります。\n\u003ca href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html\"\u003estd::iter::Iterator\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eまた、\u003ccode\u003eIterator\u003c/code\u003e trait は要素型を表す関連型を持ちます。\u003cdel\u003e例えば \u003ccode\u003eString\u003c/code\u003e は \u003ccode\u003eIterator\u0026lt;Item=char\u0026gt;\u003c/code\u003e を \u003ccode\u003eimpl\u003c/code\u003e しています。これは \u003ccode\u003echar\u003c/code\u003e 型を要素にもつ \u003ccode\u003eIterator\u003c/code\u003e であることを意味します。\u003c/del\u003e\nここ間違っていました。\u003ccode\u003eString\u003c/code\u003e が直接 \u003ccode\u003eIterator\u003c/code\u003e を \u003ccode\u003eimpl\u003c/code\u003e しているのではありませんでした。\u003c/p\u003e\n\n\u003cp\u003eたまに \u003ccode\u003eIterator\u0026lt;Item=Result\u0026lt;T, E\u0026gt;\u0026gt;\u003c/code\u003e のようになっている型を見かけます（T, E にはなにかしら具体的な型が入っていると思ってください）。\n例えば、\u003ccode\u003estd::io::stdin().bytes()\u003c/code\u003e の返り値である \u003ca href=\"https://doc.rust-lang.org/stable/std/io/struct.Bytes.html\"\u003estd::io::Bytes\u003c/a\u003e は \u003ccode\u003eIterator\u0026lt;Item=Result\u0026lt;u8\u0026gt;\u0026gt;\u003c/code\u003e を \u003ccode\u003eimpl\u003c/code\u003e しています。\n（ちょっとわかりにくいのですがここでの \u003ccode\u003eResult\u003c/code\u003e は \u003ccode\u003estd::result::Result\u003c/code\u003e ではなくて \u003ccode\u003estd::io::Result\u003c/code\u003e です。\u003ccode\u003estd::io::Result\u003c/code\u003e は \u003ccode\u003estd::result::Result\u0026lt;T, std::io::Error\u0026gt;\u003c/code\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eです。）\u003c/p\u003e\n\n\u003cp\u003eさて、このような \u003ccode\u003eIterator\u003c/code\u003e からすべての要素が \u003ccode\u003eOk(_)\u003c/code\u003e であれば \u003ccode\u003eOk\u0026lt;Vec_\u0026gt;\u0026gt;\u003c/code\u003e を、\u003ccode\u003eErr(_)\u003c/code\u003e があれば \u003ccode\u003eErr\u0026lt;_\u0026gt;\u003c/code\u003e を返すような処理を書きたいということは割りとよくあります。\nで、これを一生懸命実装しようとしていたのですが、標準ライブラリの範囲内ですでに実装されていました。べんり。\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e result \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003estd\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003eio\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003estdin\u003c/span\u003e().\u003cspan class=\"synIdentifier\"\u003ebytes\u003c/span\u003e().\u003cspan class=\"synIdentifier\"\u003ecollect\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003eResult\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e_\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e, _\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e();\n\u003c/pre\u003e\n\n\u003cp\u003eこれだけです。これで要件を満たす \u003ccode\u003eResult\u0026lt;Vec\u0026lt;_\u0026gt;, _\u0026gt;\u003c/code\u003e が返って来ます。すばらしい。\u003c/p\u003e\n\n\u003cp\u003eタネは簡単な話で \u003ccode\u003eResult\u003c/code\u003e が \u003ccode\u003eFromIterator\u003c/code\u003e trait を \u003ccode\u003eimpl\u003c/code\u003e しているので \u003ccode\u003ecollect\u003c/code\u003e で変換が可能であるというお話でした。\n\u003ca href=\"https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html\"\u003estd::iter::FromIterator\u003c/a\u003e\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eRust には失敗するかもしれない値を表す \u003ccode\u003eResult\u0026lt;T, E\u0026gt;\u003c/code\u003e という型があります。\n\u003ca href=\"https://doc.rust-lang.org/std/result/enum.Result.html\"\u003estd::result::Result\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eそして iterate できることを表す \u003ccode\u003eIterator\u003c/code\u003e という trait があります。\n\u003ca href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html\"\u003estd::iter::Iterator\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eまた、\u003ccode\u003eIterator\u003c/code\u003e trait は要素型を表す関連型を持ちます。\u003cdel\u003e例えば \u003ccode\u003eString\u003c/code\u003e は \u003ccode\u003eIterator\u0026lt;Item=char\u0026gt;\u003c/code\u003e を \u003ccode\u003eimpl\u003c/code\u003e しています。これは \u003ccode\u003echar\u003c/code\u003e 型を要素にもつ \u003ccode\u003eIterator\u003c/code\u003e であることを意味します。\u003c/del\u003e\nここ間違っていました。\u003ccode\u003eString\u003c/code\u003e が直接 \u003ccode\u003eIterator\u003c/code\u003e を \u003ccode\u003eimpl\u003c/code\u003e しているのではありませんでした。\u003c/p\u003e\n\n\u003cp\u003eたまに \u003ccode\u003eIterator\u0026lt;Item=Result\u0026lt;T, E\u0026gt;\u0026gt;\u003c/code\u003e のようになっている型を見かけます（T, E にはなにかしら具体的な型が入っていると思ってください）。\n例えば、\u003ccode\u003estd::io::stdin().bytes()\u003c/code\u003e の返り値である \u003ca href=\"https://doc.rust-lang.org/stable/std/io/struct.Bytes.html\"\u003estd::io::Bytes\u003c/a\u003e は \u003ccode\u003eIterator\u0026lt;Item=Result\u0026lt;u8\u0026gt;\u0026gt;\u003c/code\u003e を \u003ccode\u003eimpl\u003c/code\u003e しています。\n（ちょっとわかりにくいのですがここでの \u003ccode\u003eResult\u003c/code\u003e は \u003ccode\u003estd::result::Result\u003c/code\u003e ではなくて \u003ccode\u003estd::io::Result\u003c/code\u003e です。\u003ccode\u003estd::io::Result\u003c/code\u003e は \u003ccode\u003estd::result::Result\u0026lt;T, std::io::Error\u0026gt;\u003c/code\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eです。）\u003c/p\u003e\n\n\u003cp\u003eさて、このような \u003ccode\u003eIterator\u003c/code\u003e からすべての要素が \u003ccode\u003eOk(_)\u003c/code\u003e であれば \u003ccode\u003eOk\u0026lt;Vec_\u0026gt;\u0026gt;\u003c/code\u003e を、\u003ccode\u003eErr(_)\u003c/code\u003e があれば \u003ccode\u003eErr\u0026lt;_\u0026gt;\u003c/code\u003e を返すような処理を書きたいということは割りとよくあります。\nで、これを一生懸命実装しようとしていたのですが、標準ライブラリの範囲内ですでに実装されていました。べんり。\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e result \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003estd\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003eio\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003estdin\u003c/span\u003e().\u003cspan class=\"synIdentifier\"\u003ebytes\u003c/span\u003e().\u003cspan class=\"synIdentifier\"\u003ecollect\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003eResult\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e_\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e, _\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e();\n\u003c/pre\u003e\n\n\u003cp\u003eこれだけです。これで要件を満たす \u003ccode\u003eResult\u0026lt;Vec\u0026lt;_\u0026gt;, _\u0026gt;\u003c/code\u003e が返って来ます。すばらしい。\u003c/p\u003e\n\n\u003cp\u003eタネは簡単な話で \u003ccode\u003eResult\u003c/code\u003e が \u003ccode\u003eFromIterator\u003c/code\u003e trait を \u003ccode\u003eimpl\u003c/code\u003e しているので \u003ccode\u003ecollect\u003c/code\u003e で変換が可能であるというお話でした。\n\u003ca href=\"https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html\"\u003estd::iter::FromIterator\u003c/a\u003e\u003c/p\u003e\n\n---\n\n---\n","slug":"Rust_の_Result_と_Iterator","title":"Rust の Result と Iterator","timestamp":1473086845000,"tags":[]},{"rawMarkdown":"---\ntitle: \"値と参照について\"\ndate: 2016-08-14T04:56:32.000Z\ntags: []\n---\n\n\u003cp\u003e「値」と「参照」という言葉があります。\nこのへんの言葉について、今の理解をまとめておこうと思います。\n言葉の定義や理解が誤っている部分があればご指摘ください。\u003c/p\u003e\n\n\u003cp\u003eまず、前提として以下では、「値」ベースの言語として C, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e, Rust などを、「参照」ベースの言語として \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%23\"\u003eC#\u003c/a\u003e, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\"\u003eRuby\u003c/a\u003e などを想定しています。\n（もちろん言語によってはハイブリッドなものもあります: Crystal, Go, D, ...）\u003c/p\u003e\n\n\u003ch2\u003eそもそも「値」「参照」とは\u003c/h2\u003e\n\n\u003cp\u003e「値」は「実体」、「参照」は「実体へのポインタ」です。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eint\u003c/code\u003e の配列みたいなものを考えてみます。\n\u003ccode\u003e[1, 2, 3]\u003c/code\u003e をメモリ上にどう表現できるでしょうか。\u003c/p\u003e\n\n\u003cp\u003e配列ですから、単純にメモリ上のどこかに以下のような領域を作ればよさそうです。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e+---+\n| 1 |\n+---+\n| 2 |\n+---+\n| 3 |\n+---+\u003c/pre\u003e\n\n\u003cp\u003eこれが「値」であり配列の実体です。\nそして、実体の配置されたメモリ領域へのポインタが「参照」です。\u003c/p\u003e\n\n\u003ch2\u003eスタック上の表現\u003c/h2\u003e\n\n\u003cp\u003eさて、プログラム上ではこの配列のようなオブジェクトを、ローカル変数としてスタック上で表現したり、関数に引数として渡したりします。\nでは、スタック上での配列の表現はどうなっているのか考えてみます。\u003c/p\u003e\n\n\u003cp\u003eここで、「値」と「参照」という言葉が重要になります。\u003c/p\u003e\n\n\u003cp\u003e「値」ベースな言語では、スタック上に\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e+---+\n| 1 |\n+---+\n| 2 |\n+---+\n| 3 |\n+---+\u003c/pre\u003e\n\n\u003cp\u003eをそのままべたっと配置します。\u003c/p\u003e\n\n\u003cp\u003e一方で、「参照」ベースな言語では、ヒープ上に\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e+---+\n| 1 |\n+---+\n| 2 |\n+---+\n| 3 |\n+---+\u003c/pre\u003e\n\n\u003cp\u003eを配置し、スタック上では実体へのポインタという表現になります。\n（必ずしもヒープに置くとは限らない？処理系や最適化によってはスタックに置くこともありえる？とにかくローカル変数などの表現としては実体へのポインタという形をとるということ）\u003c/p\u003e\n\n\u003ch2\u003e値渡し・参照渡し\u003c/h2\u003e\n\n\u003cp\u003e値渡しとか参照渡しという言葉があります。\u003c/p\u003e\n\n\u003cp\u003e以下に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%BC%BB%F7%A5%B3%A1%BC%A5%C9\"\u003e擬似コード\u003c/a\u003eを一つ書いてみます。（C 風に書いていますが C ではないと思ってください）\u003c/p\u003e\n\n\u003cpre class=\"code lang-c\" data-lang=\"c\" data-unlink\u003e\u003cspan class=\"synType\"\u003evoid\u003c/span\u003e inc_age(Person p) {\n  p.age++;\n}\n\nPerson john = Person { \u003cspan class=\"synConstant\"\u003e\u0026quot;john\u0026quot;\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e };\ninc_age(john);\nprint(john.age); \u003cspan class=\"synComment\"\u003e// =\u0026gt; ??\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eこのコード、処理系が「値」ベースか「参照」ベースかで結果が異なります。\u003c/p\u003e\n\n\u003ch4\u003e「値」ベースの場合\u003c/h4\u003e\n\n\u003cp\u003e値ベースの言語の場合、\u003ccode\u003einc_age\u003c/code\u003e の引数に \u003ccode\u003ejohn\u003c/code\u003e を渡した時には、\u003ccode\u003einc_age\u003c/code\u003e 内のローカル変数（引数） \u003ccode\u003ep\u003c/code\u003e のために、\u003ccode\u003ejohn\u003c/code\u003e のコピーが作られます。\u003cbr/\u003e\n\u003ccode\u003einc_age\u003c/code\u003e 内で \u003ccode\u003ep.age++\u003c/code\u003e としていますが、\u003ccode\u003ep\u003c/code\u003e は \u003ccode\u003ejohn\u003c/code\u003e のコピーであって \u003ccode\u003ejohn\u003c/code\u003e ではありませんから、\u003ccode\u003einc_age\u003c/code\u003e から戻ってきて \u003ccode\u003ejohn.age\u003c/code\u003e を参照しても 20 のまま変化が無いはずです。\u003c/p\u003e\n\n\u003cp\u003eしたがって結果として \u003ccode\u003e20\u003c/code\u003e が出力されます。\u003c/p\u003e\n\n\u003ch4\u003e「参照」ベースの場合\u003c/h4\u003e\n\n\u003cp\u003e参照ベースの言語の場合、\u003ccode\u003ejohn\u003c/code\u003e 変数のメモリ上での表現は、ヒープに置かれた \u003ccode\u003ePerson { \"john\", 20 }\u003c/code\u003e というオブジェクトへのポインタになります。\u003cbr/\u003e\n\u003ccode\u003einc_age\u003c/code\u003e にこれを引数として渡すと、ポインタの値がコピーされますから、\u003ccode\u003ep\u003c/code\u003e と \u003ccode\u003ejohn\u003c/code\u003e は同じオブジェクトを参照しているポインタになります。\u003cbr/\u003e\n\u003ccode\u003ep.age++\u003c/code\u003e とすると \u003ccode\u003ep\u003c/code\u003e が参照するオブジェクトが変更されます。これは \u003ccode\u003ejohn\u003c/code\u003e が参照するオブジェクトと同一ですから、\u003ccode\u003ejohn.age\u003c/code\u003e も 21 に変化します。\u003c/p\u003e\n\n\u003cp\u003eしたがって結果として \u003ccode\u003e21\u003c/code\u003e が出力されます。\u003c/p\u003e\n\n\u003ch3\u003eC の場合\u003c/h3\u003e\n\n\u003cp\u003eC の場合、ポインタが直接表現できますから、参照渡しの挙動を模倣することができます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-c\" data-lang=\"c\" data-unlink\u003e\u003cspan class=\"synType\"\u003evoid\u003c/span\u003e inc_age(Person *p) {\n    p-\u0026gt;age++;\n}\n\nPerson john = Person { \u003cspan class=\"synConstant\"\u003e\u0026quot;john\u0026quot;\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e };\ninc_age(\u0026amp;john);\nprint(john.age); \u003cspan class=\"synComment\"\u003e// =\u0026gt; 21\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003ep\u003c/code\u003e が \u003ccode\u003ePerson*\u003c/code\u003e 型であること、そして \u003ccode\u003einc_age\u003c/code\u003e に \u003ccode\u003ejohn\u003c/code\u003e のアドレスを渡していることに注目してください。\nこの場合、\u003ccode\u003ep\u003c/code\u003e は \u003ccode\u003ejohn\u003c/code\u003e を参照するポインタですから、結果は \u003ccode\u003e21\u003c/code\u003e になります。\u003c/p\u003e\n\n\u003ch3\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の場合\u003c/h3\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の場合、言語機能として「参照渡し」という機能があります。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003evoid\u003c/span\u003e inc_age(Person\u0026amp; p) {\n    p.age++;\n}\n\nPerson john = Person { \u003cspan class=\"synConstant\"\u003e\u0026quot;john\u0026quot;\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e };\ninc_age(john);\nprint(john.age); \u003cspan class=\"synComment\"\u003e// =\u0026gt; 21\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003ep\u003c/code\u003e が \u003ccode\u003ePerson\u0026amp;\u003c/code\u003e 型であること、\u003ccode\u003einc_age\u003c/code\u003e には \u003ccode\u003ejohn\u003c/code\u003e をそのまま渡しているように見えることに注目してください。\nこれは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の提供する機能で、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eすると、\u003ccode\u003ePerson\u0026amp;\u003c/code\u003e は実質 \u003ccode\u003ePerson*\u003c/code\u003e と同じ表現になります。\n\u003ccode\u003ep-\u0026gt;age\u003c/code\u003e ではなく \u003ccode\u003ep.age\u003c/code\u003e と書けること、\u003ccode\u003e\u0026amp;john\u003c/code\u003e ではなく \u003ccode\u003ejohn\u003c/code\u003e のままで参照渡しが実現できるようになっています。\n単純なポインタを使っても同じことが出来ますが、ポインタと違って \u003ccode\u003enullptr\u003c/code\u003e になることがないという特徴があります。\u003c/p\u003e\n\n\u003ch2\u003e参照のハマりやすい点\u003c/h2\u003e\n\n\u003cp\u003e個人的に参照ベースの言語でハマりやすいなと感じるのは以下のようなコードです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-java\" data-lang=\"java\" data-unlink\u003e\u003cspan class=\"synType\"\u003evoid\u003c/span\u003e some_function(Person p) {\n    p.age++;\n    p = \u003cspan class=\"synStatement\"\u003enew\u003c/span\u003e Person(\u003cspan class=\"synConstant\"\u003e\u0026quot;bob\u0026quot;\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e30\u003c/span\u003e);\n}\n\nPerson p = \u003cspan class=\"synStatement\"\u003enew\u003c/span\u003e Person(\u003cspan class=\"synConstant\"\u003e\u0026quot;john\u0026quot;\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e);\nsome_function(p);\nprintln(p.name); \u003cspan class=\"synComment\"\u003e// =\u0026gt; john\u003c/span\u003e\nprintln(p.age); \u003cspan class=\"synComment\"\u003e// =\u0026gt; 21\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003ep.age++\u003c/code\u003e の部分は呼び出し元のオブジェクトに反映されるのに、\u003ccode\u003ep = new Person(...)\u003c/code\u003e の部分はなんで反映されないの！ってなります。（なりません？）\n本質的にポインタの値渡しにすぎないんだということを理解していればまぁ納得なのですが...\u003c/p\u003e\n\n\u003cp\u003e（ちなみに \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e や D の参照渡しだと \u003ccode\u003ep = new Person(...)\u003c/code\u003e 的なコードも呼び出し元に反映されます。）\u003c/p\u003e\n\n\u003ch2\u003e値のハマりやすい点\u003c/h2\u003e\n\n\u003cp\u003eハマりやすいというか、気がつかないままパフォーマンスが悪くなりやすいのが値ベースの言語の弱点でしょう。\u003c/p\u003e\n\n\u003cpre class=\"code lang-c\" data-lang=\"c\" data-unlink\u003e\u003cspan class=\"synType\"\u003evoid\u003c/span\u003e print_object(HugeObject obj) {\n   printf(\u003cspan class=\"synConstant\"\u003e\u0026quot;\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e%s\\n\u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026quot;\u003c/span\u003e, obj.name);\n}\nHugeObject obj = ...;\nprint_object(obj);\n\u003c/pre\u003e\n\n\u003cp\u003eこのようなコードを書くと、ただ名前を表示するだけの関数が激重になる可能性があります。\n値ベースの言語では、引数として値を渡すとまるっとそのコピーをつくりますから、不要にもかかわらず巨大な値のコピーを作ってしまいます。\u003c/p\u003e\n\n\u003ch2\u003eまとめ\u003c/h2\u003e\n\n\u003cp\u003e「ムーブセマンティクス」とか「immutable と参照」とかについてまとめようと思ったのですが、前提として「値」「参照」についてまとめていないと書きにくいなと思ったのでまとめておきました。\u003c/p\u003e\n\n\u003cp\u003e内部表現を知ることでハマりやすい点の回避にもつながると思うので、この辺はきちんと理解しておきたいです。\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e「値」と「参照」という言葉があります。\nこのへんの言葉について、今の理解をまとめておこうと思います。\n言葉の定義や理解が誤っている部分があればご指摘ください。\u003c/p\u003e\n\n\u003cp\u003eまず、前提として以下では、「値」ベースの言語として C, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e, Rust などを、「参照」ベースの言語として \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%23\"\u003eC#\u003c/a\u003e, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\"\u003eRuby\u003c/a\u003e などを想定しています。\n（もちろん言語によってはハイブリッドなものもあります: Crystal, Go, D, ...）\u003c/p\u003e\n\n\u003ch2\u003eそもそも「値」「参照」とは\u003c/h2\u003e\n\n\u003cp\u003e「値」は「実体」、「参照」は「実体へのポインタ」です。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eint\u003c/code\u003e の配列みたいなものを考えてみます。\n\u003ccode\u003e[1, 2, 3]\u003c/code\u003e をメモリ上にどう表現できるでしょうか。\u003c/p\u003e\n\n\u003cp\u003e配列ですから、単純にメモリ上のどこかに以下のような領域を作ればよさそうです。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e+---+\n| 1 |\n+---+\n| 2 |\n+---+\n| 3 |\n+---+\u003c/pre\u003e\n\n\u003cp\u003eこれが「値」であり配列の実体です。\nそして、実体の配置されたメモリ領域へのポインタが「参照」です。\u003c/p\u003e\n\n\u003ch2\u003eスタック上の表現\u003c/h2\u003e\n\n\u003cp\u003eさて、プログラム上ではこの配列のようなオブジェクトを、ローカル変数としてスタック上で表現したり、関数に引数として渡したりします。\nでは、スタック上での配列の表現はどうなっているのか考えてみます。\u003c/p\u003e\n\n\u003cp\u003eここで、「値」と「参照」という言葉が重要になります。\u003c/p\u003e\n\n\u003cp\u003e「値」ベースな言語では、スタック上に\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e+---+\n| 1 |\n+---+\n| 2 |\n+---+\n| 3 |\n+---+\u003c/pre\u003e\n\n\u003cp\u003eをそのままべたっと配置します。\u003c/p\u003e\n\n\u003cp\u003e一方で、「参照」ベースな言語では、ヒープ上に\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e+---+\n| 1 |\n+---+\n| 2 |\n+---+\n| 3 |\n+---+\u003c/pre\u003e\n\n\u003cp\u003eを配置し、スタック上では実体へのポインタという表現になります。\n（必ずしもヒープに置くとは限らない？処理系や最適化によってはスタックに置くこともありえる？とにかくローカル変数などの表現としては実体へのポインタという形をとるということ）\u003c/p\u003e\n\n\u003ch2\u003e値渡し・参照渡し\u003c/h2\u003e\n\n\u003cp\u003e値渡しとか参照渡しという言葉があります。\u003c/p\u003e\n\n\u003cp\u003e以下に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%BC%BB%F7%A5%B3%A1%BC%A5%C9\"\u003e擬似コード\u003c/a\u003eを一つ書いてみます。（C 風に書いていますが C ではないと思ってください）\u003c/p\u003e\n\n\u003cpre class=\"code lang-c\" data-lang=\"c\" data-unlink\u003e\u003cspan class=\"synType\"\u003evoid\u003c/span\u003e inc_age(Person p) {\n  p.age++;\n}\n\nPerson john = Person { \u003cspan class=\"synConstant\"\u003e\u0026quot;john\u0026quot;\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e };\ninc_age(john);\nprint(john.age); \u003cspan class=\"synComment\"\u003e// =\u0026gt; ??\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eこのコード、処理系が「値」ベースか「参照」ベースかで結果が異なります。\u003c/p\u003e\n\n\u003ch4\u003e「値」ベースの場合\u003c/h4\u003e\n\n\u003cp\u003e値ベースの言語の場合、\u003ccode\u003einc_age\u003c/code\u003e の引数に \u003ccode\u003ejohn\u003c/code\u003e を渡した時には、\u003ccode\u003einc_age\u003c/code\u003e 内のローカル変数（引数） \u003ccode\u003ep\u003c/code\u003e のために、\u003ccode\u003ejohn\u003c/code\u003e のコピーが作られます。\u003cbr/\u003e\n\u003ccode\u003einc_age\u003c/code\u003e 内で \u003ccode\u003ep.age++\u003c/code\u003e としていますが、\u003ccode\u003ep\u003c/code\u003e は \u003ccode\u003ejohn\u003c/code\u003e のコピーであって \u003ccode\u003ejohn\u003c/code\u003e ではありませんから、\u003ccode\u003einc_age\u003c/code\u003e から戻ってきて \u003ccode\u003ejohn.age\u003c/code\u003e を参照しても 20 のまま変化が無いはずです。\u003c/p\u003e\n\n\u003cp\u003eしたがって結果として \u003ccode\u003e20\u003c/code\u003e が出力されます。\u003c/p\u003e\n\n\u003ch4\u003e「参照」ベースの場合\u003c/h4\u003e\n\n\u003cp\u003e参照ベースの言語の場合、\u003ccode\u003ejohn\u003c/code\u003e 変数のメモリ上での表現は、ヒープに置かれた \u003ccode\u003ePerson { \"john\", 20 }\u003c/code\u003e というオブジェクトへのポインタになります。\u003cbr/\u003e\n\u003ccode\u003einc_age\u003c/code\u003e にこれを引数として渡すと、ポインタの値がコピーされますから、\u003ccode\u003ep\u003c/code\u003e と \u003ccode\u003ejohn\u003c/code\u003e は同じオブジェクトを参照しているポインタになります。\u003cbr/\u003e\n\u003ccode\u003ep.age++\u003c/code\u003e とすると \u003ccode\u003ep\u003c/code\u003e が参照するオブジェクトが変更されます。これは \u003ccode\u003ejohn\u003c/code\u003e が参照するオブジェクトと同一ですから、\u003ccode\u003ejohn.age\u003c/code\u003e も 21 に変化します。\u003c/p\u003e\n\n\u003cp\u003eしたがって結果として \u003ccode\u003e21\u003c/code\u003e が出力されます。\u003c/p\u003e\n\n\u003ch3\u003eC の場合\u003c/h3\u003e\n\n\u003cp\u003eC の場合、ポインタが直接表現できますから、参照渡しの挙動を模倣することができます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-c\" data-lang=\"c\" data-unlink\u003e\u003cspan class=\"synType\"\u003evoid\u003c/span\u003e inc_age(Person *p) {\n    p-\u0026gt;age++;\n}\n\nPerson john = Person { \u003cspan class=\"synConstant\"\u003e\u0026quot;john\u0026quot;\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e };\ninc_age(\u0026amp;john);\nprint(john.age); \u003cspan class=\"synComment\"\u003e// =\u0026gt; 21\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003ep\u003c/code\u003e が \u003ccode\u003ePerson*\u003c/code\u003e 型であること、そして \u003ccode\u003einc_age\u003c/code\u003e に \u003ccode\u003ejohn\u003c/code\u003e のアドレスを渡していることに注目してください。\nこの場合、\u003ccode\u003ep\u003c/code\u003e は \u003ccode\u003ejohn\u003c/code\u003e を参照するポインタですから、結果は \u003ccode\u003e21\u003c/code\u003e になります。\u003c/p\u003e\n\n\u003ch3\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の場合\u003c/h3\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の場合、言語機能として「参照渡し」という機能があります。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003evoid\u003c/span\u003e inc_age(Person\u0026amp; p) {\n    p.age++;\n}\n\nPerson john = Person { \u003cspan class=\"synConstant\"\u003e\u0026quot;john\u0026quot;\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e };\ninc_age(john);\nprint(john.age); \u003cspan class=\"synComment\"\u003e// =\u0026gt; 21\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003ep\u003c/code\u003e が \u003ccode\u003ePerson\u0026amp;\u003c/code\u003e 型であること、\u003ccode\u003einc_age\u003c/code\u003e には \u003ccode\u003ejohn\u003c/code\u003e をそのまま渡しているように見えることに注目してください。\nこれは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の提供する機能で、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eすると、\u003ccode\u003ePerson\u0026amp;\u003c/code\u003e は実質 \u003ccode\u003ePerson*\u003c/code\u003e と同じ表現になります。\n\u003ccode\u003ep-\u0026gt;age\u003c/code\u003e ではなく \u003ccode\u003ep.age\u003c/code\u003e と書けること、\u003ccode\u003e\u0026amp;john\u003c/code\u003e ではなく \u003ccode\u003ejohn\u003c/code\u003e のままで参照渡しが実現できるようになっています。\n単純なポインタを使っても同じことが出来ますが、ポインタと違って \u003ccode\u003enullptr\u003c/code\u003e になることがないという特徴があります。\u003c/p\u003e\n\n\u003ch2\u003e参照のハマりやすい点\u003c/h2\u003e\n\n\u003cp\u003e個人的に参照ベースの言語でハマりやすいなと感じるのは以下のようなコードです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-java\" data-lang=\"java\" data-unlink\u003e\u003cspan class=\"synType\"\u003evoid\u003c/span\u003e some_function(Person p) {\n    p.age++;\n    p = \u003cspan class=\"synStatement\"\u003enew\u003c/span\u003e Person(\u003cspan class=\"synConstant\"\u003e\u0026quot;bob\u0026quot;\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e30\u003c/span\u003e);\n}\n\nPerson p = \u003cspan class=\"synStatement\"\u003enew\u003c/span\u003e Person(\u003cspan class=\"synConstant\"\u003e\u0026quot;john\u0026quot;\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e);\nsome_function(p);\nprintln(p.name); \u003cspan class=\"synComment\"\u003e// =\u0026gt; john\u003c/span\u003e\nprintln(p.age); \u003cspan class=\"synComment\"\u003e// =\u0026gt; 21\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003ep.age++\u003c/code\u003e の部分は呼び出し元のオブジェクトに反映されるのに、\u003ccode\u003ep = new Person(...)\u003c/code\u003e の部分はなんで反映されないの！ってなります。（なりません？）\n本質的にポインタの値渡しにすぎないんだということを理解していればまぁ納得なのですが...\u003c/p\u003e\n\n\u003cp\u003e（ちなみに \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e や D の参照渡しだと \u003ccode\u003ep = new Person(...)\u003c/code\u003e 的なコードも呼び出し元に反映されます。）\u003c/p\u003e\n\n\u003ch2\u003e値のハマりやすい点\u003c/h2\u003e\n\n\u003cp\u003eハマりやすいというか、気がつかないままパフォーマンスが悪くなりやすいのが値ベースの言語の弱点でしょう。\u003c/p\u003e\n\n\u003cpre class=\"code lang-c\" data-lang=\"c\" data-unlink\u003e\u003cspan class=\"synType\"\u003evoid\u003c/span\u003e print_object(HugeObject obj) {\n   printf(\u003cspan class=\"synConstant\"\u003e\u0026quot;\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e%s\\n\u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026quot;\u003c/span\u003e, obj.name);\n}\nHugeObject obj = ...;\nprint_object(obj);\n\u003c/pre\u003e\n\n\u003cp\u003eこのようなコードを書くと、ただ名前を表示するだけの関数が激重になる可能性があります。\n値ベースの言語では、引数として値を渡すとまるっとそのコピーをつくりますから、不要にもかかわらず巨大な値のコピーを作ってしまいます。\u003c/p\u003e\n\n\u003ch2\u003eまとめ\u003c/h2\u003e\n\n\u003cp\u003e「ムーブセマンティクス」とか「immutable と参照」とかについてまとめようと思ったのですが、前提として「値」「参照」についてまとめていないと書きにくいなと思ったのでまとめておきました。\u003c/p\u003e\n\n\u003cp\u003e内部表現を知ることでハマりやすい点の回避にもつながると思うので、この辺はきちんと理解しておきたいです。\u003c/p\u003e\n\n---\n\n---\n","slug":"値と参照について","title":"値と参照について","timestamp":1471150592000,"tags":[]},{"rawMarkdown":"---\ntitle: \"再帰的 grep ツール crepe を作っています\"\ndate: 2016-07-08T15:36:15.000Z\ntags: []\n---\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003e的にパスをたどりながらパターンにマッチする行を検索する \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/grep\"\u003egrep\u003c/a\u003e 系のツールを作っています。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/agatan/crepe\"\u003eagatan/crepe\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e有名どころとしては、\u003ca href=\"http://beyondgrep.com/\"\u003eack\u003c/a\u003e とか \u003ca href=\"https://github.com/ggreer/the_silver_searcher\"\u003eggreer/the_silver_searcher\u003c/a\u003e(ag) とか \u003ca href=\"https://github.com/monochromegane/the_platinum_searcher\"\u003emonochromegane/the_platinum_searcher\u003c/a\u003e とか \u003ca href=\"https://github.com/tkengo/highway\"\u003etkengo/highway\u003c/a\u003e なんかがあります。群雄割拠ですね。\u003c/p\u003e\n\n\u003cp\u003eこれらの有名ツール達はそれぞれ特徴があって(速さとか出力形式とか\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%F3%A5%B3%A1%BC%A5%C9\"\u003eエンコード\u003c/a\u003e対応とか)便利に使わせていただいております。\u003cbr/\u003e\n今回 \u003ccode\u003ecrepe\u003c/code\u003e を作ろうと思った理由は、なんとなく \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e でちゃんとスレッド立てて並行処理みたいなコードを書いてみたくなったからです。\u003c/p\u003e\n\n\u003cp\u003e速度等も測っていないのでどこまで意味があるのか怪しいのですが、とりあえず現状 3 つの仕事を並列に動かしています。\u003c/p\u003e\n\n\u003cp\u003e一つ目は出力を担当するスレッドで、マッチ結果を受け取って出力するだけです。\u003cbr/\u003e\n二つ目はマッチを担当するスレッドで、ファイル名と \u003ccode\u003eFILE*\u003c/code\u003e を受け取ってマッチ結果を生成し出力担当スレッドに渡します。\u003cbr/\u003e\n三つ目はパスを walk するスレッドで、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\"\u003eディレクト\u003c/a\u003eリを掘りながらファイルを開いてマッチスレッドに送ります。\u003c/p\u003e\n\n\u003cp\u003e現状はまだ部分一致の matcher しか実装していないので\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%C9%BD%B8%BD\"\u003e正規表現\u003c/a\u003eや fuzzy マッチは未実装です。\u003cbr/\u003e\n標準入力かパスから部分一致する行を探してきて出力します。\u003cbr/\u003e\n出力形式は \u003ccode\u003eag\u003c/code\u003e に近い形式で、ファイルごとにグループ分けして行番号とともに出力します（オプションでこの辺の挙動はいじれるようにはなっています）\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\"\u003eバイ\u003c/a\u003eナリファイルっぽいファイルはスキップするようになっています。\u003c/p\u003e\n\n\u003ch2\u003eやりたいこと\u003c/h2\u003e\n\n\u003cp\u003e最終目標として \u003ccode\u003ecrepe\u003c/code\u003e は \u003ca href=\"https://github.com/peco/peco\"\u003epeco\u003c/a\u003e のような interactive な検索を実装してみたいなと思っています。\u003cbr/\u003e\n\u003ccode\u003eag\u003c/code\u003e と \u003ccode\u003epeco\u003c/code\u003e の組み合わせで云々みたいな\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\"\u003eユースケース\u003c/a\u003eが割りとあるなぁと思ったので。\u003cbr/\u003e\nただこれメモリ使用量とか速度上の制約からまともに働くのかはよくわかっていません。\u003cbr/\u003e\n単純に考えると、ユーザが一文字入力するたびにファイルの read からやり直す必要があるので...\u003cbr/\u003e\n入力ファイルが多すぎた場合にどこまでキャッシュするのかとかその辺を相当うまくやらないと死ぬのでは？という気がします。\u003c/p\u003e\n\n\u003cp\u003e短期的な目標としては\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e.gitignore 対応 (意外とめっちゃ面倒で苦しんでいます)\u003c/li\u003e\n\u003cli\u003efuzzy マッチ\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%C9%BD%B8%BD\"\u003e正規表現\u003c/a\u003eマッチ\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eあたりから順にやっていきたいなと思っています。とりあえずこっちからやろうかなと思います。\u003c/p\u003e\n\n\u003cp\u003eというわけで気合を入れる意味も込めて記事にしました。プルリクやフィードバック大歓迎なのでぜひよろしくお願いします。\u003c/p\u003e\n\n---\n\nCOMMENT:\nAUTHOR: smaranrebub\nEMAIL: ruysqucp@gmail.com\nURL: http://cialisvipsale.com\nIP: 200.26.168.127\nDATE: 03/24/2018 15:30:29\n\nVery good info, Thanks!\nwalgreens price for cialis \u003ca href=\"http://cialisvipsale.com\"\u003ebuy brand cialis cheap\u003c/a\u003e\nprices on cialis 10 mg \u003ca href=\"http://cialisvipsale.com\"\u003ehttp://cialisvipsale.com\u003c/a\u003e\nacheter du cialis a geneve \u003ca href=\"http://cialisvipsale.com\"\u003eeffetti del cialis\u003c/a\u003e\nprices for cialis 50mg\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003e的にパスをたどりながらパターンにマッチする行を検索する \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/grep\"\u003egrep\u003c/a\u003e 系のツールを作っています。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/agatan/crepe\"\u003eagatan/crepe\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e有名どころとしては、\u003ca href=\"http://beyondgrep.com/\"\u003eack\u003c/a\u003e とか \u003ca href=\"https://github.com/ggreer/the_silver_searcher\"\u003eggreer/the_silver_searcher\u003c/a\u003e(ag) とか \u003ca href=\"https://github.com/monochromegane/the_platinum_searcher\"\u003emonochromegane/the_platinum_searcher\u003c/a\u003e とか \u003ca href=\"https://github.com/tkengo/highway\"\u003etkengo/highway\u003c/a\u003e なんかがあります。群雄割拠ですね。\u003c/p\u003e\n\n\u003cp\u003eこれらの有名ツール達はそれぞれ特徴があって(速さとか出力形式とか\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%F3%A5%B3%A1%BC%A5%C9\"\u003eエンコード\u003c/a\u003e対応とか)便利に使わせていただいております。\u003cbr/\u003e\n今回 \u003ccode\u003ecrepe\u003c/code\u003e を作ろうと思った理由は、なんとなく \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e でちゃんとスレッド立てて並行処理みたいなコードを書いてみたくなったからです。\u003c/p\u003e\n\n\u003cp\u003e速度等も測っていないのでどこまで意味があるのか怪しいのですが、とりあえず現状 3 つの仕事を並列に動かしています。\u003c/p\u003e\n\n\u003cp\u003e一つ目は出力を担当するスレッドで、マッチ結果を受け取って出力するだけです。\u003cbr/\u003e\n二つ目はマッチを担当するスレッドで、ファイル名と \u003ccode\u003eFILE*\u003c/code\u003e を受け取ってマッチ結果を生成し出力担当スレッドに渡します。\u003cbr/\u003e\n三つ目はパスを walk するスレッドで、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\"\u003eディレクト\u003c/a\u003eリを掘りながらファイルを開いてマッチスレッドに送ります。\u003c/p\u003e\n\n\u003cp\u003e現状はまだ部分一致の matcher しか実装していないので\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%C9%BD%B8%BD\"\u003e正規表現\u003c/a\u003eや fuzzy マッチは未実装です。\u003cbr/\u003e\n標準入力かパスから部分一致する行を探してきて出力します。\u003cbr/\u003e\n出力形式は \u003ccode\u003eag\u003c/code\u003e に近い形式で、ファイルごとにグループ分けして行番号とともに出力します（オプションでこの辺の挙動はいじれるようにはなっています）\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\"\u003eバイ\u003c/a\u003eナリファイルっぽいファイルはスキップするようになっています。\u003c/p\u003e\n\n\u003ch2\u003eやりたいこと\u003c/h2\u003e\n\n\u003cp\u003e最終目標として \u003ccode\u003ecrepe\u003c/code\u003e は \u003ca href=\"https://github.com/peco/peco\"\u003epeco\u003c/a\u003e のような interactive な検索を実装してみたいなと思っています。\u003cbr/\u003e\n\u003ccode\u003eag\u003c/code\u003e と \u003ccode\u003epeco\u003c/code\u003e の組み合わせで云々みたいな\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\"\u003eユースケース\u003c/a\u003eが割りとあるなぁと思ったので。\u003cbr/\u003e\nただこれメモリ使用量とか速度上の制約からまともに働くのかはよくわかっていません。\u003cbr/\u003e\n単純に考えると、ユーザが一文字入力するたびにファイルの read からやり直す必要があるので...\u003cbr/\u003e\n入力ファイルが多すぎた場合にどこまでキャッシュするのかとかその辺を相当うまくやらないと死ぬのでは？という気がします。\u003c/p\u003e\n\n\u003cp\u003e短期的な目標としては\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e.gitignore 対応 (意外とめっちゃ面倒で苦しんでいます)\u003c/li\u003e\n\u003cli\u003efuzzy マッチ\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%C9%BD%B8%BD\"\u003e正規表現\u003c/a\u003eマッチ\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eあたりから順にやっていきたいなと思っています。とりあえずこっちからやろうかなと思います。\u003c/p\u003e\n\n\u003cp\u003eというわけで気合を入れる意味も込めて記事にしました。プルリクやフィードバック大歓迎なのでぜひよろしくお願いします。\u003c/p\u003e\n\n---\n\nCOMMENT:\nAUTHOR: smaranrebub\nEMAIL: ruysqucp@gmail.com\nURL: http://cialisvipsale.com\nIP: 200.26.168.127\nDATE: 03/24/2018 15:30:29\n\nVery good info, Thanks!\nwalgreens price for cialis \u003ca href=\"http://cialisvipsale.com\"\u003ebuy brand cialis cheap\u003c/a\u003e\nprices on cialis 10 mg \u003ca href=\"http://cialisvipsale.com\"\u003ehttp://cialisvipsale.com\u003c/a\u003e\nacheter du cialis a geneve \u003ca href=\"http://cialisvipsale.com\"\u003eeffetti del cialis\u003c/a\u003e\nprices for cialis 50mg\n\n---\n\n---\n","slug":"再帰的_grep_ツール_crepe_を作っています","title":"再帰的 grep ツール crepe を作っています","timestamp":1467992175000,"tags":[]},{"rawMarkdown":"---\ntitle: \"C++ で result 型を作る\"\ndate: 2016-07-01T14:30:09.000Z\ntags: []\n---\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e や Rust など多くの強力な型システムを持つ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\"\u003eプログラミング言語\u003c/a\u003eは、\u003ccode\u003eEither\u003c/code\u003e とか \u003ccode\u003eResult\u003c/code\u003e といった「失敗するかもしれない」計算の値を示す型を持っています。\u003c/p\u003e\n\n\u003cp\u003e現在の \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の標準ライブラリにはこのような型はありませんので、それを自作してみようというわけです。\u003c/p\u003e\n\n\u003cp\u003eちなみに現在策定中の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e17には \u003ccode\u003estd::optional\u003c/code\u003e が入ることが決定しているようです。これは、\u003ccode\u003eresult\u003c/code\u003e と同様に失敗するかもしれな値を示しますが、失敗した原因がなんなのかを通知する仕組みを持っていません。\u003c/p\u003e\n\n\u003ch2\u003eそもそもどういう型か\u003c/h2\u003e\n\n\u003cp\u003eRust の \u003ccode\u003eResult\u003c/code\u003e 型を例にみてみます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003eenum\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eResult\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eV, E\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"synConstant\"\u003eOk\u003c/span\u003e(V),\n  \u003cspan class=\"synConstant\"\u003eErr\u003c/span\u003e(E),\n}\n\u003c/pre\u003e\n\n\u003cp\u003eRust における \u003ccode\u003eResult\u003c/code\u003e 型はだいたいこんな感じで定義されています。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eResult\u003c/code\u003e は型引数を２つとります。\u003ccode\u003eV\u003c/code\u003e が成功時の値で、\u003ccode\u003eE\u003c/code\u003e が失敗時のエラー情報です。\n例えば、\u003ccode\u003efn parse_int(s: \u0026amp;str) -\u0026gt; Result\u0026lt;isize, String\u0026gt;;\u003c/code\u003e は、文字列を受け取り、それが整数としてパース出来れば \u003ccode\u003eisize\u003c/code\u003e に変換し、\u003ccode\u003eOk(isize)\u003c/code\u003e として返します。\nもし整数としてパース出来ないなどのエラーがあれば、それを \u003ccode\u003eString\u003c/code\u003e で表現し、\u003ccode\u003eErr(String)\u003c/code\u003e で返します。\u003c/p\u003e\n\n\u003cp\u003e本質的にはこれが全てです。ここに、\u003ccode\u003eResult\u003c/code\u003e から中身を取り出す(\u003ccode\u003eErr\u003c/code\u003e なら \u003ccode\u003epanic\u003c/code\u003e する)関数などを定義してあげれば便利にエラー状態を表現できます。\u003cbr/\u003e\n(Rust の \u003ccode\u003etry\u003c/code\u003e マクロはとても便利ですよね)\u003c/p\u003e\n\n\u003ch2\u003eまずはベースとなる result を作る\u003c/h2\u003e\n\n\u003cp\u003eまずはベースとなる \u003ccode\u003eresult\u003c/code\u003e 型を作ってみます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T, \u003cspan class=\"synType\"\u003etypename\u003c/span\u003e E\u0026gt;\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e result {\n\n  result(T \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; ok) : t(tag::OK) {\n    ok_ = ok;\n  }\n\n  result(E \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; e) : t(tag::OK) {\n    err_ = e;\n  }\n\n  ~result() {\n    \u003cspan class=\"synStatement\"\u003eswitch\u003c/span\u003e (t) {\n      \u003cspan class=\"synStatement\"\u003ecase\u003c/span\u003e tag::OK:\n        ok_.~T();\n        \u003cspan class=\"synStatement\"\u003ebreak\u003c/span\u003e;\n      \u003cspan class=\"synStatement\"\u003ecase\u003c/span\u003e tag::ERROR:\n        err_.~E();\n        \u003cspan class=\"synStatement\"\u003ebreak\u003c/span\u003e;\n    }\n  }\n\n  result(result \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; r): t(r.t) {\n    \u003cspan class=\"synStatement\"\u003eswitch\u003c/span\u003e (t) {\n      \u003cspan class=\"synStatement\"\u003ecase\u003c/span\u003e tag::OK:\n        ok_ = r.ok_;\n        \u003cspan class=\"synStatement\"\u003ebreak\u003c/span\u003e;\n      \u003cspan class=\"synStatement\"\u003ecase\u003c/span\u003e tag::ERROR:\n        err_ = r.err_;\n        \u003cspan class=\"synStatement\"\u003ebreak\u003c/span\u003e;\n    }\n  }\n\n  T \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; get() \u003cspan class=\"synType\"\u003econst\u003c/span\u003e {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (t != tag::OK) {\n      \u003cspan class=\"synStatement\"\u003ethrow\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;invalid get operation\u0026quot;\u003c/span\u003e;\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e ok_;\n  }\n\n  E \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; get_error() \u003cspan class=\"synType\"\u003econst\u003c/span\u003e {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (t != tag::ERROR) {\n      \u003cspan class=\"synStatement\"\u003ethrow\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;invalid get operation\u0026quot;\u003c/span\u003e;\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e err_;\n  }\n\n\u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n  \u003cspan class=\"synType\"\u003eenum\u003c/span\u003e \u003cspan class=\"synType\"\u003eclass\u003c/span\u003e tag {\n    OK,\n    ERROR,\n  };\n  tag t;\n  \u003cspan class=\"synType\"\u003eunion\u003c/span\u003e {\n    T ok_;\n    E err_;\n  };\n\n};\n\u003c/pre\u003e\n\n\u003cp\u003eかなり雑ですが、ざっくりこんな感じになるはずです。\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e11 から拡張されて自由度がかなり高くなった \u003ccode\u003eunion\u003c/code\u003e がとても便利です。\u003c/p\u003e\n\n\u003cp\u003eこれで \u003ccode\u003eresult\u0026lt;int, std::string\u0026gt;(1).get()\u003c/code\u003e とやれば \u003ccode\u003e1\u003c/code\u003e が返るし \u003ccode\u003eresult\u0026lt;int, std::string\u0026gt;(std::string(\"test\")).get_error()\u003c/code\u003e で \u003ccode\u003e\"test\"\u003c/code\u003e が返るはずです。\u003c/p\u003e\n\n\u003ch2\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e でやると何が難しいか\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e で難しいのは、Rustより弱い\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\"\u003e型推論\u003c/a\u003eが引き起こす問題です。\u003cbr/\u003e\nRust では、\u003ccode\u003eOk(1isize)\u003c/code\u003e とか \u003ccode\u003eErr(\"error!\".to_owned())\u003c/code\u003e とすれば、その値がどういう型であることが期待されているのかまで含めて\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\"\u003e型推論\u003c/a\u003eや単一化が行われます。\nすなわち、\u003ccode\u003eOk(1isize)\u003c/code\u003e だけを見てもエラーの型がわからないため、\u003ccode\u003eResult\u0026lt;isize, E\u0026gt;\u003c/code\u003e の \u003ccode\u003eE\u003c/code\u003e を決定することが出来ないが、Rust は強力な\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\"\u003e型推論\u003c/a\u003e機構を持つため、これを決定することが出来ます。\u003c/p\u003e\n\n\u003cp\u003e一方、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e では \u003ccode\u003eresult\u0026lt;int, std::string\u0026gt; f() { return 1; }\u003c/code\u003e は \u003ccode\u003eint\u003c/code\u003e から \u003ccode\u003eresult\u0026lt;int, std::string\u0026gt;\u003c/code\u003e の暗黙変換がきくので可能ですが、\u003ccode\u003eresult\u0026lt;int, int\u0026gt;\u003c/code\u003e などとした瞬間、暗黙変換に頼ることはできなくなります。\nそこで、出来れば \u003ccode\u003eok(1)\u003c/code\u003e とか \u003ccode\u003eerr(\"test\")\u003c/code\u003e という感じにしたいのですが、これは一筋縄では行きません。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T, \u003cspan class=\"synType\"\u003etypename\u003c/span\u003e E\u0026gt; \nresult\u0026lt;T, E\u0026gt; ok(T);\n\u003c/pre\u003e\n\n\u003cp\u003eこれだと \u003ccode\u003eT\u003c/code\u003e は推論されても \u003ccode\u003eE\u003c/code\u003e が推論されないので、\u003ccode\u003eok\u0026lt;int, std::string\u0026gt;(1)\u003c/code\u003e などとしなければなりません。これは使いづらすぎます。\u003c/p\u003e\n\n\u003ch2\u003eじゃあどうするか\u003c/h2\u003e\n\n\u003cp\u003e先ほどとは違う形ですが、やっぱり暗黙の型変換を応用します。\u003c/p\u003e\n\n\u003cp\u003e要するに \u003ccode\u003eok\u003c/code\u003e を表す型と \u003ccode\u003eerror\u003c/code\u003e を表す型を区別しつつ、\u003ccode\u003eresult\u0026lt;V, E\u0026gt;\u003c/code\u003e とはなるべくシームレスに変換をしたいというわけですから、それぞれ専用の型を作ってしまえば良いのです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e ok_value {\n  \u003cspan class=\"synType\"\u003eexplicit\u003c/span\u003e ok_value(T t): t(t) {}\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e V, \u003cspan class=\"synType\"\u003etypename\u003c/span\u003e E\u0026gt;\n  \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e result\u0026lt;V, E\u0026gt; () \u003cspan class=\"synType\"\u003econst\u003c/span\u003e;\n\n\u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n  T t;\n};\n\n\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e V, \u003cspan class=\"synType\"\u003etypename\u003c/span\u003e E\u0026gt;\nok_value\u0026lt;T\u0026gt;::\u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e result\u0026lt;V, E\u0026gt; () \u003cspan class=\"synType\"\u003econst\u003c/span\u003e {\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e result\u0026lt;V, E\u0026gt;(t);\n}\n\n\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\nok_value\u0026lt;T\u0026gt; ok(T t) {\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e ok_value\u0026lt;T\u0026gt;(t);\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eok\u003c/code\u003e 側だけ示しました。\u003cbr/\u003e\n\u003ccode\u003eok\u003c/code\u003e 関数はテンプレートになっており、\u003ccode\u003eT\u003c/code\u003e 型の値をとって \u003ccode\u003eok_value\u0026lt;T\u0026gt;\u003c/code\u003e を返します。（本当は値渡し以外にも対応すべきですが、簡単のために値渡しだけ実装しています）\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eok_value\u0026lt;T\u0026gt;\u003c/code\u003e は型変換\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\"\u003e演算子\u003c/a\u003e \u003ccode\u003eoperator result\u0026lt;V, E\u0026gt;() const\u003c/code\u003e を持ちます。これによって \u003ccode\u003eok_value\u003c/code\u003e から \u003ccode\u003eresult\u003c/code\u003e への暗黙変換が可能になります。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eok_value\u0026lt;T\u0026gt;\u003c/code\u003e は \u003ccode\u003eresult\u0026lt;T, E\u0026gt;\u003c/code\u003e に変換出来れば良さそうに見えるのですが、それでは不十分です。\u003cbr/\u003e\n\u003ccode\u003eok(\"test\")\u003c/code\u003e は \u003ccode\u003eok_value\u0026lt;const char*\u0026gt;\u003c/code\u003e を返します。\u003ccode\u003eok_value\u0026lt;T\u0026gt; -\u0026gt; result\u0026lt;T, E\u0026gt;\u003c/code\u003e の変換しか提供していない場合は、\u003ccode\u003eresult\u0026lt;std::string, E\u0026gt;\u003c/code\u003e への変換ができなくなってしまいます。これは不便ですよね。\u003cbr/\u003e\nそこで新たにテンプレート引数を導入することでこれを解決しています。もっときちんとやるなら \u003ccode\u003estd::is_constructible\u003c/code\u003e などを使ってチェックをするべきだとは思いますが。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eerror\u003c/code\u003e 側もほぼ同様のコードを書いてやれば、\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003eresult\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, std::string\u0026gt; parse_digit(\u003cspan class=\"synType\"\u003echar\u003c/span\u003e c) {\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (c \u0026lt; \u003cspan class=\"synConstant\"\u003e'0'\u003c/span\u003e || \u003cspan class=\"synConstant\"\u003e'9'\u003c/span\u003e \u0026lt; c) {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e error(\u003cspan class=\"synConstant\"\u003e\u0026quot;invalid character\u0026quot;\u003c/span\u003e);\n  }\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e ok(c - \u003cspan class=\"synConstant\"\u003e'0'\u003c/span\u003e);\n}\n\u003c/pre\u003e\n\n\u003cp\u003eというように書けます。\u003c/p\u003e\n\n\u003ch2\u003eまとめ\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode\u003eT\u003c/code\u003e から \u003ccode\u003eresult\u0026lt;T, E\u0026gt;\u003c/code\u003e への暗黙変換を許すという方針も全然ありだとは思いますが、個人的に Rust などで \u003ccode\u003eok\u003c/code\u003e なら \u003ccode\u003eok\u003c/code\u003e と明示するスタイルに慣れているので、こっちのほうが気に入っています。\u003cbr/\u003e\n明らかに正常に値を返していそうな感じがコードにあらわれて好きです。\u003c/p\u003e\n\n\u003cp\u003e暗黙の型変換って危険だしあまり良いイメージはないと思うのですが、やっぱりあれば便利ですね。\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e を使っている時点で気を抜いたら死なので、「取り扱いを把握して全力で注意しながら使えば危険じゃない」という気持ちで便利に使いたいものです。\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e や Rust など多くの強力な型システムを持つ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\"\u003eプログラミング言語\u003c/a\u003eは、\u003ccode\u003eEither\u003c/code\u003e とか \u003ccode\u003eResult\u003c/code\u003e といった「失敗するかもしれない」計算の値を示す型を持っています。\u003c/p\u003e\n\n\u003cp\u003e現在の \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の標準ライブラリにはこのような型はありませんので、それを自作してみようというわけです。\u003c/p\u003e\n\n\u003cp\u003eちなみに現在策定中の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e17には \u003ccode\u003estd::optional\u003c/code\u003e が入ることが決定しているようです。これは、\u003ccode\u003eresult\u003c/code\u003e と同様に失敗するかもしれな値を示しますが、失敗した原因がなんなのかを通知する仕組みを持っていません。\u003c/p\u003e\n\n\u003ch2\u003eそもそもどういう型か\u003c/h2\u003e\n\n\u003cp\u003eRust の \u003ccode\u003eResult\u003c/code\u003e 型を例にみてみます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003eenum\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eResult\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eV, E\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"synConstant\"\u003eOk\u003c/span\u003e(V),\n  \u003cspan class=\"synConstant\"\u003eErr\u003c/span\u003e(E),\n}\n\u003c/pre\u003e\n\n\u003cp\u003eRust における \u003ccode\u003eResult\u003c/code\u003e 型はだいたいこんな感じで定義されています。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eResult\u003c/code\u003e は型引数を２つとります。\u003ccode\u003eV\u003c/code\u003e が成功時の値で、\u003ccode\u003eE\u003c/code\u003e が失敗時のエラー情報です。\n例えば、\u003ccode\u003efn parse_int(s: \u0026amp;str) -\u0026gt; Result\u0026lt;isize, String\u0026gt;;\u003c/code\u003e は、文字列を受け取り、それが整数としてパース出来れば \u003ccode\u003eisize\u003c/code\u003e に変換し、\u003ccode\u003eOk(isize)\u003c/code\u003e として返します。\nもし整数としてパース出来ないなどのエラーがあれば、それを \u003ccode\u003eString\u003c/code\u003e で表現し、\u003ccode\u003eErr(String)\u003c/code\u003e で返します。\u003c/p\u003e\n\n\u003cp\u003e本質的にはこれが全てです。ここに、\u003ccode\u003eResult\u003c/code\u003e から中身を取り出す(\u003ccode\u003eErr\u003c/code\u003e なら \u003ccode\u003epanic\u003c/code\u003e する)関数などを定義してあげれば便利にエラー状態を表現できます。\u003cbr/\u003e\n(Rust の \u003ccode\u003etry\u003c/code\u003e マクロはとても便利ですよね)\u003c/p\u003e\n\n\u003ch2\u003eまずはベースとなる result を作る\u003c/h2\u003e\n\n\u003cp\u003eまずはベースとなる \u003ccode\u003eresult\u003c/code\u003e 型を作ってみます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T, \u003cspan class=\"synType\"\u003etypename\u003c/span\u003e E\u0026gt;\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e result {\n\n  result(T \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; ok) : t(tag::OK) {\n    ok_ = ok;\n  }\n\n  result(E \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; e) : t(tag::OK) {\n    err_ = e;\n  }\n\n  ~result() {\n    \u003cspan class=\"synStatement\"\u003eswitch\u003c/span\u003e (t) {\n      \u003cspan class=\"synStatement\"\u003ecase\u003c/span\u003e tag::OK:\n        ok_.~T();\n        \u003cspan class=\"synStatement\"\u003ebreak\u003c/span\u003e;\n      \u003cspan class=\"synStatement\"\u003ecase\u003c/span\u003e tag::ERROR:\n        err_.~E();\n        \u003cspan class=\"synStatement\"\u003ebreak\u003c/span\u003e;\n    }\n  }\n\n  result(result \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; r): t(r.t) {\n    \u003cspan class=\"synStatement\"\u003eswitch\u003c/span\u003e (t) {\n      \u003cspan class=\"synStatement\"\u003ecase\u003c/span\u003e tag::OK:\n        ok_ = r.ok_;\n        \u003cspan class=\"synStatement\"\u003ebreak\u003c/span\u003e;\n      \u003cspan class=\"synStatement\"\u003ecase\u003c/span\u003e tag::ERROR:\n        err_ = r.err_;\n        \u003cspan class=\"synStatement\"\u003ebreak\u003c/span\u003e;\n    }\n  }\n\n  T \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; get() \u003cspan class=\"synType\"\u003econst\u003c/span\u003e {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (t != tag::OK) {\n      \u003cspan class=\"synStatement\"\u003ethrow\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;invalid get operation\u0026quot;\u003c/span\u003e;\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e ok_;\n  }\n\n  E \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; get_error() \u003cspan class=\"synType\"\u003econst\u003c/span\u003e {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (t != tag::ERROR) {\n      \u003cspan class=\"synStatement\"\u003ethrow\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;invalid get operation\u0026quot;\u003c/span\u003e;\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e err_;\n  }\n\n\u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n  \u003cspan class=\"synType\"\u003eenum\u003c/span\u003e \u003cspan class=\"synType\"\u003eclass\u003c/span\u003e tag {\n    OK,\n    ERROR,\n  };\n  tag t;\n  \u003cspan class=\"synType\"\u003eunion\u003c/span\u003e {\n    T ok_;\n    E err_;\n  };\n\n};\n\u003c/pre\u003e\n\n\u003cp\u003eかなり雑ですが、ざっくりこんな感じになるはずです。\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e11 から拡張されて自由度がかなり高くなった \u003ccode\u003eunion\u003c/code\u003e がとても便利です。\u003c/p\u003e\n\n\u003cp\u003eこれで \u003ccode\u003eresult\u0026lt;int, std::string\u0026gt;(1).get()\u003c/code\u003e とやれば \u003ccode\u003e1\u003c/code\u003e が返るし \u003ccode\u003eresult\u0026lt;int, std::string\u0026gt;(std::string(\"test\")).get_error()\u003c/code\u003e で \u003ccode\u003e\"test\"\u003c/code\u003e が返るはずです。\u003c/p\u003e\n\n\u003ch2\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e でやると何が難しいか\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e で難しいのは、Rustより弱い\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\"\u003e型推論\u003c/a\u003eが引き起こす問題です。\u003cbr/\u003e\nRust では、\u003ccode\u003eOk(1isize)\u003c/code\u003e とか \u003ccode\u003eErr(\"error!\".to_owned())\u003c/code\u003e とすれば、その値がどういう型であることが期待されているのかまで含めて\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\"\u003e型推論\u003c/a\u003eや単一化が行われます。\nすなわち、\u003ccode\u003eOk(1isize)\u003c/code\u003e だけを見てもエラーの型がわからないため、\u003ccode\u003eResult\u0026lt;isize, E\u0026gt;\u003c/code\u003e の \u003ccode\u003eE\u003c/code\u003e を決定することが出来ないが、Rust は強力な\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\"\u003e型推論\u003c/a\u003e機構を持つため、これを決定することが出来ます。\u003c/p\u003e\n\n\u003cp\u003e一方、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e では \u003ccode\u003eresult\u0026lt;int, std::string\u0026gt; f() { return 1; }\u003c/code\u003e は \u003ccode\u003eint\u003c/code\u003e から \u003ccode\u003eresult\u0026lt;int, std::string\u0026gt;\u003c/code\u003e の暗黙変換がきくので可能ですが、\u003ccode\u003eresult\u0026lt;int, int\u0026gt;\u003c/code\u003e などとした瞬間、暗黙変換に頼ることはできなくなります。\nそこで、出来れば \u003ccode\u003eok(1)\u003c/code\u003e とか \u003ccode\u003eerr(\"test\")\u003c/code\u003e という感じにしたいのですが、これは一筋縄では行きません。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T, \u003cspan class=\"synType\"\u003etypename\u003c/span\u003e E\u0026gt; \nresult\u0026lt;T, E\u0026gt; ok(T);\n\u003c/pre\u003e\n\n\u003cp\u003eこれだと \u003ccode\u003eT\u003c/code\u003e は推論されても \u003ccode\u003eE\u003c/code\u003e が推論されないので、\u003ccode\u003eok\u0026lt;int, std::string\u0026gt;(1)\u003c/code\u003e などとしなければなりません。これは使いづらすぎます。\u003c/p\u003e\n\n\u003ch2\u003eじゃあどうするか\u003c/h2\u003e\n\n\u003cp\u003e先ほどとは違う形ですが、やっぱり暗黙の型変換を応用します。\u003c/p\u003e\n\n\u003cp\u003e要するに \u003ccode\u003eok\u003c/code\u003e を表す型と \u003ccode\u003eerror\u003c/code\u003e を表す型を区別しつつ、\u003ccode\u003eresult\u0026lt;V, E\u0026gt;\u003c/code\u003e とはなるべくシームレスに変換をしたいというわけですから、それぞれ専用の型を作ってしまえば良いのです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e ok_value {\n  \u003cspan class=\"synType\"\u003eexplicit\u003c/span\u003e ok_value(T t): t(t) {}\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e V, \u003cspan class=\"synType\"\u003etypename\u003c/span\u003e E\u0026gt;\n  \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e result\u0026lt;V, E\u0026gt; () \u003cspan class=\"synType\"\u003econst\u003c/span\u003e;\n\n\u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n  T t;\n};\n\n\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e V, \u003cspan class=\"synType\"\u003etypename\u003c/span\u003e E\u0026gt;\nok_value\u0026lt;T\u0026gt;::\u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e result\u0026lt;V, E\u0026gt; () \u003cspan class=\"synType\"\u003econst\u003c/span\u003e {\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e result\u0026lt;V, E\u0026gt;(t);\n}\n\n\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\nok_value\u0026lt;T\u0026gt; ok(T t) {\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e ok_value\u0026lt;T\u0026gt;(t);\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eok\u003c/code\u003e 側だけ示しました。\u003cbr/\u003e\n\u003ccode\u003eok\u003c/code\u003e 関数はテンプレートになっており、\u003ccode\u003eT\u003c/code\u003e 型の値をとって \u003ccode\u003eok_value\u0026lt;T\u0026gt;\u003c/code\u003e を返します。（本当は値渡し以外にも対応すべきですが、簡単のために値渡しだけ実装しています）\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eok_value\u0026lt;T\u0026gt;\u003c/code\u003e は型変換\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\"\u003e演算子\u003c/a\u003e \u003ccode\u003eoperator result\u0026lt;V, E\u0026gt;() const\u003c/code\u003e を持ちます。これによって \u003ccode\u003eok_value\u003c/code\u003e から \u003ccode\u003eresult\u003c/code\u003e への暗黙変換が可能になります。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eok_value\u0026lt;T\u0026gt;\u003c/code\u003e は \u003ccode\u003eresult\u0026lt;T, E\u0026gt;\u003c/code\u003e に変換出来れば良さそうに見えるのですが、それでは不十分です。\u003cbr/\u003e\n\u003ccode\u003eok(\"test\")\u003c/code\u003e は \u003ccode\u003eok_value\u0026lt;const char*\u0026gt;\u003c/code\u003e を返します。\u003ccode\u003eok_value\u0026lt;T\u0026gt; -\u0026gt; result\u0026lt;T, E\u0026gt;\u003c/code\u003e の変換しか提供していない場合は、\u003ccode\u003eresult\u0026lt;std::string, E\u0026gt;\u003c/code\u003e への変換ができなくなってしまいます。これは不便ですよね。\u003cbr/\u003e\nそこで新たにテンプレート引数を導入することでこれを解決しています。もっときちんとやるなら \u003ccode\u003estd::is_constructible\u003c/code\u003e などを使ってチェックをするべきだとは思いますが。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eerror\u003c/code\u003e 側もほぼ同様のコードを書いてやれば、\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003eresult\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, std::string\u0026gt; parse_digit(\u003cspan class=\"synType\"\u003echar\u003c/span\u003e c) {\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (c \u0026lt; \u003cspan class=\"synConstant\"\u003e'0'\u003c/span\u003e || \u003cspan class=\"synConstant\"\u003e'9'\u003c/span\u003e \u0026lt; c) {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e error(\u003cspan class=\"synConstant\"\u003e\u0026quot;invalid character\u0026quot;\u003c/span\u003e);\n  }\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e ok(c - \u003cspan class=\"synConstant\"\u003e'0'\u003c/span\u003e);\n}\n\u003c/pre\u003e\n\n\u003cp\u003eというように書けます。\u003c/p\u003e\n\n\u003ch2\u003eまとめ\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode\u003eT\u003c/code\u003e から \u003ccode\u003eresult\u0026lt;T, E\u0026gt;\u003c/code\u003e への暗黙変換を許すという方針も全然ありだとは思いますが、個人的に Rust などで \u003ccode\u003eok\u003c/code\u003e なら \u003ccode\u003eok\u003c/code\u003e と明示するスタイルに慣れているので、こっちのほうが気に入っています。\u003cbr/\u003e\n明らかに正常に値を返していそうな感じがコードにあらわれて好きです。\u003c/p\u003e\n\n\u003cp\u003e暗黙の型変換って危険だしあまり良いイメージはないと思うのですが、やっぱりあれば便利ですね。\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e を使っている時点で気を抜いたら死なので、「取り扱いを把握して全力で注意しながら使えば危険じゃない」という気持ちで便利に使いたいものです。\u003c/p\u003e\n\n---\n\n---\n","slug":"C++_で_result_型を作る","title":"C++ で result 型を作る","timestamp":1467383409000,"tags":[]},{"rawMarkdown":"---\ntitle: \"C++テンプレートイディオム CRTP\"\ndate: 2016-06-16T10:27:08.000Z\ntags: []\n---\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eテンプレートの有名なイディオムとして、CRTPというものがあります。\n今回はそれについて。\n複雑な部分特殊化みたいな話もないですし、メリットもわかりやすい良いイディオムだと思うので、ちょっとまとめておきます。\n(Control キーのことをよく CTRL と書くので、CTRP とタイポしがち）\u003c/p\u003e\n\n\u003cp\u003e詳細はこちらを参照してください。\n\u003ca href=\"https://ja.wikibooks.org/wiki/More_C%2B%2B_Idioms/%E5%A5%87%E5%A6%99%E3%81%AB%E5%86%8D%E5%B8%B0%E3%81%97%E3%81%9F%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3(Curiously_Recurring_Template_Pattern\"\u003eMore C++ Idioms/奇妙に再帰したテンプレートパターン(Curiously Recurring Template Pattern) - Wikibooks\u003c/a\u003e)\u003c/p\u003e\n\n\u003ch2\u003eCRTPの利点\u003c/h2\u003e\n\n\u003cp\u003e細かい実装の話の前に、CRTPを使うと何がうれしいのかを簡単に。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e静的 Template Method パターンの実現\u003c/strong\u003e_ 。これがCRTPの利点です。\u003c/p\u003e\n\n\u003cp\u003eTemplate Method パターンについてはここでは説明しませんが、大枠の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\"\u003eアルゴリズム\u003c/a\u003eを共有しつつその内部で使用する実装の詳細をクラスごとに切り替えるといった目的に使われる\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%B6%A5%A4%A5%F3%A5%D1%A5%BF%A1%BC%A5%F3\"\u003eデザインパターン\u003c/a\u003eです。\u003c/p\u003e\n\n\u003cp\u003e通常 Template Method パターンを \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e で実現しようと思うとどうしても仮想関数を使うことになると思います。これによって実行時のオーバヘッドがかかってしまいます。\nTemplate Method パターンは、いわゆるクラスベースの動的な\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DD%A5%EA%A5%E2%A1%BC%A5%D5%A5%A3%A5%BA%A5%E0\"\u003eポリモーフィズム\u003c/a\u003eを必要としないクラスであっても、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\"\u003eアルゴリズム\u003c/a\u003eの共有やボイラープレートコードの削減に非常に有用なパターンです。\nこれを静的に実現するのが CRTP の目的なのです。\u003c/p\u003e\n\n\u003ch2\u003e実装\u003c/h2\u003e\n\n\u003cp\u003eCRTP とは、その名の通り、奇妙に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003eしたテンプレートのパターンのことです。\n情報量０の文章ですね。実際のコードも見たほうがわかりやすいと思います。\u003c/p\u003e\n\n\u003cp\u003e以下に、\u003ccode\u003ecompare\u003c/code\u003e というメソッドから比較\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\"\u003e演算子\u003c/a\u003eを \u003cem\u003ederive\u003c/em\u003e (自動導出) する例をのせます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e comparable {\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e U\u0026gt;\n  \u003cspan class=\"synStatement\"\u003efriend\u003c/span\u003e \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e==(comparable \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; lhs, U \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; rhs) {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synStatement\"\u003estatic_cast\u003c/span\u003e\u0026lt;T \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp;\u0026gt;(lhs).compare(rhs) == \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e U\u0026gt;\n  \u003cspan class=\"synStatement\"\u003efriend\u003c/span\u003e \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e\u0026gt;(comparable \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; lhs, U \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; rhs) {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synStatement\"\u003estatic_cast\u003c/span\u003e\u0026lt;T \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp;\u0026gt;(lhs).compare(rhs) \u0026gt; \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e U\u0026gt;\n  \u003cspan class=\"synStatement\"\u003efriend\u003c/span\u003e \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e\u0026lt;(comparable \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; lhs, U \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; rhs) {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synStatement\"\u003estatic_cast\u003c/span\u003e\u0026lt;T \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp;\u0026gt;(lhs).compare(rhs) \u0026lt; \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n  }\n};\n\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e person : comparable\u0026lt;person\u0026gt; {\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e age;\n\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e compare(person \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; rhs) \u003cspan class=\"synType\"\u003econst\u003c/span\u003e {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e age - rhs.age;\n  }\n};\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main() {\n  person p1, p2;\n  p1.age = \u003cspan class=\"synConstant\"\u003e10\u003c/span\u003e;\n  p2.age = \u003cspan class=\"synConstant\"\u003e100\u003c/span\u003e;\n\n  std::cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; (p1 == p2) \u0026lt;\u0026lt; std::endl;\n  std::cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; (p1 \u0026lt; p2) \u0026lt;\u0026lt; std::endl;\n  std::cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; (p1 \u0026gt; p2) \u0026lt;\u0026lt; std::endl;\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eperson\u003c/code\u003e クラスには \u003ccode\u003eoperator==\u003c/code\u003e など定義していないにもかかわらず、\u003ccode\u003eperson\u003c/code\u003e を比較することが出来ています。\u003c/p\u003e\n\n\u003cp\u003eCRTPの中心となるのは \u003ccode\u003estruct person : comparable\u0026lt;person\u0026gt;\u003c/code\u003e という部分です。\nクラスを定義する際に、自分をテンプレート引数にとるクラスを継承するというコード、これこそが「奇妙な\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003e」なのです。\n実際、\u003ccode\u003estruct person : comparable\u0026lt;person\u0026gt;\u003c/code\u003e の部分ではまだ \u003ccode\u003eperson\u003c/code\u003e がどんな実装になるかはわかっていません。奇妙ですね。\u003c/p\u003e\n\n\u003cp\u003eさて、まずは \u003ccode\u003eperson\u003c/code\u003e の中身を見てみます。\n\u003ccode\u003eperson\u003c/code\u003e では、\u003ccode\u003eperson const\u0026amp;\u003c/code\u003e を引数にとり、それが自分より大きければ正の値を、小さければ負の値を、等しければ0を返すような、\u003ccode\u003ecompare\u003c/code\u003e というメソッドを定義しています。\n\u003ccode\u003eperson\u003c/code\u003e の仕事はこれだけです。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ecomparable\u003c/code\u003e は、テンプレート引数にひとつの型をとります。\u003cbr/\u003e\n\u003ccode\u003ecomparable\u003c/code\u003e はその型が \u003ccode\u003ecompare\u003c/code\u003e というメソッドをもつことを期待しています。(暗黙のインターフェース)\u003cbr/\u003e\n\u003ccode\u003ecomparable\u003c/code\u003e の仕事は \u003ccode\u003ecompare\u003c/code\u003e というひとつのメソッドから、\u003ccode\u003eoperator==\u003c/code\u003e, \u003ccode\u003eoperator\u0026lt;\u003c/code\u003e, \u003ccode\u003eoperator\u0026gt;\u003c/code\u003e を自動的に導くことです。\u003cbr/\u003e\nTemplate Methodパターンをご存じの方ならすんなり理解できるかと思います。\u003c/p\u003e\n\n\u003cp\u003eCRTP のすごいところは、仮想関数をまったく使わないことです。つまり、実行時のテーブルルックアップは発生しません。すべてが静的に決定されるのです。\u003c/p\u003e\n\n\u003ch2\u003eおまけ\u003c/h2\u003e\n\n\u003cp\u003e先に挙げた \u003ccode\u003ecompare\u003c/code\u003e から \u003ccode\u003eoperator==\u003c/code\u003e を自動導出する例ですが、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e の \u003ccode\u003eOrd\u003c/code\u003e 型クラスを意識しています。\u003c/p\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003e\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e Eq a \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e Ord a \u003cspan class=\"synType\"\u003ewhere\u003c/span\u003e\n  compare \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e a \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e a \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e Ordering\n  (\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e), (\u003cspan class=\"synStatement\"\u003e\u0026lt;=\u003c/span\u003e), (\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e), (\u003cspan class=\"synStatement\"\u003e\u0026lt;=\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e a \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e a \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e Bool\n  max, min \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e a \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e a \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e a\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eOrd\u003c/code\u003e 型クラスの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\"\u003eインスタンス\u003c/a\u003eになるためには、最低でも \u003ccode\u003ecompare\u003c/code\u003e を実装している必要があります。\n逆にいえば、\u003ccode\u003ecompare\u003c/code\u003e だけ実装すれば、他の関数は自動的に実装されます。\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e では、\u003ccode\u003eOrd\u003c/code\u003e になるためには \u003ccode\u003eEq\u003c/code\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\"\u003eインスタンス\u003c/a\u003eである必要があります。\nこれを \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e で表現するためには、\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e ord : eq\u0026lt;T\u0026gt; {\n  ...\n};\n\u003c/pre\u003e\n\n\u003cp\u003eこんな感じでしょうか。もちろん型クラスの代替にはなりえないんですけどね。\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e の型クラスの利点のひとつである、最小限のインターフェース実装による関数の自動導出っぽいこともできるよというお話でした。\u003c/p\u003e\n\n\u003cp\u003e実際にテンプレートライブラリを書いてみて改めて有用性がわかったテクニックでした。\n拙作の coco にも導入したい... すべてのパーサにユーティリティ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eを追加するみたいなことが出来るはず... いつかやります。\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eテンプレートの有名なイディオムとして、CRTPというものがあります。\n今回はそれについて。\n複雑な部分特殊化みたいな話もないですし、メリットもわかりやすい良いイディオムだと思うので、ちょっとまとめておきます。\n(Control キーのことをよく CTRL と書くので、CTRP とタイポしがち）\u003c/p\u003e\n\n\u003cp\u003e詳細はこちらを参照してください。\n\u003ca href=\"https://ja.wikibooks.org/wiki/More_C%2B%2B_Idioms/%E5%A5%87%E5%A6%99%E3%81%AB%E5%86%8D%E5%B8%B0%E3%81%97%E3%81%9F%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3(Curiously_Recurring_Template_Pattern\"\u003eMore C++ Idioms/奇妙に再帰したテンプレートパターン(Curiously Recurring Template Pattern) - Wikibooks\u003c/a\u003e)\u003c/p\u003e\n\n\u003ch2\u003eCRTPの利点\u003c/h2\u003e\n\n\u003cp\u003e細かい実装の話の前に、CRTPを使うと何がうれしいのかを簡単に。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e静的 Template Method パターンの実現\u003c/strong\u003e_ 。これがCRTPの利点です。\u003c/p\u003e\n\n\u003cp\u003eTemplate Method パターンについてはここでは説明しませんが、大枠の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\"\u003eアルゴリズム\u003c/a\u003eを共有しつつその内部で使用する実装の詳細をクラスごとに切り替えるといった目的に使われる\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%B6%A5%A4%A5%F3%A5%D1%A5%BF%A1%BC%A5%F3\"\u003eデザインパターン\u003c/a\u003eです。\u003c/p\u003e\n\n\u003cp\u003e通常 Template Method パターンを \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e で実現しようと思うとどうしても仮想関数を使うことになると思います。これによって実行時のオーバヘッドがかかってしまいます。\nTemplate Method パターンは、いわゆるクラスベースの動的な\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DD%A5%EA%A5%E2%A1%BC%A5%D5%A5%A3%A5%BA%A5%E0\"\u003eポリモーフィズム\u003c/a\u003eを必要としないクラスであっても、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\"\u003eアルゴリズム\u003c/a\u003eの共有やボイラープレートコードの削減に非常に有用なパターンです。\nこれを静的に実現するのが CRTP の目的なのです。\u003c/p\u003e\n\n\u003ch2\u003e実装\u003c/h2\u003e\n\n\u003cp\u003eCRTP とは、その名の通り、奇妙に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003eしたテンプレートのパターンのことです。\n情報量０の文章ですね。実際のコードも見たほうがわかりやすいと思います。\u003c/p\u003e\n\n\u003cp\u003e以下に、\u003ccode\u003ecompare\u003c/code\u003e というメソッドから比較\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\"\u003e演算子\u003c/a\u003eを \u003cem\u003ederive\u003c/em\u003e (自動導出) する例をのせます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e comparable {\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e U\u0026gt;\n  \u003cspan class=\"synStatement\"\u003efriend\u003c/span\u003e \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e==(comparable \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; lhs, U \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; rhs) {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synStatement\"\u003estatic_cast\u003c/span\u003e\u0026lt;T \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp;\u0026gt;(lhs).compare(rhs) == \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e U\u0026gt;\n  \u003cspan class=\"synStatement\"\u003efriend\u003c/span\u003e \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e\u0026gt;(comparable \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; lhs, U \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; rhs) {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synStatement\"\u003estatic_cast\u003c/span\u003e\u0026lt;T \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp;\u0026gt;(lhs).compare(rhs) \u0026gt; \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e U\u0026gt;\n  \u003cspan class=\"synStatement\"\u003efriend\u003c/span\u003e \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e\u0026lt;(comparable \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; lhs, U \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; rhs) {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synStatement\"\u003estatic_cast\u003c/span\u003e\u0026lt;T \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp;\u0026gt;(lhs).compare(rhs) \u0026lt; \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n  }\n};\n\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e person : comparable\u0026lt;person\u0026gt; {\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e age;\n\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e compare(person \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; rhs) \u003cspan class=\"synType\"\u003econst\u003c/span\u003e {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e age - rhs.age;\n  }\n};\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main() {\n  person p1, p2;\n  p1.age = \u003cspan class=\"synConstant\"\u003e10\u003c/span\u003e;\n  p2.age = \u003cspan class=\"synConstant\"\u003e100\u003c/span\u003e;\n\n  std::cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; (p1 == p2) \u0026lt;\u0026lt; std::endl;\n  std::cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; (p1 \u0026lt; p2) \u0026lt;\u0026lt; std::endl;\n  std::cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; (p1 \u0026gt; p2) \u0026lt;\u0026lt; std::endl;\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eperson\u003c/code\u003e クラスには \u003ccode\u003eoperator==\u003c/code\u003e など定義していないにもかかわらず、\u003ccode\u003eperson\u003c/code\u003e を比較することが出来ています。\u003c/p\u003e\n\n\u003cp\u003eCRTPの中心となるのは \u003ccode\u003estruct person : comparable\u0026lt;person\u0026gt;\u003c/code\u003e という部分です。\nクラスを定義する際に、自分をテンプレート引数にとるクラスを継承するというコード、これこそが「奇妙な\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003e」なのです。\n実際、\u003ccode\u003estruct person : comparable\u0026lt;person\u0026gt;\u003c/code\u003e の部分ではまだ \u003ccode\u003eperson\u003c/code\u003e がどんな実装になるかはわかっていません。奇妙ですね。\u003c/p\u003e\n\n\u003cp\u003eさて、まずは \u003ccode\u003eperson\u003c/code\u003e の中身を見てみます。\n\u003ccode\u003eperson\u003c/code\u003e では、\u003ccode\u003eperson const\u0026amp;\u003c/code\u003e を引数にとり、それが自分より大きければ正の値を、小さければ負の値を、等しければ0を返すような、\u003ccode\u003ecompare\u003c/code\u003e というメソッドを定義しています。\n\u003ccode\u003eperson\u003c/code\u003e の仕事はこれだけです。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ecomparable\u003c/code\u003e は、テンプレート引数にひとつの型をとります。\u003cbr/\u003e\n\u003ccode\u003ecomparable\u003c/code\u003e はその型が \u003ccode\u003ecompare\u003c/code\u003e というメソッドをもつことを期待しています。(暗黙のインターフェース)\u003cbr/\u003e\n\u003ccode\u003ecomparable\u003c/code\u003e の仕事は \u003ccode\u003ecompare\u003c/code\u003e というひとつのメソッドから、\u003ccode\u003eoperator==\u003c/code\u003e, \u003ccode\u003eoperator\u0026lt;\u003c/code\u003e, \u003ccode\u003eoperator\u0026gt;\u003c/code\u003e を自動的に導くことです。\u003cbr/\u003e\nTemplate Methodパターンをご存じの方ならすんなり理解できるかと思います。\u003c/p\u003e\n\n\u003cp\u003eCRTP のすごいところは、仮想関数をまったく使わないことです。つまり、実行時のテーブルルックアップは発生しません。すべてが静的に決定されるのです。\u003c/p\u003e\n\n\u003ch2\u003eおまけ\u003c/h2\u003e\n\n\u003cp\u003e先に挙げた \u003ccode\u003ecompare\u003c/code\u003e から \u003ccode\u003eoperator==\u003c/code\u003e を自動導出する例ですが、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e の \u003ccode\u003eOrd\u003c/code\u003e 型クラスを意識しています。\u003c/p\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003e\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e Eq a \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e Ord a \u003cspan class=\"synType\"\u003ewhere\u003c/span\u003e\n  compare \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e a \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e a \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e Ordering\n  (\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e), (\u003cspan class=\"synStatement\"\u003e\u0026lt;=\u003c/span\u003e), (\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e), (\u003cspan class=\"synStatement\"\u003e\u0026lt;=\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e a \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e a \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e Bool\n  max, min \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e a \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e a \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e a\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eOrd\u003c/code\u003e 型クラスの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\"\u003eインスタンス\u003c/a\u003eになるためには、最低でも \u003ccode\u003ecompare\u003c/code\u003e を実装している必要があります。\n逆にいえば、\u003ccode\u003ecompare\u003c/code\u003e だけ実装すれば、他の関数は自動的に実装されます。\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e では、\u003ccode\u003eOrd\u003c/code\u003e になるためには \u003ccode\u003eEq\u003c/code\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\"\u003eインスタンス\u003c/a\u003eである必要があります。\nこれを \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e で表現するためには、\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e ord : eq\u0026lt;T\u0026gt; {\n  ...\n};\n\u003c/pre\u003e\n\n\u003cp\u003eこんな感じでしょうか。もちろん型クラスの代替にはなりえないんですけどね。\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e の型クラスの利点のひとつである、最小限のインターフェース実装による関数の自動導出っぽいこともできるよというお話でした。\u003c/p\u003e\n\n\u003cp\u003e実際にテンプレートライブラリを書いてみて改めて有用性がわかったテクニックでした。\n拙作の coco にも導入したい... すべてのパーサにユーティリティ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eを追加するみたいなことが出来るはず... いつかやります。\u003c/p\u003e\n\n---\n\n---\n","slug":"C++テンプレートイディオム_CRTP","title":"C++テンプレートイディオム CRTP","timestamp":1466072828000,"tags":[]},{"rawMarkdown":"---\ntitle: \"C++ のテンプレートの実装\"\ndate: 2016-06-13T07:59:27.000Z\ntags: []\n---\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のテンプレートがなぜ必要で，どんな構文・種類のものがあるかについては前回までにまとめました。\u003cbr/\u003e\nというわけで次は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e ではテンプレートという機能を使用するとどんな\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\"\u003eバイ\u003c/a\u003eナリが生成されるのかについて見ていきます。\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のテンプレートの強力さとか勘所みたいなものを把握するために非常に重要な部分なので、覚えておくとよいと思います。\u003c/p\u003e\n\n\u003ch2\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e でテンプレートを\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eしてみる\u003c/h2\u003e\n\n\u003cp\u003e早速ですが、実際に \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e でテンプレートを使っているコードを\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eしてみます。\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%BB%A5%F3%A5%D6%A5%EA\"\u003eアセンブリ\u003c/a\u003eよりも \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR のほうがわかりやすいかな？と思うので、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR を clang++ で生成させてみます。\n（\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR については \u003ca href=\"http://postd.cc/llvm-for-grad-students/\"\u003e大学院生のためのLLVM | インフラ・ミドルウェア | POSTD\u003c/a\u003e あたりを読んでおくとなんとなく概念がつかめると思います。公式は\u003ca href=\"http://llvm.org/docs/LangRef.html\"\u003eLLVM Language Reference Manual — LLVM 3.9 documentation\u003c/a\u003e）\u003c/p\u003e\n\n\u003cp\u003e対象となるコードはこちら。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synComment\"\u003e// main.cpp\u003c/span\u003e\n\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\nT identity(T x) {\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e x;\n}\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main() {\n  \u003cspan class=\"synType\"\u003efloat\u003c/span\u003e f = \u003cspan class=\"synConstant\"\u003e0.0f\u003c/span\u003e;\n  identity(f);\n\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e d = \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n  identity(d);\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n}\n\u003c/pre\u003e\n\n\u003cp\u003eclang++ で \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR を生成させるには，\u003ccode\u003e-S -emit-llvm\u003c/code\u003e をオプションに指定します。また、今回のコードは最適化されてしまうとほとんどコードが残らないので、最適化を抑制するよう、\u003ccode\u003e-O0\u003c/code\u003e を付けます。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e$ clang++ -O0 -S -emit-llvm main.cpp\u003c/pre\u003e\n\n\u003cp\u003eすると \u003ccode\u003emain.ll\u003c/code\u003e というファイルが出来ています。これが \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR です。\u003c/p\u003e\n\n\u003ch2\u003eIR を読む\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR は，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e という\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003e基盤技術における中間表現 (Intermediate Representation) です。\u003cbr/\u003e\nざっくり言うと、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3\"\u003eアーキテクチャ\u003c/a\u003eに依存しない、読みやすい\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%BB%A5%F3%A5%D6%A5%EA\"\u003eアセンブリ\u003c/a\u003eです。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003emain.ll\u003c/code\u003e はそこまで長くないですが、エッセンスだけ抜粋します。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003edefine i32 @main() #0 { ;; main 関数\n  %1 = alloca i32, align 4\n  %f = alloca float, align 4\n  %d = alloca i32, align 4\n  store i32 0, i32* %1\n  store float 0.000000e+00, float* %f, align 4\n  %2 = load float* %f, align 4\n  %3 = call float @_Z8identityIfET_S0_(float %2)\n  store i32 0, i32* %d, align 4\n  %4 = load i32* %d, align 4\n  %5 = call i32 @_Z8identityIiET_S0_(i32 %4)\n  ret i32 0\n}\n\ndefine linkonce_odr float @_Z8identityIfET_S0_(float %x) #1 { ;; identity\u0026lt;float\u0026gt; の実体\n  %1 = alloca float, align 4\n  store float %x, float* %1, align 4\n  %2 = load float* %1, align 4\n  ret float %2\n}\n\ndefine linkonce_odr i32 @_Z8identityIiET_S0_(i32 %x) #1 { ;; identity\u0026lt;int\u0026gt; の実体\n  %1 = alloca i32, align 4\n  store i32 %x, i32* %1, align 4\n  %2 = load i32* %1, align 4\n  ret i32 %2\n}\u003c/pre\u003e\n\n\u003cp\u003eコメントでも書きましたが、3 つの関数が定義されていることがわかると思います。\nここで重要なのは、 \u003cstrong\u003eidentity\u0026lt;int\u003eとidentity\u0026lt;float\u003eがそれぞれ別の関数として定義されている\u003c/strong\u003e ことです。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eidentity\u0026lt;int\u0026gt;\u003c/code\u003e と \u003ccode\u003eidentity\u0026lt;float\u0026gt;\u003c/code\u003e は \u003ccode\u003emain\u003c/code\u003e の中で使われています。\u003cbr/\u003e\nつまり、テンプレートは、「使った分だけ実体が作られる。かつその処理は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時に終わる。」ということがわかります。\u003cbr/\u003e\nたとえば\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\"\u003eソースコード\u003c/a\u003e中に \u003ccode\u003eidentity\u0026lt;bool\u0026gt;\u003c/code\u003e の実体化を要求するコードがあれば、その時はじめて \u003ccode\u003eidentity\u0026lt;bool\u0026gt;\u003c/code\u003e が作られます。\n独自定義でも構いません。\u003ccode\u003eidentity\u0026lt;MyClass\u0026gt;\u003c/code\u003e の実体化を要求するコードがあれば、その時はじめて \u003ccode\u003eidentity\u0026lt;MyClass\u0026gt;\u003c/code\u003e が作られます。\u003c/p\u003e\n\n\u003cp\u003eもちろん、一度実体化されたテンプレートは再利用されます。つまり、\u003ccode\u003eidentity\u0026lt;int\u0026gt;\u003c/code\u003e を要求するコードが、一つの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\"\u003eソースコード\u003c/a\u003eに何度現れても、ただひとつの \u003ccode\u003eidentity\u0026lt;int\u0026gt;\u003c/code\u003e が生成されます。\u003c/p\u003e\n\n\u003ch2\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e との比較\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e にも\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eという仕組みがあります。\u003cbr/\u003e\n概念的にはテンプレートに似たものなので、比較してみます (テンプレートの方がより強力ですが、型を汎用化したいという目的であれば、両者とも同様に使用できます。)\u003c/p\u003e\n\n\u003cp\u003e同じようなコードを\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eして\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\"\u003eバイトコード\u003c/a\u003eを見てみます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-java\" data-lang=\"java\" data-unlink\u003e\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e Main {\n  \u003cspan class=\"synType\"\u003estatic\u003c/span\u003e \u0026lt;T\u0026gt; T identity(T x) {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e x;\n  }\n\n  \u003cspan class=\"synType\"\u003epublic\u003c/span\u003e \u003cspan class=\"synType\"\u003estatic\u003c/span\u003e \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e main(String[] args) {\n    Integer d = \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e;\n    Float f = \u003cspan class=\"synConstant\"\u003e0.0f\u003c/span\u003e;\n    Main.identity(f);\n    Main.identity(d);\n  }\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003ejavac Main.java\u003c/code\u003e してから、\u003ccode\u003ejavap -v Main\u003c/code\u003e します。これで\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\"\u003eバイトコード\u003c/a\u003eが出力されます。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eclass Main\n/* 中略 */\n{\n  Main();\n    descriptor: ()V\n    flags:\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V\n         4: return\n      LineNumberTable:\n        line 1: 0\n\n  static \u0026lt;T extends java.lang.Object\u0026gt; T identity(T);\n    descriptor: (Ljava/lang/Object;)Ljava/lang/Object;\n    flags: ACC_STATIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: areturn\n      LineNumberTable:\n        line 3: 0\n    Signature: #14                          // \u0026lt;T:Ljava/lang/Object;\u0026gt;(TT;)TT;\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=1, locals=3, args_size=1\n         0: iconst_1\n         1: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n         4: astore_1\n         5: fconst_0\n         6: invokestatic  #3                  // Method java/lang/Float.valueOf:(F)Ljava/lang/Float;\n         9: astore_2\n        10: aload_2\n        11: invokestatic  #4                  // Method identity:(Ljava/lang/Object;)Ljava/lang/Object;\n        14: pop\n        15: aload_1\n        16: invokestatic  #4                  // Method identity:(Ljava/lang/Object;)Ljava/lang/Object;\n        19: pop\n        20: return\n      LineNumberTable:\n        line 7: 0\n        line 8: 5\n        line 9: 10\n        line 10: 15\n        line 11: 20\n}\nSourceFile: \u0026#34;Main.java\u0026#34;\u003c/pre\u003e\n\n\u003cp\u003e注目すべきは \u003ccode\u003e// Method identity:(Ljava/lang/Object;)Ljava/lang/Object;\u003c/code\u003e というコメントのついた行です。\u003cbr/\u003e\n2 行ありますが、それぞれ \u003ccode\u003eidentity(d)\u003c/code\u003e と \u003ccode\u003eidentity(f)\u003c/code\u003e に相当します。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eInteger.valueOf\u003c/code\u003e や \u003ccode\u003eFloat.valueOf\u003c/code\u003e を含むコメントを見ていただければわかると思いますが、このコメント部分には呼び出しているメソッドの型が記されています。\u003cbr/\u003e\nつまり、\u003ccode\u003eidentity\u003c/code\u003e は \u003ccode\u003eInteger\u003c/code\u003e で呼んでも \u003ccode\u003eFloat\u003c/code\u003e で呼んでも \u003ccode\u003eObject identity(Object)\u003c/code\u003e を呼んでいるということです。\u003c/p\u003e\n\n\u003cp\u003eこれは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eの大きな特徴で型消去などと呼ばれる性質です。\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eによる型はすべて\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時にのみ利用され、実行時にはすべて \u003ccode\u003eObject\u003c/code\u003e として表現しつつ適切にキャストを挟むような構造になっています。\u003cbr/\u003e\nキャストはキャストでも、正しいことが\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eによって保証されたキャストになるので、\u003ccode\u003eList\u003c/code\u003e よりも \u003ccode\u003eList\u0026lt;String\u0026gt;\u003c/code\u003e のほうが安全というわけです。\u003c/p\u003e\n\n\u003ch2\u003eそれぞれの利点と欠点\u003c/h2\u003e\n\n\u003cp\u003eテンプレートや\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eを実現する方法として、2つの例を上げました。\u003cbr/\u003e\n一つは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の採用している方式で、テンプレート引数ごとに新しく実体を作ってしまう方式です。\u003cbr/\u003e\nもう一つは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e の採用している方式で、\u003ccode\u003eObject\u003c/code\u003e のようにすべての型を受け取れる基底クラスのようなものを用いて、実行時には型情報を残さない方式です。\u003c/p\u003e\n\n\u003cp\u003e今回はたまたま \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e と \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e を例にあげましたが、他の言語でもこのような方式を使っている言語は多いです。（みんなだいすき D 言語は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の方式を採用しています）\u003c/p\u003e\n\n\u003cp\u003eさてそれぞれの利点と欠点についてです。\u003c/p\u003e\n\n\u003ch3\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e 方式\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e利点\n\n\u003cul\u003e\n\u003cli\u003e分割\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eが容易（\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eな関数を提供する側は \u003ccode\u003eObject\u003c/code\u003e を入れた\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\"\u003eバイ\u003c/a\u003eナリや\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\"\u003eバイトコード\u003c/a\u003eと、型情報だけを生成すればよい。使用する側は、型情報から型検査を行った後、\u003ccode\u003eObject\u003c/code\u003e へのキャストなどを含めた\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\"\u003eバイ\u003c/a\u003eナリや\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\"\u003eバイトコード\u003c/a\u003eをはけば良い）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e欠点\n\n\u003cul\u003e\n\u003cli\u003e実行時にやることが増えるのでオーバヘッドがある\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e 方式\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e利点\n\n\u003cul\u003e\n\u003cli\u003e実行時オーバヘッドなし（全て\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時に解決される）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e欠点\n\n\u003cul\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\"\u003eバイ\u003c/a\u003eナリサイズの増加\u003c/li\u003e\n\u003cli\u003e分割\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eが困難 (テンプレートを実体化しようと思うと、型情報だけでは足りない。使用者側が定義そのものをまるまる知っている必要がある。)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eこんな感じでしょうか。\u003cbr/\u003e\nこの比較はあくまで型を汎用化したいという目的に関しての比較です。\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のテンプレートにできて \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eに出来ないことはたくさんあります。\u003c/p\u003e\n\n\u003ch2\u003eまとめ\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eer はみんな実行時のオーバヘッドが嫌いです。テンプレートは、今までに紹介してきた使用法からは想像も出来ないほど豊富な計算を、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時にすべて行うことが出来ます。実行時のオーバヘッドなしで。\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時にテンプレートの解決が終わるということは、強力な最適化が望めるということでもあります。つまり、実行時のキャストといったわかりやすいオーバヘッド以上に、実行速度には差が生まれるでしょう。\u003c/p\u003e\n\n\u003cp\u003eというわけで今回はテンプレートの実現方法について、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e と比較しながら説明してみました。\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のテンプレートがなぜ必要で，どんな構文・種類のものがあるかについては前回までにまとめました。\u003cbr/\u003e\nというわけで次は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e ではテンプレートという機能を使用するとどんな\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\"\u003eバイ\u003c/a\u003eナリが生成されるのかについて見ていきます。\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のテンプレートの強力さとか勘所みたいなものを把握するために非常に重要な部分なので、覚えておくとよいと思います。\u003c/p\u003e\n\n\u003ch2\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e でテンプレートを\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eしてみる\u003c/h2\u003e\n\n\u003cp\u003e早速ですが、実際に \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e でテンプレートを使っているコードを\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eしてみます。\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%BB%A5%F3%A5%D6%A5%EA\"\u003eアセンブリ\u003c/a\u003eよりも \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR のほうがわかりやすいかな？と思うので、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR を clang++ で生成させてみます。\n（\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR については \u003ca href=\"http://postd.cc/llvm-for-grad-students/\"\u003e大学院生のためのLLVM | インフラ・ミドルウェア | POSTD\u003c/a\u003e あたりを読んでおくとなんとなく概念がつかめると思います。公式は\u003ca href=\"http://llvm.org/docs/LangRef.html\"\u003eLLVM Language Reference Manual — LLVM 3.9 documentation\u003c/a\u003e）\u003c/p\u003e\n\n\u003cp\u003e対象となるコードはこちら。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synComment\"\u003e// main.cpp\u003c/span\u003e\n\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\nT identity(T x) {\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e x;\n}\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main() {\n  \u003cspan class=\"synType\"\u003efloat\u003c/span\u003e f = \u003cspan class=\"synConstant\"\u003e0.0f\u003c/span\u003e;\n  identity(f);\n\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e d = \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n  identity(d);\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n}\n\u003c/pre\u003e\n\n\u003cp\u003eclang++ で \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR を生成させるには，\u003ccode\u003e-S -emit-llvm\u003c/code\u003e をオプションに指定します。また、今回のコードは最適化されてしまうとほとんどコードが残らないので、最適化を抑制するよう、\u003ccode\u003e-O0\u003c/code\u003e を付けます。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e$ clang++ -O0 -S -emit-llvm main.cpp\u003c/pre\u003e\n\n\u003cp\u003eすると \u003ccode\u003emain.ll\u003c/code\u003e というファイルが出来ています。これが \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR です。\u003c/p\u003e\n\n\u003ch2\u003eIR を読む\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR は，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e という\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003e基盤技術における中間表現 (Intermediate Representation) です。\u003cbr/\u003e\nざっくり言うと、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3\"\u003eアーキテクチャ\u003c/a\u003eに依存しない、読みやすい\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%BB%A5%F3%A5%D6%A5%EA\"\u003eアセンブリ\u003c/a\u003eです。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003emain.ll\u003c/code\u003e はそこまで長くないですが、エッセンスだけ抜粋します。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003edefine i32 @main() #0 { ;; main 関数\n  %1 = alloca i32, align 4\n  %f = alloca float, align 4\n  %d = alloca i32, align 4\n  store i32 0, i32* %1\n  store float 0.000000e+00, float* %f, align 4\n  %2 = load float* %f, align 4\n  %3 = call float @_Z8identityIfET_S0_(float %2)\n  store i32 0, i32* %d, align 4\n  %4 = load i32* %d, align 4\n  %5 = call i32 @_Z8identityIiET_S0_(i32 %4)\n  ret i32 0\n}\n\ndefine linkonce_odr float @_Z8identityIfET_S0_(float %x) #1 { ;; identity\u0026lt;float\u0026gt; の実体\n  %1 = alloca float, align 4\n  store float %x, float* %1, align 4\n  %2 = load float* %1, align 4\n  ret float %2\n}\n\ndefine linkonce_odr i32 @_Z8identityIiET_S0_(i32 %x) #1 { ;; identity\u0026lt;int\u0026gt; の実体\n  %1 = alloca i32, align 4\n  store i32 %x, i32* %1, align 4\n  %2 = load i32* %1, align 4\n  ret i32 %2\n}\u003c/pre\u003e\n\n\u003cp\u003eコメントでも書きましたが、3 つの関数が定義されていることがわかると思います。\nここで重要なのは、 \u003cstrong\u003eidentity\u0026lt;int\u003eとidentity\u0026lt;float\u003eがそれぞれ別の関数として定義されている\u003c/strong\u003e ことです。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eidentity\u0026lt;int\u0026gt;\u003c/code\u003e と \u003ccode\u003eidentity\u0026lt;float\u0026gt;\u003c/code\u003e は \u003ccode\u003emain\u003c/code\u003e の中で使われています。\u003cbr/\u003e\nつまり、テンプレートは、「使った分だけ実体が作られる。かつその処理は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時に終わる。」ということがわかります。\u003cbr/\u003e\nたとえば\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\"\u003eソースコード\u003c/a\u003e中に \u003ccode\u003eidentity\u0026lt;bool\u0026gt;\u003c/code\u003e の実体化を要求するコードがあれば、その時はじめて \u003ccode\u003eidentity\u0026lt;bool\u0026gt;\u003c/code\u003e が作られます。\n独自定義でも構いません。\u003ccode\u003eidentity\u0026lt;MyClass\u0026gt;\u003c/code\u003e の実体化を要求するコードがあれば、その時はじめて \u003ccode\u003eidentity\u0026lt;MyClass\u0026gt;\u003c/code\u003e が作られます。\u003c/p\u003e\n\n\u003cp\u003eもちろん、一度実体化されたテンプレートは再利用されます。つまり、\u003ccode\u003eidentity\u0026lt;int\u0026gt;\u003c/code\u003e を要求するコードが、一つの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\"\u003eソースコード\u003c/a\u003eに何度現れても、ただひとつの \u003ccode\u003eidentity\u0026lt;int\u0026gt;\u003c/code\u003e が生成されます。\u003c/p\u003e\n\n\u003ch2\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e との比較\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e にも\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eという仕組みがあります。\u003cbr/\u003e\n概念的にはテンプレートに似たものなので、比較してみます (テンプレートの方がより強力ですが、型を汎用化したいという目的であれば、両者とも同様に使用できます。)\u003c/p\u003e\n\n\u003cp\u003e同じようなコードを\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eして\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\"\u003eバイトコード\u003c/a\u003eを見てみます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-java\" data-lang=\"java\" data-unlink\u003e\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e Main {\n  \u003cspan class=\"synType\"\u003estatic\u003c/span\u003e \u0026lt;T\u0026gt; T identity(T x) {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e x;\n  }\n\n  \u003cspan class=\"synType\"\u003epublic\u003c/span\u003e \u003cspan class=\"synType\"\u003estatic\u003c/span\u003e \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e main(String[] args) {\n    Integer d = \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e;\n    Float f = \u003cspan class=\"synConstant\"\u003e0.0f\u003c/span\u003e;\n    Main.identity(f);\n    Main.identity(d);\n  }\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003ejavac Main.java\u003c/code\u003e してから、\u003ccode\u003ejavap -v Main\u003c/code\u003e します。これで\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\"\u003eバイトコード\u003c/a\u003eが出力されます。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eclass Main\n/* 中略 */\n{\n  Main();\n    descriptor: ()V\n    flags:\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V\n         4: return\n      LineNumberTable:\n        line 1: 0\n\n  static \u0026lt;T extends java.lang.Object\u0026gt; T identity(T);\n    descriptor: (Ljava/lang/Object;)Ljava/lang/Object;\n    flags: ACC_STATIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: areturn\n      LineNumberTable:\n        line 3: 0\n    Signature: #14                          // \u0026lt;T:Ljava/lang/Object;\u0026gt;(TT;)TT;\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=1, locals=3, args_size=1\n         0: iconst_1\n         1: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n         4: astore_1\n         5: fconst_0\n         6: invokestatic  #3                  // Method java/lang/Float.valueOf:(F)Ljava/lang/Float;\n         9: astore_2\n        10: aload_2\n        11: invokestatic  #4                  // Method identity:(Ljava/lang/Object;)Ljava/lang/Object;\n        14: pop\n        15: aload_1\n        16: invokestatic  #4                  // Method identity:(Ljava/lang/Object;)Ljava/lang/Object;\n        19: pop\n        20: return\n      LineNumberTable:\n        line 7: 0\n        line 8: 5\n        line 9: 10\n        line 10: 15\n        line 11: 20\n}\nSourceFile: \u0026#34;Main.java\u0026#34;\u003c/pre\u003e\n\n\u003cp\u003e注目すべきは \u003ccode\u003e// Method identity:(Ljava/lang/Object;)Ljava/lang/Object;\u003c/code\u003e というコメントのついた行です。\u003cbr/\u003e\n2 行ありますが、それぞれ \u003ccode\u003eidentity(d)\u003c/code\u003e と \u003ccode\u003eidentity(f)\u003c/code\u003e に相当します。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eInteger.valueOf\u003c/code\u003e や \u003ccode\u003eFloat.valueOf\u003c/code\u003e を含むコメントを見ていただければわかると思いますが、このコメント部分には呼び出しているメソッドの型が記されています。\u003cbr/\u003e\nつまり、\u003ccode\u003eidentity\u003c/code\u003e は \u003ccode\u003eInteger\u003c/code\u003e で呼んでも \u003ccode\u003eFloat\u003c/code\u003e で呼んでも \u003ccode\u003eObject identity(Object)\u003c/code\u003e を呼んでいるということです。\u003c/p\u003e\n\n\u003cp\u003eこれは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eの大きな特徴で型消去などと呼ばれる性質です。\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eによる型はすべて\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時にのみ利用され、実行時にはすべて \u003ccode\u003eObject\u003c/code\u003e として表現しつつ適切にキャストを挟むような構造になっています。\u003cbr/\u003e\nキャストはキャストでも、正しいことが\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eによって保証されたキャストになるので、\u003ccode\u003eList\u003c/code\u003e よりも \u003ccode\u003eList\u0026lt;String\u0026gt;\u003c/code\u003e のほうが安全というわけです。\u003c/p\u003e\n\n\u003ch2\u003eそれぞれの利点と欠点\u003c/h2\u003e\n\n\u003cp\u003eテンプレートや\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eを実現する方法として、2つの例を上げました。\u003cbr/\u003e\n一つは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の採用している方式で、テンプレート引数ごとに新しく実体を作ってしまう方式です。\u003cbr/\u003e\nもう一つは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e の採用している方式で、\u003ccode\u003eObject\u003c/code\u003e のようにすべての型を受け取れる基底クラスのようなものを用いて、実行時には型情報を残さない方式です。\u003c/p\u003e\n\n\u003cp\u003e今回はたまたま \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e と \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e を例にあげましたが、他の言語でもこのような方式を使っている言語は多いです。（みんなだいすき D 言語は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の方式を採用しています）\u003c/p\u003e\n\n\u003cp\u003eさてそれぞれの利点と欠点についてです。\u003c/p\u003e\n\n\u003ch3\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e 方式\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e利点\n\n\u003cul\u003e\n\u003cli\u003e分割\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eが容易（\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eな関数を提供する側は \u003ccode\u003eObject\u003c/code\u003e を入れた\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\"\u003eバイ\u003c/a\u003eナリや\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\"\u003eバイトコード\u003c/a\u003eと、型情報だけを生成すればよい。使用する側は、型情報から型検査を行った後、\u003ccode\u003eObject\u003c/code\u003e へのキャストなどを含めた\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\"\u003eバイ\u003c/a\u003eナリや\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\"\u003eバイトコード\u003c/a\u003eをはけば良い）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e欠点\n\n\u003cul\u003e\n\u003cli\u003e実行時にやることが増えるのでオーバヘッドがある\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e 方式\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e利点\n\n\u003cul\u003e\n\u003cli\u003e実行時オーバヘッドなし（全て\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時に解決される）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e欠点\n\n\u003cul\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\"\u003eバイ\u003c/a\u003eナリサイズの増加\u003c/li\u003e\n\u003cli\u003e分割\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eが困難 (テンプレートを実体化しようと思うと、型情報だけでは足りない。使用者側が定義そのものをまるまる知っている必要がある。)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eこんな感じでしょうか。\u003cbr/\u003e\nこの比較はあくまで型を汎用化したいという目的に関しての比較です。\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のテンプレートにできて \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eに出来ないことはたくさんあります。\u003c/p\u003e\n\n\u003ch2\u003eまとめ\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eer はみんな実行時のオーバヘッドが嫌いです。テンプレートは、今までに紹介してきた使用法からは想像も出来ないほど豊富な計算を、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時にすべて行うことが出来ます。実行時のオーバヘッドなしで。\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時にテンプレートの解決が終わるということは、強力な最適化が望めるということでもあります。つまり、実行時のキャストといったわかりやすいオーバヘッド以上に、実行速度には差が生まれるでしょう。\u003c/p\u003e\n\n\u003cp\u003eというわけで今回はテンプレートの実現方法について、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e と比較しながら説明してみました。\u003c/p\u003e\n\n---\n\n---\n","slug":"C++_のテンプレートの実装","title":"C++ のテンプレートの実装","timestamp":1465804767000,"tags":[]},{"rawMarkdown":"---\ntitle: \"C++ のテンプレートについてまとめるのまとめ\"\ndate: 2016-06-03T03:54:57.000Z\ntags: []\n---\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のテンプレートについてまとめているのでそれらをまとめておきます。\u003cbr/\u003e\n今後の予定も合わせて目次にしておきます。\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eなぜテンプレートが必要なのか\n \u003ciframe src=\"http://agtn.hatenablog.com/embed/2016/05/30/234647\" title=\"C++ のテンプレートについてまとめる（１）なぜテンプレートが必要なのか - refer to 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"http://agtn.hatenablog.com/entry/2016/05/30/234647\"\u003eagtn.hatenablog.com\u003c/a\u003e\u003c/cite\u003e\u003c/li\u003e\n\u003cli\u003eテンプレートの種類と構文\n\u003ciframe src=\"http://agtn.hatenablog.com/embed/2016/05/31/175756\" title=\"C++ のテンプレートについてまとめる(２) テンプレートの種類と構文 - refer to 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"http://agtn.hatenablog.com/entry/2016/05/31/175756\"\u003eagtn.hatenablog.com\u003c/a\u003e\u003c/cite\u003e\u003c/li\u003e\n\u003cli\u003e(おまけ) テンプレートの実行時表現と\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e方法\u003c/li\u003e\n\u003cli\u003e特殊化と部分特殊化\u003c/li\u003e\n\u003cli\u003eメタ関数\u003c/li\u003e\n\u003cli\u003eSFINAE\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e後々CRTPやtype erasureについてもまとめていけたらと思います\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のテンプレートについてまとめているのでそれらをまとめておきます。\u003cbr/\u003e\n今後の予定も合わせて目次にしておきます。\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eなぜテンプレートが必要なのか\n \u003ciframe src=\"http://agtn.hatenablog.com/embed/2016/05/30/234647\" title=\"C++ のテンプレートについてまとめる（１）なぜテンプレートが必要なのか - refer to 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"http://agtn.hatenablog.com/entry/2016/05/30/234647\"\u003eagtn.hatenablog.com\u003c/a\u003e\u003c/cite\u003e\u003c/li\u003e\n\u003cli\u003eテンプレートの種類と構文\n\u003ciframe src=\"http://agtn.hatenablog.com/embed/2016/05/31/175756\" title=\"C++ のテンプレートについてまとめる(２) テンプレートの種類と構文 - refer to 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"http://agtn.hatenablog.com/entry/2016/05/31/175756\"\u003eagtn.hatenablog.com\u003c/a\u003e\u003c/cite\u003e\u003c/li\u003e\n\u003cli\u003e(おまけ) テンプレートの実行時表現と\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e方法\u003c/li\u003e\n\u003cli\u003e特殊化と部分特殊化\u003c/li\u003e\n\u003cli\u003eメタ関数\u003c/li\u003e\n\u003cli\u003eSFINAE\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e後々CRTPやtype erasureについてもまとめていけたらと思います\u003c/p\u003e\n\n---\n\n---\n","slug":"C++_のテンプレートについてまとめるのまとめ","title":"C++ のテンプレートについてまとめるのまとめ","timestamp":1464926097000,"tags":[]},{"rawMarkdown":"---\ntitle: \"C++ テンプレートの種類と構文\"\ndate: 2016-05-31T08:57:56.000Z\ntags: []\n---\n\n\u003cp\u003e前回テンプレートがなぜ必要なのかについて簡単にまとめたので、今回はその構文や種類についてまとめたいと思います。\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"http://agtn.hatenablog.com/embed/2016/05/30/234647\" title=\"C++ のテンプレートについてまとめる（１）なぜテンプレートが必要なのか - refer to 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"http://agtn.hatenablog.com/entry/2016/05/30/234647\"\u003eagtn.hatenablog.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003ch2\u003eアウトライン\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003eテンプレートの種類と構文\n\n\u003cul\u003e\n\u003cli\u003e定義する\u003c/li\u003e\n\u003cli\u003e使用する(\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\"\u003eインスタンス\u003c/a\u003e化)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eクラステンプレート\u003c/li\u003e\n\u003cli\u003e関数テンプレート\u003c/li\u003e\n\u003cli\u003eメンバテンプレート\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eテンプレート(\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e11〜)\u003c/li\u003e\n\u003cli\u003e変数テンプレート(\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e14〜)\u003c/li\u003e\n\u003cli\u003eまとめと今後\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003eテンプレートの種類と構文\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のテンプレートは，大きく 5 種類に分類することが出来ます。\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eクラステンプレート\u003c/li\u003e\n\u003cli\u003e関数テンプレート\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eテンプレート\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eテンプレート\u003c/li\u003e\n\u003cli\u003e変数テンプレート\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eこれらについて、以降で詳しくまとめていきます。\u003c/p\u003e\n\n\u003cp\u003eまずざっくり共通する\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%F3%A5%BF%A5%C3%A5%AF%A5%B9\"\u003eシンタックス\u003c/a\u003eを示しておきます。\u003c/p\u003e\n\n\u003ch3\u003e定義する\u003c/h3\u003e\n\n\u003cp\u003e何かのテンプレートを定義したい場合は、通常の定義の前に \u003ccode\u003etemplate\u003c/code\u003e 宣言を記述します。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e stack {\n  ...\n};\n\u003c/pre\u003e\n\n\u003cp\u003e複数のテンプレート引数を取りたい場合や、型以外のテンプレート引数を取りたい場合には、以下のようにします。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e N\u0026gt;\n\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e my_array {\n  ...\n};\n\u003c/pre\u003e\n\n\u003cp\u003e上の例はクラステンプレートでしたが、関数でも\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eでも、\u003ccode\u003etemplate\u003c/code\u003e を宣言する部分は共通です。\u003c/p\u003e\n\n\u003ch3\u003e使用する(\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\"\u003eインスタンス\u003c/a\u003e化)\u003c/h3\u003e\n\n\u003cp\u003e次にテンプレートを使用する場合です。\u003cbr/\u003e\nテンプレートはあくまでテンプレートなので、使用する際には、具体的なテンプレート引数を与えて実体化する必要があります。これを \u003cstrong\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\"\u003eインスタンス\u003c/a\u003e化\u003c/strong\u003e といいます。\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\"\u003eインスタンス\u003c/a\u003e化の構文も、テンプレートの種類によらず基本的には共通しています。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003estack\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; int_stack;\nmy_array\u0026lt;std::string, \u003cspan class=\"synConstant\"\u003e5\u003c/span\u003e\u0026gt; five_strings;\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eテンプレート名 \u0026lt; 引数 \u0026gt;\u003c/code\u003e という感じです。\u003cbr/\u003e\n一応注意書きをしておきますと、\u003ccode\u003estack\u0026lt;stack\u0026lt;int\u0026gt;\u0026gt;\u003c/code\u003e が\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%F3%A5%BF%A5%C3%A5%AF%A5%B9\"\u003eシンタックス\u003c/a\u003eエラーになる場合があります。\n意味としては \u003ccode\u003estack\u0026lt;int\u0026gt;\u003c/code\u003e のスタックです。\u003cbr/\u003e\n\u003ccode\u003estack\u0026lt;stack\u0026lt;int\u0026gt;\u0026gt;\u003c/code\u003e が\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーになる場合は、使っている\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eが古いかもしれません。\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e03 では、\u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e の部分がシフト\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\"\u003e演算子\u003c/a\u003eとして解釈されてしまうためです。\u003cbr/\u003e\n\u003ccode\u003eg++ -std=c++11\u003c/code\u003e とか \u003ccode\u003eclang++ -std=c++11\u003c/code\u003e とか \u003ccode\u003eg++ -std=c++14\u003c/code\u003e とか \u003ccode\u003eclang++ -std=c++14\u003c/code\u003e とか、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eが新しい規格を参照するようにオプションを渡してあげれば動きます。\u003cbr/\u003e\n(もし動かない場合は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eが古すぎます。もう 2016 年ですから、最低でも \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e11 以降を使いましょう。別物です。)\u003c/p\u003e\n\n\u003cp\u003eでは、以降、それぞれのテンプレートについて詳しく見ていきます。\u003c/p\u003e\n\n\u003ch2\u003eクラステンプレート\u003c/h2\u003e\n\n\u003cp\u003eクラステンプレートは、クラスのテンプレートです。前回の \u003ccode\u003estack\u003c/code\u003e がこれにあたります。\u003cbr/\u003e\n一番わかり易い\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\"\u003eユースケース\u003c/a\u003eは、コンテナ型の定義でしょう。\u003cbr/\u003e\nスタックや単方向リスト、ハッシュマップなど、内部に保持する型に依存しないデータ構造を定義するために使えます。\u003c/p\u003e\n\n\u003cp\u003e前回の \u003ccode\u003estack\u003c/code\u003e を再掲しておきます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e stack {\n\u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n  stack() : data(), n() {}\n\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e push(T x) {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (n \u0026gt;= MAX_ELEM) {\n      \u003cspan class=\"synStatement\"\u003ethrow\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;stack is full!!\u0026quot;\u003c/span\u003e;\n    }\n    data[n++] = x;\n  }\n\n  T pop() {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (n \u0026lt; \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e) {\n      \u003cspan class=\"synStatement\"\u003ethrow\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;stack is empty!!\u0026quot;\u003c/span\u003e;\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e data[--n];\n  }\n\u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n  T data[MAX_ELEM];\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e n;\n};\n\u003c/pre\u003e\n\n\u003ch2\u003e関数テンプレート\u003c/h2\u003e\n\n\u003cp\u003e関数テンプレートは以下の様なものです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\nT max(T left, T right) {\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (left \u0026gt; right) {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e left;\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e right;\n  }\n}\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e x = max\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;(\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e); \u003cspan class=\"synComment\"\u003e// =\u0026gt; x == 1\u003c/span\u003e\n\u003cspan class=\"synType\"\u003edouble\u003c/span\u003e y = max\u0026lt;\u003cspan class=\"synType\"\u003edouble\u003c/span\u003e\u0026gt;(\u003cspan class=\"synConstant\"\u003e0.5\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e100.0\u003c/span\u003e); \u003cspan class=\"synComment\"\u003e// =\u0026gt; y == 100.0\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003emax\u003c/code\u003e 関数は、「ある型 T について、２つの引数のうち、大きい方を返す」関数です。\u003cbr/\u003e\n明示的に \u003ccode\u003emax\u0026lt;int\u0026gt;\u003c/code\u003e や \u003ccode\u003emax\u0026lt;double\u0026gt;\u003c/code\u003e とすることで、\u003ccode\u003eint\u003c/code\u003e や \u003ccode\u003edouble\u003c/code\u003e についての「大きい方を返す」関数を得ています。\u003c/p\u003e\n\n\u003ch3\u003eテンプレート引数の推論\u003c/h3\u003e\n\n\u003cp\u003e実は、関数テンプレートの場合、明示的にテンプレートを引数を渡す必要がない場合があります。\u003cbr/\u003e\n今回の \u003ccode\u003emax\u003c/code\u003e 関数はまさにそのケースです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eint\u003c/span\u003e x = max(\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e);\n\u003c/pre\u003e\n\n\u003cp\u003eこれは、テンプレート引数の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\"\u003e型推論\u003c/a\u003eの結果です。\u003cbr/\u003e\n\u003ccode\u003emax\u003c/code\u003e 関数の第一引数、第二引数はそれぞれ \u003ccode\u003eT\u003c/code\u003e です。そして、実際に渡されている \u003ccode\u003e1\u003c/code\u003e や \u003ccode\u003e0\u003c/code\u003e は \u003ccode\u003eint\u003c/code\u003e 型です。\u003cbr/\u003e\nこれらの情報から、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eは \u003ccode\u003eT == int\u003c/code\u003e であることを推論します。\u003cbr/\u003e\nしたがって暗黙に \u003ccode\u003emax\u0026lt;int\u0026gt;\u003c/code\u003e と指定されることになります。\u003cbr/\u003e\nこの推論は色々複雑だったりしますが、はじめは引数から単純に推論できれば推論されると思っておけば良いんじゃないかなと思います。\u003c/p\u003e\n\n\u003cp\u003e一方、クラステンプレートなど、関数テンプレート(と\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eテンプレート)以外のテンプレートの場合には、この推論は行われません。\u003cbr/\u003e\n勘違いしやすいので気をつけましょう。特にクラステンプレートは間違いやすいです。\u003c/p\u003e\n\n\u003ch3\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eテンプレート\u003c/h3\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e printer {\n\u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n  \u003cspan class=\"synType\"\u003eexplicit\u003c/span\u003e printer(std::ostream\u0026amp; os) : os(os) {}\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e print(T \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; v) {\n    os \u0026lt;\u0026lt; v;\n  }\n\u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n  std::ostream\u0026amp; os;\n};\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eテンプレートは、関数テンプレートとほとんど同じです。違いは、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eとして定義されていることだけです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003eprinter p(std::cout);\n\u003c/pre\u003e\n\n\u003cp\u003eここまではテンプレートでもなんでもないただのクラスです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003ep.print(\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e);\np.print(\u003cspan class=\"synConstant\"\u003e\u0026quot;abc\u0026quot;\u003c/span\u003e);\np.print\u0026lt;\u003cspan class=\"synType\"\u003edouble\u003c/span\u003e\u0026gt;(\u003cspan class=\"synConstant\"\u003e0.1\u003c/span\u003e);\n\u003c/pre\u003e\n\n\u003cp\u003eこんな感じで使います。関数テンプレートとほぼ同じですね。\u003c/p\u003e\n\n\u003ch3\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eテンプレート\u003c/h3\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eテンプレートは、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e11 から使用できるテンプレートです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T, \u003cspan class=\"synType\"\u003etypename\u003c/span\u003e U\u0026gt;\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e pair;\n\n\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e with_int_t = pair\u0026lt;T, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;;\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eusing\u003c/code\u003e で型名の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eを作ることが出来ますが、それをテンプレートにすることが出来ます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003ewith_int_t\u0026lt;\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e\u0026gt; p(\u003cspan class=\"synConstant\"\u003etrue\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e);  \u003cspan class=\"synComment\"\u003e// pair\u0026lt;bool, int\u0026gt; p(true, 0);\u003c/span\u003e\nwith_int_t\u0026lt;std::string\u0026gt; s(\u003cspan class=\"synConstant\"\u003e\u0026quot;abc\u0026quot;\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e100\u003c/span\u003e);  \u003cspan class=\"synComment\"\u003e// pair\u0026lt;std::string, int\u0026gt; s(\u0026quot;abc\u0026quot;, 100);\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eちなみに \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e11 より前は、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eテンプレートの代替として、\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e with_int {\n  \u003cspan class=\"synType\"\u003etypedef\u003c/span\u003e pair\u0026lt;T, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; type;\n}\n\nwith_int\u0026lt;\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e\u0026gt;::type p(\u003cspan class=\"synConstant\"\u003etrue\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e); \u003cspan class=\"synComment\"\u003e// pair\u0026lt;bool, int\u0026gt; p(true, 0);\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eという記述をしていました。(今でもライブラリなどで現役の表現ですので覚えておきましょう)\u003c/p\u003e\n\n\u003ch3\u003e変数テンプレート\u003c/h3\u003e\n\n\u003cp\u003e最後の変数テンプレートは、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e14 から使用できるテンプレートです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\nconstexpr T pi = \u003cspan class=\"synStatement\"\u003estatic_cast\u003c/span\u003e\u0026lt;T\u0026gt;(\u003cspan class=\"synConstant\"\u003e3.1415926\u003c/span\u003e);\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e x = pi\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;;\n\u003cspan class=\"synType\"\u003edouble\u003c/span\u003e y = pi\u0026lt;\u003cspan class=\"synType\"\u003edouble\u003c/span\u003e\u0026gt;;\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003econstexpr\u003c/code\u003e は定数式というやつです。\u003c/p\u003e\n\n\u003cp\u003eちなみに \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e14 より前は、代替として\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e pi {\n  \u003cspan class=\"synType\"\u003estatic\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e T value = \u003cspan class=\"synStatement\"\u003estatic_cast\u003c/span\u003e\u0026lt;T\u0026gt;(\u003cspan class=\"synConstant\"\u003e3.1415926\u003c/span\u003e);\n};\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e x = pi\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;::value;\n\u003cspan class=\"synType\"\u003edouble\u003c/span\u003e y = pi\u0026lt;\u003cspan class=\"synType\"\u003edouble\u003c/span\u003e\u0026gt;::value;\n\u003c/pre\u003e\n\n\u003cp\u003eという記述をしていました。(こちらも現役の表現です)\u003c/p\u003e\n\n\u003ch2\u003eまとめと今後\u003c/h2\u003e\n\n\u003cp\u003eというわけで今回はテンプレートの種類とそれぞれの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%F3%A5%BF%A5%C3%A5%AF%A5%B9\"\u003eシンタックス\u003c/a\u003eについてまとめてみました。\u003cbr/\u003e\n今後、特殊化や部分特殊化などのお話をするときに種類によって微妙に違いがあったりするので、しっかり区別しておいたほうが良さそうです。\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e前回テンプレートがなぜ必要なのかについて簡単にまとめたので、今回はその構文や種類についてまとめたいと思います。\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"http://agtn.hatenablog.com/embed/2016/05/30/234647\" title=\"C++ のテンプレートについてまとめる（１）なぜテンプレートが必要なのか - refer to 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"http://agtn.hatenablog.com/entry/2016/05/30/234647\"\u003eagtn.hatenablog.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003ch2\u003eアウトライン\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003eテンプレートの種類と構文\n\n\u003cul\u003e\n\u003cli\u003e定義する\u003c/li\u003e\n\u003cli\u003e使用する(\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\"\u003eインスタンス\u003c/a\u003e化)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eクラステンプレート\u003c/li\u003e\n\u003cli\u003e関数テンプレート\u003c/li\u003e\n\u003cli\u003eメンバテンプレート\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eテンプレート(\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e11〜)\u003c/li\u003e\n\u003cli\u003e変数テンプレート(\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e14〜)\u003c/li\u003e\n\u003cli\u003eまとめと今後\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003eテンプレートの種類と構文\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のテンプレートは，大きく 5 種類に分類することが出来ます。\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eクラステンプレート\u003c/li\u003e\n\u003cli\u003e関数テンプレート\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eテンプレート\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eテンプレート\u003c/li\u003e\n\u003cli\u003e変数テンプレート\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eこれらについて、以降で詳しくまとめていきます。\u003c/p\u003e\n\n\u003cp\u003eまずざっくり共通する\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%F3%A5%BF%A5%C3%A5%AF%A5%B9\"\u003eシンタックス\u003c/a\u003eを示しておきます。\u003c/p\u003e\n\n\u003ch3\u003e定義する\u003c/h3\u003e\n\n\u003cp\u003e何かのテンプレートを定義したい場合は、通常の定義の前に \u003ccode\u003etemplate\u003c/code\u003e 宣言を記述します。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e stack {\n  ...\n};\n\u003c/pre\u003e\n\n\u003cp\u003e複数のテンプレート引数を取りたい場合や、型以外のテンプレート引数を取りたい場合には、以下のようにします。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e N\u0026gt;\n\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e my_array {\n  ...\n};\n\u003c/pre\u003e\n\n\u003cp\u003e上の例はクラステンプレートでしたが、関数でも\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eでも、\u003ccode\u003etemplate\u003c/code\u003e を宣言する部分は共通です。\u003c/p\u003e\n\n\u003ch3\u003e使用する(\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\"\u003eインスタンス\u003c/a\u003e化)\u003c/h3\u003e\n\n\u003cp\u003e次にテンプレートを使用する場合です。\u003cbr/\u003e\nテンプレートはあくまでテンプレートなので、使用する際には、具体的なテンプレート引数を与えて実体化する必要があります。これを \u003cstrong\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\"\u003eインスタンス\u003c/a\u003e化\u003c/strong\u003e といいます。\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\"\u003eインスタンス\u003c/a\u003e化の構文も、テンプレートの種類によらず基本的には共通しています。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003estack\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; int_stack;\nmy_array\u0026lt;std::string, \u003cspan class=\"synConstant\"\u003e5\u003c/span\u003e\u0026gt; five_strings;\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eテンプレート名 \u0026lt; 引数 \u0026gt;\u003c/code\u003e という感じです。\u003cbr/\u003e\n一応注意書きをしておきますと、\u003ccode\u003estack\u0026lt;stack\u0026lt;int\u0026gt;\u0026gt;\u003c/code\u003e が\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%F3%A5%BF%A5%C3%A5%AF%A5%B9\"\u003eシンタックス\u003c/a\u003eエラーになる場合があります。\n意味としては \u003ccode\u003estack\u0026lt;int\u0026gt;\u003c/code\u003e のスタックです。\u003cbr/\u003e\n\u003ccode\u003estack\u0026lt;stack\u0026lt;int\u0026gt;\u0026gt;\u003c/code\u003e が\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーになる場合は、使っている\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eが古いかもしれません。\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e03 では、\u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e の部分がシフト\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\"\u003e演算子\u003c/a\u003eとして解釈されてしまうためです。\u003cbr/\u003e\n\u003ccode\u003eg++ -std=c++11\u003c/code\u003e とか \u003ccode\u003eclang++ -std=c++11\u003c/code\u003e とか \u003ccode\u003eg++ -std=c++14\u003c/code\u003e とか \u003ccode\u003eclang++ -std=c++14\u003c/code\u003e とか、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eが新しい規格を参照するようにオプションを渡してあげれば動きます。\u003cbr/\u003e\n(もし動かない場合は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eが古すぎます。もう 2016 年ですから、最低でも \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e11 以降を使いましょう。別物です。)\u003c/p\u003e\n\n\u003cp\u003eでは、以降、それぞれのテンプレートについて詳しく見ていきます。\u003c/p\u003e\n\n\u003ch2\u003eクラステンプレート\u003c/h2\u003e\n\n\u003cp\u003eクラステンプレートは、クラスのテンプレートです。前回の \u003ccode\u003estack\u003c/code\u003e がこれにあたります。\u003cbr/\u003e\n一番わかり易い\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\"\u003eユースケース\u003c/a\u003eは、コンテナ型の定義でしょう。\u003cbr/\u003e\nスタックや単方向リスト、ハッシュマップなど、内部に保持する型に依存しないデータ構造を定義するために使えます。\u003c/p\u003e\n\n\u003cp\u003e前回の \u003ccode\u003estack\u003c/code\u003e を再掲しておきます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e stack {\n\u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n  stack() : data(), n() {}\n\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e push(T x) {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (n \u0026gt;= MAX_ELEM) {\n      \u003cspan class=\"synStatement\"\u003ethrow\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;stack is full!!\u0026quot;\u003c/span\u003e;\n    }\n    data[n++] = x;\n  }\n\n  T pop() {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (n \u0026lt; \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e) {\n      \u003cspan class=\"synStatement\"\u003ethrow\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;stack is empty!!\u0026quot;\u003c/span\u003e;\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e data[--n];\n  }\n\u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n  T data[MAX_ELEM];\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e n;\n};\n\u003c/pre\u003e\n\n\u003ch2\u003e関数テンプレート\u003c/h2\u003e\n\n\u003cp\u003e関数テンプレートは以下の様なものです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\nT max(T left, T right) {\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (left \u0026gt; right) {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e left;\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e right;\n  }\n}\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e x = max\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;(\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e); \u003cspan class=\"synComment\"\u003e// =\u0026gt; x == 1\u003c/span\u003e\n\u003cspan class=\"synType\"\u003edouble\u003c/span\u003e y = max\u0026lt;\u003cspan class=\"synType\"\u003edouble\u003c/span\u003e\u0026gt;(\u003cspan class=\"synConstant\"\u003e0.5\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e100.0\u003c/span\u003e); \u003cspan class=\"synComment\"\u003e// =\u0026gt; y == 100.0\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003emax\u003c/code\u003e 関数は、「ある型 T について、２つの引数のうち、大きい方を返す」関数です。\u003cbr/\u003e\n明示的に \u003ccode\u003emax\u0026lt;int\u0026gt;\u003c/code\u003e や \u003ccode\u003emax\u0026lt;double\u0026gt;\u003c/code\u003e とすることで、\u003ccode\u003eint\u003c/code\u003e や \u003ccode\u003edouble\u003c/code\u003e についての「大きい方を返す」関数を得ています。\u003c/p\u003e\n\n\u003ch3\u003eテンプレート引数の推論\u003c/h3\u003e\n\n\u003cp\u003e実は、関数テンプレートの場合、明示的にテンプレートを引数を渡す必要がない場合があります。\u003cbr/\u003e\n今回の \u003ccode\u003emax\u003c/code\u003e 関数はまさにそのケースです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eint\u003c/span\u003e x = max(\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e);\n\u003c/pre\u003e\n\n\u003cp\u003eこれは、テンプレート引数の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\"\u003e型推論\u003c/a\u003eの結果です。\u003cbr/\u003e\n\u003ccode\u003emax\u003c/code\u003e 関数の第一引数、第二引数はそれぞれ \u003ccode\u003eT\u003c/code\u003e です。そして、実際に渡されている \u003ccode\u003e1\u003c/code\u003e や \u003ccode\u003e0\u003c/code\u003e は \u003ccode\u003eint\u003c/code\u003e 型です。\u003cbr/\u003e\nこれらの情報から、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eは \u003ccode\u003eT == int\u003c/code\u003e であることを推論します。\u003cbr/\u003e\nしたがって暗黙に \u003ccode\u003emax\u0026lt;int\u0026gt;\u003c/code\u003e と指定されることになります。\u003cbr/\u003e\nこの推論は色々複雑だったりしますが、はじめは引数から単純に推論できれば推論されると思っておけば良いんじゃないかなと思います。\u003c/p\u003e\n\n\u003cp\u003e一方、クラステンプレートなど、関数テンプレート(と\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eテンプレート)以外のテンプレートの場合には、この推論は行われません。\u003cbr/\u003e\n勘違いしやすいので気をつけましょう。特にクラステンプレートは間違いやすいです。\u003c/p\u003e\n\n\u003ch3\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eテンプレート\u003c/h3\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e printer {\n\u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n  \u003cspan class=\"synType\"\u003eexplicit\u003c/span\u003e printer(std::ostream\u0026amp; os) : os(os) {}\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e print(T \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; v) {\n    os \u0026lt;\u0026lt; v;\n  }\n\u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n  std::ostream\u0026amp; os;\n};\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eテンプレートは、関数テンプレートとほとんど同じです。違いは、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eとして定義されていることだけです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003eprinter p(std::cout);\n\u003c/pre\u003e\n\n\u003cp\u003eここまではテンプレートでもなんでもないただのクラスです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003ep.print(\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e);\np.print(\u003cspan class=\"synConstant\"\u003e\u0026quot;abc\u0026quot;\u003c/span\u003e);\np.print\u0026lt;\u003cspan class=\"synType\"\u003edouble\u003c/span\u003e\u0026gt;(\u003cspan class=\"synConstant\"\u003e0.1\u003c/span\u003e);\n\u003c/pre\u003e\n\n\u003cp\u003eこんな感じで使います。関数テンプレートとほぼ同じですね。\u003c/p\u003e\n\n\u003ch3\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eテンプレート\u003c/h3\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eテンプレートは、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e11 から使用できるテンプレートです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T, \u003cspan class=\"synType\"\u003etypename\u003c/span\u003e U\u0026gt;\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e pair;\n\n\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e with_int_t = pair\u0026lt;T, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;;\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eusing\u003c/code\u003e で型名の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eを作ることが出来ますが、それをテンプレートにすることが出来ます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003ewith_int_t\u0026lt;\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e\u0026gt; p(\u003cspan class=\"synConstant\"\u003etrue\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e);  \u003cspan class=\"synComment\"\u003e// pair\u0026lt;bool, int\u0026gt; p(true, 0);\u003c/span\u003e\nwith_int_t\u0026lt;std::string\u0026gt; s(\u003cspan class=\"synConstant\"\u003e\u0026quot;abc\u0026quot;\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e100\u003c/span\u003e);  \u003cspan class=\"synComment\"\u003e// pair\u0026lt;std::string, int\u0026gt; s(\u0026quot;abc\u0026quot;, 100);\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eちなみに \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e11 より前は、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eテンプレートの代替として、\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e with_int {\n  \u003cspan class=\"synType\"\u003etypedef\u003c/span\u003e pair\u0026lt;T, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; type;\n}\n\nwith_int\u0026lt;\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e\u0026gt;::type p(\u003cspan class=\"synConstant\"\u003etrue\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e); \u003cspan class=\"synComment\"\u003e// pair\u0026lt;bool, int\u0026gt; p(true, 0);\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eという記述をしていました。(今でもライブラリなどで現役の表現ですので覚えておきましょう)\u003c/p\u003e\n\n\u003ch3\u003e変数テンプレート\u003c/h3\u003e\n\n\u003cp\u003e最後の変数テンプレートは、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e14 から使用できるテンプレートです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\nconstexpr T pi = \u003cspan class=\"synStatement\"\u003estatic_cast\u003c/span\u003e\u0026lt;T\u0026gt;(\u003cspan class=\"synConstant\"\u003e3.1415926\u003c/span\u003e);\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e x = pi\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;;\n\u003cspan class=\"synType\"\u003edouble\u003c/span\u003e y = pi\u0026lt;\u003cspan class=\"synType\"\u003edouble\u003c/span\u003e\u0026gt;;\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003econstexpr\u003c/code\u003e は定数式というやつです。\u003c/p\u003e\n\n\u003cp\u003eちなみに \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e14 より前は、代替として\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e pi {\n  \u003cspan class=\"synType\"\u003estatic\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e T value = \u003cspan class=\"synStatement\"\u003estatic_cast\u003c/span\u003e\u0026lt;T\u0026gt;(\u003cspan class=\"synConstant\"\u003e3.1415926\u003c/span\u003e);\n};\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e x = pi\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;::value;\n\u003cspan class=\"synType\"\u003edouble\u003c/span\u003e y = pi\u0026lt;\u003cspan class=\"synType\"\u003edouble\u003c/span\u003e\u0026gt;::value;\n\u003c/pre\u003e\n\n\u003cp\u003eという記述をしていました。(こちらも現役の表現です)\u003c/p\u003e\n\n\u003ch2\u003eまとめと今後\u003c/h2\u003e\n\n\u003cp\u003eというわけで今回はテンプレートの種類とそれぞれの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%F3%A5%BF%A5%C3%A5%AF%A5%B9\"\u003eシンタックス\u003c/a\u003eについてまとめてみました。\u003cbr/\u003e\n今後、特殊化や部分特殊化などのお話をするときに種類によって微妙に違いがあったりするので、しっかり区別しておいたほうが良さそうです。\u003c/p\u003e\n\n---\n\n---\n","slug":"C++_テンプレートの種類と構文","title":"C++ テンプレートの種類と構文","timestamp":1464685076000,"tags":[]},{"rawMarkdown":"---\ntitle: \"C++ : なぜテンプレートが必要なのか\"\ndate: 2016-05-30T14:46:47.000Z\ntags: []\n---\n\n\u003cp\u003eこんにちは。\u003cbr/\u003e\nちょっと \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e への熱を冷まさないために、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のテンプレートについてまとめてみたいと思います。\u003c/p\u003e\n\n\u003ch2\u003e対象\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のテンプレートが怖い人\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーメッセージが怖い人\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の規格とブログポストを比較して誤りを探したい人(もし誤っていたら教えて下さい...)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003eテンプレートとは\u003c/h2\u003e\n\n\u003cblockquote\u003e\u003cp\u003eプログラミングにおけるテンプレートは、静的型付けの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eでデータ型にとらわれずにコードを書くことを可能にする機能であり、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eにおいては\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eプログラミングに用いられる。\u003cbr/\u003e\n\u003ca href=\"https://ja.wikipedia.org/wiki/%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0\"\u003eテンプレート (プログラミング) - Wikipedia\u003c/a\u003e)より\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e他の静的型付きな\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\"\u003eプログラミング言語\u003c/a\u003eをすでに知っている場合は，すんなり入りやすいかもしれません。\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e や \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scala\"\u003eScala\u003c/a\u003e, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%23\"\u003eC#\u003c/a\u003e でいうところの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eに近い存在です。\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003e や \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e だと多相とか。\u003c/p\u003e\n\n\u003cp\u003e雑に表現するならば、リストとか\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CF%A2%C1%DB%C7%DB%CE%F3\"\u003e連想配列\u003c/a\u003eのように内部のデータ型に依らないデータ構造を、静的型のもとにどうやったらうまく表現できるかな、に対する解の一つです。\u003c/p\u003e\n\n\u003ch3\u003e例\u003c/h3\u003e\n\n\u003cp\u003eでは一つの例として、スタックというデータ構造をプログラムに落としこむことを考えます。\u003cbr/\u003e\nまずは \u003ccode\u003eint\u003c/code\u003e 型のスタックを定義してみます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#define MAX_ELEM \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e10\u003c/span\u003e\n\n\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e int_stack {\n\u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n  int_stack() : data(), n() {}\n\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e push(\u003cspan class=\"synType\"\u003eint\u003c/span\u003e x) {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (n \u0026gt;= MAX_ELEM) {\n      \u003cspan class=\"synStatement\"\u003ethrow\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;stack is full!!\u0026quot;\u003c/span\u003e;\n    }\n    data[n++] = x;\n  }\n\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e pop() {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (n \u0026lt; \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e) {\n      \u003cspan class=\"synStatement\"\u003ethrow\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;stack is empty!!\u0026quot;\u003c/span\u003e;\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e data[--n];\n  }\n\u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e data[MAX_ELEM];\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e n;\n};\n\u003c/pre\u003e\n\n\u003cp\u003e簡単のため、かなりお粗末なスタックですが、最低限のスタックとしての見た目はしていると思います。\u003c/p\u003e\n\n\u003cp\u003eでは次に、\u003ccode\u003estd::string\u003c/code\u003e 型のスタックや \u003ccode\u003edouble\u003c/code\u003e 型のスタックを作りたいとなったらどうすればよいでしょうか。\u003cbr/\u003e\nコピーして \u003ccode\u003eint\u003c/code\u003e を置換しますか？あまり褒められた方法ではなさそうです。\u003c/p\u003e\n\n\u003ch4\u003eC でのアプローチの一つ\u003c/h4\u003e\n\n\u003cp\u003eC 言語の場合、このような問題に対しては \u003ccode\u003evoid*\u003c/code\u003e というアプローチがあります。\u003cbr/\u003e\n\u003ccode\u003evoid*\u003c/code\u003e は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/java\"\u003ejava\u003c/a\u003e でいう \u003ccode\u003eObject\u003c/code\u003e のように扱われます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-c\" data-lang=\"c\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#define MAX_ELEM \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e10\u003c/span\u003e\n\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e stack {\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e *data[MAX_ELEM];\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e n;\n};\n\n\u003cspan class=\"synType\"\u003evoid\u003c/span\u003e push(stack *s, \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e *elem) {\n  ....\n}\n\n\u003cspan class=\"synType\"\u003evoid\u003c/span\u003e *pop(stack *s) {\n  ....\n}\n\n\u003cspan class=\"synComment\"\u003e/* Usage */\u003c/span\u003e\nstack *s = new_stack();\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e *x = (\u003cspan class=\"synType\"\u003eint\u003c/span\u003e*)malloc(\u003cspan class=\"synStatement\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"synType\"\u003eint\u003c/span\u003e));\n*x = \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e;\npush(s, (\u003cspan class=\"synType\"\u003evoid\u003c/span\u003e*)x);\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e *y = (\u003cspan class=\"synType\"\u003eint\u003c/span\u003e*)pop(s);\nprintf(\u003cspan class=\"synConstant\"\u003e\u0026quot;\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e%d\\n\u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026quot;\u003c/span\u003e *y); \u003cspan class=\"synComment\"\u003e/* =\u0026gt; 1 */\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eこんな感じでしょうか。実装の細かい部分は省略しています。\u003cbr/\u003e\n\u003ccode\u003epush\u003c/code\u003e の際にはあらゆるポインタを \u003ccode\u003evoid*\u003c/code\u003e にキャストし、逆に \u003ccode\u003epop\u003c/code\u003e する際には \u003ccode\u003evoid*\u003c/code\u003e を求める型にキャストしています。\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eのなかった頃の \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/java\"\u003ejava\u003c/a\u003e は、これを \u003ccode\u003eObject\u003c/code\u003e へのキャスト・\u003ccode\u003eObject\u003c/code\u003e からのキャストとして表現していました。\u003c/p\u003e\n\n\u003ch5\u003evoid* のデメリット\u003c/h5\u003e\n\n\u003cp\u003e\u003ccode\u003evoid*\u003c/code\u003e を使う場合のデメリットは、型システムを台無しにしている点です。(\u003ccode\u003emalloc\u003c/code\u003e や \u003ccode\u003efree\u003c/code\u003e が必要であることは C 言語特有の問題なのでスルー)\u003cbr/\u003e\nつまり、\u003ccode\u003eint\u003c/code\u003e のスタックから \u003ccode\u003epop\u003c/code\u003e してきたとき、\u003ccode\u003eint*\u003c/code\u003e に正しくキャストを行う責任は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DE\"\u003eプログラマ\u003c/a\u003eにあり、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eは何も手助けをしてくれないということです。\u003cbr/\u003e\nしたがって、 \u003ccode\u003eint\u003c/code\u003e スタックに \u003ccode\u003edouble\u003c/code\u003e の値を \u003ccode\u003epush\u003c/code\u003e したり、 \u003ccode\u003edouble\u003c/code\u003e スタックから \u003ccode\u003echar*\u003c/code\u003e を \u003ccode\u003epop\u003c/code\u003e したりというミスが簡単に引き起こされてしまうということです。\u003c/p\u003e\n\n\u003ch4\u003eそこでテンプレート\u003c/h4\u003e\n\n\u003cp\u003eでは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e ではどのようなアプローチを取るかというと、テンプレートを使います。\u003cbr/\u003e\n今回は型に関するテンプレートの話しかしないので、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/java\"\u003ejava\u003c/a\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eも大体同じ話だと思って構わないと思います。(実行時の表現や\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eの動きなどの違いはあるが、対象としている問題は同じ)\u003c/p\u003e\n\n\u003cp\u003eさきほどの \u003ccode\u003eint_stack\u003c/code\u003e の実装では、要素型が \u003ccode\u003eint\u003c/code\u003e に固定化されてしまっているのが問題でした。\u003cbr/\u003e\nそこで、テンプレートでは、型を抽象化し、ある種の引数のように扱っています。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e stack {\n\u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n  stack() : data(), n() {}\n\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e push(T x) {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (n \u0026gt;= MAX_ELEM) {\n      \u003cspan class=\"synStatement\"\u003ethrow\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;stack is full!!\u0026quot;\u003c/span\u003e;\n    }\n    data[n++] = x;\n  }\n\n  T pop() {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (n \u0026lt; \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e) {\n      \u003cspan class=\"synStatement\"\u003ethrow\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;stack is empty!!\u0026quot;\u003c/span\u003e;\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e data[--n];\n  }\n\u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n  T data[MAX_ELEM];\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e n;\n};\n\u003c/pre\u003e\n\n\u003cp\u003e先頭の \u003ccode\u003etemplate \u0026lt;typename T\u0026gt;\u003c/code\u003e (\u003ccode\u003etemplate \u0026lt;class T\u0026gt;\u003c/code\u003e でも可)は、型引数の導入の役割を果たしています。\u003cbr/\u003e\n\u003ccode\u003estack\u003c/code\u003e クラスの定義内に登場する \u003ccode\u003eT\u003c/code\u003e は型引数として導入された型を表します。\u003c/p\u003e\n\n\u003cp\u003e利用する際には、\u003ccode\u003estack\u0026lt;int\u0026gt;\u003c/code\u003e とか \u003ccode\u003estack\u0026lt;std::string\u0026gt;\u003c/code\u003e とか、型を \u003ccode\u003estack\u003c/code\u003e に渡してあげればOKです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003estack\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; int_stack;\nint_stack.push(\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e);\nint_stack.push(\u003cspan class=\"synConstant\"\u003e2\u003c/span\u003e);\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e x = int_stack.pop();\nint_stack.push(\u003cspan class=\"synConstant\"\u003e\u0026quot;abc\u0026quot;\u003c/span\u003e); \u003cspan class=\"synComment\"\u003e// =\u0026gt; Compile error!\u003c/span\u003e\n\nstack\u0026lt;std::string\u0026gt; str_stack;\nstr_stack.push(\u003cspan class=\"synConstant\"\u003e\u0026quot;abc\u0026quot;\u003c/span\u003e);\nstr_stack.push(\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e); \u003cspan class=\"synComment\"\u003e// =\u0026gt; Compile error!\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eこのように、同じコードをコピペすることなく、複数の型に対応したスタックという汎用的なデータ構造を表現することが出来ています。\u003cbr/\u003e\nさらに、この方法では、\u003ccode\u003evoid*\u003c/code\u003e や \u003ccode\u003eObject\u003c/code\u003e と異なり、型的に誤った使用方法をしようとすると\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーになるというメリットがあります。\u003cbr/\u003e\nランタイムエラーより\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーのほうが\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%D0%A5%C3%A5%B0\"\u003eデバッグ\u003c/a\u003eしやすいし発見しやすいですよね。\u003c/p\u003e\n\n\u003ch2\u003e一旦まとめ\u003c/h2\u003e\n\n\u003cp\u003eというわけで今回はテンプレートがなぜ便利かという話のほんのさわりの部分について書いてみました。\u003cbr/\u003e\n次はテンプレートや\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eの実現方法、ランタイムにおける表現方法などについて書いてみます。\u003cbr/\u003e\nそこからはテンプレート引数として値をとる話や、TMP についても触れていければと思っています。\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eこんにちは。\u003cbr/\u003e\nちょっと \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e への熱を冷まさないために、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のテンプレートについてまとめてみたいと思います。\u003c/p\u003e\n\n\u003ch2\u003e対象\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のテンプレートが怖い人\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーメッセージが怖い人\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の規格とブログポストを比較して誤りを探したい人(もし誤っていたら教えて下さい...)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003eテンプレートとは\u003c/h2\u003e\n\n\u003cblockquote\u003e\u003cp\u003eプログラミングにおけるテンプレートは、静的型付けの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eでデータ型にとらわれずにコードを書くことを可能にする機能であり、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eにおいては\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eプログラミングに用いられる。\u003cbr/\u003e\n\u003ca href=\"https://ja.wikipedia.org/wiki/%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0\"\u003eテンプレート (プログラミング) - Wikipedia\u003c/a\u003e)より\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e他の静的型付きな\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\"\u003eプログラミング言語\u003c/a\u003eをすでに知っている場合は，すんなり入りやすいかもしれません。\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e や \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scala\"\u003eScala\u003c/a\u003e, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%23\"\u003eC#\u003c/a\u003e でいうところの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eに近い存在です。\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003e や \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e だと多相とか。\u003c/p\u003e\n\n\u003cp\u003e雑に表現するならば、リストとか\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CF%A2%C1%DB%C7%DB%CE%F3\"\u003e連想配列\u003c/a\u003eのように内部のデータ型に依らないデータ構造を、静的型のもとにどうやったらうまく表現できるかな、に対する解の一つです。\u003c/p\u003e\n\n\u003ch3\u003e例\u003c/h3\u003e\n\n\u003cp\u003eでは一つの例として、スタックというデータ構造をプログラムに落としこむことを考えます。\u003cbr/\u003e\nまずは \u003ccode\u003eint\u003c/code\u003e 型のスタックを定義してみます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#define MAX_ELEM \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e10\u003c/span\u003e\n\n\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e int_stack {\n\u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n  int_stack() : data(), n() {}\n\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e push(\u003cspan class=\"synType\"\u003eint\u003c/span\u003e x) {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (n \u0026gt;= MAX_ELEM) {\n      \u003cspan class=\"synStatement\"\u003ethrow\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;stack is full!!\u0026quot;\u003c/span\u003e;\n    }\n    data[n++] = x;\n  }\n\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e pop() {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (n \u0026lt; \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e) {\n      \u003cspan class=\"synStatement\"\u003ethrow\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;stack is empty!!\u0026quot;\u003c/span\u003e;\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e data[--n];\n  }\n\u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e data[MAX_ELEM];\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e n;\n};\n\u003c/pre\u003e\n\n\u003cp\u003e簡単のため、かなりお粗末なスタックですが、最低限のスタックとしての見た目はしていると思います。\u003c/p\u003e\n\n\u003cp\u003eでは次に、\u003ccode\u003estd::string\u003c/code\u003e 型のスタックや \u003ccode\u003edouble\u003c/code\u003e 型のスタックを作りたいとなったらどうすればよいでしょうか。\u003cbr/\u003e\nコピーして \u003ccode\u003eint\u003c/code\u003e を置換しますか？あまり褒められた方法ではなさそうです。\u003c/p\u003e\n\n\u003ch4\u003eC でのアプローチの一つ\u003c/h4\u003e\n\n\u003cp\u003eC 言語の場合、このような問題に対しては \u003ccode\u003evoid*\u003c/code\u003e というアプローチがあります。\u003cbr/\u003e\n\u003ccode\u003evoid*\u003c/code\u003e は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/java\"\u003ejava\u003c/a\u003e でいう \u003ccode\u003eObject\u003c/code\u003e のように扱われます。\u003c/p\u003e\n\n\u003cpre class=\"code lang-c\" data-lang=\"c\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#define MAX_ELEM \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e10\u003c/span\u003e\n\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e stack {\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e *data[MAX_ELEM];\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e n;\n};\n\n\u003cspan class=\"synType\"\u003evoid\u003c/span\u003e push(stack *s, \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e *elem) {\n  ....\n}\n\n\u003cspan class=\"synType\"\u003evoid\u003c/span\u003e *pop(stack *s) {\n  ....\n}\n\n\u003cspan class=\"synComment\"\u003e/* Usage */\u003c/span\u003e\nstack *s = new_stack();\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e *x = (\u003cspan class=\"synType\"\u003eint\u003c/span\u003e*)malloc(\u003cspan class=\"synStatement\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"synType\"\u003eint\u003c/span\u003e));\n*x = \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e;\npush(s, (\u003cspan class=\"synType\"\u003evoid\u003c/span\u003e*)x);\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e *y = (\u003cspan class=\"synType\"\u003eint\u003c/span\u003e*)pop(s);\nprintf(\u003cspan class=\"synConstant\"\u003e\u0026quot;\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e%d\\n\u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026quot;\u003c/span\u003e *y); \u003cspan class=\"synComment\"\u003e/* =\u0026gt; 1 */\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eこんな感じでしょうか。実装の細かい部分は省略しています。\u003cbr/\u003e\n\u003ccode\u003epush\u003c/code\u003e の際にはあらゆるポインタを \u003ccode\u003evoid*\u003c/code\u003e にキャストし、逆に \u003ccode\u003epop\u003c/code\u003e する際には \u003ccode\u003evoid*\u003c/code\u003e を求める型にキャストしています。\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eのなかった頃の \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/java\"\u003ejava\u003c/a\u003e は、これを \u003ccode\u003eObject\u003c/code\u003e へのキャスト・\u003ccode\u003eObject\u003c/code\u003e からのキャストとして表現していました。\u003c/p\u003e\n\n\u003ch5\u003evoid* のデメリット\u003c/h5\u003e\n\n\u003cp\u003e\u003ccode\u003evoid*\u003c/code\u003e を使う場合のデメリットは、型システムを台無しにしている点です。(\u003ccode\u003emalloc\u003c/code\u003e や \u003ccode\u003efree\u003c/code\u003e が必要であることは C 言語特有の問題なのでスルー)\u003cbr/\u003e\nつまり、\u003ccode\u003eint\u003c/code\u003e のスタックから \u003ccode\u003epop\u003c/code\u003e してきたとき、\u003ccode\u003eint*\u003c/code\u003e に正しくキャストを行う責任は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DE\"\u003eプログラマ\u003c/a\u003eにあり、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eは何も手助けをしてくれないということです。\u003cbr/\u003e\nしたがって、 \u003ccode\u003eint\u003c/code\u003e スタックに \u003ccode\u003edouble\u003c/code\u003e の値を \u003ccode\u003epush\u003c/code\u003e したり、 \u003ccode\u003edouble\u003c/code\u003e スタックから \u003ccode\u003echar*\u003c/code\u003e を \u003ccode\u003epop\u003c/code\u003e したりというミスが簡単に引き起こされてしまうということです。\u003c/p\u003e\n\n\u003ch4\u003eそこでテンプレート\u003c/h4\u003e\n\n\u003cp\u003eでは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e ではどのようなアプローチを取るかというと、テンプレートを使います。\u003cbr/\u003e\n今回は型に関するテンプレートの話しかしないので、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/java\"\u003ejava\u003c/a\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eも大体同じ話だと思って構わないと思います。(実行時の表現や\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eの動きなどの違いはあるが、対象としている問題は同じ)\u003c/p\u003e\n\n\u003cp\u003eさきほどの \u003ccode\u003eint_stack\u003c/code\u003e の実装では、要素型が \u003ccode\u003eint\u003c/code\u003e に固定化されてしまっているのが問題でした。\u003cbr/\u003e\nそこで、テンプレートでは、型を抽象化し、ある種の引数のように扱っています。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt;\n\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e stack {\n\u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n  stack() : data(), n() {}\n\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e push(T x) {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (n \u0026gt;= MAX_ELEM) {\n      \u003cspan class=\"synStatement\"\u003ethrow\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;stack is full!!\u0026quot;\u003c/span\u003e;\n    }\n    data[n++] = x;\n  }\n\n  T pop() {\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (n \u0026lt; \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e) {\n      \u003cspan class=\"synStatement\"\u003ethrow\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;stack is empty!!\u0026quot;\u003c/span\u003e;\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e data[--n];\n  }\n\u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n  T data[MAX_ELEM];\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e n;\n};\n\u003c/pre\u003e\n\n\u003cp\u003e先頭の \u003ccode\u003etemplate \u0026lt;typename T\u0026gt;\u003c/code\u003e (\u003ccode\u003etemplate \u0026lt;class T\u0026gt;\u003c/code\u003e でも可)は、型引数の導入の役割を果たしています。\u003cbr/\u003e\n\u003ccode\u003estack\u003c/code\u003e クラスの定義内に登場する \u003ccode\u003eT\u003c/code\u003e は型引数として導入された型を表します。\u003c/p\u003e\n\n\u003cp\u003e利用する際には、\u003ccode\u003estack\u0026lt;int\u0026gt;\u003c/code\u003e とか \u003ccode\u003estack\u0026lt;std::string\u0026gt;\u003c/code\u003e とか、型を \u003ccode\u003estack\u003c/code\u003e に渡してあげればOKです。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003estack\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; int_stack;\nint_stack.push(\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e);\nint_stack.push(\u003cspan class=\"synConstant\"\u003e2\u003c/span\u003e);\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e x = int_stack.pop();\nint_stack.push(\u003cspan class=\"synConstant\"\u003e\u0026quot;abc\u0026quot;\u003c/span\u003e); \u003cspan class=\"synComment\"\u003e// =\u0026gt; Compile error!\u003c/span\u003e\n\nstack\u0026lt;std::string\u0026gt; str_stack;\nstr_stack.push(\u003cspan class=\"synConstant\"\u003e\u0026quot;abc\u0026quot;\u003c/span\u003e);\nstr_stack.push(\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e); \u003cspan class=\"synComment\"\u003e// =\u0026gt; Compile error!\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eこのように、同じコードをコピペすることなく、複数の型に対応したスタックという汎用的なデータ構造を表現することが出来ています。\u003cbr/\u003e\nさらに、この方法では、\u003ccode\u003evoid*\u003c/code\u003e や \u003ccode\u003eObject\u003c/code\u003e と異なり、型的に誤った使用方法をしようとすると\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーになるというメリットがあります。\u003cbr/\u003e\nランタイムエラーより\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーのほうが\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%D0%A5%C3%A5%B0\"\u003eデバッグ\u003c/a\u003eしやすいし発見しやすいですよね。\u003c/p\u003e\n\n\u003ch2\u003e一旦まとめ\u003c/h2\u003e\n\n\u003cp\u003eというわけで今回はテンプレートがなぜ便利かという話のほんのさわりの部分について書いてみました。\u003cbr/\u003e\n次はテンプレートや\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\"\u003eジェネリクス\u003c/a\u003eの実現方法、ランタイムにおける表現方法などについて書いてみます。\u003cbr/\u003e\nそこからはテンプレート引数として値をとる話や、TMP についても触れていければと思っています。\u003c/p\u003e\n\n---\n\n---\n","slug":"C++_:_なぜテンプレートが必要なのか","title":"C++ : なぜテンプレートが必要なのか","timestamp":1464619607000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Rust のパーサコンビネータライブラリ combine を使う時の tips\"\ndate: 2016-05-14T16:03:19.000Z\ntags: []\n---\n\n\u003cp\u003eRust のパーサ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eライブラリの一つである \u003ca href=\"https://github.com/Marwes/combine\"\u003eMarwes/combine: A parser combinator library for Rust\u003c/a\u003e を使ってみています．\u003cbr/\u003e\n詳しい使い方はきちんとしたドキュメントがあるのでそちらを参照してください．\u003cbr/\u003e\nざっくりいうと \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e の \u003ca href=\"https://hackage.haskell.org/package/parsec\"\u003eparsec: Monadic parser combinators | Hackage\u003c/a\u003e の Rust 版という感じです．\u003c/p\u003e\n\n\u003cp\u003e(ちなみに私も combine を参考に \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e でパーサ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eを作ってみたりしました. )\n\u003ciframe src=\"http://agtn.hatenablog.com/embed/2016/04/30/003009\" title=\"C++ でパーサコンビネータを書きました - 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"http://agtn.hatenablog.com/entry/2016/04/30/003009\"\u003eagtn.hatenablog.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003eで、このライブラリ、とても\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eなコードで書かれているので、かなり\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時間が増加します\u0026hellip; (Boost.Spirit 系に近いです． \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーなどは遥かに読みやすいのであまり困ることはないですが)  \u003cbr/\u003e\nパーサを書いている時にはテストは頻繁に行いたいので，ちょっと\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eがおそいのはつらい．\u003c/p\u003e\n\n\u003cp\u003eなにか解決策はないかなぁと思っていたら本家に issue がたっていました．\u003cbr/\u003e\n\u003ca href=\"https://github.com/Marwes/combine/issues/21\"\u003eExtremely long compile times · Issue #21 · Marwes/combine\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e今回この issue にかかれていた内容を検証してみたので，ここでまとめておこうと思います．\u003c/p\u003e\n\n\u003ch2\u003e結論\u003c/h2\u003e\n\n\u003cp\u003eパーサの定義を，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eな構造体のメソッドとして定義すると\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時間が大幅に短くなる\u003c/p\u003e\n\n\u003ch2\u003e方法\u003c/h2\u003e\n\n\u003cp\u003eまずはじめに言われているのは，入力ストリーム型を\u003ccode\u003eI: Stream\u0026lt;Item=char\u0026gt;\u003c/code\u003e から \u003ccode\u003e\u0026amp;str\u003c/code\u003e にしてしまうという方法です．\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e(It might be possible to specialize the parsers directly as well, say\n\u003ccode\u003e\nfn expr(input: State\u0026lt;\u0026amp;str\u0026gt;) -\u0026gt; ParseResult\u0026lt;Expr, \u0026amp;str\u0026gt;\n\u003c/code\u003e\ninstead of\n\u003ccode\u003e\nfn expr\u0026lt;I: Stream\u0026gt;(input: State\u0026lt;I\u0026gt;) -\u0026gt; ParseResult\u0026lt;I, \u0026amp;str\u0026gt;\n\u003c/code\u003e\n)\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003eこれは作ったパーサを\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eな入力に対して適用することができなくなりますが，ライブラリの利用者側としては，\u003ccode\u003echar\u003c/code\u003e のストリームといったらだいたい \u003ccode\u003e\u0026amp;str\u003c/code\u003e だと思うので，ぶっちゃけ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eじゃなくてもいいじゃんという感じです．\u003c/p\u003e\n\n\u003cp\u003eそしてもう一つが,  \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eな構造体を作って，パーサの定義をその中に閉じ込めるという方法です．\u003cbr/\u003e\nちょっとこちらはコード例を実際に見たほうがわかりやすいと思うので後で説明します．\u003c/p\u003e\n\n\u003ch2\u003e実験コード\u003c/h2\u003e\n\n\u003cp\u003eというわけで，\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eなパーサ\u003c/li\u003e\n\u003cli\u003e\u0026amp;str のみを受理するパーサ\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eな構造体の中に定義された\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eでないパーサ\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eの三種類について，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時間をはかってみます．\u003c/p\u003e\n\n\u003cp\u003eパーサ界のハローワールド，計算機で実験してみます．\nまずは\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eなパーサです．\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003ecombine\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synType\"\u003e*\u003c/span\u003e;\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003ecombine\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003eprimitives\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eStream;\n\n\u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003einteger\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003ewhere\u003c/span\u003e I: Stream\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eItem \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n{\n    \u003cspan class=\"synIdentifier\"\u003emany1\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e_\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e, _\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003edigit\u003c/span\u003e())\n        .\u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e(\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003eis\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e is.\u003cspan class=\"synIdentifier\"\u003einto_iter\u003c/span\u003e().\u003cspan class=\"synIdentifier\"\u003efold\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e, \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003elhs, rhs\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e+\u003c/span\u003e (rhs \u003cspan class=\"synStatement\"\u003eas\u003c/span\u003e \u003cspan class=\"synType\"\u003ei64\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e-\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e'0'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eas\u003c/span\u003e \u003cspan class=\"synType\"\u003ei64\u003c/span\u003e)))\n        .\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n}\n\n\u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003efactor\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003ewhere\u003c/span\u003e I: Stream\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eItem \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n{\n    \u003cspan class=\"synIdentifier\"\u003ebetween\u003c/span\u003e(\u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'('\u003c/span\u003e), \u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e')'\u003c/span\u003e), \u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(expr)).\u003cspan class=\"synIdentifier\"\u003eor\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(integer)).\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n}\n\n\u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eterm\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003ewhere\u003c/span\u003e I: Stream\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eItem \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n{\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e op \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'*'\u003c/span\u003e).\u003cspan class=\"synIdentifier\"\u003eor\u003c/span\u003e(\u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'/'\u003c/span\u003e)).\u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e(\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003ec\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e {\n        \u003cspan class=\"synType\"\u003emove\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003elhs, rhs\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e c {\n            \u003cspan class=\"synConstant\"\u003e'*'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e*\u003c/span\u003e rhs,\n            \u003cspan class=\"synConstant\"\u003e'/'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e/\u003c/span\u003e rhs,\n            _ \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eunreachable!\u003c/span\u003e(),\n        }\n    });\n    \u003cspan class=\"synIdentifier\"\u003echainl1\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(factor), op).\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n}\n\n\u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eexpr\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003ewhere\u003c/span\u003e I: Stream\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eItem \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n{\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e op \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'+'\u003c/span\u003e).\u003cspan class=\"synIdentifier\"\u003eor\u003c/span\u003e(\u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'-'\u003c/span\u003e)).\u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e(\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003ec\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e {\n        \u003cspan class=\"synType\"\u003emove\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003elhs, rhs\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e c {\n            \u003cspan class=\"synConstant\"\u003e'+'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e+\u003c/span\u003e rhs,\n            \u003cspan class=\"synConstant\"\u003e'-'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e-\u003c/span\u003e rhs,\n            _ \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eunreachable!\u003c/span\u003e(),\n        }\n    });\n    \u003cspan class=\"synIdentifier\"\u003echainl1\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(term), op).\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n}\n\n\u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eparse\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(input: I) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003eResult\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e(\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I), ParseError\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003ewhere\u003c/span\u003e I: Stream\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eItem \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n{\n    \u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(expr).\u003cspan class=\"synIdentifier\"\u003eparse\u003c/span\u003e(input)\n}\n\u003c/pre\u003e\n\n\u003cp\u003eそれぞれの関数が一つのパーサの役割を担います．それぞれのパーサが独立していて，それぞれ別々に型変数を導入しています．\u003c/p\u003e\n\n\u003cp\u003e次に \u003ccode\u003e\u0026amp;str\u003c/code\u003e だけを受け取るパーサです．これは上記の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eなパーサの，型変数を \u003ccode\u003e\u0026amp;str\u003c/code\u003e に置き換えるだけなのでとても簡単です．\u003cbr/\u003e\n一部だけ掲載します．\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eexpr\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003e\u0026amp;str\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, \u003cspan class=\"synType\"\u003e\u0026amp;str\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n     \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e op \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'+'\u003c/span\u003e).\u003cspan class=\"synIdentifier\"\u003eor\u003c/span\u003e(\u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'-'\u003c/span\u003e)).\u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e(\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003ec\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e {\n        \u003cspan class=\"synType\"\u003emove\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003elhs, rhs\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e c {\n            \u003cspan class=\"synConstant\"\u003e'+'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e+\u003c/span\u003e rhs,\n            \u003cspan class=\"synConstant\"\u003e'-'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e-\u003c/span\u003e rhs,\n            _ \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eunreachable!\u003c/span\u003e(),\n        }\n    });\n    \u003cspan class=\"synIdentifier\"\u003echainl1\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(term), op).\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n}\n\n\u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eparse\u003c/span\u003e(input: \u003cspan class=\"synType\"\u003e\u0026amp;str\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003eResult\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e(\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, \u003cspan class=\"synType\"\u003e\u0026amp;str\u003c/span\u003e), ParseError\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003e\u0026amp;str\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(expr).\u003cspan class=\"synIdentifier\"\u003eparse\u003c/span\u003e(input)\n}\n\u003c/pre\u003e\n\n\u003cp\u003e最後が，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eな構造体のメソッド中に，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eでないパーサを定義して閉じ込める方法です．\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003ecombine\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synType\"\u003e*\u003c/span\u003e;\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003ecombine\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003eprimitives\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eStream;\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003estd\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003emarker\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003ePhantomData;\n\n truct P\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(PhantomData\u003cspan class=\"synStatement\"\u003e\u0026lt;fn\u003c/span\u003e(I) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e);\n\n\u003cspan class=\"synStatement\"\u003eimpl\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e P\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ewhere\u003c/span\u003e I: Stream\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eItem \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003einteger\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"synIdentifier\"\u003emany1\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e_\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e, _\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003edigit\u003c/span\u003e())\n            .\u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e(\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003eis\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e is.\u003cspan class=\"synIdentifier\"\u003einto_iter\u003c/span\u003e().\u003cspan class=\"synIdentifier\"\u003efold\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e, \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003elhs, rhs\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e+\u003c/span\u003e (rhs \u003cspan class=\"synStatement\"\u003eas\u003c/span\u003e \u003cspan class=\"synType\"\u003ei64\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e-\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e'0'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eas\u003c/span\u003e \u003cspan class=\"synType\"\u003ei64\u003c/span\u003e)))\n            .\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n    }\n\n    \u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003efactor\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"synIdentifier\"\u003ebetween\u003c/span\u003e(\u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'('\u003c/span\u003e), \u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e')'\u003c/span\u003e), \u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eP\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eexpr))\n            .\u003cspan class=\"synIdentifier\"\u003eor\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eP\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003einteger))\n            .\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n    }\n\n    \u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eterm\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e op \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'*'\u003c/span\u003e).\u003cspan class=\"synIdentifier\"\u003eor\u003c/span\u003e(\u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'/'\u003c/span\u003e)).\u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e(\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003ec\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e {\n            \u003cspan class=\"synType\"\u003emove\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003elhs, rhs\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e c {\n                \u003cspan class=\"synConstant\"\u003e'*'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e*\u003c/span\u003e rhs,\n                \u003cspan class=\"synConstant\"\u003e'/'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e/\u003c/span\u003e rhs,\n                _ \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eunreachable!\u003c/span\u003e(),\n            }\n        });\n        \u003cspan class=\"synIdentifier\"\u003echainl1\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eP\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003efactor), op).\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n    }\n\n    \u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eexpr\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e op \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'+'\u003c/span\u003e).\u003cspan class=\"synIdentifier\"\u003eor\u003c/span\u003e(\u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'-'\u003c/span\u003e)).\u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e(\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003ec\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e {\n            \u003cspan class=\"synType\"\u003emove\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003elhs, rhs\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e c {\n                \u003cspan class=\"synConstant\"\u003e'+'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e+\u003c/span\u003e rhs,\n                \u003cspan class=\"synConstant\"\u003e'-'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e-\u003c/span\u003e rhs,\n                _ \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eunreachable!\u003c/span\u003e(),\n            }\n        });\n        \u003cspan class=\"synIdentifier\"\u003echainl1\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eP\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eterm), op).\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n    }\n}\n\n\u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eparse\u003c/span\u003e(input: \u003cspan class=\"synType\"\u003e\u0026amp;str\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003eResult\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e(\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, \u003cspan class=\"synType\"\u003e\u0026amp;str\u003c/span\u003e), ParseError\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003e\u0026amp;str\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(\u003cspan class=\"synPreProc\"\u003eP\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eexpr).\u003cspan class=\"synIdentifier\"\u003eparse\u003c/span\u003e(input)\n}\n\u003c/pre\u003e\n\n\u003cp\u003e言葉で説明すると難しいのですが，型変数を導入する部分を構造体の定義部分だけにしてあげることで，型変数をそれぞれのパーサが別々に導入する必要がなくなっています．\u003cbr/\u003e\nコードも割りとすっきりしますね．\u003c/p\u003e\n\n\u003ch2\u003e結果\u003c/h2\u003e\n\n\u003cp\u003e上記をコードを \u003ccode\u003ecfg\u003c/code\u003e を使って\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時に切り替えながら\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eしてみました．\u003cbr/\u003e\n本当はきちんと繰り返し計測すべきですが，ちょっとサボっています．まぁ何度実行してもだいたい同じくらいになったので許してください．\u003c/p\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left;\"\u003e 実装方法 \u003c/th\u003e\n\u003cth style=\"text-align:right;\"\u003e \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時間 \u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003e \u003c/td\u003e\n\u003ctd style=\"text-align:right;\"\u003e 2.666s \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e \u003ccode\u003e\u0026amp;str\u003c/code\u003e \u003c/td\u003e\n\u003ctd style=\"text-align:right;\"\u003e 1.70s \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e 構造体内で定義 \u003c/td\u003e\n\u003ctd style=\"text-align:right;\"\u003e 1.55s \u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cp\u003eこのような結果になりました．\u003cbr/\u003e\nつまり，先ほどの issue で述べられている\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時間の短縮方法はかなり効き目があるということですね．\u003cbr/\u003e\n構造体の中に閉じ込める方法が，\u003ccode\u003e\u0026amp;str\u003c/code\u003e しか受理しないようにする方法よりもはやく\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eできるのは意外でした\u0026hellip; 参照を引数にとると暗黙に lifetime 変数が導入されたと記憶しているので，その関係なのかな？\u003c/p\u003e\n\n\u003cp\u003e構造体内で定義する方法では，\u003ccode\u003e\u0026amp;str\u003c/code\u003e 以外の入力ストリーム型を受けつけることを可能にしつつも\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時間を短縮できるということで，積極的にこの方式でパーサを定義するべきということがわかりました．\u003c/p\u003e\n\n\u003cp\u003e注意点として，構造体内で別のパーサを呼ぶときには，必ず \u003ccode\u003eP::term\u003c/code\u003e という形ではなく，\u003ccode\u003eP::\u0026lt;I\u0026gt;::term\u003c/code\u003e という形で呼び出すようにする必要があるようです．\u003cbr/\u003e\nきちんと明示的に指定しないと，結局\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\"\u003e型推論\u003c/a\u003eするはめになって意味がないということのようです．\u003c/p\u003e\n\n---\n\nCOMMENT:\nAUTHOR: anevaden\nEMAIL: pgbsajrq@gmail.com\nURL: http://cialisvipsale.com\nIP: 60.173.69.118\nDATE: 03/24/2018 13:14:29\n\nRegards. Quite a lot of posts.\n\ntadalafil 20 mg \u003ca href=\"http://cialisvipsale.com\"\u003ecialis tablets australia\u003c/a\u003e\ninteractions for cialis \u003ca href=\"http://cialisvipsale.com\"\u003ehttp://cialisvipsale.com\u003c/a\u003e\ncialis 5mg prix \u003ca href=\"http://cialisvipsale.com\"\u003ecialis generico\u003c/a\u003e\ncialis dose 30mg\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eRust のパーサ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eライブラリの一つである \u003ca href=\"https://github.com/Marwes/combine\"\u003eMarwes/combine: A parser combinator library for Rust\u003c/a\u003e を使ってみています．\u003cbr/\u003e\n詳しい使い方はきちんとしたドキュメントがあるのでそちらを参照してください．\u003cbr/\u003e\nざっくりいうと \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e の \u003ca href=\"https://hackage.haskell.org/package/parsec\"\u003eparsec: Monadic parser combinators | Hackage\u003c/a\u003e の Rust 版という感じです．\u003c/p\u003e\n\n\u003cp\u003e(ちなみに私も combine を参考に \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e でパーサ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eを作ってみたりしました. )\n\u003ciframe src=\"http://agtn.hatenablog.com/embed/2016/04/30/003009\" title=\"C++ でパーサコンビネータを書きました - 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"http://agtn.hatenablog.com/entry/2016/04/30/003009\"\u003eagtn.hatenablog.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003eで、このライブラリ、とても\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eなコードで書かれているので、かなり\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時間が増加します\u0026hellip; (Boost.Spirit 系に近いです． \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーなどは遥かに読みやすいのであまり困ることはないですが)  \u003cbr/\u003e\nパーサを書いている時にはテストは頻繁に行いたいので，ちょっと\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eがおそいのはつらい．\u003c/p\u003e\n\n\u003cp\u003eなにか解決策はないかなぁと思っていたら本家に issue がたっていました．\u003cbr/\u003e\n\u003ca href=\"https://github.com/Marwes/combine/issues/21\"\u003eExtremely long compile times · Issue #21 · Marwes/combine\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e今回この issue にかかれていた内容を検証してみたので，ここでまとめておこうと思います．\u003c/p\u003e\n\n\u003ch2\u003e結論\u003c/h2\u003e\n\n\u003cp\u003eパーサの定義を，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eな構造体のメソッドとして定義すると\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時間が大幅に短くなる\u003c/p\u003e\n\n\u003ch2\u003e方法\u003c/h2\u003e\n\n\u003cp\u003eまずはじめに言われているのは，入力ストリーム型を\u003ccode\u003eI: Stream\u0026lt;Item=char\u0026gt;\u003c/code\u003e から \u003ccode\u003e\u0026amp;str\u003c/code\u003e にしてしまうという方法です．\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e(It might be possible to specialize the parsers directly as well, say\n\u003ccode\u003e\nfn expr(input: State\u0026lt;\u0026amp;str\u0026gt;) -\u0026gt; ParseResult\u0026lt;Expr, \u0026amp;str\u0026gt;\n\u003c/code\u003e\ninstead of\n\u003ccode\u003e\nfn expr\u0026lt;I: Stream\u0026gt;(input: State\u0026lt;I\u0026gt;) -\u0026gt; ParseResult\u0026lt;I, \u0026amp;str\u0026gt;\n\u003c/code\u003e\n)\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003eこれは作ったパーサを\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eな入力に対して適用することができなくなりますが，ライブラリの利用者側としては，\u003ccode\u003echar\u003c/code\u003e のストリームといったらだいたい \u003ccode\u003e\u0026amp;str\u003c/code\u003e だと思うので，ぶっちゃけ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eじゃなくてもいいじゃんという感じです．\u003c/p\u003e\n\n\u003cp\u003eそしてもう一つが,  \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eな構造体を作って，パーサの定義をその中に閉じ込めるという方法です．\u003cbr/\u003e\nちょっとこちらはコード例を実際に見たほうがわかりやすいと思うので後で説明します．\u003c/p\u003e\n\n\u003ch2\u003e実験コード\u003c/h2\u003e\n\n\u003cp\u003eというわけで，\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eなパーサ\u003c/li\u003e\n\u003cli\u003e\u0026amp;str のみを受理するパーサ\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eな構造体の中に定義された\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eでないパーサ\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eの三種類について，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時間をはかってみます．\u003c/p\u003e\n\n\u003cp\u003eパーサ界のハローワールド，計算機で実験してみます．\nまずは\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eなパーサです．\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003ecombine\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synType\"\u003e*\u003c/span\u003e;\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003ecombine\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003eprimitives\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eStream;\n\n\u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003einteger\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003ewhere\u003c/span\u003e I: Stream\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eItem \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n{\n    \u003cspan class=\"synIdentifier\"\u003emany1\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e_\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e, _\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003edigit\u003c/span\u003e())\n        .\u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e(\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003eis\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e is.\u003cspan class=\"synIdentifier\"\u003einto_iter\u003c/span\u003e().\u003cspan class=\"synIdentifier\"\u003efold\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e, \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003elhs, rhs\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e+\u003c/span\u003e (rhs \u003cspan class=\"synStatement\"\u003eas\u003c/span\u003e \u003cspan class=\"synType\"\u003ei64\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e-\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e'0'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eas\u003c/span\u003e \u003cspan class=\"synType\"\u003ei64\u003c/span\u003e)))\n        .\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n}\n\n\u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003efactor\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003ewhere\u003c/span\u003e I: Stream\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eItem \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n{\n    \u003cspan class=\"synIdentifier\"\u003ebetween\u003c/span\u003e(\u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'('\u003c/span\u003e), \u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e')'\u003c/span\u003e), \u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(expr)).\u003cspan class=\"synIdentifier\"\u003eor\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(integer)).\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n}\n\n\u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eterm\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003ewhere\u003c/span\u003e I: Stream\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eItem \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n{\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e op \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'*'\u003c/span\u003e).\u003cspan class=\"synIdentifier\"\u003eor\u003c/span\u003e(\u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'/'\u003c/span\u003e)).\u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e(\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003ec\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e {\n        \u003cspan class=\"synType\"\u003emove\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003elhs, rhs\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e c {\n            \u003cspan class=\"synConstant\"\u003e'*'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e*\u003c/span\u003e rhs,\n            \u003cspan class=\"synConstant\"\u003e'/'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e/\u003c/span\u003e rhs,\n            _ \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eunreachable!\u003c/span\u003e(),\n        }\n    });\n    \u003cspan class=\"synIdentifier\"\u003echainl1\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(factor), op).\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n}\n\n\u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eexpr\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003ewhere\u003c/span\u003e I: Stream\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eItem \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n{\n    \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e op \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'+'\u003c/span\u003e).\u003cspan class=\"synIdentifier\"\u003eor\u003c/span\u003e(\u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'-'\u003c/span\u003e)).\u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e(\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003ec\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e {\n        \u003cspan class=\"synType\"\u003emove\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003elhs, rhs\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e c {\n            \u003cspan class=\"synConstant\"\u003e'+'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e+\u003c/span\u003e rhs,\n            \u003cspan class=\"synConstant\"\u003e'-'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e-\u003c/span\u003e rhs,\n            _ \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eunreachable!\u003c/span\u003e(),\n        }\n    });\n    \u003cspan class=\"synIdentifier\"\u003echainl1\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(term), op).\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n}\n\n\u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eparse\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(input: I) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003eResult\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e(\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I), ParseError\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003ewhere\u003c/span\u003e I: Stream\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eItem \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\n{\n    \u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(expr).\u003cspan class=\"synIdentifier\"\u003eparse\u003c/span\u003e(input)\n}\n\u003c/pre\u003e\n\n\u003cp\u003eそれぞれの関数が一つのパーサの役割を担います．それぞれのパーサが独立していて，それぞれ別々に型変数を導入しています．\u003c/p\u003e\n\n\u003cp\u003e次に \u003ccode\u003e\u0026amp;str\u003c/code\u003e だけを受け取るパーサです．これは上記の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eなパーサの，型変数を \u003ccode\u003e\u0026amp;str\u003c/code\u003e に置き換えるだけなのでとても簡単です．\u003cbr/\u003e\n一部だけ掲載します．\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eexpr\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003e\u0026amp;str\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, \u003cspan class=\"synType\"\u003e\u0026amp;str\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n     \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e op \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'+'\u003c/span\u003e).\u003cspan class=\"synIdentifier\"\u003eor\u003c/span\u003e(\u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'-'\u003c/span\u003e)).\u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e(\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003ec\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e {\n        \u003cspan class=\"synType\"\u003emove\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003elhs, rhs\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e c {\n            \u003cspan class=\"synConstant\"\u003e'+'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e+\u003c/span\u003e rhs,\n            \u003cspan class=\"synConstant\"\u003e'-'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e-\u003c/span\u003e rhs,\n            _ \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eunreachable!\u003c/span\u003e(),\n        }\n    });\n    \u003cspan class=\"synIdentifier\"\u003echainl1\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(term), op).\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n}\n\n\u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eparse\u003c/span\u003e(input: \u003cspan class=\"synType\"\u003e\u0026amp;str\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003eResult\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e(\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, \u003cspan class=\"synType\"\u003e\u0026amp;str\u003c/span\u003e), ParseError\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003e\u0026amp;str\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(expr).\u003cspan class=\"synIdentifier\"\u003eparse\u003c/span\u003e(input)\n}\n\u003c/pre\u003e\n\n\u003cp\u003e最後が，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eな構造体のメソッド中に，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eでないパーサを定義して閉じ込める方法です．\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003ecombine\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synType\"\u003e*\u003c/span\u003e;\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003ecombine\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003eprimitives\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eStream;\n\u003cspan class=\"synStatement\"\u003euse\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003estd\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003emarker\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003ePhantomData;\n\n truct P\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(PhantomData\u003cspan class=\"synStatement\"\u003e\u0026lt;fn\u003c/span\u003e(I) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e);\n\n\u003cspan class=\"synStatement\"\u003eimpl\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e P\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ewhere\u003c/span\u003e I: Stream\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eItem \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003einteger\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"synIdentifier\"\u003emany1\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003eVec\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e_\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e, _\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003edigit\u003c/span\u003e())\n            .\u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e(\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003eis\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e is.\u003cspan class=\"synIdentifier\"\u003einto_iter\u003c/span\u003e().\u003cspan class=\"synIdentifier\"\u003efold\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e, \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003elhs, rhs\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e+\u003c/span\u003e (rhs \u003cspan class=\"synStatement\"\u003eas\u003c/span\u003e \u003cspan class=\"synType\"\u003ei64\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e-\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e'0'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eas\u003c/span\u003e \u003cspan class=\"synType\"\u003ei64\u003c/span\u003e)))\n            .\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n    }\n\n    \u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003efactor\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"synIdentifier\"\u003ebetween\u003c/span\u003e(\u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'('\u003c/span\u003e), \u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e')'\u003c/span\u003e), \u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eP\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eexpr))\n            .\u003cspan class=\"synIdentifier\"\u003eor\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eP\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003einteger))\n            .\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n    }\n\n    \u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eterm\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e op \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'*'\u003c/span\u003e).\u003cspan class=\"synIdentifier\"\u003eor\u003c/span\u003e(\u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'/'\u003c/span\u003e)).\u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e(\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003ec\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e {\n            \u003cspan class=\"synType\"\u003emove\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003elhs, rhs\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e c {\n                \u003cspan class=\"synConstant\"\u003e'*'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e*\u003c/span\u003e rhs,\n                \u003cspan class=\"synConstant\"\u003e'/'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e/\u003c/span\u003e rhs,\n                _ \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eunreachable!\u003c/span\u003e(),\n            }\n        });\n        \u003cspan class=\"synIdentifier\"\u003echainl1\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eP\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003efactor), op).\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n    }\n\n    \u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eexpr\u003c/span\u003e(input: State\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ParseResult\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, I\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e op \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'+'\u003c/span\u003e).\u003cspan class=\"synIdentifier\"\u003eor\u003c/span\u003e(\u003cspan class=\"synType\"\u003echar\u003c/span\u003e(\u003cspan class=\"synConstant\"\u003e'-'\u003c/span\u003e)).\u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e(\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003ec\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e {\n            \u003cspan class=\"synType\"\u003emove\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003elhs, rhs\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e c {\n                \u003cspan class=\"synConstant\"\u003e'+'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e+\u003c/span\u003e rhs,\n                \u003cspan class=\"synConstant\"\u003e'-'\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e lhs \u003cspan class=\"synStatement\"\u003e-\u003c/span\u003e rhs,\n                _ \u003cspan class=\"synStatement\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eunreachable!\u003c/span\u003e(),\n            }\n        });\n        \u003cspan class=\"synIdentifier\"\u003echainl1\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(\u003cspan class=\"synIdentifier\"\u003eP\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003eI\u003cspan class=\"synStatement\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eterm), op).\u003cspan class=\"synIdentifier\"\u003eparse_state\u003c/span\u003e(input)\n    }\n}\n\n\u003cspan class=\"synStatement\"\u003epub\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eparse\u003c/span\u003e(input: \u003cspan class=\"synType\"\u003e\u0026amp;str\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synType\"\u003eResult\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e(\u003cspan class=\"synType\"\u003ei64\u003c/span\u003e, \u003cspan class=\"synType\"\u003e\u0026amp;str\u003c/span\u003e), ParseError\u003cspan class=\"synStatement\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"synType\"\u003e\u0026amp;str\u003c/span\u003e\u003cspan class=\"synStatement\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"synIdentifier\"\u003eparser\u003c/span\u003e(\u003cspan class=\"synPreProc\"\u003eP\u003c/span\u003e\u003cspan class=\"synSpecial\"\u003e::\u003c/span\u003eexpr).\u003cspan class=\"synIdentifier\"\u003eparse\u003c/span\u003e(input)\n}\n\u003c/pre\u003e\n\n\u003cp\u003e言葉で説明すると難しいのですが，型変数を導入する部分を構造体の定義部分だけにしてあげることで，型変数をそれぞれのパーサが別々に導入する必要がなくなっています．\u003cbr/\u003e\nコードも割りとすっきりしますね．\u003c/p\u003e\n\n\u003ch2\u003e結果\u003c/h2\u003e\n\n\u003cp\u003e上記をコードを \u003ccode\u003ecfg\u003c/code\u003e を使って\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時に切り替えながら\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eしてみました．\u003cbr/\u003e\n本当はきちんと繰り返し計測すべきですが，ちょっとサボっています．まぁ何度実行してもだいたい同じくらいになったので許してください．\u003c/p\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left;\"\u003e 実装方法 \u003c/th\u003e\n\u003cth style=\"text-align:right;\"\u003e \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時間 \u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003e \u003c/td\u003e\n\u003ctd style=\"text-align:right;\"\u003e 2.666s \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e \u003ccode\u003e\u0026amp;str\u003c/code\u003e \u003c/td\u003e\n\u003ctd style=\"text-align:right;\"\u003e 1.70s \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left;\"\u003e 構造体内で定義 \u003c/td\u003e\n\u003ctd style=\"text-align:right;\"\u003e 1.55s \u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cp\u003eこのような結果になりました．\u003cbr/\u003e\nつまり，先ほどの issue で述べられている\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時間の短縮方法はかなり効き目があるということですね．\u003cbr/\u003e\n構造体の中に閉じ込める方法が，\u003ccode\u003e\u0026amp;str\u003c/code\u003e しか受理しないようにする方法よりもはやく\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eできるのは意外でした\u0026hellip; 参照を引数にとると暗黙に lifetime 変数が導入されたと記憶しているので，その関係なのかな？\u003c/p\u003e\n\n\u003cp\u003e構造体内で定義する方法では，\u003ccode\u003e\u0026amp;str\u003c/code\u003e 以外の入力ストリーム型を受けつけることを可能にしつつも\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時間を短縮できるということで，積極的にこの方式でパーサを定義するべきということがわかりました．\u003c/p\u003e\n\n\u003cp\u003e注意点として，構造体内で別のパーサを呼ぶときには，必ず \u003ccode\u003eP::term\u003c/code\u003e という形ではなく，\u003ccode\u003eP::\u0026lt;I\u0026gt;::term\u003c/code\u003e という形で呼び出すようにする必要があるようです．\u003cbr/\u003e\nきちんと明示的に指定しないと，結局\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\"\u003e型推論\u003c/a\u003eするはめになって意味がないということのようです．\u003c/p\u003e\n\n---\n\nCOMMENT:\nAUTHOR: anevaden\nEMAIL: pgbsajrq@gmail.com\nURL: http://cialisvipsale.com\nIP: 60.173.69.118\nDATE: 03/24/2018 13:14:29\n\nRegards. Quite a lot of posts.\n\ntadalafil 20 mg \u003ca href=\"http://cialisvipsale.com\"\u003ecialis tablets australia\u003c/a\u003e\ninteractions for cialis \u003ca href=\"http://cialisvipsale.com\"\u003ehttp://cialisvipsale.com\u003c/a\u003e\ncialis 5mg prix \u003ca href=\"http://cialisvipsale.com\"\u003ecialis generico\u003c/a\u003e\ncialis dose 30mg\n\n---\n\n---\n","slug":"Rust_のパーサコンビネータライブラリ_combine_を使う時の_tips","title":"Rust のパーサコンビネータライブラリ combine を使う時の tips","timestamp":1463241799000,"tags":[]},{"rawMarkdown":"---\ntitle: \"C++ でパーサコンビネータを書きました\"\ndate: 2016-04-29T15:30:09.000Z\ntags: []\n---\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e で\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eといえば，Boost.Spirit や \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/yacc\"\u003eyacc\u003c/a\u003e系などが有名ですが，どうにも使うの辛かったので作りました．\u003c/p\u003e\n\n\u003ch3\u003e2016/05/01 追記　\u003c/h3\u003e\n\n\u003cp\u003eいろいろ更新しました．肯定先読み以外はプリミティブも実装し終わっているかと思います．\u003cbr/\u003e\nドキュメントはまだ無いのですが，すべての機能についてテストは書いてあるので，それを見てもらえればなんとか使い方もわかるかと思います．\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/agatan/coco\"\u003eagatan/coco\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ecoco::combix\u003c/code\u003e がパーサ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eライブラリの namespace です．\u003c/p\u003e\n\n\u003cp\u003eBoost.Spirit は高機能かつ高性能なんですが，かなり変態的な構文で記述する必要があり(まぁ \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e なんですけど)，さらにその性能や便利さ，構文のために異常なまでにテンプレートを多用しています．私は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003e後の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%CC%DA\"\u003e構文木\u003c/a\u003eの構築に Boost.Variant を使ってみているのですが，Boost.Spirit と Boost.Variant の両面から，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eすぎるがゆえの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラー爆発攻撃を食らって本当に辛いです．\u003c/p\u003e\n\n\u003cp\u003eそこで，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e の \u003ca href=\"https://hackage.haskell.org/package/parsec\"\u003eparsec\u003c/a\u003e や Rust の \u003ca href=\"https://github.com/Marwes/combine\"\u003ecombine\u003c/a\u003e を参考にしつつ，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e でパーサ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eを書いてみました．(実際これを使っても\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーは割りと発狂しますが)\u003c/p\u003e\n\n\u003ch2\u003e例\u003c/h2\u003e\n\n\u003cp\u003e例となるコードは \u003ca href=\"https://github.com/agatan/coco-combix-demo\"\u003eagatan/coco-combix-demo\u003c/a\u003e においてあります．\u003cbr/\u003e\nドキュメントもないので，なんとなく雰囲気だけコードから読み取る必要があります．(例に出ていない機能もちょいちょい実装されてしまっています．)\u003c/p\u003e\n\n\u003cp\u003e以下にちょっと簡略版のコードを載せてみます．ありがちな電卓です．AST を作らず直接計算しています．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;functional\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;coco/combix.hpp\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e cbx = coco::combix;\n\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e stream_type = cbx::iterator_stream\u0026lt;std::string::const_iterator\u0026gt;;\n\ncbx::parser\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, stream_type\u0026gt; expression();\n\ncbx::parser\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, stream_type\u0026gt; number() {\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e cbx::expected(cbx::map(cbx::many1(cbx::digit()),\n                                [](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; is) \u003cspan class=\"synError\"\u003e{\u003c/span\u003e\n                                  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e acc = \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n                                  \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e (\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e i : is) \u003cspan class=\"synError\"\u003e{\u003c/span\u003e\n                                    acc = acc * \u003cspan class=\"synConstant\"\u003e10\u003c/span\u003e + i;\n                                  \u003cspan class=\"synError\"\u003e}\u003c/span\u003e\n                                  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e acc;\n                                }\u003cspan class=\"synError\"\u003e)\u003c/span\u003e,\n                       \u003cspan class=\"synConstant\"\u003e\u0026quot;integer number\u0026quot;\u003c/span\u003e\u003cspan class=\"synError\"\u003e)\u003c/span\u003e;\n}\n\ncbx::parser\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, stream_type\u0026gt; factor() {\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e cbx::choice(\n      number(),\n      cbx::between(cbx::skip(cbx::token(\u003cspan class=\"synConstant\"\u003e'('\u003c/span\u003e), cbx::spaces()),\n                   cbx::skip(cbx::token(\u003cspan class=\"synConstant\"\u003e')'\u003c/span\u003e), cbx::spaces()),\n                   cbx::skip(cbx::lazy_fun(expression), cbx::spaces())));\n}\n\ncbx::parser\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, stream_type\u0026gt; term() {\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e op = cbx::map(\n      cbx::skip(cbx::choice(cbx::token(\u003cspan class=\"synConstant\"\u003e'*'\u003c/span\u003e), cbx::token(\u003cspan class=\"synConstant\"\u003e'/'\u003c/span\u003e)), cbx::spaces()),\n      [](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e c) -\u0026gt; std::function\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e(\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e)\u0026gt; \u003cspan class=\"synError\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (c == \u003cspan class=\"synConstant\"\u003e'*'\u003c/span\u003e) \u003cspan class=\"synError\"\u003e{\u003c/span\u003e\n          \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e std::multiplies\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;();\n        \u003cspan class=\"synError\"\u003e}\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e \u003cspan class=\"synError\"\u003e{\u003c/span\u003e\n          \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e std::divides\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;();\n        \u003cspan class=\"synError\"\u003e}\u003c/span\u003e\n      }\u003cspan class=\"synError\"\u003e)\u003c/span\u003e;\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e cbx::chainl1(cbx::skip(factor(), cbx::spaces()), op);\n}\n\ncbx::parser\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, stream_type\u0026gt; expression() {\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e op = cbx::map(\n      cbx::skip(cbx::choice(cbx::token(\u003cspan class=\"synConstant\"\u003e'+'\u003c/span\u003e), cbx::token(\u003cspan class=\"synConstant\"\u003e'-'\u003c/span\u003e)), cbx::spaces()),\n      [](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e c) -\u0026gt; std::function\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e(\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e)\u0026gt; \u003cspan class=\"synError\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (c == \u003cspan class=\"synConstant\"\u003e'+'\u003c/span\u003e) \u003cspan class=\"synError\"\u003e{\u003c/span\u003e\n          \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e std::plus\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;();\n        \u003cspan class=\"synError\"\u003e}\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e \u003cspan class=\"synError\"\u003e{\u003c/span\u003e\n          \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e std::minus\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;();\n        \u003cspan class=\"synError\"\u003e}\u003c/span\u003e\n      }\u003cspan class=\"synError\"\u003e)\u003c/span\u003e;\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e cbx::chainl1(cbx::skip(term(), cbx::spaces()), op);\n}\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main() {\n  std::string src;\n  std::getline(std::cin, src);\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e n = number();\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e stream = cbx::range_stream(src);\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e parser = expression();\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e res = cbx::parse(parser, stream)) {\n    std::cout \u0026lt;\u0026lt; res.unwrap() \u0026lt;\u0026lt; std::endl;\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    std::cout \u0026lt;\u0026lt; cbx::to_string(res.unwrap_error()) \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\n\u003ch2\u003e特徴\u003c/h2\u003e\n\n\u003cp\u003eparsec を知っている方であれば読めるはずです...\u003cbr/\u003e\n特徴としては，多くのパーサは入力ストリームの型に依存せずに作れるようになっていることです．例えば，あらゆる入力一つを受け付け消費する \u003ccode\u003eany\u003c/code\u003e というパーサは，入力が \u003ccode\u003echar\u003c/code\u003e のストリームであろうと \u003ccode\u003eint\u003c/code\u003e のストリームであろうとパースを実行できるようになっています．\u003cbr/\u003e\n本来はエラーメッセージの爆発や読みづらさを防ぐために，すべてのパーサ自体にストリームの型をひも付けたかったのですが，そうすると，\u003ccode\u003eany\u003c/code\u003e を使うたびに，\u003ccode\u003eany\u0026lt;cbx::iterator_stream\u0026lt;typename std::vector\u0026lt;int\u0026gt;::const_iterator\u0026gt;\u0026gt;()\u003c/code\u003e とか \u003ccode\u003eany\u0026lt;cbx::iterator_stream\u0026lt;std::string::const_iterator\u0026gt;\u0026gt;()\u003c/code\u003e とかしなくてはなりません．これは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e や Rust と違って \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\"\u003e型推論\u003c/a\u003eが限定的であるためです．(\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e や Rust では後でその値がどう使われているかも推論の根拠として使われます．)\u003cbr/\u003e\nそこで，パーサ自体には入力ストリームの型を指定させずに，実際にパースする部分で初めて入力ストリームの型を検査することにしました．\u003c/p\u003e\n\n\u003cp\u003eで，\u003ccode\u003ecbx::parser\u0026lt;int, stream_type\u0026gt;\u003c/code\u003e はパーサを type erasure を使ってラップします．普通に使っていると簡単に \u003ccode\u003ecbx::expected\u0026lt;cbx::map_parser\u0026lt;cbx::many1_parser\u0026lt;cbx::digit_parser\u0026gt;, (lambda at ...)\u0026gt;\u0026gt;\u003c/code\u003e 型とかが出てきます(\u003ccode\u003ecbx::expected(cbx::map(cbx::many1(cbx::digit()), [](auto\u0026amp;\u0026amp;) {...}), \"integer number\")\u003c/code\u003e の型です)\u003cbr/\u003e\nこれを関数定義のたびに書くとか発狂してしまうので，type erasure を使って型をラップし短絡します．\u003cbr/\u003e\nただしパフォーマンスの観点から行くとおそらく型をラップするために仮想関数を使ってしまうので，インライン展開等がきかなくなると思われます．まぁ仕方ないです．\u003cbr/\u003e\nただ，型を膨らませすぎずに適度にラップしてやると，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーの内容がかなり読みやすくなるはずです．なのでなんかわからんけどエラーになるっていうときは細かくパーサを分割してラップしてやると良いかもしれません．\u003c/p\u003e\n\n\u003ch2\u003eまとめ\u003c/h2\u003e\n\n\u003cp\u003eあまりにもドキュメントやコメント書かなすぎてひどいですが，ちょっと\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eしたいとかっていうときに便利だと思います．\u003cbr/\u003e\nBoost.Spirit と違って普通に \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のプログラムとして書けます．(Boost.Spirit も \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e プログラムとして書けてはいるんですが，なんかあれはあれで別の言語を覚えているような気分になってしまったので...)\u003c/p\u003e\n\n\u003cp\u003eあと PEG のプリミティブをまだ完全に実装していないと思います．先読みや否定先読みが出来ません．(実装します…)\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e で\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eといえば，Boost.Spirit や \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/yacc\"\u003eyacc\u003c/a\u003e系などが有名ですが，どうにも使うの辛かったので作りました．\u003c/p\u003e\n\n\u003ch3\u003e2016/05/01 追記　\u003c/h3\u003e\n\n\u003cp\u003eいろいろ更新しました．肯定先読み以外はプリミティブも実装し終わっているかと思います．\u003cbr/\u003e\nドキュメントはまだ無いのですが，すべての機能についてテストは書いてあるので，それを見てもらえればなんとか使い方もわかるかと思います．\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/agatan/coco\"\u003eagatan/coco\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ecoco::combix\u003c/code\u003e がパーサ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eライブラリの namespace です．\u003c/p\u003e\n\n\u003cp\u003eBoost.Spirit は高機能かつ高性能なんですが，かなり変態的な構文で記述する必要があり(まぁ \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e なんですけど)，さらにその性能や便利さ，構文のために異常なまでにテンプレートを多用しています．私は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003e後の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%CC%DA\"\u003e構文木\u003c/a\u003eの構築に Boost.Variant を使ってみているのですが，Boost.Spirit と Boost.Variant の両面から，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eすぎるがゆえの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラー爆発攻撃を食らって本当に辛いです．\u003c/p\u003e\n\n\u003cp\u003eそこで，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e の \u003ca href=\"https://hackage.haskell.org/package/parsec\"\u003eparsec\u003c/a\u003e や Rust の \u003ca href=\"https://github.com/Marwes/combine\"\u003ecombine\u003c/a\u003e を参考にしつつ，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e でパーサ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eを書いてみました．(実際これを使っても\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーは割りと発狂しますが)\u003c/p\u003e\n\n\u003ch2\u003e例\u003c/h2\u003e\n\n\u003cp\u003e例となるコードは \u003ca href=\"https://github.com/agatan/coco-combix-demo\"\u003eagatan/coco-combix-demo\u003c/a\u003e においてあります．\u003cbr/\u003e\nドキュメントもないので，なんとなく雰囲気だけコードから読み取る必要があります．(例に出ていない機能もちょいちょい実装されてしまっています．)\u003c/p\u003e\n\n\u003cp\u003e以下にちょっと簡略版のコードを載せてみます．ありがちな電卓です．AST を作らず直接計算しています．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;functional\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;coco/combix.hpp\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e cbx = coco::combix;\n\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e stream_type = cbx::iterator_stream\u0026lt;std::string::const_iterator\u0026gt;;\n\ncbx::parser\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, stream_type\u0026gt; expression();\n\ncbx::parser\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, stream_type\u0026gt; number() {\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e cbx::expected(cbx::map(cbx::many1(cbx::digit()),\n                                [](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; is) \u003cspan class=\"synError\"\u003e{\u003c/span\u003e\n                                  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e acc = \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n                                  \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e (\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e i : is) \u003cspan class=\"synError\"\u003e{\u003c/span\u003e\n                                    acc = acc * \u003cspan class=\"synConstant\"\u003e10\u003c/span\u003e + i;\n                                  \u003cspan class=\"synError\"\u003e}\u003c/span\u003e\n                                  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e acc;\n                                }\u003cspan class=\"synError\"\u003e)\u003c/span\u003e,\n                       \u003cspan class=\"synConstant\"\u003e\u0026quot;integer number\u0026quot;\u003c/span\u003e\u003cspan class=\"synError\"\u003e)\u003c/span\u003e;\n}\n\ncbx::parser\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, stream_type\u0026gt; factor() {\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e cbx::choice(\n      number(),\n      cbx::between(cbx::skip(cbx::token(\u003cspan class=\"synConstant\"\u003e'('\u003c/span\u003e), cbx::spaces()),\n                   cbx::skip(cbx::token(\u003cspan class=\"synConstant\"\u003e')'\u003c/span\u003e), cbx::spaces()),\n                   cbx::skip(cbx::lazy_fun(expression), cbx::spaces())));\n}\n\ncbx::parser\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, stream_type\u0026gt; term() {\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e op = cbx::map(\n      cbx::skip(cbx::choice(cbx::token(\u003cspan class=\"synConstant\"\u003e'*'\u003c/span\u003e), cbx::token(\u003cspan class=\"synConstant\"\u003e'/'\u003c/span\u003e)), cbx::spaces()),\n      [](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e c) -\u0026gt; std::function\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e(\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e)\u0026gt; \u003cspan class=\"synError\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (c == \u003cspan class=\"synConstant\"\u003e'*'\u003c/span\u003e) \u003cspan class=\"synError\"\u003e{\u003c/span\u003e\n          \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e std::multiplies\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;();\n        \u003cspan class=\"synError\"\u003e}\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e \u003cspan class=\"synError\"\u003e{\u003c/span\u003e\n          \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e std::divides\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;();\n        \u003cspan class=\"synError\"\u003e}\u003c/span\u003e\n      }\u003cspan class=\"synError\"\u003e)\u003c/span\u003e;\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e cbx::chainl1(cbx::skip(factor(), cbx::spaces()), op);\n}\n\ncbx::parser\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, stream_type\u0026gt; expression() {\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e op = cbx::map(\n      cbx::skip(cbx::choice(cbx::token(\u003cspan class=\"synConstant\"\u003e'+'\u003c/span\u003e), cbx::token(\u003cspan class=\"synConstant\"\u003e'-'\u003c/span\u003e)), cbx::spaces()),\n      [](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e c) -\u0026gt; std::function\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e(\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e)\u0026gt; \u003cspan class=\"synError\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (c == \u003cspan class=\"synConstant\"\u003e'+'\u003c/span\u003e) \u003cspan class=\"synError\"\u003e{\u003c/span\u003e\n          \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e std::plus\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;();\n        \u003cspan class=\"synError\"\u003e}\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e \u003cspan class=\"synError\"\u003e{\u003c/span\u003e\n          \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e std::minus\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;();\n        \u003cspan class=\"synError\"\u003e}\u003c/span\u003e\n      }\u003cspan class=\"synError\"\u003e)\u003c/span\u003e;\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e cbx::chainl1(cbx::skip(term(), cbx::spaces()), op);\n}\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main() {\n  std::string src;\n  std::getline(std::cin, src);\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e n = number();\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e stream = cbx::range_stream(src);\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e parser = expression();\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e res = cbx::parse(parser, stream)) {\n    std::cout \u0026lt;\u0026lt; res.unwrap() \u0026lt;\u0026lt; std::endl;\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    std::cout \u0026lt;\u0026lt; cbx::to_string(res.unwrap_error()) \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\n\u003ch2\u003e特徴\u003c/h2\u003e\n\n\u003cp\u003eparsec を知っている方であれば読めるはずです...\u003cbr/\u003e\n特徴としては，多くのパーサは入力ストリームの型に依存せずに作れるようになっていることです．例えば，あらゆる入力一つを受け付け消費する \u003ccode\u003eany\u003c/code\u003e というパーサは，入力が \u003ccode\u003echar\u003c/code\u003e のストリームであろうと \u003ccode\u003eint\u003c/code\u003e のストリームであろうとパースを実行できるようになっています．\u003cbr/\u003e\n本来はエラーメッセージの爆発や読みづらさを防ぐために，すべてのパーサ自体にストリームの型をひも付けたかったのですが，そうすると，\u003ccode\u003eany\u003c/code\u003e を使うたびに，\u003ccode\u003eany\u0026lt;cbx::iterator_stream\u0026lt;typename std::vector\u0026lt;int\u0026gt;::const_iterator\u0026gt;\u0026gt;()\u003c/code\u003e とか \u003ccode\u003eany\u0026lt;cbx::iterator_stream\u0026lt;std::string::const_iterator\u0026gt;\u0026gt;()\u003c/code\u003e とかしなくてはなりません．これは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e や Rust と違って \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\"\u003e型推論\u003c/a\u003eが限定的であるためです．(\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e や Rust では後でその値がどう使われているかも推論の根拠として使われます．)\u003cbr/\u003e\nそこで，パーサ自体には入力ストリームの型を指定させずに，実際にパースする部分で初めて入力ストリームの型を検査することにしました．\u003c/p\u003e\n\n\u003cp\u003eで，\u003ccode\u003ecbx::parser\u0026lt;int, stream_type\u0026gt;\u003c/code\u003e はパーサを type erasure を使ってラップします．普通に使っていると簡単に \u003ccode\u003ecbx::expected\u0026lt;cbx::map_parser\u0026lt;cbx::many1_parser\u0026lt;cbx::digit_parser\u0026gt;, (lambda at ...)\u0026gt;\u0026gt;\u003c/code\u003e 型とかが出てきます(\u003ccode\u003ecbx::expected(cbx::map(cbx::many1(cbx::digit()), [](auto\u0026amp;\u0026amp;) {...}), \"integer number\")\u003c/code\u003e の型です)\u003cbr/\u003e\nこれを関数定義のたびに書くとか発狂してしまうので，type erasure を使って型をラップし短絡します．\u003cbr/\u003e\nただしパフォーマンスの観点から行くとおそらく型をラップするために仮想関数を使ってしまうので，インライン展開等がきかなくなると思われます．まぁ仕方ないです．\u003cbr/\u003e\nただ，型を膨らませすぎずに適度にラップしてやると，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーの内容がかなり読みやすくなるはずです．なのでなんかわからんけどエラーになるっていうときは細かくパーサを分割してラップしてやると良いかもしれません．\u003c/p\u003e\n\n\u003ch2\u003eまとめ\u003c/h2\u003e\n\n\u003cp\u003eあまりにもドキュメントやコメント書かなすぎてひどいですが，ちょっと\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eしたいとかっていうときに便利だと思います．\u003cbr/\u003e\nBoost.Spirit と違って普通に \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のプログラムとして書けます．(Boost.Spirit も \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e プログラムとして書けてはいるんですが，なんかあれはあれで別の言語を覚えているような気分になってしまったので...)\u003c/p\u003e\n\n\u003cp\u003eあと PEG のプリミティブをまだ完全に実装していないと思います．先読みや否定先読みが出来ません．(実装します…)\u003c/p\u003e\n\n---\n\n---\n","slug":"C++_でパーサコンビネータを書きました","title":"C++ でパーサコンビネータを書きました","timestamp":1461943809000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Rust における return文の LLVM IR 表現について\"\ndate: 2016-04-13T09:34:03.000Z\ntags: []\n---\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eif\u003c/code\u003e 文が値を返す\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ereturn\u003c/code\u003e 文を持つ\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e以上のような特徴を持つ言語はどういう感じで\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eされるのか知りたくて，Rust について調べてみました．\u003c/p\u003e\n\n\u003cp\u003eRust では以下の様なことが出来ます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003ef\u003c/span\u003e() {\n  \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e x = \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e cond {\n    return None;\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e\n  };\n  ...\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scala\"\u003eScala\u003c/a\u003e とかもできると思います．\u003ccode\u003econd\u003c/code\u003e が真だった場合は，\u003ccode\u003ex\u003c/code\u003e の値を返すのではなく，関数から抜けてしまうという意味です．\u003c/p\u003e\n\n\u003cp\u003eこれを Rust ではどんな \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR に落とし込んでいるのか．\u003c/p\u003e\n\n\u003ch1\u003e\u003ccode\u003ereturn\u003c/code\u003e 文がない場合\u003c/h1\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003enoreturn\u003c/span\u003e(x: isize) -\u0026gt; isize {\n  x\n}\n\u003c/pre\u003e\n\n\u003cp\u003e最も単純な場合です．この場合，生成される \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR は，\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003edefine internal i64 @_ZN4hoge8noreturn17h811bf1a871f85432E(i64) unnamed_addr #0 {\nentry-block:\n  %x = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  ret i64 %1\n}\u003c/pre\u003e\n\n\u003cp\u003eとなります．\n名前がマングルされていますが，上記の \u003ccode\u003enoreturn\u003c/code\u003e 関数です．\nやっていることは単純で，第一引数を読み込んで返すだけです．\u003c/p\u003e\n\n\u003ch1\u003e\u003ccode\u003ereturn\u003c/code\u003e に相当する文が一つのみの場合\u003c/h1\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eonereturn\u003c/span\u003e(x: isize) -\u0026gt; isize {\n  \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e y = \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e x == \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e {\n    \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    x\n  };\n  return x;\n}\n\u003c/pre\u003e\n\n\u003cp\u003e実際に値を返す部分が一箇所しかない場合です．途中に分岐があっても最終的に一箇所になっていれば多分同じ結果になります．\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003edefine internal i64 @_ZN4hoge9onereturn17h8b718f32daa6a379E(i64) unnamed_addr #0 {\nentry-block:\n  %x = alloca i64\n  %y = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  %2 = icmp eq i64 %1, 0\n  br i1 %2, label %then-block-18-, label %else-block\n\nthen-block-18-:                                   ; preds = %entry-block\n  store i64 1, i64* %y\n  br label %join\n\nelse-block:                                       ; preds = %entry-block\n  %3 = load i64, i64* %x\n  store i64 %3, i64* %y\n  br label %join\n\njoin:                                             ; preds = %else-block, %then-block-18-\n  %4 = load i64, i64* %x\n  br label %clean_ast_10_\n\nreturn:                                           ; preds = %clean_ast_10_\n  ret i64 %4\n\nclean_ast_10_:                                    ; preds = %join\n  br label %return\n}\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003ereturn\u003c/code\u003e という BasicBlock ができています．これは \u003ccode\u003ereturn\u003c/code\u003e 文が現れると作られるよう？です．\nで，その中では単純に \u003ccode\u003ex\u003c/code\u003e に該当する値を返しています．\u003c/p\u003e\n\n\u003cp\u003e最後の \u003ccode\u003ereturn x;\u003c/code\u003e 文を 単純に \u003ccode\u003ex\u003c/code\u003e に置き換えてみると，\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003edefine internal i64 @_ZN4hoge9onereturn17h8b718f32daa6a379E(i64) unnamed_addr #0 {\nentry-block:\n  %x = alloca i64\n  %y = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  %2 = icmp eq i64 %1, 0\n  br i1 %2, label %then-block-18-, label %else-block\n\nthen-block-18-:                                   ; preds = %entry-block\n  store i64 1, i64* %y\n  br label %join\n\nelse-block:                                       ; preds = %entry-block\n  %3 = load i64, i64* %x\n  store i64 %3, i64* %y\n  br label %join\n\njoin:                                             ; preds = %else-block, %then-block-18-\n  %4 = load i64, i64* %x\n  ret i64 %4\n}\u003c/pre\u003e\n\n\u003cp\u003eとなります． \u003ccode\u003ereturn\u003c/code\u003e ブロックが消えていますね．なので \u003ccode\u003ereturn\u003c/code\u003e 文があると \u003ccode\u003ereturn\u003c/code\u003e ブロックが作られる、で良さそう？\u003c/p\u003e\n\n\u003ch1\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eのパスから値を返す\u003c/h1\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003emultireturn\u003c/span\u003e(x: isize) -\u0026gt; isize {\n  \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e y = \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e x == \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e {\n    return -\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e;\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    x\n  };\n  y\n}\n\u003c/pre\u003e\n\n\u003cp\u003eさて，では最初に述べた，\u003ccode\u003eif\u003c/code\u003e の分岐内にある \u003ccode\u003ereturn\u003c/code\u003e についてです．\nこれは，\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003edefine internal i64 @_ZN4hoge11multireturn17had379e8ce5a18f08E(i64) unnamed_addr #0 {\nentry-block:\n  %sret_slot = alloca i64\n  %x = alloca i64\n  %y = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  %2 = icmp eq i64 %1, 0\n  br i1 %2, label %then-block-18-, label %else-block\n\nthen-block-18-:                                   ; preds = %entry-block\n  store i64 -1, i64* %sret_slot\n  br label %return\n\nelse-block:                                       ; preds = %entry-block\n  %3 = load i64, i64* %x\n  store i64 %3, i64* %y\n  br label %join\n\njoin:                                             ; preds = %else-block\n  %4 = load i64, i64* %y\n  store i64 %4, i64* %sret_slot\n  br label %return\n\nreturn:                                           ; preds = %join, %then-block-18-\n  %5 = load i64, i64* %sret_slot\n  ret i64 %5\n}\u003c/pre\u003e\n\n\u003cp\u003eこうなりました．\nまず，\u003ccode\u003ereturn\u003c/code\u003e 文があるため？，\u003ccode\u003ereturn\u003c/code\u003e ブロックが作られています．\nしかし今回は，パスによって返すものが違います．(値が違うという意味ではなく，同じ変数ですらないという意味です...)\u003c/p\u003e\n\n\u003cp\u003eよく IR を読むと，関数の頭で \u003ccode\u003e%sret_slot\u003c/code\u003e という名前でスタック領域を確保していることがわかります．\nそして，\u003ccode\u003ereturn\u003c/code\u003e ブロック内では，これを読んできて返しています．\u003cbr/\u003e\nさらに，\u003ccode\u003eif\u003c/code\u003e 文の then 節にあたる，\u003ccode\u003ethen-block-18-\u003c/code\u003e というブロックでは，\u003ccode\u003e%sret_slot\u003c/code\u003e に値を格納して \u003ccode\u003ereturn\u003c/code\u003e ブロックへジャンプしています．\nelse 節のあとの部分 (\u003ccode\u003ejoin\u003c/code\u003e ブロック) でも同様に, \u003ccode\u003e%sret_slot\u003c/code\u003e に値を格納して \u003ccode\u003ereturn\u003c/code\u003e ブロックへジャンプしています．\u003c/p\u003e\n\n\u003ch1\u003eまとめ\u003c/h1\u003e\n\n\u003cp\u003eというわけで，様々な Rust コードを \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR に変換して見てみた結果，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eのパスから値を返す場合は，「ローカル変数として返り値を定義し，そこに返したい値を格納してから \u003ccode\u003ereturn\u003c/code\u003e に goto」という形になっていることがわかりました．\u003c/p\u003e\n\n\u003cp\u003e(ほとんど \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR を乗っけるだけになってしまった...)\u003c/p\u003e\n\n\u003ch2\u003eちなみに ...\u003c/h2\u003e\n\n\u003ch1\u003e\u003ccode\u003eif\u003c/code\u003e 文の返す値をそのまま返す\u003c/h1\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eifreturn\u003c/span\u003e(x: isize) -\u0026gt; isize {\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e x == \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e {\n    \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    x\n  }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eRust に慣れていないとちょっとわかりにくいですが，\u003ccode\u003ex == 0\u003c/code\u003e の場合は 1 を返し，そうでない場合は \u003ccode\u003ex\u003c/code\u003e を返す関数です．\u003c/p\u003e\n\n\u003cp\u003eこれは，\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003edefine internal i64 @_ZN4hoge8ifreturn17hcdaab6e376d6c95cE(i64) unnamed_addr #0 {\nentry-block:\n  %sret_slot = alloca i64\n  %x = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  %2 = icmp eq i64 %1, 0\n  br i1 %2, label %then-block-15-, label %else-block\n\nthen-block-15-:                                   ; preds = %entry-block\n  store i64 1, i64* %sret_slot\n  br label %join\n\nelse-block:                                       ; preds = %entry-block\n  %3 = load i64, i64* %x\n  store i64 %3, i64* %sret_slot\n  br label %join\n\njoin:                                             ; preds = %else-block, %then-block-15-\n  %4 = load i64, i64* %sret_slot\n  ret i64 %4\n}\u003c/pre\u003e\n\n\u003cp\u003eこうなります．やっていることは上記の例たちとあまり変わりません．\nしかし，\u003ccode\u003ereturn\u003c/code\u003e 文がないので？，\u003ccode\u003ereturn\u003c/code\u003e ブロックが作られていません．が, \u003ccode\u003e%sret_slot\u003c/code\u003e は定義されていますね...\u003cbr/\u003e\nこれはどういうことなんでしょう．\u003ccode\u003erustc\u003c/code\u003e のコードを読むべきなのかもしれませんが，イマイチ内部処理が想像しにくいです...\u003c/p\u003e\n\n\u003cp\u003e普通に翻訳していったら，\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003elet x = if x == 0 { 1 } else { x };\nx\u003c/pre\u003e\n\n\u003cp\u003eと同じ感じになる気がするので，\u003ccode\u003e%sret_slot\u003c/code\u003e という名前が出てくる余地は無い気がするのですが...(実質同じ処理ではあります)\n分岐が直接返戻値になる場合は特別扱いしているのかな？\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eif\u003c/code\u003e 文が値を返す\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ereturn\u003c/code\u003e 文を持つ\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e以上のような特徴を持つ言語はどういう感じで\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eされるのか知りたくて，Rust について調べてみました．\u003c/p\u003e\n\n\u003cp\u003eRust では以下の様なことが出来ます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003ef\u003c/span\u003e() {\n  \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e x = \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e cond {\n    return None;\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e\n  };\n  ...\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scala\"\u003eScala\u003c/a\u003e とかもできると思います．\u003ccode\u003econd\u003c/code\u003e が真だった場合は，\u003ccode\u003ex\u003c/code\u003e の値を返すのではなく，関数から抜けてしまうという意味です．\u003c/p\u003e\n\n\u003cp\u003eこれを Rust ではどんな \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR に落とし込んでいるのか．\u003c/p\u003e\n\n\u003ch1\u003e\u003ccode\u003ereturn\u003c/code\u003e 文がない場合\u003c/h1\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003enoreturn\u003c/span\u003e(x: isize) -\u0026gt; isize {\n  x\n}\n\u003c/pre\u003e\n\n\u003cp\u003e最も単純な場合です．この場合，生成される \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR は，\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003edefine internal i64 @_ZN4hoge8noreturn17h811bf1a871f85432E(i64) unnamed_addr #0 {\nentry-block:\n  %x = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  ret i64 %1\n}\u003c/pre\u003e\n\n\u003cp\u003eとなります．\n名前がマングルされていますが，上記の \u003ccode\u003enoreturn\u003c/code\u003e 関数です．\nやっていることは単純で，第一引数を読み込んで返すだけです．\u003c/p\u003e\n\n\u003ch1\u003e\u003ccode\u003ereturn\u003c/code\u003e に相当する文が一つのみの場合\u003c/h1\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eonereturn\u003c/span\u003e(x: isize) -\u0026gt; isize {\n  \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e y = \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e x == \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e {\n    \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    x\n  };\n  return x;\n}\n\u003c/pre\u003e\n\n\u003cp\u003e実際に値を返す部分が一箇所しかない場合です．途中に分岐があっても最終的に一箇所になっていれば多分同じ結果になります．\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003edefine internal i64 @_ZN4hoge9onereturn17h8b718f32daa6a379E(i64) unnamed_addr #0 {\nentry-block:\n  %x = alloca i64\n  %y = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  %2 = icmp eq i64 %1, 0\n  br i1 %2, label %then-block-18-, label %else-block\n\nthen-block-18-:                                   ; preds = %entry-block\n  store i64 1, i64* %y\n  br label %join\n\nelse-block:                                       ; preds = %entry-block\n  %3 = load i64, i64* %x\n  store i64 %3, i64* %y\n  br label %join\n\njoin:                                             ; preds = %else-block, %then-block-18-\n  %4 = load i64, i64* %x\n  br label %clean_ast_10_\n\nreturn:                                           ; preds = %clean_ast_10_\n  ret i64 %4\n\nclean_ast_10_:                                    ; preds = %join\n  br label %return\n}\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003ereturn\u003c/code\u003e という BasicBlock ができています．これは \u003ccode\u003ereturn\u003c/code\u003e 文が現れると作られるよう？です．\nで，その中では単純に \u003ccode\u003ex\u003c/code\u003e に該当する値を返しています．\u003c/p\u003e\n\n\u003cp\u003e最後の \u003ccode\u003ereturn x;\u003c/code\u003e 文を 単純に \u003ccode\u003ex\u003c/code\u003e に置き換えてみると，\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003edefine internal i64 @_ZN4hoge9onereturn17h8b718f32daa6a379E(i64) unnamed_addr #0 {\nentry-block:\n  %x = alloca i64\n  %y = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  %2 = icmp eq i64 %1, 0\n  br i1 %2, label %then-block-18-, label %else-block\n\nthen-block-18-:                                   ; preds = %entry-block\n  store i64 1, i64* %y\n  br label %join\n\nelse-block:                                       ; preds = %entry-block\n  %3 = load i64, i64* %x\n  store i64 %3, i64* %y\n  br label %join\n\njoin:                                             ; preds = %else-block, %then-block-18-\n  %4 = load i64, i64* %x\n  ret i64 %4\n}\u003c/pre\u003e\n\n\u003cp\u003eとなります． \u003ccode\u003ereturn\u003c/code\u003e ブロックが消えていますね．なので \u003ccode\u003ereturn\u003c/code\u003e 文があると \u003ccode\u003ereturn\u003c/code\u003e ブロックが作られる、で良さそう？\u003c/p\u003e\n\n\u003ch1\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eのパスから値を返す\u003c/h1\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003emultireturn\u003c/span\u003e(x: isize) -\u0026gt; isize {\n  \u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e y = \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e x == \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e {\n    return -\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e;\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    x\n  };\n  y\n}\n\u003c/pre\u003e\n\n\u003cp\u003eさて，では最初に述べた，\u003ccode\u003eif\u003c/code\u003e の分岐内にある \u003ccode\u003ereturn\u003c/code\u003e についてです．\nこれは，\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003edefine internal i64 @_ZN4hoge11multireturn17had379e8ce5a18f08E(i64) unnamed_addr #0 {\nentry-block:\n  %sret_slot = alloca i64\n  %x = alloca i64\n  %y = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  %2 = icmp eq i64 %1, 0\n  br i1 %2, label %then-block-18-, label %else-block\n\nthen-block-18-:                                   ; preds = %entry-block\n  store i64 -1, i64* %sret_slot\n  br label %return\n\nelse-block:                                       ; preds = %entry-block\n  %3 = load i64, i64* %x\n  store i64 %3, i64* %y\n  br label %join\n\njoin:                                             ; preds = %else-block\n  %4 = load i64, i64* %y\n  store i64 %4, i64* %sret_slot\n  br label %return\n\nreturn:                                           ; preds = %join, %then-block-18-\n  %5 = load i64, i64* %sret_slot\n  ret i64 %5\n}\u003c/pre\u003e\n\n\u003cp\u003eこうなりました．\nまず，\u003ccode\u003ereturn\u003c/code\u003e 文があるため？，\u003ccode\u003ereturn\u003c/code\u003e ブロックが作られています．\nしかし今回は，パスによって返すものが違います．(値が違うという意味ではなく，同じ変数ですらないという意味です...)\u003c/p\u003e\n\n\u003cp\u003eよく IR を読むと，関数の頭で \u003ccode\u003e%sret_slot\u003c/code\u003e という名前でスタック領域を確保していることがわかります．\nそして，\u003ccode\u003ereturn\u003c/code\u003e ブロック内では，これを読んできて返しています．\u003cbr/\u003e\nさらに，\u003ccode\u003eif\u003c/code\u003e 文の then 節にあたる，\u003ccode\u003ethen-block-18-\u003c/code\u003e というブロックでは，\u003ccode\u003e%sret_slot\u003c/code\u003e に値を格納して \u003ccode\u003ereturn\u003c/code\u003e ブロックへジャンプしています．\nelse 節のあとの部分 (\u003ccode\u003ejoin\u003c/code\u003e ブロック) でも同様に, \u003ccode\u003e%sret_slot\u003c/code\u003e に値を格納して \u003ccode\u003ereturn\u003c/code\u003e ブロックへジャンプしています．\u003c/p\u003e\n\n\u003ch1\u003eまとめ\u003c/h1\u003e\n\n\u003cp\u003eというわけで，様々な Rust コードを \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR に変換して見てみた結果，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eのパスから値を返す場合は，「ローカル変数として返り値を定義し，そこに返したい値を格納してから \u003ccode\u003ereturn\u003c/code\u003e に goto」という形になっていることがわかりました．\u003c/p\u003e\n\n\u003cp\u003e(ほとんど \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\"\u003eLLVM\u003c/a\u003e IR を乗っけるだけになってしまった...)\u003c/p\u003e\n\n\u003ch2\u003eちなみに ...\u003c/h2\u003e\n\n\u003ch1\u003e\u003ccode\u003eif\u003c/code\u003e 文の返す値をそのまま返す\u003c/h1\u003e\n\n\u003cpre class=\"code lang-rust\" data-lang=\"rust\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efn\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003eifreturn\u003c/span\u003e(x: isize) -\u0026gt; isize {\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e x == \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e {\n    \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    x\n  }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eRust に慣れていないとちょっとわかりにくいですが，\u003ccode\u003ex == 0\u003c/code\u003e の場合は 1 を返し，そうでない場合は \u003ccode\u003ex\u003c/code\u003e を返す関数です．\u003c/p\u003e\n\n\u003cp\u003eこれは，\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003edefine internal i64 @_ZN4hoge8ifreturn17hcdaab6e376d6c95cE(i64) unnamed_addr #0 {\nentry-block:\n  %sret_slot = alloca i64\n  %x = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  %2 = icmp eq i64 %1, 0\n  br i1 %2, label %then-block-15-, label %else-block\n\nthen-block-15-:                                   ; preds = %entry-block\n  store i64 1, i64* %sret_slot\n  br label %join\n\nelse-block:                                       ; preds = %entry-block\n  %3 = load i64, i64* %x\n  store i64 %3, i64* %sret_slot\n  br label %join\n\njoin:                                             ; preds = %else-block, %then-block-15-\n  %4 = load i64, i64* %sret_slot\n  ret i64 %4\n}\u003c/pre\u003e\n\n\u003cp\u003eこうなります．やっていることは上記の例たちとあまり変わりません．\nしかし，\u003ccode\u003ereturn\u003c/code\u003e 文がないので？，\u003ccode\u003ereturn\u003c/code\u003e ブロックが作られていません．が, \u003ccode\u003e%sret_slot\u003c/code\u003e は定義されていますね...\u003cbr/\u003e\nこれはどういうことなんでしょう．\u003ccode\u003erustc\u003c/code\u003e のコードを読むべきなのかもしれませんが，イマイチ内部処理が想像しにくいです...\u003c/p\u003e\n\n\u003cp\u003e普通に翻訳していったら，\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003elet x = if x == 0 { 1 } else { x };\nx\u003c/pre\u003e\n\n\u003cp\u003eと同じ感じになる気がするので，\u003ccode\u003e%sret_slot\u003c/code\u003e という名前が出てくる余地は無い気がするのですが...(実質同じ処理ではあります)\n分岐が直接返戻値になる場合は特別扱いしているのかな？\u003c/p\u003e\n\n---\n\n---\n","slug":"Rust_における_return文の_LLVM_IR_表現について","title":"Rust における return文の LLVM IR 表現について","timestamp":1460540043000,"tags":[]},{"rawMarkdown":"---\ntitle: \"C++ の複雑な型を整形するプログラムを作りました\"\ndate: 2016-03-08T11:55:10.000Z\ntags: []\n---\n\n\u003cp\u003eテンプレートをバリバリ使っている \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e プログラムの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーが，死ぬほど辛かったので作りました．\n型を綺麗に出力するだけです．\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eの型版 \u003ccode\u003ejq\u003c/code\u003e みたいなやつありそうだけど無いのかな？\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/agatan/tf\"\u003eagatan/tf\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eたとえば，\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003eboost::spirit::x3::raw_directive\u0026lt;boost::spirit::x3::lexeme_directive\u0026lt;boost::spirit::x3::sequence\u0026lt;boost::spirit::x3::alternative\u0026lt;boost::spirit::x3::char_class\u0026lt;boost::spirit::char_encoding::standard, boost::spirit::x3::alpha_tag\u0026gt;, boost::spirit::x3::literal_char\u0026lt;boost::spirit::char_encoding::standard, boost::spirit::x3::unused_type\u0026gt; \u0026gt;, boost::spirit::x3::kleene\u0026lt;boost::spirit::x3::alternative\u0026lt;boost::spirit::x3::char_class\u0026lt;boost::spirit::char_encoding::standard, boost::spirit::x3::alnum_tag\u0026gt;, boost::spirit::x3::literal_char\u0026lt;boost::spirit::char_encoding::standard, boost::spirit::x3::unused_type\u0026gt; \u0026gt; \u0026gt; \u0026gt; \u0026gt; \u0026gt;::parse\u0026lt;__gnu_cxx::__normal_iterator\u0026lt;\u003cspan class=\"synType\"\u003econst\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e *, std::__cxx11::basic_string\u0026lt;\u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u0026gt; \u0026gt;, boost::spirit::x3::context\u0026lt;boost::spirit::x3::error_handler_tag, \u003cspan class=\"synType\"\u003econst\u003c/span\u003e std::reference_wrapper\u0026lt;boost::spirit::x3::error_handler\u0026lt;__gnu_cxx::__normal_iterator\u0026lt;\u003cspan class=\"synType\"\u003econst\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e *, std::__cxx11::basic_string\u0026lt;\u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u0026gt; \u0026gt; \u0026gt; \u0026gt;, boost::spirit::x3::context\u0026lt;boost::spirit::x3::skipper_tag, \u003cspan class=\"synType\"\u003econst\u003c/span\u003e boost::spirit::x3::char_class\u0026lt;boost::spirit::char_encoding::ascii, boost::spirit::x3::space_tag\u0026gt;, boost::spirit::x3::unused_type\u0026gt; \u0026gt;, std::__cxx11::basic_string\u0026lt;\u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u0026gt;, \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u0026gt;\n\u003c/pre\u003e\n\n\u003cp\u003eこんなエラーがよく有りますよね．\u003c/p\u003e\n\n\u003cp\u003eこれを \u003ccode\u003etf\u003c/code\u003e の標準入力に流しこむと，\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003eboost::spirit::x3::raw_directive\u0026lt;\n    boost::spirit::x3::lexeme_directive\u0026lt;\n        boost::spirit::x3::sequence\u0026lt;\n            boost::spirit::x3::alternative\u0026lt;\n                boost::spirit::x3::char_class\u0026lt;\n                    boost::spirit::char_encoding::standard,\n                    boost::spirit::x3::alpha_tag\n                \u0026gt;,\n                boost::spirit::x3::literal_char\u0026lt;\n                    boost::spirit::char_encoding::standard,\n                    boost::spirit::x3::unused_type\n                \u0026gt;\n            \u0026gt;,\n            boost::spirit::x3::kleene\u0026lt;\n                boost::spirit::x3::alternative\u0026lt;\n                    boost::spirit::x3::char_class\u0026lt;\n                        boost::spirit::char_encoding::standard,\n                        boost::spirit::x3::alnum_tag\n                    \u0026gt;,\n                    boost::spirit::x3::literal_char\u0026lt;\n                        boost::spirit::char_encoding::standard,\n                        boost::spirit::x3::unused_type\n                    \u0026gt;\n                \u0026gt;\n            \u0026gt;\n        \u0026gt;\n    \u0026gt;\n\u0026gt;::parse\u0026lt;\n    __gnu_cxx::__normal_iterator\u0026lt;\n        constchar*,\n        std::__cxx11::basic_string\u0026lt;\n            \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\n        \u0026gt;\n    \u0026gt;,\n    boost::spirit::x3::context\u0026lt;\n        boost::spirit::x3::error_handler_tag,\n        conststd::reference_wrapper\u0026lt;\n            boost::spirit::x3::error_handler\u0026lt;\n                __gnu_cxx::__normal_iterator\u0026lt;\n                    constchar*,\n                    std::__cxx11::basic_string\u0026lt;\n                        \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\n                    \u0026gt;\n                \u0026gt;\n            \u0026gt;\n        \u0026gt;,\n        boost::spirit::x3::context\u0026lt;\n            boost::spirit::x3::skipper_tag,\n            constboost::spirit::x3::char_class\u0026lt;\n                boost::spirit::char_encoding::ascii,\n                boost::spirit::x3::space_tag\n            \u0026gt;,\n            boost::spirit::x3::unused_type\n        \u0026gt;\n    \u0026gt;,\n    std::__cxx11::basic_string\u0026lt;\n        \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\n    \u0026gt;,\n    \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\n\u0026gt;\n\u003c/pre\u003e\n\n\u003cp\u003eこうなります．\u003c/p\u003e\n\n\u003cp\u003e単純に \u003ccode\u003e\u0026lt;\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u003c/code\u003e, \u003ccode\u003e,\u003c/code\u003e を見てインデントを調整しながら出力しているだけです．\n空白はスキップします．\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eとかは全くしていないので，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーをそのまま流し込んでも悲惨な事になります．\n\u003cdel\u003eあと今気がついたのですが，\u003ccode\u003econst hoge\u003c/code\u003e が \u003ccode\u003econsthoge\u003c/code\u003e になっていますね．\u003c/del\u003e\n修正しました\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003eboost::spirit::x3::raw_directive\u0026lt;\n    boost::spirit::x3::lexeme_directive\u0026lt;\n        boost::spirit::x3::sequence\u0026lt;\n            boost::spirit::x3::alternative\u0026lt;\n                boost::spirit::x3::char_class\u0026lt;\n                    boost::spirit::char_encoding::standard,\n                    boost::spirit::x3::alpha_tag\n                \u0026gt;,\n                boost::spirit::x3::literal_char\u0026lt;\n                    boost::spirit::char_encoding::standard,\n                    boost::spirit::x3::unused_type\n                \u0026gt;\n            \u0026gt;,\n            boost::spirit::x3::kleene\u0026lt;\n                boost::spirit::x3::alternative\u0026lt;\n                    boost::spirit::x3::char_class\u0026lt;\n                        boost::spirit::char_encoding::standard,\n                        boost::spirit::x3::alnum_tag\n                    \u0026gt;,\n                    boost::spirit::x3::literal_char\u0026lt;\n                        boost::spirit::char_encoding::standard,\n                        boost::spirit::x3::unused_type\n                    \u0026gt;\n                \u0026gt;\n            \u0026gt;\n        \u0026gt;\n    \u0026gt;\n\u0026gt;::parse\u0026lt;\n    __gnu_cxx::__normal_iterator\u0026lt;\n        \u003cspan class=\"synType\"\u003econst\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e *,\n        std::__cxx11::basic_string\u0026lt;\n            \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\n        \u0026gt;\n    \u0026gt;,\n    boost::spirit::x3::context\u0026lt;\n        boost::spirit::x3::error_handler_tag,\n        \u003cspan class=\"synType\"\u003econst\u003c/span\u003e std::reference_wrapper\u0026lt;\n            boost::spirit::x3::error_handler\u0026lt;\n                __gnu_cxx::__normal_iterator\u0026lt;\n                    \u003cspan class=\"synType\"\u003econst\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e *,\n                    std::__cxx11::basic_string\u0026lt;\n                        \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\n                    \u0026gt;\n                \u0026gt;\n            \u0026gt;\n        \u0026gt;,\n        boost::spirit::x3::context\u0026lt;\n            boost::spirit::x3::skipper_tag,\n            \u003cspan class=\"synType\"\u003econst\u003c/span\u003e boost::spirit::x3::char_class\u0026lt;\n                boost::spirit::char_encoding::ascii,\n                boost::spirit::x3::space_tag\n            \u0026gt;,\n            boost::spirit::x3::unused_type\n        \u0026gt;\n    \u0026gt;,\n    std::__cxx11::basic_string\u0026lt;\n        \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\n    \u0026gt;,\n    \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\n\u0026gt;\n\u003c/pre\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eテンプレートをバリバリ使っている \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e プログラムの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーが，死ぬほど辛かったので作りました．\n型を綺麗に出力するだけです．\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eの型版 \u003ccode\u003ejq\u003c/code\u003e みたいなやつありそうだけど無いのかな？\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/agatan/tf\"\u003eagatan/tf\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eたとえば，\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003eboost::spirit::x3::raw_directive\u0026lt;boost::spirit::x3::lexeme_directive\u0026lt;boost::spirit::x3::sequence\u0026lt;boost::spirit::x3::alternative\u0026lt;boost::spirit::x3::char_class\u0026lt;boost::spirit::char_encoding::standard, boost::spirit::x3::alpha_tag\u0026gt;, boost::spirit::x3::literal_char\u0026lt;boost::spirit::char_encoding::standard, boost::spirit::x3::unused_type\u0026gt; \u0026gt;, boost::spirit::x3::kleene\u0026lt;boost::spirit::x3::alternative\u0026lt;boost::spirit::x3::char_class\u0026lt;boost::spirit::char_encoding::standard, boost::spirit::x3::alnum_tag\u0026gt;, boost::spirit::x3::literal_char\u0026lt;boost::spirit::char_encoding::standard, boost::spirit::x3::unused_type\u0026gt; \u0026gt; \u0026gt; \u0026gt; \u0026gt; \u0026gt;::parse\u0026lt;__gnu_cxx::__normal_iterator\u0026lt;\u003cspan class=\"synType\"\u003econst\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e *, std::__cxx11::basic_string\u0026lt;\u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u0026gt; \u0026gt;, boost::spirit::x3::context\u0026lt;boost::spirit::x3::error_handler_tag, \u003cspan class=\"synType\"\u003econst\u003c/span\u003e std::reference_wrapper\u0026lt;boost::spirit::x3::error_handler\u0026lt;__gnu_cxx::__normal_iterator\u0026lt;\u003cspan class=\"synType\"\u003econst\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e *, std::__cxx11::basic_string\u0026lt;\u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u0026gt; \u0026gt; \u0026gt; \u0026gt;, boost::spirit::x3::context\u0026lt;boost::spirit::x3::skipper_tag, \u003cspan class=\"synType\"\u003econst\u003c/span\u003e boost::spirit::x3::char_class\u0026lt;boost::spirit::char_encoding::ascii, boost::spirit::x3::space_tag\u0026gt;, boost::spirit::x3::unused_type\u0026gt; \u0026gt;, std::__cxx11::basic_string\u0026lt;\u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u0026gt;, \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\u0026gt;\n\u003c/pre\u003e\n\n\u003cp\u003eこんなエラーがよく有りますよね．\u003c/p\u003e\n\n\u003cp\u003eこれを \u003ccode\u003etf\u003c/code\u003e の標準入力に流しこむと，\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003eboost::spirit::x3::raw_directive\u0026lt;\n    boost::spirit::x3::lexeme_directive\u0026lt;\n        boost::spirit::x3::sequence\u0026lt;\n            boost::spirit::x3::alternative\u0026lt;\n                boost::spirit::x3::char_class\u0026lt;\n                    boost::spirit::char_encoding::standard,\n                    boost::spirit::x3::alpha_tag\n                \u0026gt;,\n                boost::spirit::x3::literal_char\u0026lt;\n                    boost::spirit::char_encoding::standard,\n                    boost::spirit::x3::unused_type\n                \u0026gt;\n            \u0026gt;,\n            boost::spirit::x3::kleene\u0026lt;\n                boost::spirit::x3::alternative\u0026lt;\n                    boost::spirit::x3::char_class\u0026lt;\n                        boost::spirit::char_encoding::standard,\n                        boost::spirit::x3::alnum_tag\n                    \u0026gt;,\n                    boost::spirit::x3::literal_char\u0026lt;\n                        boost::spirit::char_encoding::standard,\n                        boost::spirit::x3::unused_type\n                    \u0026gt;\n                \u0026gt;\n            \u0026gt;\n        \u0026gt;\n    \u0026gt;\n\u0026gt;::parse\u0026lt;\n    __gnu_cxx::__normal_iterator\u0026lt;\n        constchar*,\n        std::__cxx11::basic_string\u0026lt;\n            \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\n        \u0026gt;\n    \u0026gt;,\n    boost::spirit::x3::context\u0026lt;\n        boost::spirit::x3::error_handler_tag,\n        conststd::reference_wrapper\u0026lt;\n            boost::spirit::x3::error_handler\u0026lt;\n                __gnu_cxx::__normal_iterator\u0026lt;\n                    constchar*,\n                    std::__cxx11::basic_string\u0026lt;\n                        \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\n                    \u0026gt;\n                \u0026gt;\n            \u0026gt;\n        \u0026gt;,\n        boost::spirit::x3::context\u0026lt;\n            boost::spirit::x3::skipper_tag,\n            constboost::spirit::x3::char_class\u0026lt;\n                boost::spirit::char_encoding::ascii,\n                boost::spirit::x3::space_tag\n            \u0026gt;,\n            boost::spirit::x3::unused_type\n        \u0026gt;\n    \u0026gt;,\n    std::__cxx11::basic_string\u0026lt;\n        \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\n    \u0026gt;,\n    \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\n\u0026gt;\n\u003c/pre\u003e\n\n\u003cp\u003eこうなります．\u003c/p\u003e\n\n\u003cp\u003e単純に \u003ccode\u003e\u0026lt;\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u003c/code\u003e, \u003ccode\u003e,\u003c/code\u003e を見てインデントを調整しながら出力しているだけです．\n空白はスキップします．\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eとかは全くしていないので，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eエラーをそのまま流し込んでも悲惨な事になります．\n\u003cdel\u003eあと今気がついたのですが，\u003ccode\u003econst hoge\u003c/code\u003e が \u003ccode\u003econsthoge\u003c/code\u003e になっていますね．\u003c/del\u003e\n修正しました\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003eboost::spirit::x3::raw_directive\u0026lt;\n    boost::spirit::x3::lexeme_directive\u0026lt;\n        boost::spirit::x3::sequence\u0026lt;\n            boost::spirit::x3::alternative\u0026lt;\n                boost::spirit::x3::char_class\u0026lt;\n                    boost::spirit::char_encoding::standard,\n                    boost::spirit::x3::alpha_tag\n                \u0026gt;,\n                boost::spirit::x3::literal_char\u0026lt;\n                    boost::spirit::char_encoding::standard,\n                    boost::spirit::x3::unused_type\n                \u0026gt;\n            \u0026gt;,\n            boost::spirit::x3::kleene\u0026lt;\n                boost::spirit::x3::alternative\u0026lt;\n                    boost::spirit::x3::char_class\u0026lt;\n                        boost::spirit::char_encoding::standard,\n                        boost::spirit::x3::alnum_tag\n                    \u0026gt;,\n                    boost::spirit::x3::literal_char\u0026lt;\n                        boost::spirit::char_encoding::standard,\n                        boost::spirit::x3::unused_type\n                    \u0026gt;\n                \u0026gt;\n            \u0026gt;\n        \u0026gt;\n    \u0026gt;\n\u0026gt;::parse\u0026lt;\n    __gnu_cxx::__normal_iterator\u0026lt;\n        \u003cspan class=\"synType\"\u003econst\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e *,\n        std::__cxx11::basic_string\u0026lt;\n            \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\n        \u0026gt;\n    \u0026gt;,\n    boost::spirit::x3::context\u0026lt;\n        boost::spirit::x3::error_handler_tag,\n        \u003cspan class=\"synType\"\u003econst\u003c/span\u003e std::reference_wrapper\u0026lt;\n            boost::spirit::x3::error_handler\u0026lt;\n                __gnu_cxx::__normal_iterator\u0026lt;\n                    \u003cspan class=\"synType\"\u003econst\u003c/span\u003e \u003cspan class=\"synType\"\u003echar\u003c/span\u003e *,\n                    std::__cxx11::basic_string\u0026lt;\n                        \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\n                    \u0026gt;\n                \u0026gt;\n            \u0026gt;\n        \u0026gt;,\n        boost::spirit::x3::context\u0026lt;\n            boost::spirit::x3::skipper_tag,\n            \u003cspan class=\"synType\"\u003econst\u003c/span\u003e boost::spirit::x3::char_class\u0026lt;\n                boost::spirit::char_encoding::ascii,\n                boost::spirit::x3::space_tag\n            \u0026gt;,\n            boost::spirit::x3::unused_type\n        \u0026gt;\n    \u0026gt;,\n    std::__cxx11::basic_string\u0026lt;\n        \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\n    \u0026gt;,\n    \u003cspan class=\"synType\"\u003echar\u003c/span\u003e\n\u0026gt;\n\u003c/pre\u003e\n\n---\n\n---\n","slug":"C++_の複雑な型を整形するプログラムを作りました","title":"C++ の複雑な型を整形するプログラムを作りました","timestamp":1457438110000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Type Erasure による Visitor パターンの実装\"\ndate: 2016-01-25T11:07:38.000Z\ntags: []\n---\n\n\u003cp\u003eプログラミングしていて，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eをうまく扱いたいという状況は結構良くあると思います．\u003cbr/\u003e\n代数的データ型とパターンマッチを持つ言語であればとても美しく完結に表現できる\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eですが，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A5%D6%A5%B8%A5%A7%A5%AF%A5%C8%BB%D8%B8%FE%B8%C0%B8%EC\"\u003eオブジェクト指向言語\u003c/a\u003eでやろうと思うと結構たいへんです．\u003cbr/\u003e\n典型的には Visitor パターンというやつを用います．\u003ca href=\"http://qiita.com/lyrical_logical/items/bc6126f34a571a2c4f97\"\u003eデザインパターン - Visitor パターン再考 - Qiita\u003c/a\u003eが非常にわかりやすく，理解の助けになりました．ありがとうございます．\u003c/p\u003e\n\n\u003cp\u003e一方，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の有名なライブラリ，Boost には Boost.Variant というモジュールがあり，これまたとても美しく Visitor っぽいことが出来ます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;boost/variant.hpp\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e sample = boost::variant\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003edouble\u003c/span\u003e, std::string\u0026gt;;\n\nsample s1 = \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e;\nsample s2 = \u003cspan class=\"synConstant\"\u003e2.0\u003c/span\u003e;\nsample s3 = \u003cspan class=\"synConstant\"\u003e\u0026quot;sample3\u0026quot;\u003c/span\u003e;\n\nboost::apply_visitor([](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; v) \u003cspan class=\"synError\"\u003e{\u003c/span\u003e std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; }, s1); \u003cspan class=\"synComment\"\u003e// =\u0026gt; 1\u003c/span\u003e\nboost::apply_visitor([](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; v) \u003cspan class=\"synError\"\u003e{\u003c/span\u003e std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; }, s2); \u003cspan class=\"synComment\"\u003e// =\u0026gt; 2.0\u003c/span\u003e\nboost::apply_visitor([](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; v) \u003cspan class=\"synError\"\u003e{\u003c/span\u003e std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; }, s3); \u003cspan class=\"synComment\"\u003e// =\u0026gt; sample3\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eしかし，Boost.Variant は非常に高機能ですが，テンプレートをガンガン使っていたりするので，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eコストが大きいという問題があります．\u003c/p\u003e\n\n\u003cp\u003eそこで，Type Erasure を使って visitor パターンをうまく表せれば，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eコストを下げられるのでは？というお話です．\u003cbr/\u003e\nType Erasure は「型消去」とかで\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%B0%A4%EB\"\u003eググる\u003c/a\u003eと色々解説してくださっている記事などが出てくると思います．（ありがとうございます）\u003c/p\u003e\n\n\u003cp\u003eこの話，私が考えたわけではなくて，どこかの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\"\u003eソースコード\u003c/a\u003eで見たようなきがするんですが，当時は Type Erasure とか意味不明だったのでスルーしていました．\u003cbr/\u003e\n今ならなんとなくやりたいことは出来るような気がするので（＆ちょうど必要になったので）記事にしてみていますが，もしオリジナルっぽいものや同じようなことを提案している\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\"\u003eソースコード\u003c/a\u003e・記事を見かけた方は是非ご連絡いただけると嬉しいです．\u003c/p\u003e\n\n\u003ch2\u003e1st step\u003c/h2\u003e\n\n\u003ch3\u003eVisitor\u003c/h3\u003e\n\n\u003cp\u003e今回表現したいデータ構造をまず定めます．簡単のために，足し算・掛け算・整数定数の 3 種類のノードを持つ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eを考えます．\u003cbr/\u003e\n\u003ccode\u003e(1 + 2) * 3\u003c/code\u003e なら， \u003ccode\u003emul( add(1, 2), 3 )\u003c/code\u003e みたいな感じです．\u003c/p\u003e\n\n\u003cp\u003eこの構造を visit する Visitor クラスから先に考えます．\u003cbr/\u003e\nVisitor クラスは，\u003ccode\u003evisit\u003c/code\u003e という\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eをもつ型の値を，型を消去して保持させます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e visitor {\n\u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n  \u003cspan class=\"synType\"\u003eclass\u003c/span\u003e visitor_base_holder {\n  \u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n    \u003cspan class=\"synType\"\u003evirtual\u003c/span\u003e \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e visit(add \u0026amp;) = \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n    \u003cspan class=\"synType\"\u003evirtual\u003c/span\u003e \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e visit(mul \u0026amp;) = \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n    \u003cspan class=\"synType\"\u003evirtual\u003c/span\u003e \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e visit(constant \u0026amp;) = \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n\n    \u003cspan class=\"synType\"\u003evirtual\u003c/span\u003e ~visitor_base_holder() = \u003cspan class=\"synStatement\"\u003edefault\u003c/span\u003e;\n  };\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e V\u0026gt; \u003cspan class=\"synType\"\u003eclass\u003c/span\u003e visitor_holder : \u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e visitor_base_holder {\n  \u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n    V \u0026amp;v;\n\n  \u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n    visitor_holder(V \u0026amp;v) : v(v) {}\n\n    \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e visit(add \u0026amp;a) override { v(a); }\n    \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e visit(mul \u0026amp;a) override { v(a); }\n    \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e visit(constant \u0026amp;a) override { v(a); }\n\n    \u003cspan class=\"synType\"\u003evirtual\u003c/span\u003e ~visitor_holder() = \u003cspan class=\"synStatement\"\u003edefault\u003c/span\u003e;\n  };\n\n  std::unique_ptr\u0026lt;visitor_base_holder\u0026gt; holder;\n\n\u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e V\u0026gt;\n  visitor(V \u0026amp;v)\n      : holder(std::make_unique\u0026lt;visitor_holder\u0026lt;V\u0026gt;\u0026gt;(v)) {}\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e Visitable\u0026gt; \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e visit(Visitable \u0026amp;v) { holder-\u0026gt;visit(v); }\n};\n\u003c/pre\u003e\n\n\u003cp\u003e今回は \u003ccode\u003econst\u003c/code\u003e 修飾についてすべて無視しています．( \u003ccode\u003econst\u003c/code\u003e を考慮するならば，各 \u003ccode\u003evisit\u003c/code\u003e について，visitor の \u003ccode\u003econst\u003c/code\u003e 性と node の \u003ccode\u003econst\u003c/code\u003e 性を考える必要があります．つまり 4 種類の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eを定義しなければなりません．）\u003cbr/\u003e\nvisit した対象となるそれぞれのデータについて\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A1%BC%A5%D0%A1%BC%A5%ED%A1%BC%A5%C9\"\u003eオーバーロード\u003c/a\u003eする形で \u003ccode\u003evisit\u003c/code\u003e を定義しています．\u003cbr/\u003e\n\u003ccode\u003evisitor\u003c/code\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%B9%A5%C8%A5%E9%A5%AF%A5%BF\"\u003eコンストラクタ\u003c/a\u003eに，\u003ccode\u003eoperator()(add\u0026amp;)\u003c/code\u003e, \u003ccode\u003eoperator()(mul\u0026amp;)\u003c/code\u003e, \u003ccode\u003eoperator()(constant\u0026amp;)\u003c/code\u003e を全て持つオブジェクト（\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e14 の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eラムダでもOK）を渡すことで，型消去された visitor が出来上がります．\u003cbr/\u003e\n\u003ccode\u003evisitor\u003c/code\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%B9%A5%C8%A5%E9%A5%AF%A5%BF\"\u003eコンストラクタ\u003c/a\u003eにどんな型の値を渡しても，出来上がる \u003ccode\u003evisitor\u003c/code\u003e にはその型情報は含まれないので，様々な visitor を統一して扱う（ \u003ccode\u003evector\u003c/code\u003e に突っ込むとか）事ができるようになります．\u003c/p\u003e\n\n\u003ch3\u003eNode\u003c/h3\u003e\n\n\u003cp\u003e次にノードの方について考えます． 通常，Visitor パターンでは， visit される側のクラスに \u003ccode\u003eaccept\u003c/code\u003e を実装します．\u003cbr/\u003e\nvisit される側のデータを統一的に扱う（ \u003ccode\u003evector\u003c/code\u003e に突っ込むとか）ためには，継承やインターフェースを用いるのが普通です．\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e では，Visitor 側に使った Type Erasure のテクニックが使えます．\u003cbr/\u003e\n\u003ccode\u003estd::vector\u0026lt;node\u0026gt;\u003c/code\u003e などのように，統一的にノードを扱いつつも，visit される際には，\u003ccode\u003evisit(add\u0026amp;)\u003c/code\u003e や \u003ccode\u003evisit(mul\u0026amp;)\u003c/code\u003e のような適切な\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A1%BC%A5%D0%A1%BC%A5%ED%A1%BC%A5%C9\"\u003eオーバーロード\u003c/a\u003e関数を呼び出すようにしてやればオッケーです．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e node {\n\u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n  \u003cspan class=\"synType\"\u003eclass\u003c/span\u003e node_base_holder {\n  \u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n    \u003cspan class=\"synType\"\u003evirtual\u003c/span\u003e \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e accept(visitor \u0026amp;v) = \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n\n    \u003cspan class=\"synType\"\u003evirtual\u003c/span\u003e ~node_base_holder() = \u003cspan class=\"synStatement\"\u003edefault\u003c/span\u003e;\n  };\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt; \u003cspan class=\"synType\"\u003eclass\u003c/span\u003e node_holder : \u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e node_base_holder {\n  \u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n    node_holder(T \u003cspan class=\"synType\"\u003econst\u003c/span\u003e \u0026amp;n) : node(n) {}\n    node_holder(T \u0026amp;\u0026amp;n) : node(n) {}\n\n    \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e accept(visitor \u0026amp;v) override { v.visit(node); }\n\n    ~node_holder() = \u003cspan class=\"synStatement\"\u003edefault\u003c/span\u003e;\n\n  \u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n    T node;\n  };\n\n  std::shared_ptr\u0026lt;node_base_holder\u0026gt; holder;\n\n\u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e Node\u0026gt;\n  node(Node \u003cspan class=\"synType\"\u003econst\u003c/span\u003e \u0026amp;n)\n      : holder(std::make_shared\u0026lt;node_holder\u0026lt;Node\u0026gt;\u0026gt;(n)) {}\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e Node\u0026gt;\n  node(Node \u0026amp;\u0026amp;n)\n      : holder(std::make_shared\u0026lt;node_holder\u0026lt;Node\u0026gt;\u0026gt;(n)) {}\n\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e accept(visitor \u0026amp;v) { holder-\u0026gt;accept(v); }\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e Visitor\u0026gt; \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e accept(Visitor \u0026amp;v) {\n    visitor visit(v);\n    holder-\u0026gt;accept(visit);\n  }\n};\n\u003c/pre\u003e\n\n\u003cp\u003eこれ結構わかりにくと思うのですが，自分でも\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eに怒られながら書いたのでいまいちよく分かってません．\u003cbr/\u003e\n先ほどの \u003ccode\u003evisitor\u003c/code\u003e の場合と異なり，\u003ccode\u003enode\u003c/code\u003e には特別満たすべきインターフェースは有りません．\u003cbr/\u003e\nType Erasure を使う理由は，適切な \u003ccode\u003evisit\u003c/code\u003e 関数へのディスパッチのためです．\u003c/p\u003e\n\n\u003ch3\u003e使う\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode\u003evisitor\u003c/code\u003e と \u003ccode\u003enode\u003c/code\u003e が出来たので，使ってみます．\u003cbr/\u003e\nその前にデータ構造を定義しておきます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e constant {\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e value;\n};\n\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e add {\n  node lhs;\n  node rhs;\n};\n\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e mul {\n  node lhs;\n  node rhs;\n};\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eadd\u003c/code\u003e や \u003ccode\u003emul\u003c/code\u003e のフィールドに，\u003ccode\u003enode\u003c/code\u003e が使用されている点が大事です．\u003cbr/\u003e\n\u003ccode\u003eadd.lhs\u003c/code\u003e や \u003ccode\u003emul.rhs\u003c/code\u003e には，\u003ccode\u003econstant\u003c/code\u003e が来るか \u003ccode\u003eadd\u003c/code\u003e が来るか \u003ccode\u003emul\u003c/code\u003e が来るか分かりません．\u003cbr/\u003e\nそこで，visit 可能な型なら何でもOKという意味で，\u003ccode\u003enode\u003c/code\u003e 型の値をフィールドとします．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003enode n = mul{add{constant{\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e}, constant{\u003cspan class=\"synConstant\"\u003e2\u003c/span\u003e}}, constant{\u003cspan class=\"synConstant\"\u003e3\u003c/span\u003e}};\n\u003c/pre\u003e\n\n\u003cp\u003eこれで，\u003ccode\u003e(1 + 2) * 3\u003c/code\u003e が表現できています．\n\u003ccode\u003eadd\u003c/code\u003e や \u003ccode\u003econstant\u003c/code\u003e から \u003ccode\u003enode\u003c/code\u003e へと暗黙変換が行われていることに注意してください．\u003c/p\u003e\n\n\u003cp\u003e次に visitor を定義します．これは，\u003ccode\u003eoperator()\u003c/code\u003e を\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A1%BC%A5%D0%A1%BC%A5%ED%A1%BC%A5%C9\"\u003eオーバーロード\u003c/a\u003eした関数オブジェクトです．\u003cbr/\u003e\n式を出力する \u003ccode\u003eprinter\u003c/code\u003e と 式を計算する \u003ccode\u003ecalculator\u003c/code\u003e を定義します．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e printer {\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e()(add \u0026amp;a) {\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e;\n    a.lhs.accept(*\u003cspan class=\"synStatement\"\u003ethis\u003c/span\u003e);\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e;\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;+\u0026quot;\u003c/span\u003e;\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e;\n    a.rhs.accept(*\u003cspan class=\"synStatement\"\u003ethis\u003c/span\u003e);\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e()(mul \u0026amp;a) {\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e;\n    a.lhs.accept(*\u003cspan class=\"synStatement\"\u003ethis\u003c/span\u003e);\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e;\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;*\u0026quot;\u003c/span\u003e;\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e;\n    a.rhs.accept(*\u003cspan class=\"synStatement\"\u003ethis\u003c/span\u003e);\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e()(constant \u0026amp;c) { std::cout \u0026lt;\u0026lt; c.value; }\n};\n\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e calculator {\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e result;\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e()(add \u0026amp;a) {\n    calculator l, r;\n    a.lhs.accept(l);\n    a.rhs.accept(r);\n    result = l.result + r.result;\n  }\n\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e()(mul \u0026amp;m) {\n    calculator l, r;\n    m.lhs.accept(l);\n    m.rhs.accept(r);\n    result = l.result * r.result;\n  }\n\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e()(constant \u0026amp;c) { result = c.value; }\n};\n\u003c/pre\u003e\n\n\u003cp\u003eこんな感じです．\u003cbr/\u003e\n\u003ccode\u003evisit\u003c/code\u003e や \u003ccode\u003eaccept\u003c/code\u003e を \u003ccode\u003evoid\u003c/code\u003e を返す関数として定義したので，\u003ccode\u003ecalculator\u003c/code\u003e は自前のフィールドに結果を保持する必要があります．\n(あとで改善します)\u003c/p\u003e\n\n\u003cp\u003e使い方は\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e  node n = mul{add{constant{\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e}, constant{\u003cspan class=\"synConstant\"\u003e2\u003c/span\u003e}}, constant{\u003cspan class=\"synConstant\"\u003e3\u003c/span\u003e}};\n  printer p;\n  n.accept(p);\n  calculator calc;\n  n.accept(calc);\n  std::cout \u0026lt;\u0026lt; std::endl;\n  std::cout \u0026lt;\u0026lt; calc.result \u0026lt;\u0026lt; std::endl;\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n\u003c/pre\u003e\n\n\u003cp\u003eです．\u003c/p\u003e\n\n\u003ch1\u003eまとめ\u003c/h1\u003e\n\n\u003cp\u003eこの方法の利点としては，データの定義そのものに Visitor パターンのためのノイズが入らないことが挙げられます．\u003cbr/\u003e\n普通の Visitor パターンでは継承必須ですし．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003econst\u003c/code\u003e つけてないせいで一時オブジェクトが使えないので \u003ccode\u003eprinter p;\u003c/code\u003e という行が必要になってしまっています．これは\u003ccode\u003econst\u003c/code\u003eをがんばってつけるだけなのでまぁ問題有りません．\u003cbr/\u003e\n一方，\u003ccode\u003ecalculator\u003c/code\u003e の方はダサいですね．値を返す visitor も定義できるようにしたい．\u003cbr/\u003e\n\u003ccode\u003evisitor\u003c/code\u003e の定義もツライです．\u003ccode\u003econst\u003c/code\u003e を考慮した場合，同じような内容の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eを 4 回ずつ書く必要がある．\u003c/p\u003e\n\n\u003cp\u003eこのへんの問題点は解決可能な気がするので出来たら後で記事にするつもりです．\u003c/p\u003e\n\n\u003cp\u003e難しすぎて普通の visitor パターンで良くね？感出てきた\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eプログラミングしていて，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eをうまく扱いたいという状況は結構良くあると思います．\u003cbr/\u003e\n代数的データ型とパターンマッチを持つ言語であればとても美しく完結に表現できる\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eですが，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A5%D6%A5%B8%A5%A7%A5%AF%A5%C8%BB%D8%B8%FE%B8%C0%B8%EC\"\u003eオブジェクト指向言語\u003c/a\u003eでやろうと思うと結構たいへんです．\u003cbr/\u003e\n典型的には Visitor パターンというやつを用います．\u003ca href=\"http://qiita.com/lyrical_logical/items/bc6126f34a571a2c4f97\"\u003eデザインパターン - Visitor パターン再考 - Qiita\u003c/a\u003eが非常にわかりやすく，理解の助けになりました．ありがとうございます．\u003c/p\u003e\n\n\u003cp\u003e一方，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の有名なライブラリ，Boost には Boost.Variant というモジュールがあり，これまたとても美しく Visitor っぽいことが出来ます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;boost/variant.hpp\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e sample = boost::variant\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003edouble\u003c/span\u003e, std::string\u0026gt;;\n\nsample s1 = \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e;\nsample s2 = \u003cspan class=\"synConstant\"\u003e2.0\u003c/span\u003e;\nsample s3 = \u003cspan class=\"synConstant\"\u003e\u0026quot;sample3\u0026quot;\u003c/span\u003e;\n\nboost::apply_visitor([](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; v) \u003cspan class=\"synError\"\u003e{\u003c/span\u003e std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; }, s1); \u003cspan class=\"synComment\"\u003e// =\u0026gt; 1\u003c/span\u003e\nboost::apply_visitor([](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; v) \u003cspan class=\"synError\"\u003e{\u003c/span\u003e std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; }, s2); \u003cspan class=\"synComment\"\u003e// =\u0026gt; 2.0\u003c/span\u003e\nboost::apply_visitor([](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e\u0026amp; v) \u003cspan class=\"synError\"\u003e{\u003c/span\u003e std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; }, s3); \u003cspan class=\"synComment\"\u003e// =\u0026gt; sample3\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eしかし，Boost.Variant は非常に高機能ですが，テンプレートをガンガン使っていたりするので，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eコストが大きいという問題があります．\u003c/p\u003e\n\n\u003cp\u003eそこで，Type Erasure を使って visitor パターンをうまく表せれば，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eコストを下げられるのでは？というお話です．\u003cbr/\u003e\nType Erasure は「型消去」とかで\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%B0%A4%EB\"\u003eググる\u003c/a\u003eと色々解説してくださっている記事などが出てくると思います．（ありがとうございます）\u003c/p\u003e\n\n\u003cp\u003eこの話，私が考えたわけではなくて，どこかの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\"\u003eソースコード\u003c/a\u003eで見たようなきがするんですが，当時は Type Erasure とか意味不明だったのでスルーしていました．\u003cbr/\u003e\n今ならなんとなくやりたいことは出来るような気がするので（＆ちょうど必要になったので）記事にしてみていますが，もしオリジナルっぽいものや同じようなことを提案している\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\"\u003eソースコード\u003c/a\u003e・記事を見かけた方は是非ご連絡いただけると嬉しいです．\u003c/p\u003e\n\n\u003ch2\u003e1st step\u003c/h2\u003e\n\n\u003ch3\u003eVisitor\u003c/h3\u003e\n\n\u003cp\u003e今回表現したいデータ構造をまず定めます．簡単のために，足し算・掛け算・整数定数の 3 種類のノードを持つ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eを考えます．\u003cbr/\u003e\n\u003ccode\u003e(1 + 2) * 3\u003c/code\u003e なら， \u003ccode\u003emul( add(1, 2), 3 )\u003c/code\u003e みたいな感じです．\u003c/p\u003e\n\n\u003cp\u003eこの構造を visit する Visitor クラスから先に考えます．\u003cbr/\u003e\nVisitor クラスは，\u003ccode\u003evisit\u003c/code\u003e という\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eをもつ型の値を，型を消去して保持させます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e visitor {\n\u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n  \u003cspan class=\"synType\"\u003eclass\u003c/span\u003e visitor_base_holder {\n  \u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n    \u003cspan class=\"synType\"\u003evirtual\u003c/span\u003e \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e visit(add \u0026amp;) = \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n    \u003cspan class=\"synType\"\u003evirtual\u003c/span\u003e \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e visit(mul \u0026amp;) = \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n    \u003cspan class=\"synType\"\u003evirtual\u003c/span\u003e \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e visit(constant \u0026amp;) = \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n\n    \u003cspan class=\"synType\"\u003evirtual\u003c/span\u003e ~visitor_base_holder() = \u003cspan class=\"synStatement\"\u003edefault\u003c/span\u003e;\n  };\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e V\u0026gt; \u003cspan class=\"synType\"\u003eclass\u003c/span\u003e visitor_holder : \u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e visitor_base_holder {\n  \u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n    V \u0026amp;v;\n\n  \u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n    visitor_holder(V \u0026amp;v) : v(v) {}\n\n    \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e visit(add \u0026amp;a) override { v(a); }\n    \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e visit(mul \u0026amp;a) override { v(a); }\n    \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e visit(constant \u0026amp;a) override { v(a); }\n\n    \u003cspan class=\"synType\"\u003evirtual\u003c/span\u003e ~visitor_holder() = \u003cspan class=\"synStatement\"\u003edefault\u003c/span\u003e;\n  };\n\n  std::unique_ptr\u0026lt;visitor_base_holder\u0026gt; holder;\n\n\u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e V\u0026gt;\n  visitor(V \u0026amp;v)\n      : holder(std::make_unique\u0026lt;visitor_holder\u0026lt;V\u0026gt;\u0026gt;(v)) {}\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e Visitable\u0026gt; \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e visit(Visitable \u0026amp;v) { holder-\u0026gt;visit(v); }\n};\n\u003c/pre\u003e\n\n\u003cp\u003e今回は \u003ccode\u003econst\u003c/code\u003e 修飾についてすべて無視しています．( \u003ccode\u003econst\u003c/code\u003e を考慮するならば，各 \u003ccode\u003evisit\u003c/code\u003e について，visitor の \u003ccode\u003econst\u003c/code\u003e 性と node の \u003ccode\u003econst\u003c/code\u003e 性を考える必要があります．つまり 4 種類の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eを定義しなければなりません．）\u003cbr/\u003e\nvisit した対象となるそれぞれのデータについて\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A1%BC%A5%D0%A1%BC%A5%ED%A1%BC%A5%C9\"\u003eオーバーロード\u003c/a\u003eする形で \u003ccode\u003evisit\u003c/code\u003e を定義しています．\u003cbr/\u003e\n\u003ccode\u003evisitor\u003c/code\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%B9%A5%C8%A5%E9%A5%AF%A5%BF\"\u003eコンストラクタ\u003c/a\u003eに，\u003ccode\u003eoperator()(add\u0026amp;)\u003c/code\u003e, \u003ccode\u003eoperator()(mul\u0026amp;)\u003c/code\u003e, \u003ccode\u003eoperator()(constant\u0026amp;)\u003c/code\u003e を全て持つオブジェクト（\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e14 の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eラムダでもOK）を渡すことで，型消去された visitor が出来上がります．\u003cbr/\u003e\n\u003ccode\u003evisitor\u003c/code\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%B9%A5%C8%A5%E9%A5%AF%A5%BF\"\u003eコンストラクタ\u003c/a\u003eにどんな型の値を渡しても，出来上がる \u003ccode\u003evisitor\u003c/code\u003e にはその型情報は含まれないので，様々な visitor を統一して扱う（ \u003ccode\u003evector\u003c/code\u003e に突っ込むとか）事ができるようになります．\u003c/p\u003e\n\n\u003ch3\u003eNode\u003c/h3\u003e\n\n\u003cp\u003e次にノードの方について考えます． 通常，Visitor パターンでは， visit される側のクラスに \u003ccode\u003eaccept\u003c/code\u003e を実装します．\u003cbr/\u003e\nvisit される側のデータを統一的に扱う（ \u003ccode\u003evector\u003c/code\u003e に突っ込むとか）ためには，継承やインターフェースを用いるのが普通です．\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e では，Visitor 側に使った Type Erasure のテクニックが使えます．\u003cbr/\u003e\n\u003ccode\u003estd::vector\u0026lt;node\u0026gt;\u003c/code\u003e などのように，統一的にノードを扱いつつも，visit される際には，\u003ccode\u003evisit(add\u0026amp;)\u003c/code\u003e や \u003ccode\u003evisit(mul\u0026amp;)\u003c/code\u003e のような適切な\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A1%BC%A5%D0%A1%BC%A5%ED%A1%BC%A5%C9\"\u003eオーバーロード\u003c/a\u003e関数を呼び出すようにしてやればオッケーです．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e node {\n\u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n  \u003cspan class=\"synType\"\u003eclass\u003c/span\u003e node_base_holder {\n  \u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n    \u003cspan class=\"synType\"\u003evirtual\u003c/span\u003e \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e accept(visitor \u0026amp;v) = \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n\n    \u003cspan class=\"synType\"\u003evirtual\u003c/span\u003e ~node_base_holder() = \u003cspan class=\"synStatement\"\u003edefault\u003c/span\u003e;\n  };\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e T\u0026gt; \u003cspan class=\"synType\"\u003eclass\u003c/span\u003e node_holder : \u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e node_base_holder {\n  \u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n    node_holder(T \u003cspan class=\"synType\"\u003econst\u003c/span\u003e \u0026amp;n) : node(n) {}\n    node_holder(T \u0026amp;\u0026amp;n) : node(n) {}\n\n    \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e accept(visitor \u0026amp;v) override { v.visit(node); }\n\n    ~node_holder() = \u003cspan class=\"synStatement\"\u003edefault\u003c/span\u003e;\n\n  \u003cspan class=\"synStatement\"\u003eprivate\u003c/span\u003e:\n    T node;\n  };\n\n  std::shared_ptr\u0026lt;node_base_holder\u0026gt; holder;\n\n\u003cspan class=\"synStatement\"\u003epublic\u003c/span\u003e:\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e Node\u0026gt;\n  node(Node \u003cspan class=\"synType\"\u003econst\u003c/span\u003e \u0026amp;n)\n      : holder(std::make_shared\u0026lt;node_holder\u0026lt;Node\u0026gt;\u0026gt;(n)) {}\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e Node\u0026gt;\n  node(Node \u0026amp;\u0026amp;n)\n      : holder(std::make_shared\u0026lt;node_holder\u0026lt;Node\u0026gt;\u0026gt;(n)) {}\n\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e accept(visitor \u0026amp;v) { holder-\u0026gt;accept(v); }\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e Visitor\u0026gt; \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e accept(Visitor \u0026amp;v) {\n    visitor visit(v);\n    holder-\u0026gt;accept(visit);\n  }\n};\n\u003c/pre\u003e\n\n\u003cp\u003eこれ結構わかりにくと思うのですが，自分でも\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eに怒られながら書いたのでいまいちよく分かってません．\u003cbr/\u003e\n先ほどの \u003ccode\u003evisitor\u003c/code\u003e の場合と異なり，\u003ccode\u003enode\u003c/code\u003e には特別満たすべきインターフェースは有りません．\u003cbr/\u003e\nType Erasure を使う理由は，適切な \u003ccode\u003evisit\u003c/code\u003e 関数へのディスパッチのためです．\u003c/p\u003e\n\n\u003ch3\u003e使う\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode\u003evisitor\u003c/code\u003e と \u003ccode\u003enode\u003c/code\u003e が出来たので，使ってみます．\u003cbr/\u003e\nその前にデータ構造を定義しておきます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e constant {\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e value;\n};\n\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e add {\n  node lhs;\n  node rhs;\n};\n\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e mul {\n  node lhs;\n  node rhs;\n};\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eadd\u003c/code\u003e や \u003ccode\u003emul\u003c/code\u003e のフィールドに，\u003ccode\u003enode\u003c/code\u003e が使用されている点が大事です．\u003cbr/\u003e\n\u003ccode\u003eadd.lhs\u003c/code\u003e や \u003ccode\u003emul.rhs\u003c/code\u003e には，\u003ccode\u003econstant\u003c/code\u003e が来るか \u003ccode\u003eadd\u003c/code\u003e が来るか \u003ccode\u003emul\u003c/code\u003e が来るか分かりません．\u003cbr/\u003e\nそこで，visit 可能な型なら何でもOKという意味で，\u003ccode\u003enode\u003c/code\u003e 型の値をフィールドとします．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003enode n = mul{add{constant{\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e}, constant{\u003cspan class=\"synConstant\"\u003e2\u003c/span\u003e}}, constant{\u003cspan class=\"synConstant\"\u003e3\u003c/span\u003e}};\n\u003c/pre\u003e\n\n\u003cp\u003eこれで，\u003ccode\u003e(1 + 2) * 3\u003c/code\u003e が表現できています．\n\u003ccode\u003eadd\u003c/code\u003e や \u003ccode\u003econstant\u003c/code\u003e から \u003ccode\u003enode\u003c/code\u003e へと暗黙変換が行われていることに注意してください．\u003c/p\u003e\n\n\u003cp\u003e次に visitor を定義します．これは，\u003ccode\u003eoperator()\u003c/code\u003e を\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A1%BC%A5%D0%A1%BC%A5%ED%A1%BC%A5%C9\"\u003eオーバーロード\u003c/a\u003eした関数オブジェクトです．\u003cbr/\u003e\n式を出力する \u003ccode\u003eprinter\u003c/code\u003e と 式を計算する \u003ccode\u003ecalculator\u003c/code\u003e を定義します．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e printer {\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e()(add \u0026amp;a) {\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e;\n    a.lhs.accept(*\u003cspan class=\"synStatement\"\u003ethis\u003c/span\u003e);\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e;\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;+\u0026quot;\u003c/span\u003e;\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e;\n    a.rhs.accept(*\u003cspan class=\"synStatement\"\u003ethis\u003c/span\u003e);\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e()(mul \u0026amp;a) {\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e;\n    a.lhs.accept(*\u003cspan class=\"synStatement\"\u003ethis\u003c/span\u003e);\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e;\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;*\u0026quot;\u003c/span\u003e;\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e;\n    a.rhs.accept(*\u003cspan class=\"synStatement\"\u003ethis\u003c/span\u003e);\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e()(constant \u0026amp;c) { std::cout \u0026lt;\u0026lt; c.value; }\n};\n\n\u003cspan class=\"synType\"\u003estruct\u003c/span\u003e calculator {\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e result;\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e()(add \u0026amp;a) {\n    calculator l, r;\n    a.lhs.accept(l);\n    a.rhs.accept(r);\n    result = l.result + r.result;\n  }\n\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e()(mul \u0026amp;m) {\n    calculator l, r;\n    m.lhs.accept(l);\n    m.rhs.accept(r);\n    result = l.result * r.result;\n  }\n\n  \u003cspan class=\"synType\"\u003evoid\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eoperator\u003c/span\u003e()(constant \u0026amp;c) { result = c.value; }\n};\n\u003c/pre\u003e\n\n\u003cp\u003eこんな感じです．\u003cbr/\u003e\n\u003ccode\u003evisit\u003c/code\u003e や \u003ccode\u003eaccept\u003c/code\u003e を \u003ccode\u003evoid\u003c/code\u003e を返す関数として定義したので，\u003ccode\u003ecalculator\u003c/code\u003e は自前のフィールドに結果を保持する必要があります．\n(あとで改善します)\u003c/p\u003e\n\n\u003cp\u003e使い方は\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e  node n = mul{add{constant{\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e}, constant{\u003cspan class=\"synConstant\"\u003e2\u003c/span\u003e}}, constant{\u003cspan class=\"synConstant\"\u003e3\u003c/span\u003e}};\n  printer p;\n  n.accept(p);\n  calculator calc;\n  n.accept(calc);\n  std::cout \u0026lt;\u0026lt; std::endl;\n  std::cout \u0026lt;\u0026lt; calc.result \u0026lt;\u0026lt; std::endl;\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n\u003c/pre\u003e\n\n\u003cp\u003eです．\u003c/p\u003e\n\n\u003ch1\u003eまとめ\u003c/h1\u003e\n\n\u003cp\u003eこの方法の利点としては，データの定義そのものに Visitor パターンのためのノイズが入らないことが挙げられます．\u003cbr/\u003e\n普通の Visitor パターンでは継承必須ですし．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003econst\u003c/code\u003e つけてないせいで一時オブジェクトが使えないので \u003ccode\u003eprinter p;\u003c/code\u003e という行が必要になってしまっています．これは\u003ccode\u003econst\u003c/code\u003eをがんばってつけるだけなのでまぁ問題有りません．\u003cbr/\u003e\n一方，\u003ccode\u003ecalculator\u003c/code\u003e の方はダサいですね．値を返す visitor も定義できるようにしたい．\u003cbr/\u003e\n\u003ccode\u003evisitor\u003c/code\u003e の定義もツライです．\u003ccode\u003econst\u003c/code\u003e を考慮した場合，同じような内容の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\"\u003eメンバ関数\u003c/a\u003eを 4 回ずつ書く必要がある．\u003c/p\u003e\n\n\u003cp\u003eこのへんの問題点は解決可能な気がするので出来たら後で記事にするつもりです．\u003c/p\u003e\n\n\u003cp\u003e難しすぎて普通の visitor パターンで良くね？感出てきた\u003c/p\u003e\n\n---\n\n---\n","slug":"Type_Erasure_による_Visitor_パターンの実装","title":"Type Erasure による Visitor パターンの実装","timestamp":1453720058000,"tags":[]},{"rawMarkdown":"---\ntitle: \"#include をソートするVimプラグインを作りました\"\ndate: 2016-01-24T10:11:25.000Z\ntags: []\n---\n\n\u003cp\u003e\u003ca href=\"http://itchyny.hatenablog.com/entry/2016/01/23/190000\"\u003eHaskellでimport文をソートするプラグイン vim-haskell-sort-import を作りました - プログラムモグモグ\u003c/a\u003eという記事を拝見して，コードを見たらすごくわかりやすくて，これの \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C/C%2B%2B\"\u003eC/C++\u003c/a\u003e 版がほしいと思い，書いてみました．\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vim\"\u003evim\u003c/a\u003e script はほとんど書いたことがないんですが，やっぱりエディタ拡張用の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\"\u003eスクリプト\u003c/a\u003eなので，普通の言語と違う部分は多いですね…\nでもその分エディタという UI が既に用意されている状態なので，なんというか書いていて楽しかったです．さくっと書けますし．（先ほどのコードを参考にしているというのもありますが）\u003c/p\u003e\n\n\u003ch2\u003e使い方\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode\u003eNeoBundle\u003c/code\u003e や \u003ccode\u003evim-plug\u003c/code\u003e のような\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%E9%A5%B0%A5%A4%A5%F3\"\u003eプラグイン\u003c/a\u003eマネージャを使うなどして runtime path に突っ込んでください．\n提供する機能は \u003ccode\u003eSortInclude\u003c/code\u003e コマンドのみです．\u003c/p\u003e\n\n\u003cp\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20160124/20160124191335.gif\" alt=\"f:id:agtn:20160124191335g:plain\" title=\"f:id:agtn:20160124191335g:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003eこんな感じの動作をします．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e#include\u003c/code\u003e は \u003ccode\u003e\"\"\u003c/code\u003e を使う場合と \u003ccode\u003e\u0026lt;\u0026gt;\u003c/code\u003e を使う場合があり，それぞれファイルパスの探索場所が異なるので，それぞれ別のグループとしてソートするようにしました．\u003c/p\u003e\n\n\u003cpre class=\"code lang-c\" data-lang=\"c\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026quot;a.h\u0026quot;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026quot;z.h\u0026quot;\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eが\u003c/p\u003e\n\n\u003cpre class=\"code lang-c\" data-lang=\"c\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026quot;a.h\u0026quot;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026quot;z.h\u0026quot;\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eにソートされたら気持ち悪いと思うので．\u003c/p\u003e\n\n\u003cp\u003eあとは参考にさせていただいた\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%E9%A5%B0%A5%A4%A5%F3\"\u003eプラグイン\u003c/a\u003eと同様，空行を挟むなどブロック化されている場合は，ブロック内でソートします．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e#include\u003c/code\u003e をソートするとか既にありふれてそうですが，はじめての \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vim\"\u003evim\u003c/a\u003e \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%E9%A5%B0%A5%A4%A5%F3\"\u003eプラグイン\u003c/a\u003eということで．\nせっかくなのでドキュメントなども \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vim\"\u003evim\u003c/a\u003e の help フォーマットにしたがって書いてみました．\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e\u003ca href=\"http://itchyny.hatenablog.com/entry/2016/01/23/190000\"\u003eHaskellでimport文をソートするプラグイン vim-haskell-sort-import を作りました - プログラムモグモグ\u003c/a\u003eという記事を拝見して，コードを見たらすごくわかりやすくて，これの \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C/C%2B%2B\"\u003eC/C++\u003c/a\u003e 版がほしいと思い，書いてみました．\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vim\"\u003evim\u003c/a\u003e script はほとんど書いたことがないんですが，やっぱりエディタ拡張用の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\"\u003eスクリプト\u003c/a\u003eなので，普通の言語と違う部分は多いですね…\nでもその分エディタという UI が既に用意されている状態なので，なんというか書いていて楽しかったです．さくっと書けますし．（先ほどのコードを参考にしているというのもありますが）\u003c/p\u003e\n\n\u003ch2\u003e使い方\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode\u003eNeoBundle\u003c/code\u003e や \u003ccode\u003evim-plug\u003c/code\u003e のような\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%E9%A5%B0%A5%A4%A5%F3\"\u003eプラグイン\u003c/a\u003eマネージャを使うなどして runtime path に突っ込んでください．\n提供する機能は \u003ccode\u003eSortInclude\u003c/code\u003e コマンドのみです．\u003c/p\u003e\n\n\u003cp\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20160124/20160124191335.gif\" alt=\"f:id:agtn:20160124191335g:plain\" title=\"f:id:agtn:20160124191335g:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003eこんな感じの動作をします．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e#include\u003c/code\u003e は \u003ccode\u003e\"\"\u003c/code\u003e を使う場合と \u003ccode\u003e\u0026lt;\u0026gt;\u003c/code\u003e を使う場合があり，それぞれファイルパスの探索場所が異なるので，それぞれ別のグループとしてソートするようにしました．\u003c/p\u003e\n\n\u003cpre class=\"code lang-c\" data-lang=\"c\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026quot;a.h\u0026quot;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026quot;z.h\u0026quot;\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eが\u003c/p\u003e\n\n\u003cpre class=\"code lang-c\" data-lang=\"c\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026quot;a.h\u0026quot;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026quot;z.h\u0026quot;\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eにソートされたら気持ち悪いと思うので．\u003c/p\u003e\n\n\u003cp\u003eあとは参考にさせていただいた\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%E9%A5%B0%A5%A4%A5%F3\"\u003eプラグイン\u003c/a\u003eと同様，空行を挟むなどブロック化されている場合は，ブロック内でソートします．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e#include\u003c/code\u003e をソートするとか既にありふれてそうですが，はじめての \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vim\"\u003evim\u003c/a\u003e \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%E9%A5%B0%A5%A4%A5%F3\"\u003eプラグイン\u003c/a\u003eということで．\nせっかくなのでドキュメントなども \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vim\"\u003evim\u003c/a\u003e の help フォーマットにしたがって書いてみました．\u003c/p\u003e\n\n---\n\n---\n","slug":"include-cpp-vim-plugin","title":"#include をソートするVimプラグインを作りました","timestamp":1453630285000,"tags":[]},{"rawMarkdown":"---\ntitle: \"コンパイラ内部の AST 表現について\"\ndate: 2015-12-29T14:25:44.000Z\ntags: []\n---\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eは大体，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\"\u003eソースコード\u003c/a\u003eを\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eし，AST を作り，意味解析，コード生成という流れで実装されると思います．\u003c/p\u003e\n\n\u003cp\u003eさて，AST は単純に書くと\u003c/p\u003e\n\n\u003cpre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003etype\u003c/span\u003e expr \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eInt\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eAdd\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e expr \u003cspan class=\"synStatement\"\u003e*\u003c/span\u003e expr\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eApply\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e expr \u003cspan class=\"synStatement\"\u003e*\u003c/span\u003e expr \u003cspan class=\"synType\"\u003elist\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e ...\n\u003c/pre\u003e\n\n\u003cp\u003eみたいな感じに書けると思います．\u003c/p\u003e\n\n\u003cp\u003eこれで確かに\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\"\u003eソースコード\u003c/a\u003eの syntax 上の余計な飾りをとっぱらった\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eになっているので抽象\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%CC%DA\"\u003e構文木\u003c/a\u003eとしては十分機能します．\n一方，既存の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eを見ると，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eの後，型検査などの意味解析時にプログラムの不正を見つけた場合，きちんとソース上の位置を合わせて通知してくれます．\nこのためには，AST に位置情報を含める必要があります．\u003c/p\u003e\n\n\u003cp\u003eまた，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\"\u003e型推論\u003c/a\u003eの前後で，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eとしては同じ構造だけれども，型情報の持ち方に違いがあるという状況もあります．\u003c/p\u003e\n\n\u003cpre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink\u003e\u003cspan class=\"synComment\"\u003e(* 型推論前 *)\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003etype\u003c/span\u003e expr \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eInt\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eAdd\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e expr \u003cspan class=\"synStatement\"\u003e*\u003c/span\u003e expr\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eApply\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e expr \u003cspan class=\"synStatement\"\u003e*\u003c/span\u003e expr \u003cspan class=\"synType\"\u003elist\u003c/span\u003e\n\n\u003cspan class=\"synComment\"\u003e(* 型推論後 *)\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003etype\u003c/span\u003e texpr \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eTyped_int\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eTyped_add\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e texpr \u003cspan class=\"synStatement\"\u003e*\u003c/span\u003e texpr\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eTyped_apply\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e texpr \u003cspan class=\"synStatement\"\u003e*\u003c/span\u003e texpr \u003cspan class=\"synType\"\u003elist\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eこのように AST の表現は，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eとしては同じだが付随する情報だけが異なるという場合があります．\u003c/p\u003e\n\n\u003cp\u003eいろいろな言語の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eの AST 表現を調査してみたところ，Elm \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eの方式が良かったのでまとめておきたいと思います．\u003c/p\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003e\u003cspan class=\"synType\"\u003etype\u003c/span\u003e Expr annotation definition variable tipe \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e\n    A.Annotated annotation (Expr' annotation definition variable tipe)\n\n\n\u003cspan class=\"synType\"\u003edata\u003c/span\u003e Expr' ann def var typ\n    \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e Literal Literal.Literal\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Var var\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Range (Expr ann def var typ) (Expr ann def var typ)\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e ExplicitList [Expr ann def var typ]\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Binop var (Expr ann def var typ) (Expr ann def var typ)\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Lambda (Pattern.Pattern ann var) (Expr ann def var typ)\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e App (Expr ann def var typ) (Expr ann def var typ)\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e If [(Expr ann def var typ, Expr ann def var typ)] (Expr ann def var typ)\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Let [def] (Expr ann def var typ)\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Case (Expr ann def var typ) [(Pattern.Pattern ann var, Expr ann def var typ)]\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Data String [Expr ann def var typ]\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Access (Expr ann def var typ) String\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Update (Expr ann def var typ) [(String, Expr ann def var typ)]\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Record [(String, Expr ann def var typ)]\n    \u003cspan class=\"synComment\"\u003e-- for type checking and code gen only\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Port (PortImpl (Expr ann def var typ) typ)\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e GLShader String String Literal.GLShaderTipe\n\u003c/pre\u003e\n\n\u003cp\u003eElm \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e で実装されています．\n\u003ccode\u003eExpr\u003c/code\u003e が型引数として，\u003ccode\u003eannotation\u003c/code\u003e などを持っています．(\u003ccode\u003edefinition\u003c/code\u003e, \u003ccode\u003etipe\u003c/code\u003e についてはいまいちなんのための抽象化か理解していません...)\n\u003ccode\u003eannotation\u003c/code\u003e は，AST に付随する情報です．\u003ccode\u003eA.Annotated\u003c/code\u003e という型が，核となる情報に，情報を annotate する役割を担います．\u003c/p\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003e\u003cspan class=\"synType\"\u003edata\u003c/span\u003e Annotated annotation a\n    \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e A annotation a\n\u003c/pre\u003e\n\n\u003cp\u003eそして，AST の核となる構造自体は \u003ccode\u003eExpr'\u003c/code\u003e が持ちます．\u003c/p\u003e\n\n\u003cp\u003eこうすることで，\u003ccode\u003eannotation\u003c/code\u003e の内容を変えるだけで，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eを何度も書き直す必要なく，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eの各ステップに適した AST 表現を作る事ができます．\nちなみに \u003ccode\u003evariable\u003c/code\u003e はどうやら変数などの名前を表現する型を表しているようです．(始めは単なる \u003ccode\u003eString\u003c/code\u003e)\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eは大体，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\"\u003eソースコード\u003c/a\u003eを\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eし，AST を作り，意味解析，コード生成という流れで実装されると思います．\u003c/p\u003e\n\n\u003cp\u003eさて，AST は単純に書くと\u003c/p\u003e\n\n\u003cpre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003etype\u003c/span\u003e expr \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eInt\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eAdd\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e expr \u003cspan class=\"synStatement\"\u003e*\u003c/span\u003e expr\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eApply\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e expr \u003cspan class=\"synStatement\"\u003e*\u003c/span\u003e expr \u003cspan class=\"synType\"\u003elist\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e ...\n\u003c/pre\u003e\n\n\u003cp\u003eみたいな感じに書けると思います．\u003c/p\u003e\n\n\u003cp\u003eこれで確かに\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\"\u003eソースコード\u003c/a\u003eの syntax 上の余計な飾りをとっぱらった\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eになっているので抽象\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%CC%DA\"\u003e構文木\u003c/a\u003eとしては十分機能します．\n一方，既存の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eを見ると，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eの後，型検査などの意味解析時にプログラムの不正を見つけた場合，きちんとソース上の位置を合わせて通知してくれます．\nこのためには，AST に位置情報を含める必要があります．\u003c/p\u003e\n\n\u003cp\u003eまた，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\"\u003e型推論\u003c/a\u003eの前後で，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eとしては同じ構造だけれども，型情報の持ち方に違いがあるという状況もあります．\u003c/p\u003e\n\n\u003cpre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink\u003e\u003cspan class=\"synComment\"\u003e(* 型推論前 *)\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003etype\u003c/span\u003e expr \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eInt\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eAdd\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e expr \u003cspan class=\"synStatement\"\u003e*\u003c/span\u003e expr\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eApply\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e expr \u003cspan class=\"synStatement\"\u003e*\u003c/span\u003e expr \u003cspan class=\"synType\"\u003elist\u003c/span\u003e\n\n\u003cspan class=\"synComment\"\u003e(* 型推論後 *)\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003etype\u003c/span\u003e texpr \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eTyped_int\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eTyped_add\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e texpr \u003cspan class=\"synStatement\"\u003e*\u003c/span\u003e texpr\n  \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eTyped_apply\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e texpr \u003cspan class=\"synStatement\"\u003e*\u003c/span\u003e texpr \u003cspan class=\"synType\"\u003elist\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eこのように AST の表現は，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eとしては同じだが付随する情報だけが異なるという場合があります．\u003c/p\u003e\n\n\u003cp\u003eいろいろな言語の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eの AST 表現を調査してみたところ，Elm \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eの方式が良かったのでまとめておきたいと思います．\u003c/p\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003e\u003cspan class=\"synType\"\u003etype\u003c/span\u003e Expr annotation definition variable tipe \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e\n    A.Annotated annotation (Expr' annotation definition variable tipe)\n\n\n\u003cspan class=\"synType\"\u003edata\u003c/span\u003e Expr' ann def var typ\n    \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e Literal Literal.Literal\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Var var\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Range (Expr ann def var typ) (Expr ann def var typ)\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e ExplicitList [Expr ann def var typ]\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Binop var (Expr ann def var typ) (Expr ann def var typ)\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Lambda (Pattern.Pattern ann var) (Expr ann def var typ)\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e App (Expr ann def var typ) (Expr ann def var typ)\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e If [(Expr ann def var typ, Expr ann def var typ)] (Expr ann def var typ)\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Let [def] (Expr ann def var typ)\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Case (Expr ann def var typ) [(Pattern.Pattern ann var, Expr ann def var typ)]\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Data String [Expr ann def var typ]\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Access (Expr ann def var typ) String\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Update (Expr ann def var typ) [(String, Expr ann def var typ)]\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Record [(String, Expr ann def var typ)]\n    \u003cspan class=\"synComment\"\u003e-- for type checking and code gen only\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e Port (PortImpl (Expr ann def var typ) typ)\n    \u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e GLShader String String Literal.GLShaderTipe\n\u003c/pre\u003e\n\n\u003cp\u003eElm \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e で実装されています．\n\u003ccode\u003eExpr\u003c/code\u003e が型引数として，\u003ccode\u003eannotation\u003c/code\u003e などを持っています．(\u003ccode\u003edefinition\u003c/code\u003e, \u003ccode\u003etipe\u003c/code\u003e についてはいまいちなんのための抽象化か理解していません...)\n\u003ccode\u003eannotation\u003c/code\u003e は，AST に付随する情報です．\u003ccode\u003eA.Annotated\u003c/code\u003e という型が，核となる情報に，情報を annotate する役割を担います．\u003c/p\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003e\u003cspan class=\"synType\"\u003edata\u003c/span\u003e Annotated annotation a\n    \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e A annotation a\n\u003c/pre\u003e\n\n\u003cp\u003eそして，AST の核となる構造自体は \u003ccode\u003eExpr'\u003c/code\u003e が持ちます．\u003c/p\u003e\n\n\u003cp\u003eこうすることで，\u003ccode\u003eannotation\u003c/code\u003e の内容を変えるだけで，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\"\u003e木構造\u003c/a\u003eを何度も書き直す必要なく，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\"\u003eコンパイラ\u003c/a\u003eの各ステップに適した AST 表現を作る事ができます．\nちなみに \u003ccode\u003evariable\u003c/code\u003e はどうやら変数などの名前を表現する型を表しているようです．(始めは単なる \u003ccode\u003eString\u003c/code\u003e)\u003c/p\u003e\n\n---\n\n---\n","slug":"コンパイラ内部の_AST_表現について","title":"コンパイラ内部の AST 表現について","timestamp":1451399144000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Boost.Spirit.X3 で簡易電卓を実装 1\"\ndate: 2015-12-18T14:27:05.000Z\ntags: []\n---\n\n\u003cp\u003e\u003ciframe src=\"http://agtn.hatenablog.com/embed/2015/12/17/190505\" title=\"Boost.Spirit.X3 の練習1 - プログラミングのメモ帳➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"http://agtn.hatenablog.com/entry/2015/12/17/190505\"\u003eagtn.hatenablog.com\u003c/a\u003e\u003c/cite\u003e\n\u003ciframe src=\"http://agtn.hatenablog.com/embed/2015/12/17/232003\" title=\"Boost.Spirit.X3 の練習 2 - プログラミングのメモ帳➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"http://agtn.hatenablog.com/entry/2015/12/17/232003\"\u003eagtn.hatenablog.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003e引き続き，\u003ccode\u003eBoost.Spirit.X3\u003c/code\u003e です．\u003cbr/\u003e\n今回は，前回までの知識をつかって，簡易電卓を実装してみます．\u003c/p\u003e\n\n\u003ch2\u003e仕様\u003c/h2\u003e\n\n\u003cp\u003e今回定義する電卓は，\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e+\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eの 4 つの演算と単項の \u003ccode\u003e-\u003c/code\u003e をサポートします．\u003cbr/\u003e\nまた，整数型のみを扱うものとします．\u003cbr/\u003e\n\u003ccode\u003e(\u003c/code\u003e, \u003ccode\u003e)\u003c/code\u003e でくくることで，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\"\u003e演算子\u003c/a\u003eの結合優先順位を書き換えられ，\u003ccode\u003e*\u003c/code\u003e と \u003ccode\u003e/\u003c/code\u003e は \u003ccode\u003e+\u003c/code\u003e と \u003ccode\u003e-\u003c/code\u003e より優先されるとします．\u003c/p\u003e\n\n\u003cp\u003e要するに整数の四則演算のみをサポートする電卓です．\u003c/p\u003e\n\n\u003cp\u003eこのような電卓を実装するサンプルは \u003ccode\u003eBoost.Spirit.X3\u003c/code\u003e 以外のライブラリ/\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C4%A1%BC%A5%EB\"\u003eツール\u003c/a\u003eでも大量に出てくると思います．\u003cbr/\u003e\n今回は，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eそのものというよりは \u003ccode\u003eBoost.Spirit.X3\u003c/code\u003e の使い方についてメモしたいので，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eそのものの話はぐぐってみてください．\u003c/p\u003e\n\n\u003ch2\u003eパーサの骨格\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\"\u003e演算子\u003c/a\u003eの結合規則をサポートするために，\u003ccode\u003eprimary\u003c/code\u003e(定数と \u003ccode\u003e()\u003c/code\u003e で囲まれた式), \u003ccode\u003eneg_expr\u003c/code\u003e(単項 \u003ccode\u003e-\u003c/code\u003e), \u003ccode\u003emul_expr\u003c/code\u003e(\u003ccode\u003e*\u003c/code\u003e, \u003ccode\u003e/\u003c/code\u003e), \u003ccode\u003eadd_expr\u003c/code\u003e(\u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e), \u003ccode\u003eexpression\u003c/code\u003e というパーサをそれぞれ定義します．\u003cbr/\u003e\n先頭から順に結合強度が強くなっています．(\u003ccode\u003eexpression\u003c/code\u003e が最弱, \u003ccode\u003eprimary\u003c/code\u003e が最強)\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eprimary\u003c/code\u003e は \u003ccode\u003e()\u003c/code\u003e で囲まれた式，つまり \u003ccode\u003e\"(\" \u0026gt; expression \u0026gt; \")\"\u003c/code\u003e を受け付ける必要があり，また，\u003ccode\u003eprimary\u003c/code\u003e 自体も \u003ccode\u003eexpression\u003c/code\u003e の一部です．\u003cbr/\u003e\nしたがって，この規則を定義するためには，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003e的なパーサを記述する必要があります．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eX3\u003c/code\u003e で\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003e的なパーサを記述する方法は\u003ca href=\"http://agtn.hatenablog.com/entry/2015/12/17/232003\"\u003e前回の記事\u003c/a\u003eにまとめました．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e primary;\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e neg_expr;\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e mul_expr;\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e add_expr;\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e expression;\n\n  x3::rule\u0026lt;primary, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e primary;\n  x3::rule\u0026lt;neg_expr, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e neg_expr;\n  x3::rule\u0026lt;mul_expr, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e mul_expr;\n  x3::rule\u0026lt;add_expr, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e add_expr;\n  x3::rule\u0026lt;expression, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e expression;\n\u003c/pre\u003e\n\n\u003cp\u003eそれぞれのパーサは attribute として整数型を持ちます．ここに演算結果が格納されることになります．\u003cbr/\u003e\n\u003ccode\u003estruct primary\u003c/code\u003e などは，今は前方宣言のみで十分です．\u003ccode\u003eon_error\u003c/code\u003e などを実装したくなった時に定義します．\u003c/p\u003e\n\n\u003ch2\u003eprimary\u003c/h2\u003e\n\n\u003cp\u003eまずは \u003ccode\u003eprimary\u003c/code\u003e を定義します.\u003cbr/\u003e\n\u003ccode\u003eprimary\u003c/code\u003e は整数定数か， \u003ccode\u003e()\u003c/code\u003e で囲まれた \u003ccode\u003eexpression\u003c/code\u003e を受理します．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e primary_def =\n    x3::int_\n  | \u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e \u0026gt; expression \u0026gt; \u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e\n  ;\n\u003c/pre\u003e\n\n\u003cp\u003eattribute を考慮しなければこんな感じでしょうか．\u003ccode\u003eexpression\u003c/code\u003e は既に宣言されているので使用可能です．(\u003ccode\u003eexpression\u003c/code\u003e の実装がこの時点で見えていなくても使用できます.)\u003c/p\u003e\n\n\u003cp\u003e単純に attribute を結果として返すセマンティックアクションはこの後もよく出てくるので，ヘルパとして定義しておきます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e detail {\n\n  decltype(\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e) assign()\n  {\n    \u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e x3::_attr;\n    \u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e x3::_val;\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e [](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; ctx) { _val(ctx) = _attr(ctx); };\n  }\n\n} \u003cspan class=\"synComment\"\u003e// namespace detail\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eassign\u003c/code\u003e は attribute を結果に代入する関数オブジェクトを返します．\u003cbr/\u003e\n関数にする必要が特にありませんが，この後出てくるヘルパと見た目を合わせたいので関数にしました．\u003c/p\u003e\n\n\u003cp\u003eこれを使うと，\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e primary_def =\n    x3::int_[detail::assign()]\n  | (\u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e \u0026gt; expression \u0026gt; \u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e)[detail::assign()]\n  ;\n\u003c/pre\u003e\n\n\u003cp\u003eこんな感じで \u003ccode\u003eprimary\u003c/code\u003e が定義できます．\u003c/p\u003e\n\n\u003ch2\u003e単項マイナス\u003c/h2\u003e\n\n\u003cp\u003e次に \u003ccode\u003eneg_expr\u003c/code\u003e を定義します．\nセマンティックアクションを考えなければ，\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e neg_expr_def =\n    primary\n  | \u003cspan class=\"synConstant\"\u003e\u0026quot;-\u0026quot;\u003c/span\u003e \u0026gt; primary\n  ;\n\u003c/pre\u003e\n\n\u003cp\u003eとなります．\u003cbr/\u003e\n\u003ccode\u003e\"-\" \u0026gt; primary\u003c/code\u003e のセマンティックアクションとしては，attribute を符号反転して結果に格納するというアクションが求められます．\u003cbr/\u003e\nここはちょっと汎用的に，attribute に関数オブジェクトを適用して結果に格納するアクションを返すような関数を定義して解決してみます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e detail {\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e F\u0026gt;\n  decltype(\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e) assign_f(F\u0026amp;\u0026amp; func)\n  {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e [func](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; ctx) { _val(ctx) = func(_attr(ctx)); };\n  }\n} \u003cspan class=\"synComment\"\u003e// namespace detail\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eassign_f\u003c/code\u003e は \u003ccode\u003eassign\u003c/code\u003e と異なり，関数オブジェクトを１つ引数に取ります．\u003cbr/\u003e\nそして，その関数オブジェクトを \u003ccode\u003e_attr(ctx)\u003c/code\u003e に適用し結果に格納します．\u003c/p\u003e\n\n\u003cp\u003eこれを使って，\u003ccode\u003eneg_expr\u003c/code\u003e は\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e neg_expr_def =\n    primary[detail::assign()]\n  | (\u003cspan class=\"synConstant\"\u003e\u0026quot;-\u0026quot;\u003c/span\u003e \u0026gt; primary)[detail::assign(std::negate\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;\u003cspan class=\"synError\"\u003e{\u003c/span\u003e})]\n  ;\n\u003c/pre\u003e\n\n\u003cp\u003eとなります．\u003ccode\u003estd::negate\u003c/code\u003e は \u003ccode\u003e\u0026lt;functional\u0026gt;\u003c/code\u003e で定義された型で，ここでは \u003ccode\u003eint\u003c/code\u003e 型の値を符号反転する関数オブジェクトとして使用しています．\u003c/p\u003e\n\n\u003ch2\u003e乗除\u003c/h2\u003e\n\n\u003cp\u003e次に結合強度が強いのは \u003ccode\u003e*\u003c/code\u003e と \u003ccode\u003e/\u003c/code\u003e です．\u003cbr/\u003e\nちょっとわかりにくいですが，セマンティックアクションを無視すれば，\u003ccode\u003emul_expr\u003c/code\u003e は\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e mul_expr_def =\n    neg_expr\n    \u0026gt;\u0026gt; *(\n        (\u003cspan class=\"synConstant\"\u003e\u0026quot;*\u0026quot;\u003c/span\u003e \u0026gt;\u0026gt; neg_expr)\n      | (\u003cspan class=\"synConstant\"\u003e\u0026quot;/\u0026quot;\u003c/span\u003e \u0026gt;\u0026gt; neg_expr)\n    )\n  ;\n\u003c/pre\u003e\n\n\u003cp\u003eと定義できます．\u003ccode\u003emul_expr\u003c/code\u003e は \u003ccode\u003e1\u003c/code\u003e や \u003ccode\u003e(1 + 2)\u003c/code\u003e, \u003ccode\u003e-1\u003c/code\u003e の後に，\u003ccode\u003e* 1\u003c/code\u003e とか \u003ccode\u003e/ -3\u003c/code\u003e とか \u003ccode\u003e* (1 - 2)\u003c/code\u003e とかが 0 回以上現れるような式です．\u003cbr/\u003e\n\u003ccode\u003e1 * -2\u003c/code\u003e はちょっと気持ち悪い気もしますが… 今気がついたので許してください．\u003c/p\u003e\n\n\u003cp\u003eセマンティックアクションとしては，\u003ccode\u003e(\"*\" \u0026gt;\u0026gt; neg_expr)\u003c/code\u003e が現れる度に，\u003ccode\u003e_val(ctx)\u003c/code\u003e を \u003ccode\u003e_val(ctx) * _attr(ctx)\u003c/code\u003e に更新すれば良いです．\u003cbr/\u003e\n始めの \u003ccode\u003eneg_expr\u003c/code\u003e の結果を \u003ccode\u003e_val(ctx)\u003c/code\u003e に格納すれば，\u003ccode\u003e_val(ctx)\u003c/code\u003e は常に現在の計算結果を表すことになります．\u003ccode\u003e(\"*\" \u0026gt;\u0026gt; neg_expr)\u003c/code\u003e は現在の計算結果に，今処理した式(\u003ccode\u003e*\u003c/code\u003e の後に続く式のこと) を処理した結果をかければ良いということです．\u003c/p\u003e\n\n\u003cp\u003eというわけで分かりにくいとは思いますが，ほしいアクションは，\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e[](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; ctx) { _val(ctx) = _val(ctx) * _attr(ctx); }\n\u003c/pre\u003e\n\n\u003cp\u003eです．\u003c/p\u003e\n\n\u003cp\u003eさて，では \u003ccode\u003e/\u003c/code\u003e の場合を考えます．\u003cbr/\u003e\n\u003ccode\u003e/\u003c/code\u003e の場合であってもほとんどは \u003ccode\u003e*\u003c/code\u003e と同じであることがわかります．\u003cbr/\u003e\nほしいアクションは\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e[](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; ctx) { _val(ctx) = _val(ctx) / _attr(ctx); }\n\u003c/pre\u003e\n\n\u003cp\u003eであり，\u003ccode\u003e*\u003c/code\u003e と \u003ccode\u003e/\u003c/code\u003e の違いしか有りません．\u003c/p\u003e\n\n\u003cp\u003eそこでこれも関数にまとめてしまいます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e detail {\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e Op\u0026gt;\n  decltype(\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e) calc_op(Op\u0026amp;\u0026amp; op)\n  {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e [op](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; ctx) { _val(ctx) = op(_val(ctx), _attr(ctx)); };\n  }\n\n} \u003cspan class=\"synComment\"\u003e// namespace detail\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eこんな関数を定義して，\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e mul_expr_def =\n    neg_expr[detail::assign()]\n    \u0026gt;\u0026gt; *(\n        (\u003cspan class=\"synConstant\"\u003e\u0026quot;*\u0026quot;\u003c/span\u003e \u0026gt;\u0026gt; neg_expr)[detail::calc_op(std::multiplies\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;\u003cspan class=\"synError\"\u003e{\u003c/span\u003e})]\n      | (\u003cspan class=\"synConstant\"\u003e\u0026quot;/\u0026quot;\u003c/span\u003e \u0026gt;\u0026gt; neg_expr)[detail::calc_op(std::divides\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;\u003cspan class=\"synError\"\u003e{\u003c/span\u003e})]\n    )\n  ;\n\u003c/pre\u003e\n\n\u003cp\u003eと使います．\u003cbr/\u003e\n\u003ccode\u003ecalc_op\u003c/code\u003e は関数オブジェクトを引数に取り，\u003ccode\u003e_val(ctx)\u003c/code\u003e と \u003ccode\u003e_attr(ctx)\u003c/code\u003e に適用した結果を格納するアクションを返します．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eadd_expr\u003c/code\u003e は \u003ccode\u003emul_expr\u003c/code\u003e とほぼおなじなので詳細はスキップします．\u003c/p\u003e\n\n\u003ch2\u003eexpression\u003c/h2\u003e\n\n\u003cp\u003e最後に \u003ccode\u003eexpression\u003c/code\u003e です．これは単純に \u003ccode\u003eadd_expr\u003c/code\u003e と一致します．\u003cbr/\u003e\n命名のわかりやすさと，今後拡張していく際に便利そうということで分けてあるだけです．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e expression_def =\n    add_expr[detail::assign()]\n  ;\n\u003c/pre\u003e\n\n\u003ch2\u003e確認\u003c/h2\u003e\n\n\u003cp\u003eコード全体を掲載します．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;boost/spirit/home/x3.hpp\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;functional\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e x3 = boost::spirit::x3;\n\n\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e grammar {\n\n  \u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e detail {\n\n    decltype(\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e) assign()\n    {\n      \u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e x3::_attr;\n      \u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e x3::_val;\n      \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e [](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; ctx) { _val(ctx) = _attr(ctx); };\n    }\n\n    \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e F\u0026gt;\n    decltype(\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e) assign_f(F\u0026amp;\u0026amp; func)\n    {\n      \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e [func](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; ctx) { _val(ctx) = func(_attr(ctx)); };\n    }\n\n    \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e Op\u0026gt;\n    decltype(\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e) calc_op(Op\u0026amp;\u0026amp; op)\n    {\n      \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e [op](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; ctx) { x3::_val(ctx) = op(x3::_val(ctx), x3::_attr(ctx)); };\n    }\n\n  } \u003cspan class=\"synComment\"\u003e// namespace detail\u003c/span\u003e\n\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e primary;\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e neg_expr;\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e mul_expr;\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e add_expr;\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e expression;\n\n  x3::rule\u0026lt;primary, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e primary;\n  x3::rule\u0026lt;neg_expr, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e neg_expr;\n  x3::rule\u0026lt;mul_expr, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e mul_expr;\n  x3::rule\u0026lt;add_expr, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e add_expr;\n  x3::rule\u0026lt;expression, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e expression;\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e primary_def =\n      x3::int_[detail::assign()]\n    | (\u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e \u0026gt; expression \u0026gt; \u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e)[detail::assign()]\n    ;\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e neg_expr_def =\n      primary[detail::assign()]\n    | (\u003cspan class=\"synConstant\"\u003e\u0026quot;-\u0026quot;\u003c/span\u003e \u0026gt; primary)[detail::assign_f(std::negate\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;\u003cspan class=\"synError\"\u003e{\u003c/span\u003e})]\n    ;\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e mul_expr_def =\n      neg_expr[detail::assign()]\n      \u0026gt;\u0026gt; *(\n          (\u003cspan class=\"synConstant\"\u003e\u0026quot;*\u0026quot;\u003c/span\u003e \u0026gt;\u0026gt; neg_expr)[detail::calc_op(std::multiplies\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;\u003cspan class=\"synError\"\u003e{\u003c/span\u003e})]\n        | (\u003cspan class=\"synConstant\"\u003e\u0026quot;/\u0026quot;\u003c/span\u003e \u0026gt;\u0026gt; neg_expr)[detail::calc_op(std::divides\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;\u003cspan class=\"synError\"\u003e{\u003c/span\u003e})]\n      )\n    ;\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e add_expr_def =\n      mul_expr[detail::assign()]\n      \u0026gt;\u0026gt; *(\n          (\u003cspan class=\"synConstant\"\u003e\u0026quot;+\u0026quot;\u003c/span\u003e \u0026gt; mul_expr)[detail::calc_op(std::plus\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;\u003cspan class=\"synError\"\u003e{\u003c/span\u003e})]\n        | (\u003cspan class=\"synConstant\"\u003e\u0026quot;-\u0026quot;\u003c/span\u003e \u0026gt; mul_expr)[detail::calc_op(std::minus\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;\u003cspan class=\"synError\"\u003e{\u003c/span\u003e})]\n      )\n    ;\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e expression_def =\n      add_expr[detail::assign()]\n    ;\n\n  BOOST_SPIRIT_DEFINE(\n      primary,\n      neg_expr,\n      mul_expr,\n      add_expr,\n      expression\n      );\n\n} \u003cspan class=\"synComment\"\u003e// namespace grammar\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e grammar::expression;\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main()\n{\n  std::string str;\n  std::getline(std::cin, str);\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e first(std::cbegin(str));\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e last(std::cend(str));\n\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e result;\n  \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::phrase_parse(first, last, expression, x3::ascii::space, result);\n\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (!success || first != last) {\n    std::cerr \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse failed.\u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; std::endl;\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e;\n  }\n\n  std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parsed: \u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl;\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n}\n\u003c/pre\u003e\n\n\u003cp\u003e実行してみます．\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e$ clang++ -std=c++14 main.cpp\n$ ./a.out\n1 + 2 * 3\nParsed: 7\n$ ./a.out\n(1 + 2) * 3\nParsed: 9\u003c/pre\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\"\u003e演算子\u003c/a\u003eの優先順位が正しく解決できていることが確認出来ます．\u003c/p\u003e\n\n\u003ch2\u003eまとめ\u003c/h2\u003e\n\n\u003cp\u003e今回は，セマンティックアクションで計算自体を行ってしまいましたが，普通は抽象\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%CC%DA\"\u003e構文木\u003c/a\u003e(AST) に変換するためにセマンティックアクションを使うのが正道だと思います．\u003cbr/\u003e\n\u003ccode\u003eX3\u003c/code\u003e は AST のための色々を提供してくれていますが，自前で作った AST でもちょっと苦労はするかもしれませんが変換できるはずなので，時間があれば，自前 AST に変換してから実行する電卓も作ってみたいと思います．\u003c/p\u003e\n\n\u003cp\u003eまた，AST に変換して計算する場合，AST に位置情報を付与することで，エラーレポートが便利になったりするはずです( 0 除算のエラーを通知する際，どの部分でのエラーなのかを吐いてくれればうれしいですよね).\u003cbr/\u003e\nパース失敗時にもどこで失敗したのかをレポートしてくれたほうが便利です．\u003cbr/\u003e\n\u003ccode\u003eX3\u003c/code\u003e で \u003ccode\u003eon_error\u003c/code\u003e, \u003ccode\u003eon_success\u003c/code\u003e を使ってこれらを実装してみようと考えています．\u003c/p\u003e\n\n\u003cp\u003e今回のコードでは \u003ccode\u003edecltype(auto)\u003c/code\u003e など，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e14 の機能を使っています．\u003ccode\u003eX3\u003c/code\u003e は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e14 前提のライブラリなので，迷いなくこういった機能を使用できて幸せデスね．\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e\u003ciframe src=\"http://agtn.hatenablog.com/embed/2015/12/17/190505\" title=\"Boost.Spirit.X3 の練習1 - プログラミングのメモ帳➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"http://agtn.hatenablog.com/entry/2015/12/17/190505\"\u003eagtn.hatenablog.com\u003c/a\u003e\u003c/cite\u003e\n\u003ciframe src=\"http://agtn.hatenablog.com/embed/2015/12/17/232003\" title=\"Boost.Spirit.X3 の練習 2 - プログラミングのメモ帳➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"\u003e\u003c/iframe\u003e\u003ccite class=\"hatena-citation\"\u003e\u003ca href=\"http://agtn.hatenablog.com/entry/2015/12/17/232003\"\u003eagtn.hatenablog.com\u003c/a\u003e\u003c/cite\u003e\u003c/p\u003e\n\n\u003cp\u003e引き続き，\u003ccode\u003eBoost.Spirit.X3\u003c/code\u003e です．\u003cbr/\u003e\n今回は，前回までの知識をつかって，簡易電卓を実装してみます．\u003c/p\u003e\n\n\u003ch2\u003e仕様\u003c/h2\u003e\n\n\u003cp\u003e今回定義する電卓は，\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e+\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eの 4 つの演算と単項の \u003ccode\u003e-\u003c/code\u003e をサポートします．\u003cbr/\u003e\nまた，整数型のみを扱うものとします．\u003cbr/\u003e\n\u003ccode\u003e(\u003c/code\u003e, \u003ccode\u003e)\u003c/code\u003e でくくることで，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\"\u003e演算子\u003c/a\u003eの結合優先順位を書き換えられ，\u003ccode\u003e*\u003c/code\u003e と \u003ccode\u003e/\u003c/code\u003e は \u003ccode\u003e+\u003c/code\u003e と \u003ccode\u003e-\u003c/code\u003e より優先されるとします．\u003c/p\u003e\n\n\u003cp\u003e要するに整数の四則演算のみをサポートする電卓です．\u003c/p\u003e\n\n\u003cp\u003eこのような電卓を実装するサンプルは \u003ccode\u003eBoost.Spirit.X3\u003c/code\u003e 以外のライブラリ/\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C4%A1%BC%A5%EB\"\u003eツール\u003c/a\u003eでも大量に出てくると思います．\u003cbr/\u003e\n今回は，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eそのものというよりは \u003ccode\u003eBoost.Spirit.X3\u003c/code\u003e の使い方についてメモしたいので，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eそのものの話はぐぐってみてください．\u003c/p\u003e\n\n\u003ch2\u003eパーサの骨格\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\"\u003e演算子\u003c/a\u003eの結合規則をサポートするために，\u003ccode\u003eprimary\u003c/code\u003e(定数と \u003ccode\u003e()\u003c/code\u003e で囲まれた式), \u003ccode\u003eneg_expr\u003c/code\u003e(単項 \u003ccode\u003e-\u003c/code\u003e), \u003ccode\u003emul_expr\u003c/code\u003e(\u003ccode\u003e*\u003c/code\u003e, \u003ccode\u003e/\u003c/code\u003e), \u003ccode\u003eadd_expr\u003c/code\u003e(\u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e), \u003ccode\u003eexpression\u003c/code\u003e というパーサをそれぞれ定義します．\u003cbr/\u003e\n先頭から順に結合強度が強くなっています．(\u003ccode\u003eexpression\u003c/code\u003e が最弱, \u003ccode\u003eprimary\u003c/code\u003e が最強)\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eprimary\u003c/code\u003e は \u003ccode\u003e()\u003c/code\u003e で囲まれた式，つまり \u003ccode\u003e\"(\" \u0026gt; expression \u0026gt; \")\"\u003c/code\u003e を受け付ける必要があり，また，\u003ccode\u003eprimary\u003c/code\u003e 自体も \u003ccode\u003eexpression\u003c/code\u003e の一部です．\u003cbr/\u003e\nしたがって，この規則を定義するためには，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003e的なパーサを記述する必要があります．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eX3\u003c/code\u003e で\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003e的なパーサを記述する方法は\u003ca href=\"http://agtn.hatenablog.com/entry/2015/12/17/232003\"\u003e前回の記事\u003c/a\u003eにまとめました．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e primary;\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e neg_expr;\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e mul_expr;\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e add_expr;\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e expression;\n\n  x3::rule\u0026lt;primary, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e primary;\n  x3::rule\u0026lt;neg_expr, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e neg_expr;\n  x3::rule\u0026lt;mul_expr, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e mul_expr;\n  x3::rule\u0026lt;add_expr, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e add_expr;\n  x3::rule\u0026lt;expression, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e expression;\n\u003c/pre\u003e\n\n\u003cp\u003eそれぞれのパーサは attribute として整数型を持ちます．ここに演算結果が格納されることになります．\u003cbr/\u003e\n\u003ccode\u003estruct primary\u003c/code\u003e などは，今は前方宣言のみで十分です．\u003ccode\u003eon_error\u003c/code\u003e などを実装したくなった時に定義します．\u003c/p\u003e\n\n\u003ch2\u003eprimary\u003c/h2\u003e\n\n\u003cp\u003eまずは \u003ccode\u003eprimary\u003c/code\u003e を定義します.\u003cbr/\u003e\n\u003ccode\u003eprimary\u003c/code\u003e は整数定数か， \u003ccode\u003e()\u003c/code\u003e で囲まれた \u003ccode\u003eexpression\u003c/code\u003e を受理します．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e primary_def =\n    x3::int_\n  | \u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e \u0026gt; expression \u0026gt; \u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e\n  ;\n\u003c/pre\u003e\n\n\u003cp\u003eattribute を考慮しなければこんな感じでしょうか．\u003ccode\u003eexpression\u003c/code\u003e は既に宣言されているので使用可能です．(\u003ccode\u003eexpression\u003c/code\u003e の実装がこの時点で見えていなくても使用できます.)\u003c/p\u003e\n\n\u003cp\u003e単純に attribute を結果として返すセマンティックアクションはこの後もよく出てくるので，ヘルパとして定義しておきます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e detail {\n\n  decltype(\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e) assign()\n  {\n    \u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e x3::_attr;\n    \u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e x3::_val;\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e [](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; ctx) { _val(ctx) = _attr(ctx); };\n  }\n\n} \u003cspan class=\"synComment\"\u003e// namespace detail\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eassign\u003c/code\u003e は attribute を結果に代入する関数オブジェクトを返します．\u003cbr/\u003e\n関数にする必要が特にありませんが，この後出てくるヘルパと見た目を合わせたいので関数にしました．\u003c/p\u003e\n\n\u003cp\u003eこれを使うと，\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e primary_def =\n    x3::int_[detail::assign()]\n  | (\u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e \u0026gt; expression \u0026gt; \u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e)[detail::assign()]\n  ;\n\u003c/pre\u003e\n\n\u003cp\u003eこんな感じで \u003ccode\u003eprimary\u003c/code\u003e が定義できます．\u003c/p\u003e\n\n\u003ch2\u003e単項マイナス\u003c/h2\u003e\n\n\u003cp\u003e次に \u003ccode\u003eneg_expr\u003c/code\u003e を定義します．\nセマンティックアクションを考えなければ，\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e neg_expr_def =\n    primary\n  | \u003cspan class=\"synConstant\"\u003e\u0026quot;-\u0026quot;\u003c/span\u003e \u0026gt; primary\n  ;\n\u003c/pre\u003e\n\n\u003cp\u003eとなります．\u003cbr/\u003e\n\u003ccode\u003e\"-\" \u0026gt; primary\u003c/code\u003e のセマンティックアクションとしては，attribute を符号反転して結果に格納するというアクションが求められます．\u003cbr/\u003e\nここはちょっと汎用的に，attribute に関数オブジェクトを適用して結果に格納するアクションを返すような関数を定義して解決してみます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e detail {\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e F\u0026gt;\n  decltype(\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e) assign_f(F\u0026amp;\u0026amp; func)\n  {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e [func](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; ctx) { _val(ctx) = func(_attr(ctx)); };\n  }\n} \u003cspan class=\"synComment\"\u003e// namespace detail\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eassign_f\u003c/code\u003e は \u003ccode\u003eassign\u003c/code\u003e と異なり，関数オブジェクトを１つ引数に取ります．\u003cbr/\u003e\nそして，その関数オブジェクトを \u003ccode\u003e_attr(ctx)\u003c/code\u003e に適用し結果に格納します．\u003c/p\u003e\n\n\u003cp\u003eこれを使って，\u003ccode\u003eneg_expr\u003c/code\u003e は\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e neg_expr_def =\n    primary[detail::assign()]\n  | (\u003cspan class=\"synConstant\"\u003e\u0026quot;-\u0026quot;\u003c/span\u003e \u0026gt; primary)[detail::assign(std::negate\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;\u003cspan class=\"synError\"\u003e{\u003c/span\u003e})]\n  ;\n\u003c/pre\u003e\n\n\u003cp\u003eとなります．\u003ccode\u003estd::negate\u003c/code\u003e は \u003ccode\u003e\u0026lt;functional\u0026gt;\u003c/code\u003e で定義された型で，ここでは \u003ccode\u003eint\u003c/code\u003e 型の値を符号反転する関数オブジェクトとして使用しています．\u003c/p\u003e\n\n\u003ch2\u003e乗除\u003c/h2\u003e\n\n\u003cp\u003e次に結合強度が強いのは \u003ccode\u003e*\u003c/code\u003e と \u003ccode\u003e/\u003c/code\u003e です．\u003cbr/\u003e\nちょっとわかりにくいですが，セマンティックアクションを無視すれば，\u003ccode\u003emul_expr\u003c/code\u003e は\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e mul_expr_def =\n    neg_expr\n    \u0026gt;\u0026gt; *(\n        (\u003cspan class=\"synConstant\"\u003e\u0026quot;*\u0026quot;\u003c/span\u003e \u0026gt;\u0026gt; neg_expr)\n      | (\u003cspan class=\"synConstant\"\u003e\u0026quot;/\u0026quot;\u003c/span\u003e \u0026gt;\u0026gt; neg_expr)\n    )\n  ;\n\u003c/pre\u003e\n\n\u003cp\u003eと定義できます．\u003ccode\u003emul_expr\u003c/code\u003e は \u003ccode\u003e1\u003c/code\u003e や \u003ccode\u003e(1 + 2)\u003c/code\u003e, \u003ccode\u003e-1\u003c/code\u003e の後に，\u003ccode\u003e* 1\u003c/code\u003e とか \u003ccode\u003e/ -3\u003c/code\u003e とか \u003ccode\u003e* (1 - 2)\u003c/code\u003e とかが 0 回以上現れるような式です．\u003cbr/\u003e\n\u003ccode\u003e1 * -2\u003c/code\u003e はちょっと気持ち悪い気もしますが… 今気がついたので許してください．\u003c/p\u003e\n\n\u003cp\u003eセマンティックアクションとしては，\u003ccode\u003e(\"*\" \u0026gt;\u0026gt; neg_expr)\u003c/code\u003e が現れる度に，\u003ccode\u003e_val(ctx)\u003c/code\u003e を \u003ccode\u003e_val(ctx) * _attr(ctx)\u003c/code\u003e に更新すれば良いです．\u003cbr/\u003e\n始めの \u003ccode\u003eneg_expr\u003c/code\u003e の結果を \u003ccode\u003e_val(ctx)\u003c/code\u003e に格納すれば，\u003ccode\u003e_val(ctx)\u003c/code\u003e は常に現在の計算結果を表すことになります．\u003ccode\u003e(\"*\" \u0026gt;\u0026gt; neg_expr)\u003c/code\u003e は現在の計算結果に，今処理した式(\u003ccode\u003e*\u003c/code\u003e の後に続く式のこと) を処理した結果をかければ良いということです．\u003c/p\u003e\n\n\u003cp\u003eというわけで分かりにくいとは思いますが，ほしいアクションは，\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e[](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; ctx) { _val(ctx) = _val(ctx) * _attr(ctx); }\n\u003c/pre\u003e\n\n\u003cp\u003eです．\u003c/p\u003e\n\n\u003cp\u003eさて，では \u003ccode\u003e/\u003c/code\u003e の場合を考えます．\u003cbr/\u003e\n\u003ccode\u003e/\u003c/code\u003e の場合であってもほとんどは \u003ccode\u003e*\u003c/code\u003e と同じであることがわかります．\u003cbr/\u003e\nほしいアクションは\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e[](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; ctx) { _val(ctx) = _val(ctx) / _attr(ctx); }\n\u003c/pre\u003e\n\n\u003cp\u003eであり，\u003ccode\u003e*\u003c/code\u003e と \u003ccode\u003e/\u003c/code\u003e の違いしか有りません．\u003c/p\u003e\n\n\u003cp\u003eそこでこれも関数にまとめてしまいます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e detail {\n\n  \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e Op\u0026gt;\n  decltype(\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e) calc_op(Op\u0026amp;\u0026amp; op)\n  {\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e [op](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; ctx) { _val(ctx) = op(_val(ctx), _attr(ctx)); };\n  }\n\n} \u003cspan class=\"synComment\"\u003e// namespace detail\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eこんな関数を定義して，\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e mul_expr_def =\n    neg_expr[detail::assign()]\n    \u0026gt;\u0026gt; *(\n        (\u003cspan class=\"synConstant\"\u003e\u0026quot;*\u0026quot;\u003c/span\u003e \u0026gt;\u0026gt; neg_expr)[detail::calc_op(std::multiplies\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;\u003cspan class=\"synError\"\u003e{\u003c/span\u003e})]\n      | (\u003cspan class=\"synConstant\"\u003e\u0026quot;/\u0026quot;\u003c/span\u003e \u0026gt;\u0026gt; neg_expr)[detail::calc_op(std::divides\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;\u003cspan class=\"synError\"\u003e{\u003c/span\u003e})]\n    )\n  ;\n\u003c/pre\u003e\n\n\u003cp\u003eと使います．\u003cbr/\u003e\n\u003ccode\u003ecalc_op\u003c/code\u003e は関数オブジェクトを引数に取り，\u003ccode\u003e_val(ctx)\u003c/code\u003e と \u003ccode\u003e_attr(ctx)\u003c/code\u003e に適用した結果を格納するアクションを返します．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eadd_expr\u003c/code\u003e は \u003ccode\u003emul_expr\u003c/code\u003e とほぼおなじなので詳細はスキップします．\u003c/p\u003e\n\n\u003ch2\u003eexpression\u003c/h2\u003e\n\n\u003cp\u003e最後に \u003ccode\u003eexpression\u003c/code\u003e です．これは単純に \u003ccode\u003eadd_expr\u003c/code\u003e と一致します．\u003cbr/\u003e\n命名のわかりやすさと，今後拡張していく際に便利そうということで分けてあるだけです．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e expression_def =\n    add_expr[detail::assign()]\n  ;\n\u003c/pre\u003e\n\n\u003ch2\u003e確認\u003c/h2\u003e\n\n\u003cp\u003eコード全体を掲載します．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;boost/spirit/home/x3.hpp\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;functional\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e x3 = boost::spirit::x3;\n\n\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e grammar {\n\n  \u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e detail {\n\n    decltype(\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e) assign()\n    {\n      \u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e x3::_attr;\n      \u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e x3::_val;\n      \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e [](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; ctx) { _val(ctx) = _attr(ctx); };\n    }\n\n    \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e F\u0026gt;\n    decltype(\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e) assign_f(F\u0026amp;\u0026amp; func)\n    {\n      \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e [func](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; ctx) { _val(ctx) = func(_attr(ctx)); };\n    }\n\n    \u003cspan class=\"synType\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"synType\"\u003etypename\u003c/span\u003e Op\u0026gt;\n    decltype(\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e) calc_op(Op\u0026amp;\u0026amp; op)\n    {\n      \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e [op](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp;\u0026amp; ctx) { x3::_val(ctx) = op(x3::_val(ctx), x3::_attr(ctx)); };\n    }\n\n  } \u003cspan class=\"synComment\"\u003e// namespace detail\u003c/span\u003e\n\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e primary;\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e neg_expr;\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e mul_expr;\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e add_expr;\n  \u003cspan class=\"synType\"\u003estruct\u003c/span\u003e expression;\n\n  x3::rule\u0026lt;primary, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e primary;\n  x3::rule\u0026lt;neg_expr, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e neg_expr;\n  x3::rule\u0026lt;mul_expr, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e mul_expr;\n  x3::rule\u0026lt;add_expr, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e add_expr;\n  x3::rule\u0026lt;expression, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e expression;\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e primary_def =\n      x3::int_[detail::assign()]\n    | (\u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e \u0026gt; expression \u0026gt; \u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e)[detail::assign()]\n    ;\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e neg_expr_def =\n      primary[detail::assign()]\n    | (\u003cspan class=\"synConstant\"\u003e\u0026quot;-\u0026quot;\u003c/span\u003e \u0026gt; primary)[detail::assign_f(std::negate\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;\u003cspan class=\"synError\"\u003e{\u003c/span\u003e})]\n    ;\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e mul_expr_def =\n      neg_expr[detail::assign()]\n      \u0026gt;\u0026gt; *(\n          (\u003cspan class=\"synConstant\"\u003e\u0026quot;*\u0026quot;\u003c/span\u003e \u0026gt;\u0026gt; neg_expr)[detail::calc_op(std::multiplies\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;\u003cspan class=\"synError\"\u003e{\u003c/span\u003e})]\n        | (\u003cspan class=\"synConstant\"\u003e\u0026quot;/\u0026quot;\u003c/span\u003e \u0026gt;\u0026gt; neg_expr)[detail::calc_op(std::divides\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;\u003cspan class=\"synError\"\u003e{\u003c/span\u003e})]\n      )\n    ;\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e add_expr_def =\n      mul_expr[detail::assign()]\n      \u0026gt;\u0026gt; *(\n          (\u003cspan class=\"synConstant\"\u003e\u0026quot;+\u0026quot;\u003c/span\u003e \u0026gt; mul_expr)[detail::calc_op(std::plus\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;\u003cspan class=\"synError\"\u003e{\u003c/span\u003e})]\n        | (\u003cspan class=\"synConstant\"\u003e\u0026quot;-\u0026quot;\u003c/span\u003e \u0026gt; mul_expr)[detail::calc_op(std::minus\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;\u003cspan class=\"synError\"\u003e{\u003c/span\u003e})]\n      )\n    ;\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e expression_def =\n      add_expr[detail::assign()]\n    ;\n\n  BOOST_SPIRIT_DEFINE(\n      primary,\n      neg_expr,\n      mul_expr,\n      add_expr,\n      expression\n      );\n\n} \u003cspan class=\"synComment\"\u003e// namespace grammar\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e grammar::expression;\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main()\n{\n  std::string str;\n  std::getline(std::cin, str);\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e first(std::cbegin(str));\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e last(std::cend(str));\n\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e result;\n  \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::phrase_parse(first, last, expression, x3::ascii::space, result);\n\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (!success || first != last) {\n    std::cerr \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse failed.\u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; std::endl;\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e;\n  }\n\n  std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parsed: \u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl;\n  \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n}\n\u003c/pre\u003e\n\n\u003cp\u003e実行してみます．\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e$ clang++ -std=c++14 main.cpp\n$ ./a.out\n1 + 2 * 3\nParsed: 7\n$ ./a.out\n(1 + 2) * 3\nParsed: 9\u003c/pre\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\"\u003e演算子\u003c/a\u003eの優先順位が正しく解決できていることが確認出来ます．\u003c/p\u003e\n\n\u003ch2\u003eまとめ\u003c/h2\u003e\n\n\u003cp\u003e今回は，セマンティックアクションで計算自体を行ってしまいましたが，普通は抽象\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%CC%DA\"\u003e構文木\u003c/a\u003e(AST) に変換するためにセマンティックアクションを使うのが正道だと思います．\u003cbr/\u003e\n\u003ccode\u003eX3\u003c/code\u003e は AST のための色々を提供してくれていますが，自前で作った AST でもちょっと苦労はするかもしれませんが変換できるはずなので，時間があれば，自前 AST に変換してから実行する電卓も作ってみたいと思います．\u003c/p\u003e\n\n\u003cp\u003eまた，AST に変換して計算する場合，AST に位置情報を付与することで，エラーレポートが便利になったりするはずです( 0 除算のエラーを通知する際，どの部分でのエラーなのかを吐いてくれればうれしいですよね).\u003cbr/\u003e\nパース失敗時にもどこで失敗したのかをレポートしてくれたほうが便利です．\u003cbr/\u003e\n\u003ccode\u003eX3\u003c/code\u003e で \u003ccode\u003eon_error\u003c/code\u003e, \u003ccode\u003eon_success\u003c/code\u003e を使ってこれらを実装してみようと考えています．\u003c/p\u003e\n\n\u003cp\u003e今回のコードでは \u003ccode\u003edecltype(auto)\u003c/code\u003e など，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e14 の機能を使っています．\u003ccode\u003eX3\u003c/code\u003e は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e14 前提のライブラリなので，迷いなくこういった機能を使用できて幸せデスね．\u003c/p\u003e\n\n---\n\n---\n","slug":"Boost.Spirit.X3_で簡易電卓を実装_1","title":"Boost.Spirit.X3 で簡易電卓を実装 1","timestamp":1450448825000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Boost.Spirit.X3 の練習 2\"\ndate: 2015-12-17T14:20:03.000Z\ntags: []\n---\n\n\u003cp\u003e\u003ca href=\"http://agtn.hatenablog.com/entry/2015/12/17/190505\"\u003eBoost.Spirit.X3 の練習1 - プログラミングのメモ帳➚\u003c/a\u003eに引き続き，\u003ccode\u003eBoost.Spirit.X3\u003c/code\u003e のお勉強メモです．\u003c/p\u003e\n\n\u003ch2\u003eセマンティックアクション\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eにはセマンティックアクションというのがつきものです．\u003cbr/\u003e\n\u003ccode\u003eyacc\u003c/code\u003e や \u003ccode\u003eparsec\u003c/code\u003e など有名な\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eのための\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C4%A1%BC%A5%EB\"\u003eツール\u003c/a\u003e/ライブラリにもありますね．\u003c/p\u003e\n\n\u003cp\u003eセマンティックアクションとは，定義したパーサのルールにマッチした時に実行するプログラムのことです．\u003cbr/\u003e\nといってもわかりにくいと思うので，コードを出してしまいます．\u003c/p\u003e\n\n\u003cp\u003e以下のコードは，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\"\u003e浮動小数点数\u003c/a\u003eにマッチしてその値を標準出力に出力するパーサの定義です．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;boost/spirit/home/x3.hpp\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\n\n\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e x3 = boost::spirit::x3;\n\n\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e print_action =\n  [](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp; ctx) { std::cout \u0026lt;\u0026lt; _attr(ctx) \u0026lt;\u0026lt; std::endl; };\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main()\n{\n\n  std::string src{ \u003cspan class=\"synConstant\"\u003e\u0026quot;( 123.4 )\u0026quot;\u003c/span\u003e };\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e first = std::cbegin(src);\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e last = std::cend(src);\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e parser = (\u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e \u0026gt;\u0026gt; x3::double_ \u0026gt;\u0026gt; \u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e)[print_action];\n\n  \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::phrase_parse(first, last, parser, x3::ascii::space);\n\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (!success || first != last) {\n    \u003cspan class=\"synComment\"\u003e// parse failed\u003c/span\u003e\n    std::cerr \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse failed.\u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e$ clang++ -std=c++14 main.cpp\n$ ./a.out\n123.4\u003c/pre\u003e\n\n\u003cp\u003eパーサの結果を受け取らないようにしています．\u003ccode\u003eparser\u003c/code\u003e は \u003ccode\u003edouble\u003c/code\u003e を返しますが，その結果は無視しています．\u003cbr/\u003e\nそして，セマンティックアクション部分で，出力を行っています．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eauto const print_action\u003c/code\u003e の定義が，セマンティックアクションです．\u003cbr/\u003e\n\u003ccode\u003eC++14\u003c/code\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eラムダの機能をつかっています．\u003cbr/\u003e\nセマンティックアクションは，\u003ccode\u003eX3\u003c/code\u003e パーサのコンテキストを第一引数に取ります．\u003cbr/\u003e\nその具体的な型を気にしてはいけません．\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eラムダで受け取ります．\u003cbr/\u003e\n\u003ccode\u003e_attr(ctx)\u003c/code\u003e で，現在マッチしているパーサの attribute にアクセス出来ます．\n\u003ccode\u003e\"(\" \u0026gt;\u0026gt; x3::double_ \u0026gt;\u0026gt; \")\"\u003c/code\u003e の attribute は \u003ccode\u003edouble\u003c/code\u003e 型なので，\u003ccode\u003e_attr(ctx)\u003c/code\u003e はマッチした\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\"\u003e浮動小数点数\u003c/a\u003eになります．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eQi\u003c/code\u003e のセマンティックアクションは，関数オブジェクトなどを単純に使用することが出来ませんでした(?) が，\u003ccode\u003eX3\u003c/code\u003e ではセマンティックアクションはただの関数オブジェクトです．\u003cbr/\u003e\nパーサのコンテキストを引数に受け，結果や attribute への参照をそのまま関数内で扱えるようになったため，セマンティックアクションの記述がより \u003cem\u003e普通\u003c/em\u003e の関数っぽくかけるようになったと感じました．\u003c/p\u003e\n\n\u003ch2\u003e名前付きパーサの定義\u003c/h2\u003e\n\n\u003cp\u003e今までのサンプルでは，シンプルなパーサを１つ定義しているだけでした．\u003cbr/\u003e\n一方現実には，パーサが\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003e的になることは珍しくありません．\u003c/p\u003e\n\n\u003cp\u003eそこで，パーサの名前を前方宣言し，あとから定義を記述するようなパーサの書き方を使用します．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;boost/spirit/home/x3.hpp\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\n\n\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e x3 = boost::spirit::x3;\n\n\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e detail {\n\n  x3::rule\u0026lt;\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e constant, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e constant;\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e constant_def = x3::int_;\n\n  BOOST_SPIRIT_DEFINE(constant);\n\n} \u003cspan class=\"synComment\"\u003e// namespace detail\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e detail::constant;\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main()\n{\n\n  std::string src{ \u003cspan class=\"synConstant\"\u003e\u0026quot;123\u0026quot;\u003c/span\u003e };\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e first = std::cbegin(src);\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e last = std::cend(src);\n\n\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e result;\n  \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::phrase_parse(first, last, constant, x3::ascii::space, result);\n\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (!success || first != last) {\n    \u003cspan class=\"synComment\"\u003e// parse failed\u003c/span\u003e\n    std::cerr \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse failed.\u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; std::endl;\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse: \u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003enamespace detail\u003c/code\u003e の中身がパーサの定義になっています．\n(\u003ccode\u003enamespace\u003c/code\u003e を分けたのは，\u003ccode\u003econstant\u003c/code\u003e そのものの名前以外を隠すためです．)\n\u003ccode\u003eX3\u003c/code\u003e では，\u003ccode\u003ex3::rule\u0026lt;class, result type\u0026gt;\u003c/code\u003e というテンプレートクラスがパーサルールになります．\u003ccode\u003eclass\u003c/code\u003e 部分は今は前方宣言だけで構わないようです．(後で \u003ccode\u003eon_error\u003c/code\u003e とかの属性を付与する際に必要になる？)\u003cbr/\u003e\n\u003ccode\u003eresult type\u003c/code\u003e はそのパーサが返すべき値になります．\u003c/p\u003e\n\n\u003cp\u003eつまり，\u003ccode\u003ex3::rule\u0026lt;class constant, int\u0026gt; const constant;\u003c/code\u003e は，\u003ccode\u003eint\u003c/code\u003e 型の値を返す，特別な属性を持たない \u003ccode\u003econstant\u003c/code\u003e という名前のパーサを宣言したことになります．\u003c/p\u003e\n\n\u003cp\u003eそして，その実装は \u003ccode\u003econstant_def\u003c/code\u003e という名前で与えられます．\u003cbr/\u003e\n\u003ccode\u003ehogehoge_def\u003c/code\u003e という名前にする規約のようです．(\u003ccode\u003eBOOST_SPIRIT_DEFINE\u003c/code\u003e 部分を書き換えれば違う名前にしても大丈夫のようだが，素直に従っておけば良さそう)\u003cbr/\u003e\n今回はシンプルに \u003ccode\u003ex3::int_\u003c/code\u003e そのものとしています．\u003c/p\u003e\n\n\u003cp\u003e最後に \u003ccode\u003eBOOST_SPIRIT_DEFINE\u003c/code\u003e することで，\u003ccode\u003econstant\u003c/code\u003e というパーサの宣言と，\u003ccode\u003econstant_def\u003c/code\u003e という実装をひも付けます．\u003c/p\u003e\n\n\u003cp\u003e使い方は今までと全く同じです．\u003c/p\u003e\n\n\u003ch2\u003e使ってみる\u003c/h2\u003e\n\n\u003cp\u003eセマンティックアクションと名前付きパーサの両方を使って，整数を受け取って2倍にした値を返すパーサを書いてみます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;boost/spirit/home/x3.hpp\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\n\n\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e x3 = boost::spirit::x3;\n\n\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e detail {\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e twice = [](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp; ctx) { _val(ctx) = _attr(ctx) * \u003cspan class=\"synConstant\"\u003e2\u003c/span\u003e; };\n\n  x3::rule\u0026lt;\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e constant, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e constant;\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e constant_def = x3::int_[twice];\n\n  BOOST_SPIRIT_DEFINE(constant);\n\n} \u003cspan class=\"synComment\"\u003e// namespace detail\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e detail::constant;\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main()\n{\n\n  std::string src{ \u003cspan class=\"synConstant\"\u003e\u0026quot;123\u0026quot;\u003c/span\u003e };\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e first = std::cbegin(src);\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e last = std::cend(src);\n\n\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e result;\n  \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::phrase_parse(first, last, constant, x3::ascii::space, result);\n\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (!success || first != last) {\n    \u003cspan class=\"synComment\"\u003e// parse failed\u003c/span\u003e\n    std::cerr \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse failed.\u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; std::endl;\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse: \u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eセマンティックアクション内では，パーサの \u003ccode\u003eresult type\u003c/code\u003e に \u003ccode\u003e_val(ctx)\u003c/code\u003e でアクセス出来ます．\n\u003ccode\u003e_val(ctx)\u003c/code\u003e は参照を返すので，ここに適当な値を代入してやれば，パーサの返り値にすることが出来ます．\u003cbr/\u003e\n\u003ccode\u003e_attr(ctx)\u003c/code\u003e は先程と同じです．\u003ccode\u003ex3::int_\u003c/code\u003e の attribute は \u003ccode\u003eint\u003c/code\u003e です．\u003c/p\u003e\n\n\u003cp\u003e実行してみると，\u003ccode\u003eParse: 246\u003c/code\u003e が返るはずです．\u003c/p\u003e\n\n\u003ch2\u003e一旦まとめ\u003c/h2\u003e\n\n\u003cp\u003eセマンティックアクションと名前付きパーサの宣言と定義をまとめました．\u003cbr/\u003e\n\u003ccode\u003eQi\u003c/code\u003e のころより，セマンティックアクションはかなり書きやすくなっている気がします．\u003cbr/\u003e\n今回の例では，\u003ccode\u003e_attr(ctx)\u003c/code\u003e が単純な値だったのでわかりやすいですが，\u003ccode\u003ex3::int_ \u0026gt;\u0026gt; x3::double_\u003c/code\u003e の \u003ccode\u003e_attr(ctx)\u003c/code\u003e は \u003ccode\u003eBoost.Fusion\u003c/code\u003e が登場したりしてちょっとややこしそうです．\u003c/p\u003e\n\n\u003cp\u003eまた，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003e的パーサを定義できるようにパーサの宣言をまとめたのに，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003e的パーサを書いていませんが，これは別記事に電卓でも作ってまとめたいと思います．\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e\u003ca href=\"http://agtn.hatenablog.com/entry/2015/12/17/190505\"\u003eBoost.Spirit.X3 の練習1 - プログラミングのメモ帳➚\u003c/a\u003eに引き続き，\u003ccode\u003eBoost.Spirit.X3\u003c/code\u003e のお勉強メモです．\u003c/p\u003e\n\n\u003ch2\u003eセマンティックアクション\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eにはセマンティックアクションというのがつきものです．\u003cbr/\u003e\n\u003ccode\u003eyacc\u003c/code\u003e や \u003ccode\u003eparsec\u003c/code\u003e など有名な\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\"\u003e構文解析\u003c/a\u003eのための\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C4%A1%BC%A5%EB\"\u003eツール\u003c/a\u003e/ライブラリにもありますね．\u003c/p\u003e\n\n\u003cp\u003eセマンティックアクションとは，定義したパーサのルールにマッチした時に実行するプログラムのことです．\u003cbr/\u003e\nといってもわかりにくいと思うので，コードを出してしまいます．\u003c/p\u003e\n\n\u003cp\u003e以下のコードは，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\"\u003e浮動小数点数\u003c/a\u003eにマッチしてその値を標準出力に出力するパーサの定義です．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;boost/spirit/home/x3.hpp\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\n\n\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e x3 = boost::spirit::x3;\n\n\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e print_action =\n  [](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp; ctx) { std::cout \u0026lt;\u0026lt; _attr(ctx) \u0026lt;\u0026lt; std::endl; };\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main()\n{\n\n  std::string src{ \u003cspan class=\"synConstant\"\u003e\u0026quot;( 123.4 )\u0026quot;\u003c/span\u003e };\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e first = std::cbegin(src);\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e last = std::cend(src);\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e parser = (\u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e \u0026gt;\u0026gt; x3::double_ \u0026gt;\u0026gt; \u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e)[print_action];\n\n  \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::phrase_parse(first, last, parser, x3::ascii::space);\n\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (!success || first != last) {\n    \u003cspan class=\"synComment\"\u003e// parse failed\u003c/span\u003e\n    std::cerr \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse failed.\u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e$ clang++ -std=c++14 main.cpp\n$ ./a.out\n123.4\u003c/pre\u003e\n\n\u003cp\u003eパーサの結果を受け取らないようにしています．\u003ccode\u003eparser\u003c/code\u003e は \u003ccode\u003edouble\u003c/code\u003e を返しますが，その結果は無視しています．\u003cbr/\u003e\nそして，セマンティックアクション部分で，出力を行っています．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eauto const print_action\u003c/code\u003e の定義が，セマンティックアクションです．\u003cbr/\u003e\n\u003ccode\u003eC++14\u003c/code\u003e の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eラムダの機能をつかっています．\u003cbr/\u003e\nセマンティックアクションは，\u003ccode\u003eX3\u003c/code\u003e パーサのコンテキストを第一引数に取ります．\u003cbr/\u003e\nその具体的な型を気にしてはいけません．\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eラムダで受け取ります．\u003cbr/\u003e\n\u003ccode\u003e_attr(ctx)\u003c/code\u003e で，現在マッチしているパーサの attribute にアクセス出来ます．\n\u003ccode\u003e\"(\" \u0026gt;\u0026gt; x3::double_ \u0026gt;\u0026gt; \")\"\u003c/code\u003e の attribute は \u003ccode\u003edouble\u003c/code\u003e 型なので，\u003ccode\u003e_attr(ctx)\u003c/code\u003e はマッチした\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\"\u003e浮動小数点数\u003c/a\u003eになります．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eQi\u003c/code\u003e のセマンティックアクションは，関数オブジェクトなどを単純に使用することが出来ませんでした(?) が，\u003ccode\u003eX3\u003c/code\u003e ではセマンティックアクションはただの関数オブジェクトです．\u003cbr/\u003e\nパーサのコンテキストを引数に受け，結果や attribute への参照をそのまま関数内で扱えるようになったため，セマンティックアクションの記述がより \u003cem\u003e普通\u003c/em\u003e の関数っぽくかけるようになったと感じました．\u003c/p\u003e\n\n\u003ch2\u003e名前付きパーサの定義\u003c/h2\u003e\n\n\u003cp\u003e今までのサンプルでは，シンプルなパーサを１つ定義しているだけでした．\u003cbr/\u003e\n一方現実には，パーサが\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003e的になることは珍しくありません．\u003c/p\u003e\n\n\u003cp\u003eそこで，パーサの名前を前方宣言し，あとから定義を記述するようなパーサの書き方を使用します．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;boost/spirit/home/x3.hpp\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\n\n\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e x3 = boost::spirit::x3;\n\n\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e detail {\n\n  x3::rule\u0026lt;\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e constant, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e constant;\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e constant_def = x3::int_;\n\n  BOOST_SPIRIT_DEFINE(constant);\n\n} \u003cspan class=\"synComment\"\u003e// namespace detail\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e detail::constant;\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main()\n{\n\n  std::string src{ \u003cspan class=\"synConstant\"\u003e\u0026quot;123\u0026quot;\u003c/span\u003e };\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e first = std::cbegin(src);\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e last = std::cend(src);\n\n\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e result;\n  \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::phrase_parse(first, last, constant, x3::ascii::space, result);\n\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (!success || first != last) {\n    \u003cspan class=\"synComment\"\u003e// parse failed\u003c/span\u003e\n    std::cerr \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse failed.\u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; std::endl;\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse: \u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003enamespace detail\u003c/code\u003e の中身がパーサの定義になっています．\n(\u003ccode\u003enamespace\u003c/code\u003e を分けたのは，\u003ccode\u003econstant\u003c/code\u003e そのものの名前以外を隠すためです．)\n\u003ccode\u003eX3\u003c/code\u003e では，\u003ccode\u003ex3::rule\u0026lt;class, result type\u0026gt;\u003c/code\u003e というテンプレートクラスがパーサルールになります．\u003ccode\u003eclass\u003c/code\u003e 部分は今は前方宣言だけで構わないようです．(後で \u003ccode\u003eon_error\u003c/code\u003e とかの属性を付与する際に必要になる？)\u003cbr/\u003e\n\u003ccode\u003eresult type\u003c/code\u003e はそのパーサが返すべき値になります．\u003c/p\u003e\n\n\u003cp\u003eつまり，\u003ccode\u003ex3::rule\u0026lt;class constant, int\u0026gt; const constant;\u003c/code\u003e は，\u003ccode\u003eint\u003c/code\u003e 型の値を返す，特別な属性を持たない \u003ccode\u003econstant\u003c/code\u003e という名前のパーサを宣言したことになります．\u003c/p\u003e\n\n\u003cp\u003eそして，その実装は \u003ccode\u003econstant_def\u003c/code\u003e という名前で与えられます．\u003cbr/\u003e\n\u003ccode\u003ehogehoge_def\u003c/code\u003e という名前にする規約のようです．(\u003ccode\u003eBOOST_SPIRIT_DEFINE\u003c/code\u003e 部分を書き換えれば違う名前にしても大丈夫のようだが，素直に従っておけば良さそう)\u003cbr/\u003e\n今回はシンプルに \u003ccode\u003ex3::int_\u003c/code\u003e そのものとしています．\u003c/p\u003e\n\n\u003cp\u003e最後に \u003ccode\u003eBOOST_SPIRIT_DEFINE\u003c/code\u003e することで，\u003ccode\u003econstant\u003c/code\u003e というパーサの宣言と，\u003ccode\u003econstant_def\u003c/code\u003e という実装をひも付けます．\u003c/p\u003e\n\n\u003cp\u003e使い方は今までと全く同じです．\u003c/p\u003e\n\n\u003ch2\u003e使ってみる\u003c/h2\u003e\n\n\u003cp\u003eセマンティックアクションと名前付きパーサの両方を使って，整数を受け取って2倍にした値を返すパーサを書いてみます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;boost/spirit/home/x3.hpp\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\n\n\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e x3 = boost::spirit::x3;\n\n\u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e detail {\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e twice = [](\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e\u0026amp; ctx) { _val(ctx) = _attr(ctx) * \u003cspan class=\"synConstant\"\u003e2\u003c/span\u003e; };\n\n  x3::rule\u0026lt;\u003cspan class=\"synType\"\u003eclass\u003c/span\u003e constant, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u003cspan class=\"synType\"\u003econst\u003c/span\u003e constant;\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e constant_def = x3::int_[twice];\n\n  BOOST_SPIRIT_DEFINE(constant);\n\n} \u003cspan class=\"synComment\"\u003e// namespace detail\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e detail::constant;\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main()\n{\n\n  std::string src{ \u003cspan class=\"synConstant\"\u003e\u0026quot;123\u0026quot;\u003c/span\u003e };\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e first = std::cbegin(src);\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e last = std::cend(src);\n\n\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e result;\n  \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::phrase_parse(first, last, constant, x3::ascii::space, result);\n\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (!success || first != last) {\n    \u003cspan class=\"synComment\"\u003e// parse failed\u003c/span\u003e\n    std::cerr \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse failed.\u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; std::endl;\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse: \u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eセマンティックアクション内では，パーサの \u003ccode\u003eresult type\u003c/code\u003e に \u003ccode\u003e_val(ctx)\u003c/code\u003e でアクセス出来ます．\n\u003ccode\u003e_val(ctx)\u003c/code\u003e は参照を返すので，ここに適当な値を代入してやれば，パーサの返り値にすることが出来ます．\u003cbr/\u003e\n\u003ccode\u003e_attr(ctx)\u003c/code\u003e は先程と同じです．\u003ccode\u003ex3::int_\u003c/code\u003e の attribute は \u003ccode\u003eint\u003c/code\u003e です．\u003c/p\u003e\n\n\u003cp\u003e実行してみると，\u003ccode\u003eParse: 246\u003c/code\u003e が返るはずです．\u003c/p\u003e\n\n\u003ch2\u003e一旦まとめ\u003c/h2\u003e\n\n\u003cp\u003eセマンティックアクションと名前付きパーサの宣言と定義をまとめました．\u003cbr/\u003e\n\u003ccode\u003eQi\u003c/code\u003e のころより，セマンティックアクションはかなり書きやすくなっている気がします．\u003cbr/\u003e\n今回の例では，\u003ccode\u003e_attr(ctx)\u003c/code\u003e が単純な値だったのでわかりやすいですが，\u003ccode\u003ex3::int_ \u0026gt;\u0026gt; x3::double_\u003c/code\u003e の \u003ccode\u003e_attr(ctx)\u003c/code\u003e は \u003ccode\u003eBoost.Fusion\u003c/code\u003e が登場したりしてちょっとややこしそうです．\u003c/p\u003e\n\n\u003cp\u003eまた，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003e的パーサを定義できるようにパーサの宣言をまとめたのに，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\"\u003e再帰\u003c/a\u003e的パーサを書いていませんが，これは別記事に電卓でも作ってまとめたいと思います．\u003c/p\u003e\n\n---\n\n---\n","slug":"Boost.Spirit.X3_の練習_2","title":"Boost.Spirit.X3 の練習 2","timestamp":1450362003000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Boost.Spirit.X3 の練習1\"\ndate: 2015-12-17T10:05:05.000Z\ntags: []\n---\n\n\u003ch1\u003eBoost.Spirit.X3 の練習1\u003c/h1\u003e\n\n\u003cp\u003e\u003ca href=\"http://ciere.com/cppnow15/x3_docs/\"\u003eBoost.Spirit.X3\u003c/a\u003e という \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のための パーサ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eライブラリを使ってみています．\u003cbr/\u003e\n\u003ccode\u003eBoost.Spirit\u003c/code\u003e というと， \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の黒魔術の塊みたいなイメージがあります． ちなみに \u003ccode\u003eBoost.Spirit.Qi\u003c/code\u003e が安定版のパーサ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eライブラリで， \u003ccode\u003eX3\u003c/code\u003e はまだ開発中のようなので注意してください．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eX3\u003c/code\u003e は \u003ccode\u003eQi\u003c/code\u003e と異なり，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e14 以降の規格を前提にしています．そのため，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eラムダなどを用いてよりわかりやすいプログラムが書けるようになっているようです．\u003cbr/\u003e\n\u003ccode\u003eQi\u003c/code\u003e は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時間が爆発していたのですが， \u003ccode\u003eX3\u003c/code\u003e だと多少マシのようです．\u003c/p\u003e\n\n\u003ch2\u003e第一歩\u003c/h2\u003e\n\n\u003cp\u003eまずは猛烈にシンプルなパーサを使ってみましょう．\n\u003ccode\u003eX3\u003c/code\u003e も \u003ccode\u003eQi\u003c/code\u003e 同様に定義済みのパーサがあるので，それを単純に使用するだけのサンプルです．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;boost/spirit/home/x3.hpp\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main()\n{\n  \u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e x3 = boost::spirit::x3;\n\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e result;\n  std::string src{ \u003cspan class=\"synConstant\"\u003e\u0026quot;123\u0026quot;\u003c/span\u003e };\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e first = std::cbegin(src);\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e last = std::cend(src);\n  \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::parse(first, last, x3::int_, result);\n\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (!success || first != last) {\n    \u003cspan class=\"synComment\"\u003e// parse failed\u003c/span\u003e\n    std::cerr \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse failed.\u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; std::endl;\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse: \u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\n\u003ch3\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e \u0026amp; 実行\u003c/h3\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e$ clang++ -std=c++14 int_parser.cpp\n$ ./a.out\nParse: 123\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eBoost.Spirit.X3\u003c/code\u003e を使用する場合は, \u003ccode\u003e#include \u0026lt;boost/spirit/home/x3.hpp\u0026gt;\u003c/code\u003e とすればオッケーです．(これは使用していない機能のヘッダも読み込んでしまっているので，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eは重くなります… が，これ以降使う機能を増やす度にヘッダを書き換えるのは面倒ですし，\u003ccode\u003eX3\u003c/code\u003e の機能の多くを使用するプログラムの場合は，大差ないと思います．)\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%BE%C1%B0%B6%F5%B4%D6\"\u003e名前空間\u003c/a\u003eは \u003ccode\u003eboost::spirit::x3\u003c/code\u003e です．頻繁に出てくるので \u003ccode\u003enamespace x3\u003c/code\u003e で\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eしました．\u003c/p\u003e\n\n\u003cp\u003e実際にパースしている部分は,\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::parse(first, last, x3::int_, result);\n\u003c/pre\u003e\n\n\u003cp\u003eの部分です．\u003cbr/\u003e\n\u003ccode\u003ex3::parse\u003c/code\u003e は，第一引数にソース文字列の先頭\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%C6%A5%EC%A1%BC%A5%BF\"\u003eイテレータ\u003c/a\u003e，第二引数にソース文字列の終端\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%C6%A5%EC%A1%BC%A5%BF\"\u003eイテレータ\u003c/a\u003eをとります．\u003cbr/\u003e\n第三引数が，パーサの定義です．ここでは， \u003ccode\u003ex3::int_\u003c/code\u003e という定義済みパーサを使用しました． これは, 整数を表す文字列を受けて，それを整数に変換するパーサです． たとえば \u003ccode\u003e\"1\"\u003c/code\u003e を \u003ccode\u003e1\u003c/code\u003e に変換します．整数以外にあたった場合はマッチせず，パースに失敗します．(\u003ccode\u003ex3::parse\u003c/code\u003e の返り値が \u003ccode\u003efalse\u003c/code\u003e になる)\n第四引数は，指定したパーサの返す値です．ここちょっと説明が難しいですね．\u003cbr/\u003e\n\u003ccode\u003ex3::int_\u003c/code\u003e は \u003ccode\u003eint\u003c/code\u003e 型の値を返すパーサです(これを \u003ccode\u003ex3::int_\u003c/code\u003e の attribute が \u003ccode\u003eint\u003c/code\u003e 型であると表現している？).\u003cbr/\u003e\nそこで，\u003ccode\u003ex3::int_\u003c/code\u003e の返す値を格納する変数として，\u003ccode\u003eint result\u003c/code\u003e の参照を渡しているという感じです．\u003cbr/\u003e\nパースが成功していれば，\u003ccode\u003eresult\u003c/code\u003e の中身は \u003ccode\u003ex3::int_\u003c/code\u003e の返り値になっているはずです．\u003c/p\u003e\n\n\u003cp\u003eパースの成否判定は \u003ccode\u003esuccess\u003c/code\u003e と \u003ccode\u003efirst == last\u003c/code\u003e で行います．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (!success || first != last) {\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003esuccess\u003c/code\u003e はそもそもパーサにソースがマッチしなかった場合, \u003ccode\u003efalse\u003c/code\u003e になります．\u003cbr/\u003e\nまた，\u003ccode\u003e\"123abc\"\u003c/code\u003e に \u003ccode\u003ex3::int_\u003c/code\u003e をマッチさせると，\u003ccode\u003e\"123\"\u003c/code\u003e だけが消費され，\u003ccode\u003e\"abc\"\u003c/code\u003e が残ります．この時，\u003ccode\u003efirst\u003c/code\u003e は \u003ccode\u003e\"a\"\u003c/code\u003e の位置まで進んでいます．\nもしソースが先頭から終端まで，パーサにマッチしていたならば，\u003ccode\u003efirst == last\u003c/code\u003e となるはずです．\u003c/p\u003e\n\n\u003cp\u003eというわけでこのプログラムは，\u003ccode\u003ex3::int_\u003c/code\u003e に \u003ccode\u003e\"123\"\u003c/code\u003e をパースさせるプログラムでした．結果，きちんと整数の \u003ccode\u003e123\u003c/code\u003e が取得できていることがわかります．\u003c/p\u003e\n\n\u003ch2\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode\u003eBoost.Spirit.X3\u003c/code\u003e はパーサ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eライブラリです．個々のパーサを組み合わせてみましょう．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e\" ( 1234.5)\"\u003c/code\u003e とか \u003ccode\u003e\"(67.8 )  \"\u003c/code\u003e にマッチして，\u003ccode\u003edouble\u003c/code\u003e を返すようなパーサを定義してみます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e parser = x3::lit(\u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e) \u0026gt;\u0026gt; x3::double_ \u0026gt;\u0026gt; x3::lit(\u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e);\n\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::phrase_parse(first, last, parser, x3::ascii::space, result);\n\u003c/pre\u003e\n\n\u003cp\u003eまずは \u003ccode\u003eparser\u003c/code\u003e の定義です．\n\u003ccode\u003ex3::lit\u003c/code\u003e は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%C6%A5%E9%A5%EB\"\u003eリテラル\u003c/a\u003eを表します．引数にとった文字列にマッチし，何も返さないパーサです．\u003ccode\u003ex3::lit(\"(\")\u003c/code\u003e は \u003ccode\u003e(\u003c/code\u003e にマッチし，何も返さないパーサということになります．\u003cbr/\u003e\n\u003ccode\u003ex3::double_\u003c/code\u003e は \u003ccode\u003ex3::int_\u003c/code\u003e と同じく，定義済みパーサで，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\"\u003e浮動小数点数\u003c/a\u003eにマッチしその値を返します．\u003c/p\u003e\n\n\u003cp\u003eそして重要なのが，\u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e です．\u003cbr/\u003e\nこれは，「左辺にマッチした後，右辺にマッチするパーサ」を作り出す\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eです．\u003cbr/\u003e\nここでは，\u003ccode\u003ex3::lit(\"(\") \u0026gt;\u0026gt; x3::double_\u003c/code\u003e ですから，\u003ccode\u003e(\u003c/code\u003e にマッチした後，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\"\u003e浮動小数点数\u003c/a\u003eにマッチするパーサ，ということになります.\u003c/p\u003e\n\n\u003cp\u003e通常，\u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e は左辺の返す値と右辺の返す値のタプルを返します．(\u003ccode\u003ex3::int_ \u0026gt;\u0026gt; x3::double_\u003c/code\u003e ならば，\u003ccode\u003eint\u003c/code\u003e と \u003ccode\u003edouble\u003c/code\u003e のタプル)\u003cbr/\u003e\nしかし，左辺右辺どちらか一方が値を返さない(正確には \u003ccode\u003ex3::unused_type\u003c/code\u003e を返す) 場合には，もう一方の値だけを返します．\u003cbr/\u003e\nつまり，\u003ccode\u003ex3::lit(\"(\") \u0026gt;\u0026gt; x3::double_\u003c/code\u003e は \u003ccode\u003edouble\u003c/code\u003e だけを返し，\u003ccode\u003e\u0026gt;\u0026gt; x3::lit(\")\")\u003c/code\u003e と続けても \u003ccode\u003edouble\u003c/code\u003e だけが返ります．\u003c/p\u003e\n\n\u003cp\u003e次に，空白の読み飛ばしについてです．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::phrase_parse(first, last, parser, x3::ascii::space, result);\n\u003c/pre\u003e\n\n\u003cp\u003eひとつ目の例と異なり，\u003ccode\u003ex3::parse\u003c/code\u003e ではなく \u003ccode\u003ex3::phrase_parse\u003c/code\u003e を使っています．\u003cbr/\u003e\nこちらは，\u003ccode\u003eattribute\u003c/code\u003e を示す最後の引数の前に，スキップパーサを取ります．\nスキップパーサとは，文字通り，スキップしてほしい文字列にマッチするパーサです．\u003cbr/\u003e\n\u003ccode\u003ex3::ascii::space\u003c/code\u003e は定義済みのパーサで，スペース，改行文字，タブにマッチします．したがって，これらの文字はスキップされます．\nスキップ判定のタイミングは \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e の部分です．つまり，\"12    3\" は \u003ccode\u003ex3::int_\u003c/code\u003e でパースすると, \u003ccode\u003e12\u003c/code\u003e までしかマッチしません．\u003ccode\u003ex3::int_ \u0026gt;\u0026gt; x3::int_\u003c/code\u003e とすることで，スペースがスキップされます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;boost/spirit/home/x3.hpp\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main()\n{\n  \u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e x3 = boost::spirit::x3;\n\n  std::string src{ \u003cspan class=\"synConstant\"\u003e\u0026quot;( 123.4 )\u0026quot;\u003c/span\u003e };\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e first = std::cbegin(src);\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e last = std::cend(src);\n  \u003cspan class=\"synType\"\u003edouble\u003c/span\u003e result;\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e parser = x3::lit(\u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e) \u0026gt;\u0026gt; x3::double_ \u0026gt;\u0026gt; x3::lit(\u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e);\n  \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::phrase_parse(first, last, parser, x3::ascii::space, result);\n\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (!success || first != last) {\n    \u003cspan class=\"synComment\"\u003e// parse failed\u003c/span\u003e\n    std::cerr \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse failed.\u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; std::endl;\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse: \u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eちなみに，\u003ccode\u003ex3::lit(\"(\") \u0026gt;\u0026gt; x3::double_ \u0026gt;\u0026gt; x3::lit(\")\")\u003c/code\u003e の部分ですが，\u003ccode\u003eoperator\u0026lt;\u0026lt;\u003c/code\u003e の引数の内，片方がパーサであれば，\u003ccode\u003echar const*\u003c/code\u003e から暗黙変換が働くので， \u003ccode\u003e\"(\" \u0026gt;\u0026gt; x3::double_ \u0026gt;\u0026gt; \")\"\u003c/code\u003e と書くことが出来ます．\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eは他にもあります．\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e|\u003c/code\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ea | b\u003c/code\u003e で，\u003ccode\u003ea\u003c/code\u003e にマッチするか \u003ccode\u003eb\u003c/code\u003e にマッチするか\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ea\u003c/code\u003e を先に試すので，両方にマッチする場合でも \u003ccode\u003ea\u003c/code\u003e にマッチしたことになる (PEG の特徴ですね)\u003c/li\u003e\n\u003cli\u003e返り値は \u003ccode\u003eboost::variant\u0026lt;a, b\u0026gt;\u003c/code\u003e です．\u003ccode\u003ea\u003c/code\u003e と \u003ccode\u003eb\u003c/code\u003e が同じ型を返す場合はその型を返します\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e とほぼ同じです．\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ea \u0026gt;\u0026gt; b\u003c/code\u003e は \u003ccode\u003ea\u003c/code\u003e にマッチして \u003ccode\u003eb\u003c/code\u003e にマッチしなかった場合，\u003ccode\u003ea\u003c/code\u003e の前にバックトラックします.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ea \u0026gt; b\u003c/code\u003e はその場合，即座にパース失敗を通知します．\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e*\u003c/code\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e*a\u003c/code\u003e という形で使う\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ea\u003c/code\u003e の 0 回以上の繰り返し\u003c/li\u003e\n\u003cli\u003e返り値は \u003ccode\u003estd::vector\u0026lt;a\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e+\u003c/code\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e+a\u003c/code\u003e という形で使う\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e*\u003c/code\u003e の一回以上繰り返し版\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-\u003c/code\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e-a\u003c/code\u003e という形で使う\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ea\u003c/code\u003e が来ても来なくても良いというパーサ\u003c/li\u003e\n\u003cli\u003e返り値は \u003ccode\u003eboost::optional\u0026lt;a\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e...\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e と \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e の違いはわかりにくいですね．\u003cbr/\u003e\n\u003ccode\u003e(x3::lit(\"(\") \u0026gt;\u0026gt; \")\") | (\"(\" \u0026gt;\u0026gt; x3::int_ \u0026gt;\u0026gt; \")\")\u003c/code\u003e に \u003ccode\u003e\"(123)\"\u003c/code\u003e を食わせると，\u003ccode\u003e|\u003c/code\u003e の後半部分にマッチしてくれます．\n一方, \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e を \u003ccode\u003e\u0026gt;\u003c/code\u003e に置換えた場合，ソース先頭の\u003ccode\u003e\"(\"\u003c/code\u003e が\u003ccode\u003ex3::lit(\"(\")\u003c/code\u003e にマッチするにもかかわらず，その直後に\u003ccode\u003e\")\"\u003c/code\u003e が来ていないため，その時点でエラーを通知してしまいます．\u003c/p\u003e\n\n\u003ch2\u003e一旦むすび\u003c/h2\u003e\n\n\u003cp\u003eとりあえず最も基本的な部分をまとめてみました．\u003cbr/\u003e\nここまでは \u003ccode\u003eQi\u003c/code\u003e と同じなんですよね．\u003c/p\u003e\n\n\u003cp\u003eセマンティックアクションや \u003ccode\u003eon_error\u003c/code\u003e などの扱いががっつり変わっているようなので，一旦ここで切って，それぞれ調べてからまとめたいと思います．\n何か間違い等あればぜひご指摘お願いします．\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003ch1\u003eBoost.Spirit.X3 の練習1\u003c/h1\u003e\n\n\u003cp\u003e\u003ca href=\"http://ciere.com/cppnow15/x3_docs/\"\u003eBoost.Spirit.X3\u003c/a\u003e という \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e のための パーサ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eライブラリを使ってみています．\u003cbr/\u003e\n\u003ccode\u003eBoost.Spirit\u003c/code\u003e というと， \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e の黒魔術の塊みたいなイメージがあります． ちなみに \u003ccode\u003eBoost.Spirit.Qi\u003c/code\u003e が安定版のパーサ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eライブラリで， \u003ccode\u003eX3\u003c/code\u003e はまだ開発中のようなので注意してください．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eX3\u003c/code\u003e は \u003ccode\u003eQi\u003c/code\u003e と異なり，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003e14 以降の規格を前提にしています．そのため，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\"\u003eジェネリック\u003c/a\u003eラムダなどを用いてよりわかりやすいプログラムが書けるようになっているようです．\u003cbr/\u003e\n\u003ccode\u003eQi\u003c/code\u003e は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e時間が爆発していたのですが， \u003ccode\u003eX3\u003c/code\u003e だと多少マシのようです．\u003c/p\u003e\n\n\u003ch2\u003e第一歩\u003c/h2\u003e\n\n\u003cp\u003eまずは猛烈にシンプルなパーサを使ってみましょう．\n\u003ccode\u003eX3\u003c/code\u003e も \u003ccode\u003eQi\u003c/code\u003e 同様に定義済みのパーサがあるので，それを単純に使用するだけのサンプルです．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;boost/spirit/home/x3.hpp\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main()\n{\n  \u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e x3 = boost::spirit::x3;\n\n  \u003cspan class=\"synType\"\u003eint\u003c/span\u003e result;\n  std::string src{ \u003cspan class=\"synConstant\"\u003e\u0026quot;123\u0026quot;\u003c/span\u003e };\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e first = std::cbegin(src);\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e last = std::cend(src);\n  \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::parse(first, last, x3::int_, result);\n\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (!success || first != last) {\n    \u003cspan class=\"synComment\"\u003e// parse failed\u003c/span\u003e\n    std::cerr \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse failed.\u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; std::endl;\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse: \u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\n\u003ch3\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003e \u0026amp; 実行\u003c/h3\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e$ clang++ -std=c++14 int_parser.cpp\n$ ./a.out\nParse: 123\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eBoost.Spirit.X3\u003c/code\u003e を使用する場合は, \u003ccode\u003e#include \u0026lt;boost/spirit/home/x3.hpp\u0026gt;\u003c/code\u003e とすればオッケーです．(これは使用していない機能のヘッダも読み込んでしまっているので，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eは重くなります… が，これ以降使う機能を増やす度にヘッダを書き換えるのは面倒ですし，\u003ccode\u003eX3\u003c/code\u003e の機能の多くを使用するプログラムの場合は，大差ないと思います．)\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%BE%C1%B0%B6%F5%B4%D6\"\u003e名前空間\u003c/a\u003eは \u003ccode\u003eboost::spirit::x3\u003c/code\u003e です．頻繁に出てくるので \u003ccode\u003enamespace x3\u003c/code\u003e で\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\"\u003eエイリアス\u003c/a\u003eしました．\u003c/p\u003e\n\n\u003cp\u003e実際にパースしている部分は,\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::parse(first, last, x3::int_, result);\n\u003c/pre\u003e\n\n\u003cp\u003eの部分です．\u003cbr/\u003e\n\u003ccode\u003ex3::parse\u003c/code\u003e は，第一引数にソース文字列の先頭\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%C6%A5%EC%A1%BC%A5%BF\"\u003eイテレータ\u003c/a\u003e，第二引数にソース文字列の終端\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%C6%A5%EC%A1%BC%A5%BF\"\u003eイテレータ\u003c/a\u003eをとります．\u003cbr/\u003e\n第三引数が，パーサの定義です．ここでは， \u003ccode\u003ex3::int_\u003c/code\u003e という定義済みパーサを使用しました． これは, 整数を表す文字列を受けて，それを整数に変換するパーサです． たとえば \u003ccode\u003e\"1\"\u003c/code\u003e を \u003ccode\u003e1\u003c/code\u003e に変換します．整数以外にあたった場合はマッチせず，パースに失敗します．(\u003ccode\u003ex3::parse\u003c/code\u003e の返り値が \u003ccode\u003efalse\u003c/code\u003e になる)\n第四引数は，指定したパーサの返す値です．ここちょっと説明が難しいですね．\u003cbr/\u003e\n\u003ccode\u003ex3::int_\u003c/code\u003e は \u003ccode\u003eint\u003c/code\u003e 型の値を返すパーサです(これを \u003ccode\u003ex3::int_\u003c/code\u003e の attribute が \u003ccode\u003eint\u003c/code\u003e 型であると表現している？).\u003cbr/\u003e\nそこで，\u003ccode\u003ex3::int_\u003c/code\u003e の返す値を格納する変数として，\u003ccode\u003eint result\u003c/code\u003e の参照を渡しているという感じです．\u003cbr/\u003e\nパースが成功していれば，\u003ccode\u003eresult\u003c/code\u003e の中身は \u003ccode\u003ex3::int_\u003c/code\u003e の返り値になっているはずです．\u003c/p\u003e\n\n\u003cp\u003eパースの成否判定は \u003ccode\u003esuccess\u003c/code\u003e と \u003ccode\u003efirst == last\u003c/code\u003e で行います．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (!success || first != last) {\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003esuccess\u003c/code\u003e はそもそもパーサにソースがマッチしなかった場合, \u003ccode\u003efalse\u003c/code\u003e になります．\u003cbr/\u003e\nまた，\u003ccode\u003e\"123abc\"\u003c/code\u003e に \u003ccode\u003ex3::int_\u003c/code\u003e をマッチさせると，\u003ccode\u003e\"123\"\u003c/code\u003e だけが消費され，\u003ccode\u003e\"abc\"\u003c/code\u003e が残ります．この時，\u003ccode\u003efirst\u003c/code\u003e は \u003ccode\u003e\"a\"\u003c/code\u003e の位置まで進んでいます．\nもしソースが先頭から終端まで，パーサにマッチしていたならば，\u003ccode\u003efirst == last\u003c/code\u003e となるはずです．\u003c/p\u003e\n\n\u003cp\u003eというわけでこのプログラムは，\u003ccode\u003ex3::int_\u003c/code\u003e に \u003ccode\u003e\"123\"\u003c/code\u003e をパースさせるプログラムでした．結果，きちんと整数の \u003ccode\u003e123\u003c/code\u003e が取得できていることがわかります．\u003c/p\u003e\n\n\u003ch2\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode\u003eBoost.Spirit.X3\u003c/code\u003e はパーサ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eライブラリです．個々のパーサを組み合わせてみましょう．\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e\" ( 1234.5)\"\u003c/code\u003e とか \u003ccode\u003e\"(67.8 )  \"\u003c/code\u003e にマッチして，\u003ccode\u003edouble\u003c/code\u003e を返すようなパーサを定義してみます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e parser = x3::lit(\u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e) \u0026gt;\u0026gt; x3::double_ \u0026gt;\u0026gt; x3::lit(\u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e);\n\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::phrase_parse(first, last, parser, x3::ascii::space, result);\n\u003c/pre\u003e\n\n\u003cp\u003eまずは \u003ccode\u003eparser\u003c/code\u003e の定義です．\n\u003ccode\u003ex3::lit\u003c/code\u003e は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%C6%A5%E9%A5%EB\"\u003eリテラル\u003c/a\u003eを表します．引数にとった文字列にマッチし，何も返さないパーサです．\u003ccode\u003ex3::lit(\"(\")\u003c/code\u003e は \u003ccode\u003e(\u003c/code\u003e にマッチし，何も返さないパーサということになります．\u003cbr/\u003e\n\u003ccode\u003ex3::double_\u003c/code\u003e は \u003ccode\u003ex3::int_\u003c/code\u003e と同じく，定義済みパーサで，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\"\u003e浮動小数点数\u003c/a\u003eにマッチしその値を返します．\u003c/p\u003e\n\n\u003cp\u003eそして重要なのが，\u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e です．\u003cbr/\u003e\nこれは，「左辺にマッチした後，右辺にマッチするパーサ」を作り出す\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eです．\u003cbr/\u003e\nここでは，\u003ccode\u003ex3::lit(\"(\") \u0026gt;\u0026gt; x3::double_\u003c/code\u003e ですから，\u003ccode\u003e(\u003c/code\u003e にマッチした後，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\"\u003e浮動小数点数\u003c/a\u003eにマッチするパーサ，ということになります.\u003c/p\u003e\n\n\u003cp\u003e通常，\u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e は左辺の返す値と右辺の返す値のタプルを返します．(\u003ccode\u003ex3::int_ \u0026gt;\u0026gt; x3::double_\u003c/code\u003e ならば，\u003ccode\u003eint\u003c/code\u003e と \u003ccode\u003edouble\u003c/code\u003e のタプル)\u003cbr/\u003e\nしかし，左辺右辺どちらか一方が値を返さない(正確には \u003ccode\u003ex3::unused_type\u003c/code\u003e を返す) 場合には，もう一方の値だけを返します．\u003cbr/\u003e\nつまり，\u003ccode\u003ex3::lit(\"(\") \u0026gt;\u0026gt; x3::double_\u003c/code\u003e は \u003ccode\u003edouble\u003c/code\u003e だけを返し，\u003ccode\u003e\u0026gt;\u0026gt; x3::lit(\")\")\u003c/code\u003e と続けても \u003ccode\u003edouble\u003c/code\u003e だけが返ります．\u003c/p\u003e\n\n\u003cp\u003e次に，空白の読み飛ばしについてです．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::phrase_parse(first, last, parser, x3::ascii::space, result);\n\u003c/pre\u003e\n\n\u003cp\u003eひとつ目の例と異なり，\u003ccode\u003ex3::parse\u003c/code\u003e ではなく \u003ccode\u003ex3::phrase_parse\u003c/code\u003e を使っています．\u003cbr/\u003e\nこちらは，\u003ccode\u003eattribute\u003c/code\u003e を示す最後の引数の前に，スキップパーサを取ります．\nスキップパーサとは，文字通り，スキップしてほしい文字列にマッチするパーサです．\u003cbr/\u003e\n\u003ccode\u003ex3::ascii::space\u003c/code\u003e は定義済みのパーサで，スペース，改行文字，タブにマッチします．したがって，これらの文字はスキップされます．\nスキップ判定のタイミングは \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e の部分です．つまり，\"12    3\" は \u003ccode\u003ex3::int_\u003c/code\u003e でパースすると, \u003ccode\u003e12\u003c/code\u003e までしかマッチしません．\u003ccode\u003ex3::int_ \u0026gt;\u0026gt; x3::int_\u003c/code\u003e とすることで，スペースがスキップされます．\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;boost/spirit/home/x3.hpp\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main()\n{\n  \u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e x3 = boost::spirit::x3;\n\n  std::string src{ \u003cspan class=\"synConstant\"\u003e\u0026quot;( 123.4 )\u0026quot;\u003c/span\u003e };\n\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e first = std::cbegin(src);\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e \u003cspan class=\"synType\"\u003econst\u003c/span\u003e last = std::cend(src);\n  \u003cspan class=\"synType\"\u003edouble\u003c/span\u003e result;\n  \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e parser = x3::lit(\u003cspan class=\"synConstant\"\u003e\u0026quot;(\u0026quot;\u003c/span\u003e) \u0026gt;\u0026gt; x3::double_ \u0026gt;\u0026gt; x3::lit(\u003cspan class=\"synConstant\"\u003e\u0026quot;)\u0026quot;\u003c/span\u003e);\n  \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e success = x3::phrase_parse(first, last, parser, x3::ascii::space, result);\n\n  \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (!success || first != last) {\n    \u003cspan class=\"synComment\"\u003e// parse failed\u003c/span\u003e\n    std::cerr \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse failed.\u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; std::endl;\n  } \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n    std::cout \u0026lt;\u0026lt; \u003cspan class=\"synConstant\"\u003e\u0026quot;Parse: \u0026quot;\u003c/span\u003e \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eちなみに，\u003ccode\u003ex3::lit(\"(\") \u0026gt;\u0026gt; x3::double_ \u0026gt;\u0026gt; x3::lit(\")\")\u003c/code\u003e の部分ですが，\u003ccode\u003eoperator\u0026lt;\u0026lt;\u003c/code\u003e の引数の内，片方がパーサであれば，\u003ccode\u003echar const*\u003c/code\u003e から暗黙変換が働くので， \u003ccode\u003e\"(\" \u0026gt;\u0026gt; x3::double_ \u0026gt;\u0026gt; \")\"\u003c/code\u003e と書くことが出来ます．\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\"\u003eコンビネータ\u003c/a\u003eは他にもあります．\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e|\u003c/code\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ea | b\u003c/code\u003e で，\u003ccode\u003ea\u003c/code\u003e にマッチするか \u003ccode\u003eb\u003c/code\u003e にマッチするか\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ea\u003c/code\u003e を先に試すので，両方にマッチする場合でも \u003ccode\u003ea\u003c/code\u003e にマッチしたことになる (PEG の特徴ですね)\u003c/li\u003e\n\u003cli\u003e返り値は \u003ccode\u003eboost::variant\u0026lt;a, b\u0026gt;\u003c/code\u003e です．\u003ccode\u003ea\u003c/code\u003e と \u003ccode\u003eb\u003c/code\u003e が同じ型を返す場合はその型を返します\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e とほぼ同じです．\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ea \u0026gt;\u0026gt; b\u003c/code\u003e は \u003ccode\u003ea\u003c/code\u003e にマッチして \u003ccode\u003eb\u003c/code\u003e にマッチしなかった場合，\u003ccode\u003ea\u003c/code\u003e の前にバックトラックします.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ea \u0026gt; b\u003c/code\u003e はその場合，即座にパース失敗を通知します．\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e*\u003c/code\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e*a\u003c/code\u003e という形で使う\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ea\u003c/code\u003e の 0 回以上の繰り返し\u003c/li\u003e\n\u003cli\u003e返り値は \u003ccode\u003estd::vector\u0026lt;a\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e+\u003c/code\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e+a\u003c/code\u003e という形で使う\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e*\u003c/code\u003e の一回以上繰り返し版\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-\u003c/code\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e-a\u003c/code\u003e という形で使う\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ea\u003c/code\u003e が来ても来なくても良いというパーサ\u003c/li\u003e\n\u003cli\u003e返り値は \u003ccode\u003eboost::optional\u0026lt;a\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e...\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e\u0026gt;\u003c/code\u003e と \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e の違いはわかりにくいですね．\u003cbr/\u003e\n\u003ccode\u003e(x3::lit(\"(\") \u0026gt;\u0026gt; \")\") | (\"(\" \u0026gt;\u0026gt; x3::int_ \u0026gt;\u0026gt; \")\")\u003c/code\u003e に \u003ccode\u003e\"(123)\"\u003c/code\u003e を食わせると，\u003ccode\u003e|\u003c/code\u003e の後半部分にマッチしてくれます．\n一方, \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e を \u003ccode\u003e\u0026gt;\u003c/code\u003e に置換えた場合，ソース先頭の\u003ccode\u003e\"(\"\u003c/code\u003e が\u003ccode\u003ex3::lit(\"(\")\u003c/code\u003e にマッチするにもかかわらず，その直後に\u003ccode\u003e\")\"\u003c/code\u003e が来ていないため，その時点でエラーを通知してしまいます．\u003c/p\u003e\n\n\u003ch2\u003e一旦むすび\u003c/h2\u003e\n\n\u003cp\u003eとりあえず最も基本的な部分をまとめてみました．\u003cbr/\u003e\nここまでは \u003ccode\u003eQi\u003c/code\u003e と同じなんですよね．\u003c/p\u003e\n\n\u003cp\u003eセマンティックアクションや \u003ccode\u003eon_error\u003c/code\u003e などの扱いががっつり変わっているようなので，一旦ここで切って，それぞれ調べてからまとめたいと思います．\n何か間違い等あればぜひご指摘お願いします．\u003c/p\u003e\n\n---\n\n---\n","slug":"Boost.Spirit.X3_の練習1","title":"Boost.Spirit.X3 の練習1","timestamp":1450346705000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Sokoban.nim を書いてみた\"\ndate: 2015-10-29T13:10:42.000Z\ntags: []\n---\n\n\u003ch1\u003eSokoban.nim を書いてみた\u003c/h1\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.nim-lang.org\"\u003eNim\u003c/a\u003e という言語を使って\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C1%D2%B8%CB%C8%D6\"\u003e倉庫番\u003c/a\u003eを書いてみました.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/agatan/sokoban-nim\"\u003esokoban-nim\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/swatteau/sokoban-rs\"\u003esokoban-rs\u003c/a\u003e に影響されました．\u003c/p\u003e\n\n\u003cp\u003eといっても \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDL\"\u003eSDL\u003c/a\u003e ド素人なので見た目は恐ろしく質素です． Nim の練習のつもりで書いてみました．\u003c/p\u003e\n\n\u003ch2\u003e動作\u003c/h2\u003e\n\n\u003cp\u003e動作としては，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%DE%A5%F3%A5%C9%A5%E9%A5%A4%A5%F3\"\u003eコマンドライン\u003c/a\u003e引数にステージ情報を記述したファイル名を指定します．\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e##########\n#   .    #\n#  $   . ####\n# @ $       #\n#           #\n#############\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eこのようなファイルを指定します． クリアするとなにも言わずに終了するようになっています．(また, ESC でも終了します)\u003c/p\u003e\n\n\u003cp\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20151029/20151029220921.png\" alt=\"f:id:agtn:20151029220921p:plain\" title=\"f:id:agtn:20151029220921p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e緑がプレイヤー, 青がゴール, 赤が箱です. 箱を押して青を塞げばクリアです.\u003c/p\u003e\n\n\u003ch2\u003e感想\u003c/h2\u003e\n\n\u003cp\u003eNim で遊びたくて作ってみましたが，思っていた以上に Nim が楽しいですね． ライブラリも整っていますし，特に難しいことはなくサクサク書けました．\u003c/p\u003e\n\n\u003cp\u003eNim で \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Lisp\"\u003eLisp\u003c/a\u003e 処理系を書いたりしていて，息抜きに\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GUI\"\u003eGUI\u003c/a\u003eっぽいものをと思って書きました． Cライブラリとの連携も非常にスムーズでしたし，Nim 流行んないかなぁと思っています．\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003ch1\u003eSokoban.nim を書いてみた\u003c/h1\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.nim-lang.org\"\u003eNim\u003c/a\u003e という言語を使って\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C1%D2%B8%CB%C8%D6\"\u003e倉庫番\u003c/a\u003eを書いてみました.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/agatan/sokoban-nim\"\u003esokoban-nim\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/swatteau/sokoban-rs\"\u003esokoban-rs\u003c/a\u003e に影響されました．\u003c/p\u003e\n\n\u003cp\u003eといっても \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDL\"\u003eSDL\u003c/a\u003e ド素人なので見た目は恐ろしく質素です． Nim の練習のつもりで書いてみました．\u003c/p\u003e\n\n\u003ch2\u003e動作\u003c/h2\u003e\n\n\u003cp\u003e動作としては，\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%DE%A5%F3%A5%C9%A5%E9%A5%A4%A5%F3\"\u003eコマンドライン\u003c/a\u003e引数にステージ情報を記述したファイル名を指定します．\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e##########\n#   .    #\n#  $   . ####\n# @ $       #\n#           #\n#############\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eこのようなファイルを指定します． クリアするとなにも言わずに終了するようになっています．(また, ESC でも終了します)\u003c/p\u003e\n\n\u003cp\u003e\u003cspan itemscope itemtype=\"http://schema.org/Photograph\"\u003e\u003cimg src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20151029/20151029220921.png\" alt=\"f:id:agtn:20151029220921p:plain\" title=\"f:id:agtn:20151029220921p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"\u003e\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e緑がプレイヤー, 青がゴール, 赤が箱です. 箱を押して青を塞げばクリアです.\u003c/p\u003e\n\n\u003ch2\u003e感想\u003c/h2\u003e\n\n\u003cp\u003eNim で遊びたくて作ってみましたが，思っていた以上に Nim が楽しいですね． ライブラリも整っていますし，特に難しいことはなくサクサク書けました．\u003c/p\u003e\n\n\u003cp\u003eNim で \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Lisp\"\u003eLisp\u003c/a\u003e 処理系を書いたりしていて，息抜きに\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GUI\"\u003eGUI\u003c/a\u003eっぽいものをと思って書きました． Cライブラリとの連携も非常にスムーズでしたし，Nim 流行んないかなぁと思っています．\u003c/p\u003e\n\n---\n\n---\n","slug":"Sokoban.nim_を書いてみた","title":"Sokoban.nim を書いてみた","timestamp":1446124242000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Golang での文字列連結に関するベンチマーク\"\ndate: 2015-09-08T08:09:45.000Z\ntags: []\n---\n\n\u003ch1\u003eまず結論\u003c/h1\u003e\n\n\u003cp\u003e\u003ccode\u003eappend\u003c/code\u003e しよう. \u003ccode\u003ebytes.Buffer\u003c/code\u003e はそんなに速くない.\u003c/p\u003e\n\n\u003ch1\u003eきっかけ\u003c/h1\u003e\n\n\u003cp\u003eこんな記事を見かけました.\u003cbr/\u003e\n\u003ca href=\"http://qiita.com/ruiu/items/2bb83b29baeae2433a79\"\u003eGoでは文字列連結はコストの高い操作 - Qiita\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ebuf += \"abc\"\u003c/code\u003e はコストが高いよーっていうお話ですね. これは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e にかぎらず, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003eとかでもよく話題になる一般的な問題だと思います.\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e だと \u003ccode\u003eStringBuilder\u003c/code\u003e を使うのが良いとされていたと思いますが, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e だと解法がいくつかあるようです.\u003c/p\u003e\n\n\u003cp\u003eそこで, 解法をそれぞれ紹介した後, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\"\u003eベンチマーク\u003c/a\u003e結果を載せてみたいと思います.\u003c/p\u003e\n\n\u003ch2\u003e1. 普通に \u003ccode\u003e+=\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003eまずは普通に \u003ccode\u003e+=\u003c/code\u003e で連結していく方法です.\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e AddString(n \u003cspan class=\"synType\"\u003eint\u003c/span\u003e) \u003cspan class=\"synType\"\u003estring\u003c/span\u003e {\n    base := \u003cspan class=\"synConstant\"\u003e\u0026quot;abc\u0026quot;\u003c/span\u003e\n    buf := \u003cspan class=\"synConstant\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; n; i++ {\n        buf += base\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e buf\n}\n\u003c/pre\u003e\n\n\u003cp\u003eこんな感じですね.\u003cbr/\u003e\nこれだと, 確実に n 回メモリ割り当てが発生するので遅いというのが問題となります.\u003c/p\u003e\n\n\u003ch2\u003e2. \u003ccode\u003eappend\u003c/code\u003e する\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e の \u003ccode\u003estring\u003c/code\u003e は, メモリ上では \u003ccode\u003e[]byte\u003c/code\u003e と同等の表現を持ちます.\u003cbr/\u003e\nそこで, \u003ccode\u003estring\u003c/code\u003e を \u003ccode\u003e[]byte\u003c/code\u003e として扱い, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e のスライスを伸長する \u003ccode\u003eappend\u003c/code\u003e 関数を用いるという方法があります.\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e AppendString(n \u003cspan class=\"synType\"\u003eint\u003c/span\u003e) \u003cspan class=\"synType\"\u003estring\u003c/span\u003e {\n    base := \u003cspan class=\"synConstant\"\u003e\u0026quot;abc\u0026quot;\u003c/span\u003e\n    buf := \u003cspan class=\"synStatement\"\u003emake\u003c/span\u003e([]\u003cspan class=\"synType\"\u003ebyte\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e)\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; n; i++ {\n        buf = append(buf, base...)\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synType\"\u003estring\u003c/span\u003e(buf)\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003emake([]byte, 0)\u003c/code\u003e によって, 長さ0のスライスを作って, それを伸長していく方法となっています.\u003cbr/\u003e\nこのあたりは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e のスライスの表現について知っていないとわかりづらいと思うのですが, わかりやすい説明がいろいろなところで読めるので, ここでは説明しません.\n\u003ccode\u003eappend\u003c/code\u003e 関数は, スライスの len を必要な分だけ大きくします. また, その結果 len が スライスの cap を超える長さになる場合は, スライスの cap を必要以上に大きくすします.\u003cbr/\u003e\nこれは, \u003ccode\u003eappend\u003c/code\u003e を繰り返し適用するような場合(今回のように)に, メモリ割り当ての回数を最小にするためです. 一度の \u003ccode\u003eappend\u003c/code\u003e で大きめにメモリを確保しておくことで, 次の \u003ccode\u003eappend\u003c/code\u003e ではメモリ割り当てをしなくても済む可能性が生まれます.\u003cbr/\u003e\nイメージとしては,\u003c/p\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:center;\"\u003e append の回数 \u003c/th\u003e\n\u003cth style=\"text-align:center;\"\u003e 0 \u003c/th\u003e\n\u003cth style=\"text-align:center;\"\u003e 1 \u003c/th\u003e\n\u003cth style=\"text-align:center;\"\u003e 2 \u003c/th\u003e\n\u003cth style=\"text-align:center;\"\u003e 3 \u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center;\"\u003e len \u003c/td\u003e\n\u003ctd style=\"text-align:center;\"\u003e 0 \u003c/td\u003e\n\u003ctd style=\"text-align:center;\"\u003e 3 \u003c/td\u003e\n\u003ctd style=\"text-align:center;\"\u003e 6 \u003c/td\u003e\n\u003ctd style=\"text-align:center;\"\u003e 9 \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center;\"\u003e cap \u003c/td\u003e\n\u003ctd style=\"text-align:center;\"\u003e 0 \u003c/td\u003e\n\u003ctd style=\"text-align:center;\"\u003e 8 \u003c/td\u003e\n\u003ctd style=\"text-align:center;\"\u003e 8 \u003c/td\u003e\n\u003ctd style=\"text-align:center;\"\u003e 16 \u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cp\u003eこんな感じでしょうか(あくまでイメージですが)\u003cbr/\u003e\n\u003ccode\u003eappend\u003c/code\u003e は3回呼ばれていますが, メモリ割り当ては2回に抑えられています.\u003cbr/\u003e\nその分, \u003ccode\u003e+=\u003c/code\u003e よりも速いだろうということですね.\u003c/p\u003e\n\n\u003ch3\u003e2'. \u003ccode\u003ecap\u003c/code\u003e を十分量確保しておく\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode\u003emake\u003c/code\u003e によるスライスの作成の際には, 長さだけでなくキャパシティを指定することが出来ます.\u003cbr/\u003e\nしたがって, はじめから \u003ccode\u003eappend\u003c/code\u003e していった後の最終的なスライスの長さがわかっているのであれば, それをキャパシティに指定することで, メモリ割り当てを最小限に抑えることが可能になります.\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e AppendStringWithCap(n \u003cspan class=\"synType\"\u003eint\u003c/span\u003e) \u003cspan class=\"synType\"\u003estring\u003c/span\u003e {\n    base := \u003cspan class=\"synConstant\"\u003e\u0026quot;abc\u0026quot;\u003c/span\u003e\n    buf := \u003cspan class=\"synStatement\"\u003emake\u003c/span\u003e([]\u003cspan class=\"synType\"\u003ebyte\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e3\u003c/span\u003e*n)\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; n; i++ {\n        buf = append(buf, base...)\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synType\"\u003estring\u003c/span\u003e(buf)\n}\n\u003c/pre\u003e\n\n\u003ch2\u003e3. \u003ccode\u003ebytes.Buffer\u003c/code\u003e を使う\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e の \u003ccode\u003eStringBuilder\u003c/code\u003e に近い解法ですね.\u003cbr/\u003e\n\u003ccode\u003ebytes.Buffer\u003c/code\u003e は文字通りバイト列のバッファリングを行ってくれます.\u003cbr/\u003e\n\u003ccode\u003ebytes.Buffer\u003c/code\u003e に文字列やバイト列を書き込んでいくと, 自動的にメモリ割り当てを減らすように計らってくれます.\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e BufferString(n \u003cspan class=\"synType\"\u003eint\u003c/span\u003e) \u003cspan class=\"synType\"\u003estring\u003c/span\u003e {\n    base := \u003cspan class=\"synConstant\"\u003e\u0026quot;abc\u0026quot;\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003evar\u003c/span\u003e buf \u003cspan class=\"synType\"\u003ebytes.Buffer\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; n; i++ {\n        buf.WriteString(base)\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e buf.String()\n}\n\u003c/pre\u003e\n\n\u003cp\u003eこんな感じです.\u003c/p\u003e\n\n\u003ch1\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\"\u003eベンチマーク\u003c/a\u003e結果\u003c/h1\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e には\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\"\u003eベンチマーク\u003c/a\u003eをとる機能も標準で付いているので, それを利用しました.\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"synStatement\"\u003eimport\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;testing\u0026quot;\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003econst\u003c/span\u003e N = \u003cspan class=\"synConstant\"\u003e1000\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e BenchmarkAddString(b *testing.B) {\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; b.N; i++ {\n        AddString(N)\n    }\n}\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e BenchmarkAppendString(b *testing.B) {\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; b.N; i++ {\n        AppendString(N)\n    }\n}\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e BenchmarkAppendStringWithCap(b *testing.B) {\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; b.N; i++ {\n        AppendStringWithCap(N)\n    }\n}\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e BenchmarkBufferString(b *testing.B) {\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; b.N; i++ {\n        BufferString(N)\n    }\n}\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e TestEquality(t *testing.T) {\n    base := AddString(N)\n    tests := []\u003cspan class=\"synType\"\u003estring\u003c/span\u003e{\n        AppendString(N),\n        AppendStringWithCap(N),\n        BufferString(N),\n    }\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e _, test := \u003cspan class=\"synStatement\"\u003erange\u003c/span\u003e tests {\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e base != test {\n            t.Fatal(\u003cspan class=\"synConstant\"\u003e\u0026quot;not fair\u0026quot;\u003c/span\u003e)\n        }\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eTestEquality\u003c/code\u003e は, すべての方法で正しく文字列を生成できていることを確認するためのテストです. \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\"\u003eベンチマーク\u003c/a\u003eには関係ありません.\u003c/p\u003e\n\n\u003ch2\u003e結果\u003c/h2\u003e\n\n\u003cp\u003e上記のファイルを用意した後, \u003ccode\u003ego test -bench . -benchmem\u003c/code\u003e とした結果を以下に示します.\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003ePASS\nBenchmarkAddString-8                5000        348347 ns/op     1592481 B/op        999 allocs/op\nBenchmarkAppendString-8           200000          7346 ns/op       13056 B/op         12 allocs/op\nBenchmarkAppendStringWithCap-8    300000          5461 ns/op        6144 B/op          2 allocs/op\nBenchmarkBufferString-8           100000         16847 ns/op       12256 B/op          8 allocs/op\nok      github.com/agatan/bench 6.881s\u003c/pre\u003e\n\n\u003cp\u003eというわけで, \u003ccode\u003emake\u003c/code\u003e の時点で十分なメモリを確保しておく 2' の方法が最も速く最もメモリを消費しないことがわかりました.\u003cbr/\u003e\nまぁ当たり前ですねｗｗ\u003c/p\u003e\n\n\u003cp\u003eより注目すべきは, 2 と 4 の結果です. 今回の結果だと, 最終的な文字列の長さがわからない場合, \u003ccode\u003ebytes.Buffer\u003c/code\u003e よりも \u003ccode\u003eappend\u003c/code\u003e を使ったほうが速いという結果になっています (メモリ使用量は若干 \u003ccode\u003ebytes.Buffer\u003c/code\u003e のほうが小さい)\u003c/p\u003e\n\n\u003cp\u003eメモリ割り当ての回数も \u003ccode\u003ebytes.Buffer\u003c/code\u003e のほうが少なく済んでいるため, \u003ccode\u003e[]byte\u003c/code\u003e と \u003ccode\u003estring\u003c/code\u003e の変換など, 文字列連結以外の部分でのオーバーヘッドが大きいため, このような結果になった可能性があります. そこで, \u003ccode\u003eN\u003c/code\u003e の値を変えて実行してみました.\u003c/p\u003e\n\n\u003ch2\u003eN = 10 の場合\u003c/h2\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003ePASS\nBenchmarkAddString-8             2000000           613 ns/op         224 B/op          9 allocs/op\nBenchmarkAppendString-8          5000000           270 ns/op          96 B/op          4 allocs/op\nBenchmarkAppendStringWithCap-8  10000000           142 ns/op          64 B/op          2 allocs/op\nBenchmarkBufferString-8          5000000           251 ns/op         144 B/op          2 allocs/op\nok      github.com/agatan/bench 6.581s\u003c/pre\u003e\n\n\u003ch2\u003eN = 10000 の場合\u003c/h2\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003ePASS\nBenchmarkAddString-8                  50      28544042 ns/op    160274378 B/op     10039 allocs/op\nBenchmarkAppendString-8            20000         71285 ns/op      160768 B/op         20 allocs/op\nBenchmarkAppendStringWithCap-8     30000         55262 ns/op       65536 B/op          2 allocs/op\nBenchmarkBufferString-8            10000        151665 ns/op      109280 B/op         11 allocs/op\nok      github.com/agatan/bench 7.393s\u003c/pre\u003e\n\n\u003ch1\u003e結論\u003c/h1\u003e\n\n\u003cp\u003e連結する文字列の長さや連結の回数にもよるが, おおよそ \u003ccode\u003eappend\u003c/code\u003e のほうが速い！！\u003cbr/\u003e\n\u003ccode\u003ebytes.Buffer\u003c/code\u003e はいつ使えばいいの...\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003ch1\u003eまず結論\u003c/h1\u003e\n\n\u003cp\u003e\u003ccode\u003eappend\u003c/code\u003e しよう. \u003ccode\u003ebytes.Buffer\u003c/code\u003e はそんなに速くない.\u003c/p\u003e\n\n\u003ch1\u003eきっかけ\u003c/h1\u003e\n\n\u003cp\u003eこんな記事を見かけました.\u003cbr/\u003e\n\u003ca href=\"http://qiita.com/ruiu/items/2bb83b29baeae2433a79\"\u003eGoでは文字列連結はコストの高い操作 - Qiita\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ebuf += \"abc\"\u003c/code\u003e はコストが高いよーっていうお話ですね. これは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e にかぎらず, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003eとかでもよく話題になる一般的な問題だと思います.\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e だと \u003ccode\u003eStringBuilder\u003c/code\u003e を使うのが良いとされていたと思いますが, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e だと解法がいくつかあるようです.\u003c/p\u003e\n\n\u003cp\u003eそこで, 解法をそれぞれ紹介した後, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\"\u003eベンチマーク\u003c/a\u003e結果を載せてみたいと思います.\u003c/p\u003e\n\n\u003ch2\u003e1. 普通に \u003ccode\u003e+=\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003eまずは普通に \u003ccode\u003e+=\u003c/code\u003e で連結していく方法です.\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e AddString(n \u003cspan class=\"synType\"\u003eint\u003c/span\u003e) \u003cspan class=\"synType\"\u003estring\u003c/span\u003e {\n    base := \u003cspan class=\"synConstant\"\u003e\u0026quot;abc\u0026quot;\u003c/span\u003e\n    buf := \u003cspan class=\"synConstant\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; n; i++ {\n        buf += base\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e buf\n}\n\u003c/pre\u003e\n\n\u003cp\u003eこんな感じですね.\u003cbr/\u003e\nこれだと, 確実に n 回メモリ割り当てが発生するので遅いというのが問題となります.\u003c/p\u003e\n\n\u003ch2\u003e2. \u003ccode\u003eappend\u003c/code\u003e する\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e の \u003ccode\u003estring\u003c/code\u003e は, メモリ上では \u003ccode\u003e[]byte\u003c/code\u003e と同等の表現を持ちます.\u003cbr/\u003e\nそこで, \u003ccode\u003estring\u003c/code\u003e を \u003ccode\u003e[]byte\u003c/code\u003e として扱い, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e のスライスを伸長する \u003ccode\u003eappend\u003c/code\u003e 関数を用いるという方法があります.\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e AppendString(n \u003cspan class=\"synType\"\u003eint\u003c/span\u003e) \u003cspan class=\"synType\"\u003estring\u003c/span\u003e {\n    base := \u003cspan class=\"synConstant\"\u003e\u0026quot;abc\u0026quot;\u003c/span\u003e\n    buf := \u003cspan class=\"synStatement\"\u003emake\u003c/span\u003e([]\u003cspan class=\"synType\"\u003ebyte\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e)\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; n; i++ {\n        buf = append(buf, base...)\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synType\"\u003estring\u003c/span\u003e(buf)\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003emake([]byte, 0)\u003c/code\u003e によって, 長さ0のスライスを作って, それを伸長していく方法となっています.\u003cbr/\u003e\nこのあたりは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e のスライスの表現について知っていないとわかりづらいと思うのですが, わかりやすい説明がいろいろなところで読めるので, ここでは説明しません.\n\u003ccode\u003eappend\u003c/code\u003e 関数は, スライスの len を必要な分だけ大きくします. また, その結果 len が スライスの cap を超える長さになる場合は, スライスの cap を必要以上に大きくすします.\u003cbr/\u003e\nこれは, \u003ccode\u003eappend\u003c/code\u003e を繰り返し適用するような場合(今回のように)に, メモリ割り当ての回数を最小にするためです. 一度の \u003ccode\u003eappend\u003c/code\u003e で大きめにメモリを確保しておくことで, 次の \u003ccode\u003eappend\u003c/code\u003e ではメモリ割り当てをしなくても済む可能性が生まれます.\u003cbr/\u003e\nイメージとしては,\u003c/p\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:center;\"\u003e append の回数 \u003c/th\u003e\n\u003cth style=\"text-align:center;\"\u003e 0 \u003c/th\u003e\n\u003cth style=\"text-align:center;\"\u003e 1 \u003c/th\u003e\n\u003cth style=\"text-align:center;\"\u003e 2 \u003c/th\u003e\n\u003cth style=\"text-align:center;\"\u003e 3 \u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center;\"\u003e len \u003c/td\u003e\n\u003ctd style=\"text-align:center;\"\u003e 0 \u003c/td\u003e\n\u003ctd style=\"text-align:center;\"\u003e 3 \u003c/td\u003e\n\u003ctd style=\"text-align:center;\"\u003e 6 \u003c/td\u003e\n\u003ctd style=\"text-align:center;\"\u003e 9 \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center;\"\u003e cap \u003c/td\u003e\n\u003ctd style=\"text-align:center;\"\u003e 0 \u003c/td\u003e\n\u003ctd style=\"text-align:center;\"\u003e 8 \u003c/td\u003e\n\u003ctd style=\"text-align:center;\"\u003e 8 \u003c/td\u003e\n\u003ctd style=\"text-align:center;\"\u003e 16 \u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cp\u003eこんな感じでしょうか(あくまでイメージですが)\u003cbr/\u003e\n\u003ccode\u003eappend\u003c/code\u003e は3回呼ばれていますが, メモリ割り当ては2回に抑えられています.\u003cbr/\u003e\nその分, \u003ccode\u003e+=\u003c/code\u003e よりも速いだろうということですね.\u003c/p\u003e\n\n\u003ch3\u003e2'. \u003ccode\u003ecap\u003c/code\u003e を十分量確保しておく\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode\u003emake\u003c/code\u003e によるスライスの作成の際には, 長さだけでなくキャパシティを指定することが出来ます.\u003cbr/\u003e\nしたがって, はじめから \u003ccode\u003eappend\u003c/code\u003e していった後の最終的なスライスの長さがわかっているのであれば, それをキャパシティに指定することで, メモリ割り当てを最小限に抑えることが可能になります.\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e AppendStringWithCap(n \u003cspan class=\"synType\"\u003eint\u003c/span\u003e) \u003cspan class=\"synType\"\u003estring\u003c/span\u003e {\n    base := \u003cspan class=\"synConstant\"\u003e\u0026quot;abc\u0026quot;\u003c/span\u003e\n    buf := \u003cspan class=\"synStatement\"\u003emake\u003c/span\u003e([]\u003cspan class=\"synType\"\u003ebyte\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e3\u003c/span\u003e*n)\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; n; i++ {\n        buf = append(buf, base...)\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synType\"\u003estring\u003c/span\u003e(buf)\n}\n\u003c/pre\u003e\n\n\u003ch2\u003e3. \u003ccode\u003ebytes.Buffer\u003c/code\u003e を使う\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003e の \u003ccode\u003eStringBuilder\u003c/code\u003e に近い解法ですね.\u003cbr/\u003e\n\u003ccode\u003ebytes.Buffer\u003c/code\u003e は文字通りバイト列のバッファリングを行ってくれます.\u003cbr/\u003e\n\u003ccode\u003ebytes.Buffer\u003c/code\u003e に文字列やバイト列を書き込んでいくと, 自動的にメモリ割り当てを減らすように計らってくれます.\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e BufferString(n \u003cspan class=\"synType\"\u003eint\u003c/span\u003e) \u003cspan class=\"synType\"\u003estring\u003c/span\u003e {\n    base := \u003cspan class=\"synConstant\"\u003e\u0026quot;abc\u0026quot;\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003evar\u003c/span\u003e buf \u003cspan class=\"synType\"\u003ebytes.Buffer\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; n; i++ {\n        buf.WriteString(base)\n    }\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e buf.String()\n}\n\u003c/pre\u003e\n\n\u003cp\u003eこんな感じです.\u003c/p\u003e\n\n\u003ch1\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\"\u003eベンチマーク\u003c/a\u003e結果\u003c/h1\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e には\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\"\u003eベンチマーク\u003c/a\u003eをとる機能も標準で付いているので, それを利用しました.\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"synStatement\"\u003eimport\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e\u0026quot;testing\u0026quot;\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003econst\u003c/span\u003e N = \u003cspan class=\"synConstant\"\u003e1000\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e BenchmarkAddString(b *testing.B) {\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; b.N; i++ {\n        AddString(N)\n    }\n}\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e BenchmarkAppendString(b *testing.B) {\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; b.N; i++ {\n        AppendString(N)\n    }\n}\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e BenchmarkAppendStringWithCap(b *testing.B) {\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; b.N; i++ {\n        AppendStringWithCap(N)\n    }\n}\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e BenchmarkBufferString(b *testing.B) {\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e i := \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e; i \u0026lt; b.N; i++ {\n        BufferString(N)\n    }\n}\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e TestEquality(t *testing.T) {\n    base := AddString(N)\n    tests := []\u003cspan class=\"synType\"\u003estring\u003c/span\u003e{\n        AppendString(N),\n        AppendStringWithCap(N),\n        BufferString(N),\n    }\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e _, test := \u003cspan class=\"synStatement\"\u003erange\u003c/span\u003e tests {\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e base != test {\n            t.Fatal(\u003cspan class=\"synConstant\"\u003e\u0026quot;not fair\u0026quot;\u003c/span\u003e)\n        }\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eTestEquality\u003c/code\u003e は, すべての方法で正しく文字列を生成できていることを確認するためのテストです. \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\"\u003eベンチマーク\u003c/a\u003eには関係ありません.\u003c/p\u003e\n\n\u003ch2\u003e結果\u003c/h2\u003e\n\n\u003cp\u003e上記のファイルを用意した後, \u003ccode\u003ego test -bench . -benchmem\u003c/code\u003e とした結果を以下に示します.\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003ePASS\nBenchmarkAddString-8                5000        348347 ns/op     1592481 B/op        999 allocs/op\nBenchmarkAppendString-8           200000          7346 ns/op       13056 B/op         12 allocs/op\nBenchmarkAppendStringWithCap-8    300000          5461 ns/op        6144 B/op          2 allocs/op\nBenchmarkBufferString-8           100000         16847 ns/op       12256 B/op          8 allocs/op\nok      github.com/agatan/bench 6.881s\u003c/pre\u003e\n\n\u003cp\u003eというわけで, \u003ccode\u003emake\u003c/code\u003e の時点で十分なメモリを確保しておく 2' の方法が最も速く最もメモリを消費しないことがわかりました.\u003cbr/\u003e\nまぁ当たり前ですねｗｗ\u003c/p\u003e\n\n\u003cp\u003eより注目すべきは, 2 と 4 の結果です. 今回の結果だと, 最終的な文字列の長さがわからない場合, \u003ccode\u003ebytes.Buffer\u003c/code\u003e よりも \u003ccode\u003eappend\u003c/code\u003e を使ったほうが速いという結果になっています (メモリ使用量は若干 \u003ccode\u003ebytes.Buffer\u003c/code\u003e のほうが小さい)\u003c/p\u003e\n\n\u003cp\u003eメモリ割り当ての回数も \u003ccode\u003ebytes.Buffer\u003c/code\u003e のほうが少なく済んでいるため, \u003ccode\u003e[]byte\u003c/code\u003e と \u003ccode\u003estring\u003c/code\u003e の変換など, 文字列連結以外の部分でのオーバーヘッドが大きいため, このような結果になった可能性があります. そこで, \u003ccode\u003eN\u003c/code\u003e の値を変えて実行してみました.\u003c/p\u003e\n\n\u003ch2\u003eN = 10 の場合\u003c/h2\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003ePASS\nBenchmarkAddString-8             2000000           613 ns/op         224 B/op          9 allocs/op\nBenchmarkAppendString-8          5000000           270 ns/op          96 B/op          4 allocs/op\nBenchmarkAppendStringWithCap-8  10000000           142 ns/op          64 B/op          2 allocs/op\nBenchmarkBufferString-8          5000000           251 ns/op         144 B/op          2 allocs/op\nok      github.com/agatan/bench 6.581s\u003c/pre\u003e\n\n\u003ch2\u003eN = 10000 の場合\u003c/h2\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003ePASS\nBenchmarkAddString-8                  50      28544042 ns/op    160274378 B/op     10039 allocs/op\nBenchmarkAppendString-8            20000         71285 ns/op      160768 B/op         20 allocs/op\nBenchmarkAppendStringWithCap-8     30000         55262 ns/op       65536 B/op          2 allocs/op\nBenchmarkBufferString-8            10000        151665 ns/op      109280 B/op         11 allocs/op\nok      github.com/agatan/bench 7.393s\u003c/pre\u003e\n\n\u003ch1\u003e結論\u003c/h1\u003e\n\n\u003cp\u003e連結する文字列の長さや連結の回数にもよるが, おおよそ \u003ccode\u003eappend\u003c/code\u003e のほうが速い！！\u003cbr/\u003e\n\u003ccode\u003ebytes.Buffer\u003c/code\u003e はいつ使えばいいの...\u003c/p\u003e\n\n---\n\n---\n","slug":"Golang_での文字列連結に関するベンチマーク","title":"Golang での文字列連結に関するベンチマーク","timestamp":1441699785000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Golangでechoサーバ\"\ndate: 2015-09-08T07:14:10.000Z\ntags: []\n---\n\n\u003cp\u003e最近 \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e が気になります\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e の特徴はもはやわざわざここに書くまでも無いことだと思うので書きませんが, 気になっている理由を書いてみます.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eバイナリ(しかもポータビリティが非常に高いバイナリ)に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eされること\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C/C%2B%2B\"\u003eC/C++\u003c/a\u003e には及ばずとも実行が非常に速いこと\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C/C%2B%2B\"\u003eC/C++\u003c/a\u003e ほど低レイヤーいじり放題なわけではないが, ある程度低レイヤーまで降りていけること\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%DE%A5%F3%A5%C9%A5%E9%A5%A4%A5%F3\"\u003eコマンドライン\u003c/a\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C4%A1%BC%A5%EB\"\u003eツール\u003c/a\u003eからWeb アプリケーションのような高レイヤーまで十分得意であること\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einterface\u003c/code\u003e による抽象化が, 過度でなく調度良く感じられること\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eこんな感じでしょうか.\u003cbr/\u003e\nCompiled \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\"\u003ePython\u003c/a\u003e っていう感じが非常に良さそうだなーと思っています.\u003c/p\u003e\n\n\u003cp\u003eというわけで\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eに引き続き \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e でも echo サーバを書いてみました\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"synStatement\"\u003eimport\u003c/span\u003e (\n    \u003cspan class=\"synConstant\"\u003e\u0026quot;fmt\u0026quot;\u003c/span\u003e\n    \u003cspan class=\"synConstant\"\u003e\u0026quot;io\u0026quot;\u003c/span\u003e\n    \u003cspan class=\"synConstant\"\u003e\u0026quot;net\u0026quot;\u003c/span\u003e\n)\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e main() {\n    listener, err := net.Listen(\u003cspan class=\"synConstant\"\u003e\u0026quot;tcp\u0026quot;\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e\u0026quot;:8080\u0026quot;\u003c/span\u003e)\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e err != \u003cspan class=\"synStatement\"\u003enil\u003c/span\u003e {\n        \u003cspan class=\"synStatement\"\u003epanic\u003c/span\u003e(err)\n    }\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e {\n        conn, err := listener.Accept()\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e err != \u003cspan class=\"synStatement\"\u003enil\u003c/span\u003e {\n            \u003cspan class=\"synStatement\"\u003epanic\u003c/span\u003e(err)\n        }\n        \u003cspan class=\"synStatement\"\u003ego\u003c/span\u003e \u003cspan class=\"synType\"\u003efunc\u003c/span\u003e(conn net.Conn) {\n            \u003cspan class=\"synStatement\"\u003edefer\u003c/span\u003e conn.Close()\n            echo(conn)\n        }(conn)\n    }\n}\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e echo(conn net.Conn) {\n    buf := \u003cspan class=\"synStatement\"\u003emake\u003c/span\u003e([]\u003cspan class=\"synType\"\u003ebyte\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e256\u003c/span\u003e)\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e {\n        n, err := conn.Read(buf)\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e err != \u003cspan class=\"synStatement\"\u003enil\u003c/span\u003e {\n            \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e err == io.EOF {\n                \u003cspan class=\"synStatement\"\u003ebreak\u003c/span\u003e\n            }\n            \u003cspan class=\"synStatement\"\u003epanic\u003c/span\u003e(err)\n        }\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e n == \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e {\n            \u003cspan class=\"synStatement\"\u003ebreak\u003c/span\u003e\n        }\n        wn, err := conn.Write(buf[\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e:n])\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e err != \u003cspan class=\"synStatement\"\u003enil\u003c/span\u003e {\n            \u003cspan class=\"synStatement\"\u003epanic\u003c/span\u003e(err)\n        }\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e wn != n {\n            \u003cspan class=\"synStatement\"\u003epanic\u003c/span\u003e(fmt.Errorf(\u003cspan class=\"synConstant\"\u003e\u0026quot;could not send all data\u0026quot;\u003c/span\u003e))\n        }\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eさすがは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e というかなんというか. ものすごく普通な空気を感じますね.\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003eはこういう普通さが売りの１つだと思っています.\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e最近 \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e が気になります\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e の特徴はもはやわざわざここに書くまでも無いことだと思うので書きませんが, 気になっている理由を書いてみます.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eバイナリ(しかもポータビリティが非常に高いバイナリ)に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\"\u003eコンパイル\u003c/a\u003eされること\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C/C%2B%2B\"\u003eC/C++\u003c/a\u003e には及ばずとも実行が非常に速いこと\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C/C%2B%2B\"\u003eC/C++\u003c/a\u003e ほど低レイヤーいじり放題なわけではないが, ある程度低レイヤーまで降りていけること\u003c/li\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%DE%A5%F3%A5%C9%A5%E9%A5%A4%A5%F3\"\u003eコマンドライン\u003c/a\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C4%A1%BC%A5%EB\"\u003eツール\u003c/a\u003eからWeb アプリケーションのような高レイヤーまで十分得意であること\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einterface\u003c/code\u003e による抽象化が, 過度でなく調度良く感じられること\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eこんな感じでしょうか.\u003cbr/\u003e\nCompiled \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\"\u003ePython\u003c/a\u003e っていう感じが非常に良さそうだなーと思っています.\u003c/p\u003e\n\n\u003cp\u003eというわけで\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eに引き続き \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e でも echo サーバを書いてみました\u003c/p\u003e\n\n\u003cpre class=\"code lang-go\" data-lang=\"go\" data-unlink\u003e\u003cspan class=\"synStatement\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"synStatement\"\u003eimport\u003c/span\u003e (\n    \u003cspan class=\"synConstant\"\u003e\u0026quot;fmt\u0026quot;\u003c/span\u003e\n    \u003cspan class=\"synConstant\"\u003e\u0026quot;io\u0026quot;\u003c/span\u003e\n    \u003cspan class=\"synConstant\"\u003e\u0026quot;net\u0026quot;\u003c/span\u003e\n)\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e main() {\n    listener, err := net.Listen(\u003cspan class=\"synConstant\"\u003e\u0026quot;tcp\u0026quot;\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e\u0026quot;:8080\u0026quot;\u003c/span\u003e)\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e err != \u003cspan class=\"synStatement\"\u003enil\u003c/span\u003e {\n        \u003cspan class=\"synStatement\"\u003epanic\u003c/span\u003e(err)\n    }\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e {\n        conn, err := listener.Accept()\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e err != \u003cspan class=\"synStatement\"\u003enil\u003c/span\u003e {\n            \u003cspan class=\"synStatement\"\u003epanic\u003c/span\u003e(err)\n        }\n        \u003cspan class=\"synStatement\"\u003ego\u003c/span\u003e \u003cspan class=\"synType\"\u003efunc\u003c/span\u003e(conn net.Conn) {\n            \u003cspan class=\"synStatement\"\u003edefer\u003c/span\u003e conn.Close()\n            echo(conn)\n        }(conn)\n    }\n}\n\n\u003cspan class=\"synStatement\"\u003efunc\u003c/span\u003e echo(conn net.Conn) {\n    buf := \u003cspan class=\"synStatement\"\u003emake\u003c/span\u003e([]\u003cspan class=\"synType\"\u003ebyte\u003c/span\u003e, \u003cspan class=\"synConstant\"\u003e256\u003c/span\u003e)\n    \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e {\n        n, err := conn.Read(buf)\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e err != \u003cspan class=\"synStatement\"\u003enil\u003c/span\u003e {\n            \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e err == io.EOF {\n                \u003cspan class=\"synStatement\"\u003ebreak\u003c/span\u003e\n            }\n            \u003cspan class=\"synStatement\"\u003epanic\u003c/span\u003e(err)\n        }\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e n == \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e {\n            \u003cspan class=\"synStatement\"\u003ebreak\u003c/span\u003e\n        }\n        wn, err := conn.Write(buf[\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e:n])\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e err != \u003cspan class=\"synStatement\"\u003enil\u003c/span\u003e {\n            \u003cspan class=\"synStatement\"\u003epanic\u003c/span\u003e(err)\n        }\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e wn != n {\n            \u003cspan class=\"synStatement\"\u003epanic\u003c/span\u003e(fmt.Errorf(\u003cspan class=\"synConstant\"\u003e\u0026quot;could not send all data\u0026quot;\u003c/span\u003e))\n        }\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eさすがは \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003e というかなんというか. ものすごく普通な空気を感じますね.\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003eはこういう普通さが売りの１つだと思っています.\u003c/p\u003e\n\n---\n\n---\n","slug":"Golangでechoサーバ","title":"Golangでechoサーバ","timestamp":1441696450000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Haskellでechoサーバ\"\ndate: 2015-07-23T12:43:44.000Z\ntags: []\n---\n\n\u003cp\u003eはいどうもー\u003cbr/\u003e\n引き続き\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eの話題です. ちょっと\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eで\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\"\u003eTCP\u003c/a\u003eソケットを使ってみたくなったので, まず簡単なものから実装してみます.\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\"\u003eTCP\u003c/a\u003eソケットの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C1%A5%E5%A1%BC%A5%C8%A5%EA%A5%A2%A5%EB\"\u003eチュートリアル\u003c/a\u003eといえばechoサーバですね！クライアントからの入力をそのまま返すサーバです.\u003cbr/\u003e\nせっかくなのできちんと\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eクライアントとの同時通信を可能にしましょう.\u003c/p\u003e\n\n\u003ch1\u003eNetwork.Socket\u003c/h1\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eで\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\"\u003eTCP\u003c/a\u003eソケットを使うには, \u003ccode\u003eNetwork.Socket\u003c/code\u003eを使うようです. \u003ca href=\"http://hackage.haskell.org/package/network-2.6.2.1/docs/Network-Socket.html\"\u003eNetwork.Socket\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eドキュメントには, 低レベル\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003eが\u003ccode\u003eNetwork.Socket\u003c/code\u003eで, 高レベル\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003eが\u003ccode\u003eNetwork\u003c/code\u003eと書いてあるのですが, \u003ccode\u003eNetwork\u003c/code\u003eモジュールのドキュメントには, 互換性のために残してあるけどこれから使う人は\u003ccode\u003eNetwork.Socket\u003c/code\u003eを使ってくれみたいなことが書いてあります.\u003cbr/\u003e\n適当に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%B0%A4%EB\"\u003eググる\u003c/a\u003eと\u003ccode\u003eNetwork\u003c/code\u003eモジュールを使ったサンプルが散見されますが, ここはドキュメントにしたがって, \u003ccode\u003eNetwork.Socket\u003c/code\u003eを使用することにします.\u003c/p\u003e\n\n\u003ch1\u003eソケットの用意\u003c/h1\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\"\u003eTCP\u003c/a\u003eのサーバ側は, ソケットの作成 -\u003e ソケットをポート番号指定でbind -\u003e 接続受付を開始(listen) -\u003e 接続を受け付ける(accept) というステップを踏む必要があります.\u003cbr/\u003e\nというわけでまずは指定したポート番号にbindされたソケットを用意するアクションを定義します.\u003c/p\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003eimport\u003c/span\u003e Network.Socket\n\nserveSocket \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e PortNumber \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e Socket\nserveSocket port \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n    soc \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e socket AF_INET Stream defaultProtocol\n    addr \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e inet_addr \u003cspan class=\"synConstant\"\u003e\u0026quot;0.0.0.0\u0026quot;\u003c/span\u003e\n    bind soc (SockAddrInet port addr)\n    return soc\n\u003c/pre\u003e\n\n\u003cp\u003eこれで引数に渡したポート番号にbindされたソケットが作成されます.\u003c/p\u003e\n\n\u003ch2\u003eaccept\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eクライアントとの同時通信を実現するためには, \u003ccode\u003eControl.Concurrent\u003c/code\u003eのちからを借ります.\u003cbr/\u003e\n今回は \u003ccode\u003eforkIO\u003c/code\u003e を使って, 各コネクションごとにスレッドを起動していくことにします. (非同期版も作れるのかな？つくれたらつくります)\u003c/p\u003e\n\n\u003cp\u003eというわけで次は \u003ccode\u003eaccept\u003c/code\u003eして\u003ccode\u003eforkIO\u003c/code\u003eするという処理を繰り返し行うアクションを定義します.\u003cbr/\u003e\n\u003ccode\u003eforkIO\u003c/code\u003e した後に実行するアクション(\u003ccode\u003eechoLoop\u003c/code\u003e)についてはとりあえず\u003ccode\u003eundefined\u003c/code\u003eとします. \u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eの\u003ccode\u003eundefined\u003c/code\u003e, とても便利ですね. 型で考えるっていうスタイルが実行しやすくなっているのは, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\"\u003eソースコード\u003c/a\u003e上にトッ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%EC%A5%D9\"\u003eプレベ\u003c/a\u003eル関数の型指定を書きやすい\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eの文法と\u003ccode\u003eundefined\u003c/code\u003eのおかげって感じがします.\u003c/p\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003eechoLoop \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e Socket \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e IO ()\nechoLoop \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e undefined\n\n\u003cspan class=\"synComment\"\u003e-- import Control.Concurrent\u003c/span\u003e\n\u003cspan class=\"synComment\"\u003e-- import Control.Monad\u003c/span\u003e\n\u003cspan class=\"synComment\"\u003e-- が必要\u003c/span\u003e\nacceptLoop \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e Socket \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e IO ()\nacceptLoop soc \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e forever \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n    (conn, _addr) \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e accept soc\n    forkIO \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e echoLoop conn\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eforever :: Monad m =\u0026gt; m a -\u0026gt; m b\u003c/code\u003eは引数にIOアクションを受け取り, それを無限に繰り返し実行し続けます. (無限にくりかえすので返り値の型変数\u003ccode\u003eb\u003c/code\u003eは不定)\u003cbr/\u003e\n\u003ccode\u003eforever\u003c/code\u003eの引数には, \u003ccode\u003eaccept\u003c/code\u003eして\u003ccode\u003eforkIO\u003c/code\u003eするアクションを渡しています.\u003c/p\u003e\n\n\u003ch1\u003eecho\u003c/h1\u003e\n\n\u003cp\u003e最後にソケットから読み込み, そのまま書き出す\u003ccode\u003eechoLoop\u003c/code\u003e部分を作ります.\u003c/p\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003e\u003cspan class=\"synComment\"\u003e-- import Control.Exception が必要\u003c/span\u003e\nechoLoop \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e Socket \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e IO ()\nechoLoop conn \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n    sequence_ \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e repeat \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n        (str, _, _) \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e recvFrom soc \u003cspan class=\"synConstant\"\u003e64\u003c/span\u003e\n        send soc str\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003erecvFrom :: Socket -\u0026gt; Int -\u0026gt; IO (String, Int, SockAddr)\u003c/code\u003eは, \u003ccode\u003erecvFrom conn n\u003c/code\u003e で, \u003ccode\u003econn\u003c/code\u003eから最大で\u003ccode\u003en\u003c/code\u003e文字まで読み込みます.\n返り値は, \u003ccode\u003e(読み込んだ文字列, 読み込んだ文字数, 読み込み元のアドレス??)\u003c/code\u003e を返します.\u003cbr/\u003e\nそして, \u003ccode\u003esend :: Socket -\u0026gt; String -\u0026gt; IO ()\u003c/code\u003e でソケットに読み込んだ文字列をそのまま書き込みます.\u003cbr/\u003e\nこのように, 読み込んでそのままｍ書き込むというアクションを \u003ccode\u003erepeat\u003c/code\u003eでつなげています. \u003ccode\u003erepeat :: a -\u0026gt; [a]\u003c/code\u003eは無限リストを作る関数です. \u003ccode\u003erepeat 0\u003c/code\u003eで\u003ccode\u003e[0, 0, 0, 0, ...\u003c/code\u003eというリストが作成されます. \u003cbr/\u003e\nこのままでは \u003ccode\u003e[IO ()]\u003c/code\u003e型なので, これを\u003ccode\u003esequence_ :: Monad m =\u0026gt; [m a] -\u0026gt; m ()\u003c/code\u003eを使って１つのIOアクションにまとめ上げます.\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eが遅延評価だから出来る芸当ですね. 無限に繰り返す感あふれるコードになっている気がします. (\u003ccode\u003eforever\u003c/code\u003e使ったほうがいいと思います)\u003c/p\u003e\n\n\u003ch1\u003e例外処理\u003c/h1\u003e\n\n\u003cp\u003e\u003ccode\u003erecvFrom\u003c/code\u003eは相手側がコネクションを切断すると\u003ccode\u003eEnd of file\u003c/code\u003eの例外を投げます. \u003ccode\u003eforkIO\u003c/code\u003eしているので, １つのスレッドが例外で落ちてもサーバ全体は動き続けますが, ソケットのクローズも出来ませんし, 標準エラーになんかでてきてよろしくないので修正します.\u003c/p\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003e\u003cspan class=\"synComment\"\u003e-- import Control.Exceptionが必要\u003c/span\u003e\nechoLoop \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e Socket \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e IO ()\nechoLoop conn \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n   sequence_ \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e repeat \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n       (str, _, _) \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e recvFrom conn \u003cspan class=\"synConstant\"\u003e64\u003c/span\u003e\n       send conn str\n   \u003cspan class=\"synStatement\"\u003e`catch`\u003c/span\u003e (\u003cspan class=\"synStatement\"\u003e\\\u003c/span\u003e(SomeException e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e return ())\n   \u003cspan class=\"synStatement\"\u003e`finally`\u003c/span\u003e close conn\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003ecatch\u003c/code\u003eと\u003ccode\u003efinally\u003c/code\u003eを追加しています.\u003cbr/\u003e\nどちらも\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003eとかのそれと同じように動きます.\u003cbr/\u003e\n\u003ccode\u003eSomeException\u003c/code\u003eはすべての例外を補足することが出来ますが, ほんとはあんまり良くないですね. ここではEOFに達した(コネクションが切断された)という場合だけを補足したいので. (どの関数がどういう場合にどんな例外を投げるのかっていうドキュメントがわからなかったのでこのままにしておきました)\u003cbr/\u003e\nそして, 例外が発生してもしなくても, 最後にかならずソケットのクローズをするよう\u003ccode\u003efinally\u003c/code\u003eを使います.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eSomeException\u003c/code\u003eですべての例外が捕捉出来るのって不思議じゃないですか？\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eには\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A5%D6%A5%B8%A5%A7%A5%AF%A5%C8%BB%D8%B8%FE\"\u003eオブジェクト指向\u003c/a\u003eっぽい型の階層関係なんてないのに.\n\u003ca href=\"http://d.hatena.ne.jp/kazu-yamamoto/20081024/1224819961\"\u003eHaskellの多相性 - あどけない話\u003c/a\u003eこのへんが関係しているっぽいなという感じがしますが詳しいことはよくわかりませんでした...\u003c/p\u003e\n\n\u003ch1\u003e全体\u003c/h1\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003e\u003cspan class=\"synType\"\u003emodule\u003c/span\u003e Main \u003cspan class=\"synType\"\u003ewhere\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003eimport\u003c/span\u003e Network.Socket\n\u003cspan class=\"synPreProc\"\u003eimport\u003c/span\u003e Control.Monad\n\u003cspan class=\"synPreProc\"\u003eimport\u003c/span\u003e Control.Concurrent\n\u003cspan class=\"synPreProc\"\u003eimport\u003c/span\u003e Control.Exception\n\nmain \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e IO ()\nmain \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n    soc \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e serveSocket \u003cspan class=\"synConstant\"\u003e8080\u003c/span\u003e\n    listen soc \u003cspan class=\"synConstant\"\u003e5\u003c/span\u003e\n    acceptLoop soc \u003cspan class=\"synStatement\"\u003e`finally`\u003c/span\u003e close soc\n\nserveSocket \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e PortNumber \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e IO Socket\nserveSocket port \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n    soc \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e socket AF_INET Stream defaultProtocol\n    addr \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e inet_addr \u003cspan class=\"synConstant\"\u003e\u0026quot;0.0.0.0\u0026quot;\u003c/span\u003e\n    bind soc (SockAddrInet port addr)\n    return soc\n\nacceptLoop \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e Socket \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e IO ()\nacceptLoop soc \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e forever \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n    (conn, addr) \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e accept soc\n    forkIO \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e echoLoop conn\n\nechoLoop \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e Socket \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e IO ()\nechoLoop conn \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n    sequence_ \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e repeat \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n      (str, _, _) \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e recvFrom conn \u003cspan class=\"synConstant\"\u003e64\u003c/span\u003e\n      send conn str\n    \u003cspan class=\"synStatement\"\u003e`catch`\u003c/span\u003e (\u003cspan class=\"synStatement\"\u003e\\\u003c/span\u003e(SomeException e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e return ())\n    \u003cspan class=\"synStatement\"\u003e`finally`\u003c/span\u003e close conn\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003emain\u003c/code\u003e内で \u003ccode\u003elisten\u003c/code\u003eするのを忘れずに！また, \u003ccode\u003eacceptLoop\u003c/code\u003e中に例外が発生してもソケットをクローズするように\u003ccode\u003efinally\u003c/code\u003eを使っています. (まぁプログラム終了するのでいらない気もします)\u003c/p\u003e\n\n\u003ch1\u003e動作確認\u003c/h1\u003e\n\n\u003cp\u003e\u003ccode\u003etelnet\u003c/code\u003eコマンドでテストします.\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e% telnet localhost 8080\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is \u0026#39;^]\u0026#39;.\ntest\ntest\naaa\naaa\nhooooogle\nhooooogle\u003c/pre\u003e\n\n\u003cp\u003eちょっとわかりづらいですが, 入力した文字列が即座にそのまま帰ってきていることがわかります. バッファリングの関係で, 一行ずつになっていますが.\u003c/p\u003e\n\n\u003ch1\u003eまとめ\u003c/h1\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eでechoサーバ, 意外とすんなりかけましたね. 例外関係があまりよく理解できていない感じがしますが...\u003cbr/\u003e\n非同期版が気になります. 調べてみます.\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eはいどうもー\u003cbr/\u003e\n引き続き\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eの話題です. ちょっと\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eで\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\"\u003eTCP\u003c/a\u003eソケットを使ってみたくなったので, まず簡単なものから実装してみます.\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\"\u003eTCP\u003c/a\u003eソケットの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C1%A5%E5%A1%BC%A5%C8%A5%EA%A5%A2%A5%EB\"\u003eチュートリアル\u003c/a\u003eといえばechoサーバですね！クライアントからの入力をそのまま返すサーバです.\u003cbr/\u003e\nせっかくなのできちんと\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eクライアントとの同時通信を可能にしましょう.\u003c/p\u003e\n\n\u003ch1\u003eNetwork.Socket\u003c/h1\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eで\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\"\u003eTCP\u003c/a\u003eソケットを使うには, \u003ccode\u003eNetwork.Socket\u003c/code\u003eを使うようです. \u003ca href=\"http://hackage.haskell.org/package/network-2.6.2.1/docs/Network-Socket.html\"\u003eNetwork.Socket\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eドキュメントには, 低レベル\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003eが\u003ccode\u003eNetwork.Socket\u003c/code\u003eで, 高レベル\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003eが\u003ccode\u003eNetwork\u003c/code\u003eと書いてあるのですが, \u003ccode\u003eNetwork\u003c/code\u003eモジュールのドキュメントには, 互換性のために残してあるけどこれから使う人は\u003ccode\u003eNetwork.Socket\u003c/code\u003eを使ってくれみたいなことが書いてあります.\u003cbr/\u003e\n適当に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%B0%A4%EB\"\u003eググる\u003c/a\u003eと\u003ccode\u003eNetwork\u003c/code\u003eモジュールを使ったサンプルが散見されますが, ここはドキュメントにしたがって, \u003ccode\u003eNetwork.Socket\u003c/code\u003eを使用することにします.\u003c/p\u003e\n\n\u003ch1\u003eソケットの用意\u003c/h1\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\"\u003eTCP\u003c/a\u003eのサーバ側は, ソケットの作成 -\u003e ソケットをポート番号指定でbind -\u003e 接続受付を開始(listen) -\u003e 接続を受け付ける(accept) というステップを踏む必要があります.\u003cbr/\u003e\nというわけでまずは指定したポート番号にbindされたソケットを用意するアクションを定義します.\u003c/p\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003eimport\u003c/span\u003e Network.Socket\n\nserveSocket \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e PortNumber \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e Socket\nserveSocket port \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n    soc \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e socket AF_INET Stream defaultProtocol\n    addr \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e inet_addr \u003cspan class=\"synConstant\"\u003e\u0026quot;0.0.0.0\u0026quot;\u003c/span\u003e\n    bind soc (SockAddrInet port addr)\n    return soc\n\u003c/pre\u003e\n\n\u003cp\u003eこれで引数に渡したポート番号にbindされたソケットが作成されます.\u003c/p\u003e\n\n\u003ch2\u003eaccept\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eクライアントとの同時通信を実現するためには, \u003ccode\u003eControl.Concurrent\u003c/code\u003eのちからを借ります.\u003cbr/\u003e\n今回は \u003ccode\u003eforkIO\u003c/code\u003e を使って, 各コネクションごとにスレッドを起動していくことにします. (非同期版も作れるのかな？つくれたらつくります)\u003c/p\u003e\n\n\u003cp\u003eというわけで次は \u003ccode\u003eaccept\u003c/code\u003eして\u003ccode\u003eforkIO\u003c/code\u003eするという処理を繰り返し行うアクションを定義します.\u003cbr/\u003e\n\u003ccode\u003eforkIO\u003c/code\u003e した後に実行するアクション(\u003ccode\u003eechoLoop\u003c/code\u003e)についてはとりあえず\u003ccode\u003eundefined\u003c/code\u003eとします. \u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eの\u003ccode\u003eundefined\u003c/code\u003e, とても便利ですね. 型で考えるっていうスタイルが実行しやすくなっているのは, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\"\u003eソースコード\u003c/a\u003e上にトッ\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%EC%A5%D9\"\u003eプレベ\u003c/a\u003eル関数の型指定を書きやすい\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eの文法と\u003ccode\u003eundefined\u003c/code\u003eのおかげって感じがします.\u003c/p\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003eechoLoop \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e Socket \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e IO ()\nechoLoop \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e undefined\n\n\u003cspan class=\"synComment\"\u003e-- import Control.Concurrent\u003c/span\u003e\n\u003cspan class=\"synComment\"\u003e-- import Control.Monad\u003c/span\u003e\n\u003cspan class=\"synComment\"\u003e-- が必要\u003c/span\u003e\nacceptLoop \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e Socket \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e IO ()\nacceptLoop soc \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e forever \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n    (conn, _addr) \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e accept soc\n    forkIO \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e echoLoop conn\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eforever :: Monad m =\u0026gt; m a -\u0026gt; m b\u003c/code\u003eは引数にIOアクションを受け取り, それを無限に繰り返し実行し続けます. (無限にくりかえすので返り値の型変数\u003ccode\u003eb\u003c/code\u003eは不定)\u003cbr/\u003e\n\u003ccode\u003eforever\u003c/code\u003eの引数には, \u003ccode\u003eaccept\u003c/code\u003eして\u003ccode\u003eforkIO\u003c/code\u003eするアクションを渡しています.\u003c/p\u003e\n\n\u003ch1\u003eecho\u003c/h1\u003e\n\n\u003cp\u003e最後にソケットから読み込み, そのまま書き出す\u003ccode\u003eechoLoop\u003c/code\u003e部分を作ります.\u003c/p\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003e\u003cspan class=\"synComment\"\u003e-- import Control.Exception が必要\u003c/span\u003e\nechoLoop \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e Socket \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e IO ()\nechoLoop conn \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n    sequence_ \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e repeat \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n        (str, _, _) \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e recvFrom soc \u003cspan class=\"synConstant\"\u003e64\u003c/span\u003e\n        send soc str\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003erecvFrom :: Socket -\u0026gt; Int -\u0026gt; IO (String, Int, SockAddr)\u003c/code\u003eは, \u003ccode\u003erecvFrom conn n\u003c/code\u003e で, \u003ccode\u003econn\u003c/code\u003eから最大で\u003ccode\u003en\u003c/code\u003e文字まで読み込みます.\n返り値は, \u003ccode\u003e(読み込んだ文字列, 読み込んだ文字数, 読み込み元のアドレス??)\u003c/code\u003e を返します.\u003cbr/\u003e\nそして, \u003ccode\u003esend :: Socket -\u0026gt; String -\u0026gt; IO ()\u003c/code\u003e でソケットに読み込んだ文字列をそのまま書き込みます.\u003cbr/\u003e\nこのように, 読み込んでそのままｍ書き込むというアクションを \u003ccode\u003erepeat\u003c/code\u003eでつなげています. \u003ccode\u003erepeat :: a -\u0026gt; [a]\u003c/code\u003eは無限リストを作る関数です. \u003ccode\u003erepeat 0\u003c/code\u003eで\u003ccode\u003e[0, 0, 0, 0, ...\u003c/code\u003eというリストが作成されます. \u003cbr/\u003e\nこのままでは \u003ccode\u003e[IO ()]\u003c/code\u003e型なので, これを\u003ccode\u003esequence_ :: Monad m =\u0026gt; [m a] -\u0026gt; m ()\u003c/code\u003eを使って１つのIOアクションにまとめ上げます.\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eが遅延評価だから出来る芸当ですね. 無限に繰り返す感あふれるコードになっている気がします. (\u003ccode\u003eforever\u003c/code\u003e使ったほうがいいと思います)\u003c/p\u003e\n\n\u003ch1\u003e例外処理\u003c/h1\u003e\n\n\u003cp\u003e\u003ccode\u003erecvFrom\u003c/code\u003eは相手側がコネクションを切断すると\u003ccode\u003eEnd of file\u003c/code\u003eの例外を投げます. \u003ccode\u003eforkIO\u003c/code\u003eしているので, １つのスレッドが例外で落ちてもサーバ全体は動き続けますが, ソケットのクローズも出来ませんし, 標準エラーになんかでてきてよろしくないので修正します.\u003c/p\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003e\u003cspan class=\"synComment\"\u003e-- import Control.Exceptionが必要\u003c/span\u003e\nechoLoop \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e Socket \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e IO ()\nechoLoop conn \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n   sequence_ \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e repeat \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n       (str, _, _) \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e recvFrom conn \u003cspan class=\"synConstant\"\u003e64\u003c/span\u003e\n       send conn str\n   \u003cspan class=\"synStatement\"\u003e`catch`\u003c/span\u003e (\u003cspan class=\"synStatement\"\u003e\\\u003c/span\u003e(SomeException e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e return ())\n   \u003cspan class=\"synStatement\"\u003e`finally`\u003c/span\u003e close conn\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003ecatch\u003c/code\u003eと\u003ccode\u003efinally\u003c/code\u003eを追加しています.\u003cbr/\u003e\nどちらも\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\"\u003eJava\u003c/a\u003eとかのそれと同じように動きます.\u003cbr/\u003e\n\u003ccode\u003eSomeException\u003c/code\u003eはすべての例外を補足することが出来ますが, ほんとはあんまり良くないですね. ここではEOFに達した(コネクションが切断された)という場合だけを補足したいので. (どの関数がどういう場合にどんな例外を投げるのかっていうドキュメントがわからなかったのでこのままにしておきました)\u003cbr/\u003e\nそして, 例外が発生してもしなくても, 最後にかならずソケットのクローズをするよう\u003ccode\u003efinally\u003c/code\u003eを使います.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eSomeException\u003c/code\u003eですべての例外が捕捉出来るのって不思議じゃないですか？\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eには\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A5%D6%A5%B8%A5%A7%A5%AF%A5%C8%BB%D8%B8%FE\"\u003eオブジェクト指向\u003c/a\u003eっぽい型の階層関係なんてないのに.\n\u003ca href=\"http://d.hatena.ne.jp/kazu-yamamoto/20081024/1224819961\"\u003eHaskellの多相性 - あどけない話\u003c/a\u003eこのへんが関係しているっぽいなという感じがしますが詳しいことはよくわかりませんでした...\u003c/p\u003e\n\n\u003ch1\u003e全体\u003c/h1\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003e\u003cspan class=\"synType\"\u003emodule\u003c/span\u003e Main \u003cspan class=\"synType\"\u003ewhere\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003eimport\u003c/span\u003e Network.Socket\n\u003cspan class=\"synPreProc\"\u003eimport\u003c/span\u003e Control.Monad\n\u003cspan class=\"synPreProc\"\u003eimport\u003c/span\u003e Control.Concurrent\n\u003cspan class=\"synPreProc\"\u003eimport\u003c/span\u003e Control.Exception\n\nmain \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e IO ()\nmain \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n    soc \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e serveSocket \u003cspan class=\"synConstant\"\u003e8080\u003c/span\u003e\n    listen soc \u003cspan class=\"synConstant\"\u003e5\u003c/span\u003e\n    acceptLoop soc \u003cspan class=\"synStatement\"\u003e`finally`\u003c/span\u003e close soc\n\nserveSocket \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e PortNumber \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e IO Socket\nserveSocket port \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n    soc \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e socket AF_INET Stream defaultProtocol\n    addr \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e inet_addr \u003cspan class=\"synConstant\"\u003e\u0026quot;0.0.0.0\u0026quot;\u003c/span\u003e\n    bind soc (SockAddrInet port addr)\n    return soc\n\nacceptLoop \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e Socket \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e IO ()\nacceptLoop soc \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e forever \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n    (conn, addr) \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e accept soc\n    forkIO \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e echoLoop conn\n\nechoLoop \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e Socket \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e IO ()\nechoLoop conn \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n    sequence_ \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e repeat \u003cspan class=\"synStatement\"\u003e$\u003c/span\u003e \u003cspan class=\"synStatement\"\u003edo\u003c/span\u003e\n      (str, _, _) \u003cspan class=\"synStatement\"\u003e\u0026lt;-\u003c/span\u003e recvFrom conn \u003cspan class=\"synConstant\"\u003e64\u003c/span\u003e\n      send conn str\n    \u003cspan class=\"synStatement\"\u003e`catch`\u003c/span\u003e (\u003cspan class=\"synStatement\"\u003e\\\u003c/span\u003e(SomeException e) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e return ())\n    \u003cspan class=\"synStatement\"\u003e`finally`\u003c/span\u003e close conn\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003emain\u003c/code\u003e内で \u003ccode\u003elisten\u003c/code\u003eするのを忘れずに！また, \u003ccode\u003eacceptLoop\u003c/code\u003e中に例外が発生してもソケットをクローズするように\u003ccode\u003efinally\u003c/code\u003eを使っています. (まぁプログラム終了するのでいらない気もします)\u003c/p\u003e\n\n\u003ch1\u003e動作確認\u003c/h1\u003e\n\n\u003cp\u003e\u003ccode\u003etelnet\u003c/code\u003eコマンドでテストします.\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e% telnet localhost 8080\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is \u0026#39;^]\u0026#39;.\ntest\ntest\naaa\naaa\nhooooogle\nhooooogle\u003c/pre\u003e\n\n\u003cp\u003eちょっとわかりづらいですが, 入力した文字列が即座にそのまま帰ってきていることがわかります. バッファリングの関係で, 一行ずつになっていますが.\u003c/p\u003e\n\n\u003ch1\u003eまとめ\u003c/h1\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eでechoサーバ, 意外とすんなりかけましたね. 例外関係があまりよく理解できていない感じがしますが...\u003cbr/\u003e\n非同期版が気になります. 調べてみます.\u003c/p\u003e\n\n---\n\n---\n","slug":"Haskellでechoサーバ","title":"Haskellでechoサーバ","timestamp":1437655424000,"tags":[]},{"rawMarkdown":"---\ntitle: \"HaskellのConcurrentについて調べてまとめる (MVar編)\"\ndate: 2015-07-22T01:21:48.000Z\ntags: []\n---\n\n\u003cp\u003eどうもこんにちは.\u003c/p\u003e\n\n\u003cp\u003e前回(\u003ca href=\"http://agtn.hatenablog.com/entry/2015/07/21/234658\"\u003eHaskellのConcurrentについて調べてまとめる (IORef編) - プログラミングのメモ帳➚\u003c/a\u003e)の続きです.\u003c/p\u003e\n\n\u003cp\u003e今回はスレッド間協調のために\u003ccode\u003eMVar\u003c/code\u003eを使う方法について調べたので, まとめたいと思います.\u003c/p\u003e\n\n\u003ch2\u003eMVar\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eにかかわらず, 最近の並行処理はメッセージパッシングでやれみたいなのが流行ってますね (\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scala\"\u003eScala\u003c/a\u003eのAkkaや\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003eのchanなど).\u003cbr/\u003e\n\u003ccode\u003eMVar\u003c/code\u003eは\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eにおける, 容量1のメッセージボックスのようなものです. \u003ccode\u003eMVar\u003c/code\u003eを使うことで, スレッド間でメッセージのやり取りを協調的に行うことができます.\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eのスレッドが１つの\u003ccode\u003eMVar\u003c/code\u003eに対して, メッセージを入れたり取り出したりすることでスレッド間協調を行います.\u003c/p\u003e\n\n\u003cp\u003e基本となる\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003eはこのような感じ\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003enewEmptyMVar :: IO (MVar a)\nnewMVar :: a -\u0026gt; IO (MVar a)\ntakeMVar :: MVar a -\u0026gt; IO a\nputMVar :: MVar a -\u0026gt; a -\u0026gt; IO ()\nreadMVar :: MVar a -\u0026gt; IO a\u003c/pre\u003e\n\n\u003cp\u003e型を見ればなんとなく使い方もわかる気がしますね.\u003cbr/\u003e\n\u003ccode\u003eMVar\u003c/code\u003eを作るには\u003ccode\u003enewEmptyMVar\u003c/code\u003eか\u003ccode\u003enewMVar\u003c/code\u003eを使用します. \u003ccode\u003enewEmptyMVar\u003c/code\u003eは空のメッセージボックスを作り, \u003ccode\u003enewMVar\u003c/code\u003eは第一引数を初期値としてもつメッセージボックスを作ります.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eMVar\u003c/code\u003eにメッセージを格納するには, \u003ccode\u003eputMVar\u003c/code\u003eを使います. \u003ccode\u003eputMVar mvar msg\u003c/code\u003e で, \u003ccode\u003emsg\u003c/code\u003eを\u003ccode\u003emvar\u003c/code\u003eに格納します.\u003cbr/\u003e\nこの際, もし\u003ccode\u003eMVar\u003c/code\u003eにすでにメッセージが格納されている場合, \u003ccode\u003eMVar\u003c/code\u003eは容量1のボックスなので, \u003ccode\u003eputMVar\u003c/code\u003eがブロックされます. 他のスレッドが\u003ccode\u003eMVar\u003c/code\u003eからメッセージを取り出して空にするまで待ってから, メッセージを格納します.\u003c/p\u003e\n\n\u003cp\u003e一方, \u003ccode\u003eMVar\u003c/code\u003eからメッセージを読み取るには, \u003ccode\u003etakeMVar\u003c/code\u003eか\u003ccode\u003ereadMVar\u003c/code\u003eを使用します.\u003cbr/\u003e\n\u003ccode\u003etakeMVar\u003c/code\u003eはメッセージを読み取り, その\u003ccode\u003eMVar\u003c/code\u003eを空にします. \u003ccode\u003ereadMVar\u003c/code\u003eはメッセージを読み取りますが, \u003ccode\u003eMVar\u003c/code\u003eの中のメッセージはそのまま残します.\u003cbr/\u003e\nここで, \u003ccode\u003eput\u003c/code\u003eの時と同様に, \u003ccode\u003etakeMVar\u003c/code\u003eも\u003ccode\u003ereadMVar\u003c/code\u003eも\u003ccode\u003eMVar\u003c/code\u003eにメッセージが格納されていなかった場合, 他のスレッドが\u003ccode\u003eMVar\u003c/code\u003eにメッセージを格納するまでブロックします.\u003c/p\u003e\n\n\u003cp\u003eというわけで簡単なサンプルコード\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003emodule Main where\n\nimport Control.Concurrent (forkIO, threadDelay)\nimport Control.Concurrent.MVar\n\nmain :: IO ()\nmain = do\n    mvar \u0026lt;- newEmptyMVar\n    forkIO $ do\n        msg \u0026lt;- takeMVar mvar\n        putStrLn $ \u0026#34;recv: \u0026#34; ++ msg\n        threadDelay $ 1 * 10 ^ 6\n        putMVar mvar \u0026#34;B\u0026#34;\n    putStrLn \u0026#34;sleep 1\u0026#34;\n    threadDelay $ 1 * 10 ^ 6\n    putStrLn \u0026#34;wake up\u0026#34;\n    putMVar mvar \u0026#34;A\u0026#34;\n    takeMVar mvar \u0026gt;\u0026gt;= print\u003c/pre\u003e\n\n\u003cp\u003e実行結果\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003esleep 1\nwake up\nrecv: A\n\u0026#34;B\u0026#34;\u003c/pre\u003e\n\n\u003cp\u003e確かにメッセージが格納されるまで \u003ccode\u003etakeMVar\u003c/code\u003eがブロックしていることがわかります\u003c/p\u003e\n\n\u003ch2\u003e共有変数としてのMVar\u003c/h2\u003e\n\n\u003cp\u003eさて, \u003ccode\u003eMVar\u003c/code\u003eにはもうひとつの使い方があります. 共有変数としての\u003ccode\u003eMVar\u003c/code\u003eです.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eMVar\u003c/code\u003eの特徴として, 誰かが\u003ccode\u003etake\u003c/code\u003eしてから\u003ccode\u003eput\u003c/code\u003eするまでの間は, 他のスレッドはだれも\u003ccode\u003eMVar\u003c/code\u003eの中身に触れないという点が挙げられます.\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003emain = do\n    mvar \u0026lt;- newMVar 0\n    forkIO $ do\n        val \u0026lt;- takeMVar mvar\n        -- 他のスレッドはMVarの中身に触れない\n        putMVar mvar $ val + 1\n    ...\u003c/pre\u003e\n\n\u003cp\u003eこの特徴はまさにロックの特徴といえます. ロックを取得し解放するまでは, 他のスレッドは同じロックで保護された区間にははいれません.\u003cbr/\u003e\nというわけで\u003ccode\u003eMVar\u003c/code\u003eは型レベルでロックがついた共有変数とみなすことができますね！(このへんはRustのMutexに似た空気を感じます. どちらも型レベルでロックとそれが保護する中身がつながっています)\u003cbr/\u003e\n型レベルでロックがくっついているので, 中身にアクセスするには必ずロックをとる(\u003ccode\u003etakeMVar\u003c/code\u003e)必要があり, ロックの取得忘れがありません.\u003c/p\u003e\n\n\u003cp\u003eさらに, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eは基本的に破壊的操作があまり登場しない言語であることもこの\u003ccode\u003eMVar\u003c/code\u003eロックにプラスに働きます.\u003c/p\u003e\n\n\u003cp\u003e例えば, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CF%A2%C1%DB%C7%DB%CE%F3\"\u003e連想配列\u003c/a\u003eをスレッド間で共有することを考えます. また, ここでは\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CF%A2%C1%DB%C7%DB%CE%F3\"\u003e連想配列\u003c/a\u003eの実装として, hashtableではなく\u003ccode\u003eData.Map\u003c/code\u003eを使用するとします(\u003ccode\u003eData.Map\u003c/code\u003eはimmutableな構造になっていて, lookupはO(log n)ですが, immutableなので\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e上で扱いやすいというメリットがあります).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eData.Map\u003c/code\u003eはimmutableなので, 一度\u003ccode\u003eMVar\u003c/code\u003eから取得してしまえばそれ以降変更される可能性もないため, ロックを保持し続ける必要がありません. そこで, 単なる読み込みの場合は, \u003ccode\u003etakeMVar\u003c/code\u003eしてすぐに\u003ccode\u003eputMVar\u003c/code\u003eで戻すだとか, \u003ccode\u003ereadMVar\u003c/code\u003eで読み込むだけにすることで, ロックの粒度を小さくできます.\u003cbr/\u003e\n\u003ccode\u003eMVar\u003c/code\u003eの中身を書き換えたい場合は, 単純にロックを取得し, 書き換え後の値を\u003ccode\u003eputMVar\u003c/code\u003eします.\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003emodule Main where\n\nimport Control.Concurrent (forkIO, threadDelay)\nimport Control.Concurrent.MVar\nimport qualified Data.Map.Strict as M\n\nmain :: IO ()\nmain = do\n    mvar \u0026lt;- newMVar M.empty\n    forkIO $ do\n        table \u0026lt;- takeMVar mvar\n        putMVar mvar table\n        -- tableを使用する操作\n    forkIO $ do\n         table \u0026lt;- readMVar mvar\n         -- tableを使用する操作\n    forkIO $ do\n        table \u0026lt;- takeMVar mvar\n        -- tableを変更する操作\n        let newTable = ...\n        putMVar mvar newTable\u003c/pre\u003e\n\n\u003cp\u003eこのように\u003ccode\u003eMVar\u003c/code\u003eとimmutableなデータ構造を組み合わせることで, 粒度の小さいロックを実現することができます.\u003cbr/\u003e\n一方, \u003ccode\u003eMVar\u003c/code\u003eとmutableなデータ構造(\u003ccode\u003eIORef\u003c/code\u003eなど)を組み合わせる場合は, たとえ読み込みしかしない場合であっても操作が終わるまではロックを保持しておく必要があることに注意しなければなりません (\u003ccode\u003eIORef\u003c/code\u003eには前回紹介したように\u003ccode\u003eatomicModifyIORef\u003c/code\u003eがあるのでなかなかこういう状況は起こりませんね)\u003c/p\u003e\n\n\u003cp\u003eまた, RustのMutexと違い, \u003ccode\u003eMVar\u003c/code\u003eによるロックの模倣(?)はロックの解放を自動的には行いません. したがって例外が送出された場合にロックを開放し忘れるケースがあるので, 注意が必要です.\u003c/p\u003e\n\n\u003ch2\u003e一旦まとめ\u003c/h2\u003e\n\n\u003cp\u003eというわけで今回は\u003ccode\u003eMVar\u003c/code\u003eについて紹介しました. \u003ccode\u003eMVar\u003c/code\u003eでロックを実現する方に関しては, 散々言われているロックの問題点をそのまま持ってきてしまうのであまり使えないかもしれませんね...\u003cbr/\u003e\n\u003ccode\u003eMVar\u003c/code\u003eは容量1のメッセージボックスでしたが, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eには\u003ccode\u003eChan\u003c/code\u003eというものもあります. こちらは\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003eのchanにかなり近いもので, 容量の制限がないキューのように働かせることができます. \u003ccode\u003eChan\u003c/code\u003eのよみとり専用のスレッドを１つ立てておき, 他の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eのスレッドがタスクを\u003ccode\u003eChan\u003c/code\u003eに書き込んでいくといった\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\"\u003eユースケース\u003c/a\u003eが考えられますね. こっちのほうが便利そうな気がしてきました.\u003c/p\u003e\n\n\u003cp\u003eロックはいろいろ厄介で, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%C3%A5%C9%A5%ED%A5%C3%A5%AF\"\u003eデッドロック\u003c/a\u003eとか解放忘れとかの問題がついて回ります. それを解決する１つの方法として\u003ccode\u003eSTM\u003c/code\u003eがあるようなので, 次はそれについて調べてみようと思います.\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eどうもこんにちは.\u003c/p\u003e\n\n\u003cp\u003e前回(\u003ca href=\"http://agtn.hatenablog.com/entry/2015/07/21/234658\"\u003eHaskellのConcurrentについて調べてまとめる (IORef編) - プログラミングのメモ帳➚\u003c/a\u003e)の続きです.\u003c/p\u003e\n\n\u003cp\u003e今回はスレッド間協調のために\u003ccode\u003eMVar\u003c/code\u003eを使う方法について調べたので, まとめたいと思います.\u003c/p\u003e\n\n\u003ch2\u003eMVar\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eにかかわらず, 最近の並行処理はメッセージパッシングでやれみたいなのが流行ってますね (\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scala\"\u003eScala\u003c/a\u003eのAkkaや\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003eのchanなど).\u003cbr/\u003e\n\u003ccode\u003eMVar\u003c/code\u003eは\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eにおける, 容量1のメッセージボックスのようなものです. \u003ccode\u003eMVar\u003c/code\u003eを使うことで, スレッド間でメッセージのやり取りを協調的に行うことができます.\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eのスレッドが１つの\u003ccode\u003eMVar\u003c/code\u003eに対して, メッセージを入れたり取り出したりすることでスレッド間協調を行います.\u003c/p\u003e\n\n\u003cp\u003e基本となる\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\"\u003eAPI\u003c/a\u003eはこのような感じ\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003enewEmptyMVar :: IO (MVar a)\nnewMVar :: a -\u0026gt; IO (MVar a)\ntakeMVar :: MVar a -\u0026gt; IO a\nputMVar :: MVar a -\u0026gt; a -\u0026gt; IO ()\nreadMVar :: MVar a -\u0026gt; IO a\u003c/pre\u003e\n\n\u003cp\u003e型を見ればなんとなく使い方もわかる気がしますね.\u003cbr/\u003e\n\u003ccode\u003eMVar\u003c/code\u003eを作るには\u003ccode\u003enewEmptyMVar\u003c/code\u003eか\u003ccode\u003enewMVar\u003c/code\u003eを使用します. \u003ccode\u003enewEmptyMVar\u003c/code\u003eは空のメッセージボックスを作り, \u003ccode\u003enewMVar\u003c/code\u003eは第一引数を初期値としてもつメッセージボックスを作ります.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eMVar\u003c/code\u003eにメッセージを格納するには, \u003ccode\u003eputMVar\u003c/code\u003eを使います. \u003ccode\u003eputMVar mvar msg\u003c/code\u003e で, \u003ccode\u003emsg\u003c/code\u003eを\u003ccode\u003emvar\u003c/code\u003eに格納します.\u003cbr/\u003e\nこの際, もし\u003ccode\u003eMVar\u003c/code\u003eにすでにメッセージが格納されている場合, \u003ccode\u003eMVar\u003c/code\u003eは容量1のボックスなので, \u003ccode\u003eputMVar\u003c/code\u003eがブロックされます. 他のスレッドが\u003ccode\u003eMVar\u003c/code\u003eからメッセージを取り出して空にするまで待ってから, メッセージを格納します.\u003c/p\u003e\n\n\u003cp\u003e一方, \u003ccode\u003eMVar\u003c/code\u003eからメッセージを読み取るには, \u003ccode\u003etakeMVar\u003c/code\u003eか\u003ccode\u003ereadMVar\u003c/code\u003eを使用します.\u003cbr/\u003e\n\u003ccode\u003etakeMVar\u003c/code\u003eはメッセージを読み取り, その\u003ccode\u003eMVar\u003c/code\u003eを空にします. \u003ccode\u003ereadMVar\u003c/code\u003eはメッセージを読み取りますが, \u003ccode\u003eMVar\u003c/code\u003eの中のメッセージはそのまま残します.\u003cbr/\u003e\nここで, \u003ccode\u003eput\u003c/code\u003eの時と同様に, \u003ccode\u003etakeMVar\u003c/code\u003eも\u003ccode\u003ereadMVar\u003c/code\u003eも\u003ccode\u003eMVar\u003c/code\u003eにメッセージが格納されていなかった場合, 他のスレッドが\u003ccode\u003eMVar\u003c/code\u003eにメッセージを格納するまでブロックします.\u003c/p\u003e\n\n\u003cp\u003eというわけで簡単なサンプルコード\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003emodule Main where\n\nimport Control.Concurrent (forkIO, threadDelay)\nimport Control.Concurrent.MVar\n\nmain :: IO ()\nmain = do\n    mvar \u0026lt;- newEmptyMVar\n    forkIO $ do\n        msg \u0026lt;- takeMVar mvar\n        putStrLn $ \u0026#34;recv: \u0026#34; ++ msg\n        threadDelay $ 1 * 10 ^ 6\n        putMVar mvar \u0026#34;B\u0026#34;\n    putStrLn \u0026#34;sleep 1\u0026#34;\n    threadDelay $ 1 * 10 ^ 6\n    putStrLn \u0026#34;wake up\u0026#34;\n    putMVar mvar \u0026#34;A\u0026#34;\n    takeMVar mvar \u0026gt;\u0026gt;= print\u003c/pre\u003e\n\n\u003cp\u003e実行結果\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003esleep 1\nwake up\nrecv: A\n\u0026#34;B\u0026#34;\u003c/pre\u003e\n\n\u003cp\u003e確かにメッセージが格納されるまで \u003ccode\u003etakeMVar\u003c/code\u003eがブロックしていることがわかります\u003c/p\u003e\n\n\u003ch2\u003e共有変数としてのMVar\u003c/h2\u003e\n\n\u003cp\u003eさて, \u003ccode\u003eMVar\u003c/code\u003eにはもうひとつの使い方があります. 共有変数としての\u003ccode\u003eMVar\u003c/code\u003eです.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eMVar\u003c/code\u003eの特徴として, 誰かが\u003ccode\u003etake\u003c/code\u003eしてから\u003ccode\u003eput\u003c/code\u003eするまでの間は, 他のスレッドはだれも\u003ccode\u003eMVar\u003c/code\u003eの中身に触れないという点が挙げられます.\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003emain = do\n    mvar \u0026lt;- newMVar 0\n    forkIO $ do\n        val \u0026lt;- takeMVar mvar\n        -- 他のスレッドはMVarの中身に触れない\n        putMVar mvar $ val + 1\n    ...\u003c/pre\u003e\n\n\u003cp\u003eこの特徴はまさにロックの特徴といえます. ロックを取得し解放するまでは, 他のスレッドは同じロックで保護された区間にははいれません.\u003cbr/\u003e\nというわけで\u003ccode\u003eMVar\u003c/code\u003eは型レベルでロックがついた共有変数とみなすことができますね！(このへんはRustのMutexに似た空気を感じます. どちらも型レベルでロックとそれが保護する中身がつながっています)\u003cbr/\u003e\n型レベルでロックがくっついているので, 中身にアクセスするには必ずロックをとる(\u003ccode\u003etakeMVar\u003c/code\u003e)必要があり, ロックの取得忘れがありません.\u003c/p\u003e\n\n\u003cp\u003eさらに, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eは基本的に破壊的操作があまり登場しない言語であることもこの\u003ccode\u003eMVar\u003c/code\u003eロックにプラスに働きます.\u003c/p\u003e\n\n\u003cp\u003e例えば, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CF%A2%C1%DB%C7%DB%CE%F3\"\u003e連想配列\u003c/a\u003eをスレッド間で共有することを考えます. また, ここでは\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CF%A2%C1%DB%C7%DB%CE%F3\"\u003e連想配列\u003c/a\u003eの実装として, hashtableではなく\u003ccode\u003eData.Map\u003c/code\u003eを使用するとします(\u003ccode\u003eData.Map\u003c/code\u003eはimmutableな構造になっていて, lookupはO(log n)ですが, immutableなので\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e上で扱いやすいというメリットがあります).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eData.Map\u003c/code\u003eはimmutableなので, 一度\u003ccode\u003eMVar\u003c/code\u003eから取得してしまえばそれ以降変更される可能性もないため, ロックを保持し続ける必要がありません. そこで, 単なる読み込みの場合は, \u003ccode\u003etakeMVar\u003c/code\u003eしてすぐに\u003ccode\u003eputMVar\u003c/code\u003eで戻すだとか, \u003ccode\u003ereadMVar\u003c/code\u003eで読み込むだけにすることで, ロックの粒度を小さくできます.\u003cbr/\u003e\n\u003ccode\u003eMVar\u003c/code\u003eの中身を書き換えたい場合は, 単純にロックを取得し, 書き換え後の値を\u003ccode\u003eputMVar\u003c/code\u003eします.\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003emodule Main where\n\nimport Control.Concurrent (forkIO, threadDelay)\nimport Control.Concurrent.MVar\nimport qualified Data.Map.Strict as M\n\nmain :: IO ()\nmain = do\n    mvar \u0026lt;- newMVar M.empty\n    forkIO $ do\n        table \u0026lt;- takeMVar mvar\n        putMVar mvar table\n        -- tableを使用する操作\n    forkIO $ do\n         table \u0026lt;- readMVar mvar\n         -- tableを使用する操作\n    forkIO $ do\n        table \u0026lt;- takeMVar mvar\n        -- tableを変更する操作\n        let newTable = ...\n        putMVar mvar newTable\u003c/pre\u003e\n\n\u003cp\u003eこのように\u003ccode\u003eMVar\u003c/code\u003eとimmutableなデータ構造を組み合わせることで, 粒度の小さいロックを実現することができます.\u003cbr/\u003e\n一方, \u003ccode\u003eMVar\u003c/code\u003eとmutableなデータ構造(\u003ccode\u003eIORef\u003c/code\u003eなど)を組み合わせる場合は, たとえ読み込みしかしない場合であっても操作が終わるまではロックを保持しておく必要があることに注意しなければなりません (\u003ccode\u003eIORef\u003c/code\u003eには前回紹介したように\u003ccode\u003eatomicModifyIORef\u003c/code\u003eがあるのでなかなかこういう状況は起こりませんね)\u003c/p\u003e\n\n\u003cp\u003eまた, RustのMutexと違い, \u003ccode\u003eMVar\u003c/code\u003eによるロックの模倣(?)はロックの解放を自動的には行いません. したがって例外が送出された場合にロックを開放し忘れるケースがあるので, 注意が必要です.\u003c/p\u003e\n\n\u003ch2\u003e一旦まとめ\u003c/h2\u003e\n\n\u003cp\u003eというわけで今回は\u003ccode\u003eMVar\u003c/code\u003eについて紹介しました. \u003ccode\u003eMVar\u003c/code\u003eでロックを実現する方に関しては, 散々言われているロックの問題点をそのまま持ってきてしまうのであまり使えないかもしれませんね...\u003cbr/\u003e\n\u003ccode\u003eMVar\u003c/code\u003eは容量1のメッセージボックスでしたが, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eには\u003ccode\u003eChan\u003c/code\u003eというものもあります. こちらは\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\"\u003egolang\u003c/a\u003eのchanにかなり近いもので, 容量の制限がないキューのように働かせることができます. \u003ccode\u003eChan\u003c/code\u003eのよみとり専用のスレッドを１つ立てておき, 他の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eのスレッドがタスクを\u003ccode\u003eChan\u003c/code\u003eに書き込んでいくといった\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\"\u003eユースケース\u003c/a\u003eが考えられますね. こっちのほうが便利そうな気がしてきました.\u003c/p\u003e\n\n\u003cp\u003eロックはいろいろ厄介で, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%C3%A5%C9%A5%ED%A5%C3%A5%AF\"\u003eデッドロック\u003c/a\u003eとか解放忘れとかの問題がついて回ります. それを解決する１つの方法として\u003ccode\u003eSTM\u003c/code\u003eがあるようなので, 次はそれについて調べてみようと思います.\u003c/p\u003e\n\n---\n\n---\n","slug":"HaskellのConcurrentについて調べてまとめる_(MVar編)","title":"HaskellのConcurrentについて調べてまとめる (MVar編)","timestamp":1437528108000,"tags":[]},{"rawMarkdown":"---\ntitle: \"HaskellのConcurrentについて調べてまとめる (IORef編)\"\ndate: 2015-07-21T14:46:58.000Z\ntags: []\n---\n\n\u003cp\u003eこんばんは. \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e(\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GHC\"\u003eGHC\u003c/a\u003e)で並行処理を必要とするアプリケーションを書いてみようと思ったのですが, 並列処理に関するいろいろについてよくわかっていない部分が多かったので, 調べたついでにまとめておこうと思います.\u003c/p\u003e\n\n\u003cp\u003eもし間違い等ありましたらコメントいただけるとありがたいです\u003c/p\u003e\n\n\u003ch2\u003eConcurrent v.s. Parallel\u003c/h2\u003e\n\n\u003cp\u003eConcurrentは並行, Parallelは並列と訳されます.\u003cbr/\u003e\nConcurrentは論理的に同時に実行されることで, 実際に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eのタスクが物理的に同時に実行している必要はありません. 実際どうであれ, 同時に実行しているように見えればOKで, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eのタスクでCPUを細かく交代で使用しながら実行していくといった実行モデルもConcurrentであるといえます.\u003cbr/\u003e\nParallelは物理的に同時に実行されることです. 必然的に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eのCPUが必要になります. 物理的に同時に実行されているタスクは, 論理的にも同時に実行しているとみなせるので, ParallelであればConcurrentです.\u003c/p\u003e\n\n\u003cp\u003eこの記事ではConcurrentについて言及しているつもりです.\u003c/p\u003e\n\n\u003ch2\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eのスレッド\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eは処理系実装の軽量スレッドを持ちます. OSが提供するネイティブスレッドと違い, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%C6%A5%AD%A5%B9%A5%C8%A5%B9%A5%A4%A5%C3%A5%C1\"\u003eコンテキストスイッチ\u003c/a\u003e(スレッドの切り替え)のオーバーヘッドが少なく, より気軽に扱えるスレッドのようです. 軽量スレッドといえば \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Erlang\"\u003eErlang\u003c/a\u003e や \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Golang\"\u003eGolang\u003c/a\u003e が思い浮かびますね.(\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Erlang\"\u003eErlang\u003c/a\u003eは軽量プロセスっていうんでしたっけ)\u003c/p\u003e\n\n\u003cp\u003e実際に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eで軽量スレッドを立ち上げてみます.  \u003cbr/\u003e\nまずはスレッドを立ち上げない場合です. (threadDelayは指定したマイクロ秒分スレッドをスリープします)\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003emodule Main where\n\nimport Control.Concurrent (threadDelay)\n\nsleepN :: Int -\u0026gt; IO ()\nsleepN n = do\n    putStrLn $ \u0026#34;sleep \u0026#34; ++ show n\n    threadDelay $ n * 10 ^ 6\n    putStrLn $ \u0026#34;wake up \u0026#34; ++ show n\n\nmain :: IO ()\nmain = do\n    sleepN 3\n    threadDelay $ 2 * 10 ^ 6\n    putStrLn \u0026#34;sleep 2 and wakeup\u0026#34;\n    threadDelay $ 2 * 10 ^ 6\n    putStrLn \u0026#34;end\u0026#34;\u003c/pre\u003e\n\n\u003cp\u003e実行結果\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003esleep 3\nwake up 3\nsleep 2 and wakeup\nend\u003c/pre\u003e\n\n\u003cp\u003e全体として, 3秒-\u003e2秒-\u003e2秒とスリープするので7秒ほどの実行時間になります.\u003c/p\u003e\n\n\u003cp\u003eつぎにスレッドを立ち上げる場合です\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eでスレッドを立ち上げるには \u003ccode\u003eforkIO :: IO () -\u0026gt; IO ThreadId\u003c/code\u003e を使用します. \u003ccode\u003eIO ()\u003c/code\u003eを渡すと, それを新しく立ち上げたスレッド上で実行してくれます.\u003cbr/\u003e\n(\u003ccode\u003eforkOS :: IO () -\u0026gt; IO ThreadId\u003c/code\u003e というものもありますが, こちらは\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eの軽量スレッドではなく, ネイティブスレッドを立ち上げます)\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003emodule Main where\n\nimport Control.Concurrent (forkIO, threadDelay)\n\nsleepN :: Int -\u0026gt; IO ()\nsleepN n = do\n    putStrLn $ \u0026#34;sleep \u0026#34; ++ show n\n    threadDelay $ n * 10 ^ 6\n    putStrLn $ \u0026#34;wake up \u0026#34; ++ show n\n\nmain :: IO ()\nmain = do\n    forkIO $ sleepN 3\n    threadDelay $ 2 * 10 ^ 6\n    putStrLn \u0026#34;sleep 2 and wakeup\u0026#34;\n    threadDelay $ 2 * 10 ^ 6\n    putStrLn \u0026#34;end\u0026#34;\u003c/pre\u003e\n\n\u003cp\u003e実行結果\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003esleep 3\nsleep 2 and wakeup\nwake up 3\nend\u003c/pre\u003e\n\n\u003cp\u003e１つのスレッドが3秒スリープしている間に, もう一つのスレッドのスリープが始まるので, 全体で4秒ほどの実行時間になります.\u003c/p\u003e\n\n\u003ch2\u003e共有変数\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eスレッドによる並行実行を扱うと, どうしても共有変数的なものが欲しくなる場合があります. \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eでスレッド間共有をしたい場合はいくつかの方法があるようです.\u003cbr/\u003e\nもっとも直感的(手続きプログラミング出身者にとって)で馴染みやすいのは \u003ccode\u003eData.IORef\u003c/code\u003e かと思います. \u003ccode\u003eIO\u003c/code\u003e の世界の内側でのみ読み書きができる\"変数\"です.\u003c/p\u003e\n\n\u003cp\u003eまずは単一スレッドで実際に使ってみます.(以後import などは省略します)\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eadd1 :: IORef Int -\u0026gt; IO ()\nadd1 v = do\n    modifyIORef v (+1)\n\nmain :: IO ()\nmain = do\n    ref \u0026lt;- newIORef 0\n    v \u0026lt;- readIORef ref\n    print v\n    add1 ref\n    v\u0026#39; \u0026lt;- readIORef ref\n    print v\u0026#39;\u003c/pre\u003e\n\n\u003cp\u003e実行結果\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e0\n1\u003c/pre\u003e\n\n\u003cp\u003eこのように変数として中身を書き換えることができます.\u003cbr/\u003e\nこれは変数なので, ひとつのスレッドで行った書き換えが他のスレッドにも影響を及ぼします.(State\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9\"\u003eモナド\u003c/a\u003eのように変数を模倣しているだけではこれはできない)\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eadd1 :: IORef Int -\u0026gt; IO ()\nadd1 v = modifyIORef v (+1)\n\nspawn :: IORef Int -\u0026gt; IO ()\nspawn ref = do\n    forkIO $ add1 ref\n    return ()\n\nmain :: IO ()\nmain = do\n    ref \u0026lt;- newIORef 0\n    spawn ref\n    spawn ref\n    spawn ref\n    threadDelay 1000000\n    v \u0026lt;- readIORef ref\n    print v\u003c/pre\u003e\n\n\u003ch2\u003eデータ競合\u003c/h2\u003e\n\n\u003cp\u003e一方これを\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eスレッドで並列に動かすことを考えます. \u003ccode\u003emodifyIORef\u003c/code\u003e はアトミックではないので,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ev の中身を読む\nv の中身 + 1 を計算する\nv にその結果を入れる\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eというそれぞれの計算の間に別のスレッドでの計算が割り込まれる可能性がある.\u003cbr/\u003e\n上の例で, \u003ccode\u003espawn ref \u0026gt;\u0026gt; spawn ref \u0026gt;\u0026gt; spawn ref\u003c/code\u003e という部分は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eスレッドから一つの変数を同時に変更しようとしている. そのため, 変更が競合し意図しない動作になる可能性がある.\u003c/p\u003e\n\n\u003cp\u003eIORefで競合を防ぐ方法としては \u003ccode\u003eatomicModifyIORef :: IORef a -\u0026gt; (a -\u0026gt; (a, b)) -\u0026gt; IO b\u003c/code\u003e を使用する方法がある.\u003cbr/\u003e\n\u003ccode\u003eatomicModifyIORef\u003c/code\u003e の第2引数は \u003ccode\u003ea -\u0026gt; (a, b)\u003c/code\u003e である. これは \u003ccode\u003eIORef\u003c/code\u003e の中身を引数にとって, \u003ccode\u003e(変更後の値, atomicModifyIORefの返り値にしたい値)\u003c/code\u003e を返す関数である.\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003einc :: IORef Int -\u0026gt; IO Int\ninc ref = atomicModifyIORef ref (\\n -\u0026gt; (n + 1, n))\n\nmain :: IO ()\nmain = do\n    ref \u0026lt;- newIORef 0\n    res \u0026lt;- inc ref\n    v \u0026lt;- readIORef ref\n    print res\n    print v\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003einc\u003c/code\u003e は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\"\u003eC言語\u003c/a\u003eの\u003ccode\u003ei++;\u003c/code\u003eのような動きをする. 加算する前の値を返し, 変数をインクリメントする.\u003cbr/\u003e\n\u003ccode\u003eatomicModifyIORef\u003c/code\u003e は名前の通り atomic な操作であり, 分割不可能になるため他のスレッドと処理が競合することがなくなる.\u003c/p\u003e\n\n\u003ch2\u003e一旦まとめ\u003c/h2\u003e\n\n\u003cp\u003e長くなってきた \u0026amp; 疲れてきたので一旦きります.\u003cbr/\u003e\n今回はスレッド間共有変数のために \u003ccode\u003eIORef\u003c/code\u003e を使用し, その変更に \u003ccode\u003eatomicModifyIORef\u003c/code\u003e を使用することでデータ競合を防ぐ方法を紹介した.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eMVar\u003c/code\u003e や \u003ccode\u003eSTM\u003c/code\u003e を使用する方法もあり, そっちのほうが良い場合もあるっぽいのでそっちについてもまとめたいと思います.\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eこんばんは. \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e(\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GHC\"\u003eGHC\u003c/a\u003e)で並行処理を必要とするアプリケーションを書いてみようと思ったのですが, 並列処理に関するいろいろについてよくわかっていない部分が多かったので, 調べたついでにまとめておこうと思います.\u003c/p\u003e\n\n\u003cp\u003eもし間違い等ありましたらコメントいただけるとありがたいです\u003c/p\u003e\n\n\u003ch2\u003eConcurrent v.s. Parallel\u003c/h2\u003e\n\n\u003cp\u003eConcurrentは並行, Parallelは並列と訳されます.\u003cbr/\u003e\nConcurrentは論理的に同時に実行されることで, 実際に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eのタスクが物理的に同時に実行している必要はありません. 実際どうであれ, 同時に実行しているように見えればOKで, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eのタスクでCPUを細かく交代で使用しながら実行していくといった実行モデルもConcurrentであるといえます.\u003cbr/\u003e\nParallelは物理的に同時に実行されることです. 必然的に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eのCPUが必要になります. 物理的に同時に実行されているタスクは, 論理的にも同時に実行しているとみなせるので, ParallelであればConcurrentです.\u003c/p\u003e\n\n\u003cp\u003eこの記事ではConcurrentについて言及しているつもりです.\u003c/p\u003e\n\n\u003ch2\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eのスレッド\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eは処理系実装の軽量スレッドを持ちます. OSが提供するネイティブスレッドと違い, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%C6%A5%AD%A5%B9%A5%C8%A5%B9%A5%A4%A5%C3%A5%C1\"\u003eコンテキストスイッチ\u003c/a\u003e(スレッドの切り替え)のオーバーヘッドが少なく, より気軽に扱えるスレッドのようです. 軽量スレッドといえば \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Erlang\"\u003eErlang\u003c/a\u003e や \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Golang\"\u003eGolang\u003c/a\u003e が思い浮かびますね.(\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Erlang\"\u003eErlang\u003c/a\u003eは軽量プロセスっていうんでしたっけ)\u003c/p\u003e\n\n\u003cp\u003e実際に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eで軽量スレッドを立ち上げてみます.  \u003cbr/\u003e\nまずはスレッドを立ち上げない場合です. (threadDelayは指定したマイクロ秒分スレッドをスリープします)\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003emodule Main where\n\nimport Control.Concurrent (threadDelay)\n\nsleepN :: Int -\u0026gt; IO ()\nsleepN n = do\n    putStrLn $ \u0026#34;sleep \u0026#34; ++ show n\n    threadDelay $ n * 10 ^ 6\n    putStrLn $ \u0026#34;wake up \u0026#34; ++ show n\n\nmain :: IO ()\nmain = do\n    sleepN 3\n    threadDelay $ 2 * 10 ^ 6\n    putStrLn \u0026#34;sleep 2 and wakeup\u0026#34;\n    threadDelay $ 2 * 10 ^ 6\n    putStrLn \u0026#34;end\u0026#34;\u003c/pre\u003e\n\n\u003cp\u003e実行結果\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003esleep 3\nwake up 3\nsleep 2 and wakeup\nend\u003c/pre\u003e\n\n\u003cp\u003e全体として, 3秒-\u003e2秒-\u003e2秒とスリープするので7秒ほどの実行時間になります.\u003c/p\u003e\n\n\u003cp\u003eつぎにスレッドを立ち上げる場合です\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eでスレッドを立ち上げるには \u003ccode\u003eforkIO :: IO () -\u0026gt; IO ThreadId\u003c/code\u003e を使用します. \u003ccode\u003eIO ()\u003c/code\u003eを渡すと, それを新しく立ち上げたスレッド上で実行してくれます.\u003cbr/\u003e\n(\u003ccode\u003eforkOS :: IO () -\u0026gt; IO ThreadId\u003c/code\u003e というものもありますが, こちらは\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eの軽量スレッドではなく, ネイティブスレッドを立ち上げます)\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003emodule Main where\n\nimport Control.Concurrent (forkIO, threadDelay)\n\nsleepN :: Int -\u0026gt; IO ()\nsleepN n = do\n    putStrLn $ \u0026#34;sleep \u0026#34; ++ show n\n    threadDelay $ n * 10 ^ 6\n    putStrLn $ \u0026#34;wake up \u0026#34; ++ show n\n\nmain :: IO ()\nmain = do\n    forkIO $ sleepN 3\n    threadDelay $ 2 * 10 ^ 6\n    putStrLn \u0026#34;sleep 2 and wakeup\u0026#34;\n    threadDelay $ 2 * 10 ^ 6\n    putStrLn \u0026#34;end\u0026#34;\u003c/pre\u003e\n\n\u003cp\u003e実行結果\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003esleep 3\nsleep 2 and wakeup\nwake up 3\nend\u003c/pre\u003e\n\n\u003cp\u003e１つのスレッドが3秒スリープしている間に, もう一つのスレッドのスリープが始まるので, 全体で4秒ほどの実行時間になります.\u003c/p\u003e\n\n\u003ch2\u003e共有変数\u003c/h2\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eスレッドによる並行実行を扱うと, どうしても共有変数的なものが欲しくなる場合があります. \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eでスレッド間共有をしたい場合はいくつかの方法があるようです.\u003cbr/\u003e\nもっとも直感的(手続きプログラミング出身者にとって)で馴染みやすいのは \u003ccode\u003eData.IORef\u003c/code\u003e かと思います. \u003ccode\u003eIO\u003c/code\u003e の世界の内側でのみ読み書きができる\"変数\"です.\u003c/p\u003e\n\n\u003cp\u003eまずは単一スレッドで実際に使ってみます.(以後import などは省略します)\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eadd1 :: IORef Int -\u0026gt; IO ()\nadd1 v = do\n    modifyIORef v (+1)\n\nmain :: IO ()\nmain = do\n    ref \u0026lt;- newIORef 0\n    v \u0026lt;- readIORef ref\n    print v\n    add1 ref\n    v\u0026#39; \u0026lt;- readIORef ref\n    print v\u0026#39;\u003c/pre\u003e\n\n\u003cp\u003e実行結果\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e0\n1\u003c/pre\u003e\n\n\u003cp\u003eこのように変数として中身を書き換えることができます.\u003cbr/\u003e\nこれは変数なので, ひとつのスレッドで行った書き換えが他のスレッドにも影響を及ぼします.(State\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9\"\u003eモナド\u003c/a\u003eのように変数を模倣しているだけではこれはできない)\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eadd1 :: IORef Int -\u0026gt; IO ()\nadd1 v = modifyIORef v (+1)\n\nspawn :: IORef Int -\u0026gt; IO ()\nspawn ref = do\n    forkIO $ add1 ref\n    return ()\n\nmain :: IO ()\nmain = do\n    ref \u0026lt;- newIORef 0\n    spawn ref\n    spawn ref\n    spawn ref\n    threadDelay 1000000\n    v \u0026lt;- readIORef ref\n    print v\u003c/pre\u003e\n\n\u003ch2\u003eデータ競合\u003c/h2\u003e\n\n\u003cp\u003e一方これを\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eスレッドで並列に動かすことを考えます. \u003ccode\u003emodifyIORef\u003c/code\u003e はアトミックではないので,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ev の中身を読む\nv の中身 + 1 を計算する\nv にその結果を入れる\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eというそれぞれの計算の間に別のスレッドでの計算が割り込まれる可能性がある.\u003cbr/\u003e\n上の例で, \u003ccode\u003espawn ref \u0026gt;\u0026gt; spawn ref \u0026gt;\u0026gt; spawn ref\u003c/code\u003e という部分は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\"\u003e複数\u003c/a\u003eスレッドから一つの変数を同時に変更しようとしている. そのため, 変更が競合し意図しない動作になる可能性がある.\u003c/p\u003e\n\n\u003cp\u003eIORefで競合を防ぐ方法としては \u003ccode\u003eatomicModifyIORef :: IORef a -\u0026gt; (a -\u0026gt; (a, b)) -\u0026gt; IO b\u003c/code\u003e を使用する方法がある.\u003cbr/\u003e\n\u003ccode\u003eatomicModifyIORef\u003c/code\u003e の第2引数は \u003ccode\u003ea -\u0026gt; (a, b)\u003c/code\u003e である. これは \u003ccode\u003eIORef\u003c/code\u003e の中身を引数にとって, \u003ccode\u003e(変更後の値, atomicModifyIORefの返り値にしたい値)\u003c/code\u003e を返す関数である.\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003einc :: IORef Int -\u0026gt; IO Int\ninc ref = atomicModifyIORef ref (\\n -\u0026gt; (n + 1, n))\n\nmain :: IO ()\nmain = do\n    ref \u0026lt;- newIORef 0\n    res \u0026lt;- inc ref\n    v \u0026lt;- readIORef ref\n    print res\n    print v\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003einc\u003c/code\u003e は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\"\u003eC言語\u003c/a\u003eの\u003ccode\u003ei++;\u003c/code\u003eのような動きをする. 加算する前の値を返し, 変数をインクリメントする.\u003cbr/\u003e\n\u003ccode\u003eatomicModifyIORef\u003c/code\u003e は名前の通り atomic な操作であり, 分割不可能になるため他のスレッドと処理が競合することがなくなる.\u003c/p\u003e\n\n\u003ch2\u003e一旦まとめ\u003c/h2\u003e\n\n\u003cp\u003e長くなってきた \u0026amp; 疲れてきたので一旦きります.\u003cbr/\u003e\n今回はスレッド間共有変数のために \u003ccode\u003eIORef\u003c/code\u003e を使用し, その変更に \u003ccode\u003eatomicModifyIORef\u003c/code\u003e を使用することでデータ競合を防ぐ方法を紹介した.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eMVar\u003c/code\u003e や \u003ccode\u003eSTM\u003c/code\u003e を使用する方法もあり, そっちのほうが良い場合もあるっぽいのでそっちについてもまとめたいと思います.\u003c/p\u003e\n\n---\n\n---\n","slug":"HaskellのConcurrentについて調べてまとめる_(IORef編)","title":"HaskellのConcurrentについて調べてまとめる (IORef編)","timestamp":1437490018000,"tags":[]},{"rawMarkdown":"---\ntitle: \"yukicoder 2015/05/08\"\ndate: 2015-05-08T15:02:19.000Z\ntags: []\n---\n\n\u003cp\u003eyukicoderさんのコンテストに出てきましたー\u003c/p\u003e\n\n\u003cp\u003e★から★★★までの四問ということでもしかしたら完答いけるんじゃないかとか甘いことを考えていたのですが...ｗｗ\u003c/p\u003e\n\n\u003ch1\u003e結果\u003c/h1\u003e\n\n\u003cp\u003e3完で19位でしたー4問目はTLEの連発で...解法全く思いつけませんでしたねー\u003cbr/\u003e\nただ前よりはちょっとは力ついてきたのかななんて思ってますｗｗ（甘いかな\u003c/p\u003e\n\n\u003ch1\u003e復習\u003c/h1\u003e\n\n\u003ch2\u003e\u003ca href=\"http://yukicoder.me/problems/526\"\u003eNo.203 ゴールデン・ウィーク(1) - yukicoder\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003e与えられた2週間の中で最長の連休を求めよという問題ですね！\u003cbr/\u003e\n2週間の情報の与え方が\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eoxoooxx\nxxoxxoo\u003c/pre\u003e\n\n\u003cp\u003eのように一週間ごとにわかれているのでそのまま素直に一週間ごとに入力受け付けるとハマる気がしますｗ\u003cbr/\u003e\n単純に14要素の配列を用意してそこに入れていけば単なる最長の連続区間を求める問題ですね！！\u003c/p\u003e\n\n\u003ch2\u003e\u003ca href=\"http://yukicoder.me/problems/490\"\u003eNo.204 ゴールデン・ウィーク(2) - yukicoder\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003eいやーやられまくりましたねｗｗランキングを見るとわかるのですが、めちゃくちゃ罠問題という感じでしたｗ\u003cbr/\u003e\nsubmit回数がすごいことになってましたね全体的に\u003c/p\u003e\n\n\u003cp\u003e問題は、先ほどの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B4%A1%BC%A5%EB%A5%C7%A5%F3%A5%A6%A5%A3%A1%BC%A5%AF\"\u003eゴールデンウィーク\u003c/a\u003eの問題とほぼ一緒なのですが、今回は有給を使うことが出来ます！！幸せっぽいですね\u003cbr/\u003e\nこれだけならまあ簡単なのですが...\u003c/p\u003e\n\n\u003cp\u003e引っ掛けポイントはこの二週間以外の部分です！\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e2週間分の平日(x)と休日(o)が分かるカレンダーが与えられます。\nこの2週間の期間以外は、平日とします。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003eこの文を読み飛ばしているとWAまみれになります。というかなりました...\u003cbr/\u003e\nこれさえ見逃さなければ素直にガリガリ数えていくだけですので、実装としてはそこまで難しくはないと思います。\u003cbr/\u003e\nもっときれいな実装や解法があるんでしょうけど、それは追々...\u003c/p\u003e\n\n\u003ch2\u003e\u003ca href=\"http://yukicoder.me/problems/412\"\u003eNo.205 マージして辞書順最小 - yukicoder\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003e与えられた文字列群の先頭から一文字ずつ選んで組み上げられる文字列のうち、辞書順最小になるものを求めよという問題。\u003cbr/\u003e\nすべての文字列の先頭文字のうち、最小のものを選んでいけばよいっぽいのですが、ひっかかりポイントとして、\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eaz\nza\u003c/pre\u003e\n\n\u003cp\u003eというような問題があります。\u003cbr/\u003e\nこの場合、\u003ccode\u003ea\u003c/code\u003e が最小なので\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003ez\nza\u003c/pre\u003e\n\n\u003cp\u003eとなります。\u003cbr/\u003e\n次の一文字を決定する際に、何も考えずに辞書順最小の文字を考えると\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e(空)\nza\u003c/pre\u003e\n\n\u003cp\u003eとなります。\u003cbr/\u003e\nそして出来上がる文字列は \u003ccode\u003eazza\u003c/code\u003e となります。\u003cbr/\u003e\n正しい答えは \u003ccode\u003eazaz\u003c/code\u003e ですよね。ここがハマリポイントぽいです。\u003c/p\u003e\n\n\u003cp\u003e今回はこのコーナーケースがサンプルにあったので発見しやすかったですね。なかったらはまってたと思います。\u003c/p\u003e\n\n\u003ch2\u003e\u003ca href=\"http://yukicoder.me/problems/440\"\u003eNo.206 数の積集合を求めるクエリ - yukicoder\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003eわかんなかったー！くそー...\u003c/p\u003e\n\n\u003cp\u003eとりあえずナイーブな実装で \u003ccode\u003emultiset\u003c/code\u003e でAの各要素 - Bの各要素の集合を作り、 \u003ccode\u003e0\u003c/code\u003eの数が \u003ccode\u003eQ = 0\u003c/code\u003eの時の解, \u003ccode\u003e1\u003c/code\u003e の数が \u003ccode\u003eQ = 1\u003c/code\u003e の時の解, ... というようにしてみました。  解はあっているっぽかったのですが、案の定 TLE ...\u003cbr/\u003e\n此の実装だと \u003ccode\u003eO(L * M)\u003c/code\u003e かな？ \u003ccode\u003eL, M\u003c/code\u003e は\u003ccode\u003e10 ^ 5\u003c/code\u003e までいくのでこれじゃダメダメですねー...\u003c/p\u003e\n\n\u003cp\u003eで、解答見たのですが、解答読んでもよくわからない...ちょっと考えてみます...\u003c/p\u003e\n\n\u003ch1\u003eまとめ\u003c/h1\u003e\n\n\u003cp\u003e前よりはまし！すこしだけ！\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003eyukicoderさんのコンテストに出てきましたー\u003c/p\u003e\n\n\u003cp\u003e★から★★★までの四問ということでもしかしたら完答いけるんじゃないかとか甘いことを考えていたのですが...ｗｗ\u003c/p\u003e\n\n\u003ch1\u003e結果\u003c/h1\u003e\n\n\u003cp\u003e3完で19位でしたー4問目はTLEの連発で...解法全く思いつけませんでしたねー\u003cbr/\u003e\nただ前よりはちょっとは力ついてきたのかななんて思ってますｗｗ（甘いかな\u003c/p\u003e\n\n\u003ch1\u003e復習\u003c/h1\u003e\n\n\u003ch2\u003e\u003ca href=\"http://yukicoder.me/problems/526\"\u003eNo.203 ゴールデン・ウィーク(1) - yukicoder\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003e与えられた2週間の中で最長の連休を求めよという問題ですね！\u003cbr/\u003e\n2週間の情報の与え方が\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eoxoooxx\nxxoxxoo\u003c/pre\u003e\n\n\u003cp\u003eのように一週間ごとにわかれているのでそのまま素直に一週間ごとに入力受け付けるとハマる気がしますｗ\u003cbr/\u003e\n単純に14要素の配列を用意してそこに入れていけば単なる最長の連続区間を求める問題ですね！！\u003c/p\u003e\n\n\u003ch2\u003e\u003ca href=\"http://yukicoder.me/problems/490\"\u003eNo.204 ゴールデン・ウィーク(2) - yukicoder\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003eいやーやられまくりましたねｗｗランキングを見るとわかるのですが、めちゃくちゃ罠問題という感じでしたｗ\u003cbr/\u003e\nsubmit回数がすごいことになってましたね全体的に\u003c/p\u003e\n\n\u003cp\u003e問題は、先ほどの\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B4%A1%BC%A5%EB%A5%C7%A5%F3%A5%A6%A5%A3%A1%BC%A5%AF\"\u003eゴールデンウィーク\u003c/a\u003eの問題とほぼ一緒なのですが、今回は有給を使うことが出来ます！！幸せっぽいですね\u003cbr/\u003e\nこれだけならまあ簡単なのですが...\u003c/p\u003e\n\n\u003cp\u003e引っ掛けポイントはこの二週間以外の部分です！\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e2週間分の平日(x)と休日(o)が分かるカレンダーが与えられます。\nこの2週間の期間以外は、平日とします。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003eこの文を読み飛ばしているとWAまみれになります。というかなりました...\u003cbr/\u003e\nこれさえ見逃さなければ素直にガリガリ数えていくだけですので、実装としてはそこまで難しくはないと思います。\u003cbr/\u003e\nもっときれいな実装や解法があるんでしょうけど、それは追々...\u003c/p\u003e\n\n\u003ch2\u003e\u003ca href=\"http://yukicoder.me/problems/412\"\u003eNo.205 マージして辞書順最小 - yukicoder\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003e与えられた文字列群の先頭から一文字ずつ選んで組み上げられる文字列のうち、辞書順最小になるものを求めよという問題。\u003cbr/\u003e\nすべての文字列の先頭文字のうち、最小のものを選んでいけばよいっぽいのですが、ひっかかりポイントとして、\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eaz\nza\u003c/pre\u003e\n\n\u003cp\u003eというような問題があります。\u003cbr/\u003e\nこの場合、\u003ccode\u003ea\u003c/code\u003e が最小なので\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003ez\nza\u003c/pre\u003e\n\n\u003cp\u003eとなります。\u003cbr/\u003e\n次の一文字を決定する際に、何も考えずに辞書順最小の文字を考えると\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003e(空)\nza\u003c/pre\u003e\n\n\u003cp\u003eとなります。\u003cbr/\u003e\nそして出来上がる文字列は \u003ccode\u003eazza\u003c/code\u003e となります。\u003cbr/\u003e\n正しい答えは \u003ccode\u003eazaz\u003c/code\u003e ですよね。ここがハマリポイントぽいです。\u003c/p\u003e\n\n\u003cp\u003e今回はこのコーナーケースがサンプルにあったので発見しやすかったですね。なかったらはまってたと思います。\u003c/p\u003e\n\n\u003ch2\u003e\u003ca href=\"http://yukicoder.me/problems/440\"\u003eNo.206 数の積集合を求めるクエリ - yukicoder\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003eわかんなかったー！くそー...\u003c/p\u003e\n\n\u003cp\u003eとりあえずナイーブな実装で \u003ccode\u003emultiset\u003c/code\u003e でAの各要素 - Bの各要素の集合を作り、 \u003ccode\u003e0\u003c/code\u003eの数が \u003ccode\u003eQ = 0\u003c/code\u003eの時の解, \u003ccode\u003e1\u003c/code\u003e の数が \u003ccode\u003eQ = 1\u003c/code\u003e の時の解, ... というようにしてみました。  解はあっているっぽかったのですが、案の定 TLE ...\u003cbr/\u003e\n此の実装だと \u003ccode\u003eO(L * M)\u003c/code\u003e かな？ \u003ccode\u003eL, M\u003c/code\u003e は\u003ccode\u003e10 ^ 5\u003c/code\u003e までいくのでこれじゃダメダメですねー...\u003c/p\u003e\n\n\u003cp\u003eで、解答見たのですが、解答読んでもよくわからない...ちょっと考えてみます...\u003c/p\u003e\n\n\u003ch1\u003eまとめ\u003c/h1\u003e\n\n\u003cp\u003e前よりはまし！すこしだけ！\u003c/p\u003e\n\n---\n\n---\n","slug":"yukicoder_2015_05_08","title":"yukicoder 2015/05/08","timestamp":1431097339000,"tags":[]},{"rawMarkdown":"---\ntitle: \"yukicoder 2015/05/03\"\ndate: 2015-05-04T09:38:47.000Z\ntags: []\n---\n\n\u003cp\u003e今週は土日共に予定があって\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\"\u003eAtCoder\u003c/a\u003eさんもyukicoderさんも出場したかったのですが出来ず...\u003c/p\u003e\n\n\u003ch1\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\"\u003eAtCoder\u003c/a\u003e - ARC\u003c/h1\u003e\n\n\u003cp\u003e今週の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\"\u003eAtCoder\u003c/a\u003eさんはABCはなかった？ぽくて, ARCに挑むにはまだちょっと力不足かなと思うので, 一旦保留します\u003c/p\u003e\n\n\u003ch1\u003eyukicoder\u003c/h1\u003e\n\n\u003cp\u003eというわけでyukicoderさんの方の最初の2問についてだけコンテスト後ですが挑戦してみましたー\u003c/p\u003e\n\n\u003ch2\u003e　\u003ca href=\"http://yukicoder.me/problems/436\"\u003eNo.201 yukicoderじゃんけん - yukicoder\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003eゆるふわなじゃんけんですね。じゃんけんといいつつ、手は全く関係ないただの数値比較ですｗｗ\u003cbr/\u003e\nただし、注意しなければならないのが数値の範囲です。\u003ccode\u003e10 ^ 1000\u003c/code\u003e までという非常に大きな数字を扱う必要があるので、単純に実装すると落ちます。\u003cbr/\u003e\n今まであんまりこういった入力数値の範囲について注視していなかったのですが、今回ばっちりひっかかって落ちたので今度からはちゃんと見ないとダメですねｗｗ\u003c/p\u003e\n\n\u003cp\u003eあ、あと今回は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eを使用してみましたー競技プログラミングとは別件で最近\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eをよく利用しているので、その流れでDから一旦変えてみましたー\u003c/p\u003e\n\n\u003cp\u003e非常に大きな数値を扱う場合、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ruby\"\u003eruby\u003c/a\u003eや\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/python\"\u003epython\u003c/a\u003eであれば自動的に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/BigDecimal\"\u003eBigDecimal\u003c/a\u003eのようなクラスを使用してくれるので素直に実装すればそのまま通ってしまいますが、今回は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eなので文字列として受け取って桁数を比較する方法で実装しました。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;functional\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;algorithm\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#define REP(i,n) \u003c/span\u003e\u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e(\u003c/span\u003e\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e i;i\u0026lt;(n);i++)\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e \u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e std;\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main() {\n    cin.tie(\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e);\n    ios::sync_with_stdio(\u003cspan class=\"synConstant\"\u003efalse\u003c/span\u003e);\n\n    string a, ap, b, bp, g;\n    cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; ap \u0026gt;\u0026gt; g \u0026gt;\u0026gt; b \u0026gt;\u0026gt; bp \u0026gt;\u0026gt; g;\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (ap.length() \u0026gt; bp.length())\n        cout \u0026lt;\u0026lt; a;\n    \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (ap.length() \u0026lt; bp.length())\n        cout \u0026lt;\u0026lt; b;\n    \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (ap \u0026gt; bp)\n            cout \u0026lt;\u0026lt; a;\n        \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (ap \u0026lt; bp)\n            cout \u0026lt;\u0026lt; b;\n        \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e\n            cout \u0026lt;\u0026lt; -\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e;\n    }\n    cout \u0026lt;\u0026lt; endl;\n\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eにもBigInt的なものはあるんですかね？あんまり\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eも詳しくないのでわかりませんが多分あるでしょう。どっちがはやいんだろうなー\u003c/p\u003e\n\n\u003ch2\u003e\u003ca href=\"http://yukicoder.me/problems/476\"\u003eNo.202 1円玉投げ - yukicoder\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003e1円玉を1つずつ投げていって重なったら取り除く、を繰り返した時最後に何枚残っているか、という問題ですね。\u003cbr/\u003e\n最初にとりあえず書いてみた解答がこちら。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;functional\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;algorithm\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;cmath\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#define REP(i,n) \u003c/span\u003e\u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e(\u003c/span\u003e\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e i=\u003c/span\u003e\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e;i\u0026lt;(n);i++)\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e \u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e std;\n\n\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e is_on(pair\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e,\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u0026amp;a, pair\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u0026amp;b)\n{\n    \u003cspan class=\"synType\"\u003edouble\u003c/span\u003e dist = (a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second);\n    dist = sqrt(dist);\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e dist \u0026lt; \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e;\n}\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main() {\n    cin.tie(\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e);\n    ios::sync_with_stdio(\u003cspan class=\"synConstant\"\u003efalse\u003c/span\u003e);\n\n    \u003cspan class=\"synType\"\u003eint\u003c/span\u003e N;\n    cin \u0026gt;\u0026gt; N;\n    \u003cspan class=\"synType\"\u003eint\u003c/span\u003e x, y;\n    cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n    N--;\n    vector\u0026lt;pair\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u0026gt; coins;\n    coins.emplace_back(x, y);\n\n    REP(i, N) {\n        cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n        \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e p = pair\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e,\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;(x, y);\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (!any_of(coins.begin(), coins.end(), [\u0026amp;p](pair\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u0026amp;a) \u003cspan class=\"synError\"\u003e{\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e is_on(a, p); })) {\n            coins.push_back(move(p));\n        }\n    }\n    cout \u0026lt;\u0026lt; coins.size() \u0026lt;\u0026lt; endl;\n\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n}\n\u003c/pre\u003e\n\n\u003cp\u003e投げるたびに、今までのコイン達と重なっているかどうかをチェックし、どれとも重なっていなかった場合は追加する、というナイーブな実装です。これだと答えは合うのですが、TLEになってしまいました。\u003cbr/\u003e\nはじめはx軸方向にソートして、x軸方向で20より離れていればチェックの必要がないので、チェックの必要がある部分を二分探索で求めるという方法を考えたのですが、なんかあんまりうまい方法に思えなくて詰まりまくりました。\u003c/p\u003e\n\n\u003cp\u003e0 \u0026lt;= x, y \u0026lt;= 20000 というフィールドを 10 × 10 の細かいフィールドに区切ってチェックするという方法がスタンダードみたいですね！なるほど！ \u003cbr/\u003e\nというわけで実装してみたのがこちら\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;functional\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;algorithm\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;cmath\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;array\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#define REP(i, n) \u003c/span\u003e\u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e(\u003c/span\u003e\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e i=\u003c/span\u003e\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e;i\u0026lt;(n);i++)\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e \u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e std;\n\n\u003cspan class=\"synType\"\u003etypedef\u003c/span\u003e pair\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; P;\n\n\u003cspan class=\"synType\"\u003econst\u003c/span\u003e \u003cspan class=\"synType\"\u003eint\u003c/span\u003e MAX_N = \u003cspan class=\"synConstant\"\u003e100000\u003c/span\u003e;\narray\u0026lt;array\u0026lt;vector\u0026lt;P\u0026gt;, \u003cspan class=\"synConstant\"\u003e2000\u003c/span\u003e\u0026gt;, \u003cspan class=\"synConstant\"\u003e20000\u003c/span\u003e / \u003cspan class=\"synConstant\"\u003e10\u003c/span\u003e\u0026gt; fields;\n\n\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e is_on(pair\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u0026amp;a, pair\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u0026amp;b) {\n    \u003cspan class=\"synType\"\u003edouble\u003c/span\u003e dist = (a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second);\n    dist = sqrt(dist);\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e dist \u0026lt; \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e;\n}\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main() {\n    cin.tie(\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e);\n    ios::sync_with_stdio(\u003cspan class=\"synConstant\"\u003efalse\u003c/span\u003e);\n\n    \u003cspan class=\"synType\"\u003eint\u003c/span\u003e N;\n    cin \u0026gt;\u0026gt; N;\n    \u003cspan class=\"synType\"\u003eint\u003c/span\u003e x, y;\n    cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n    N--;\n    fields[x / \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e][y / \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e].emplace_back(x, y);\n\n    \u003cspan class=\"synType\"\u003eint\u003c/span\u003e ans = \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e;\n\n    REP(k, N) {\n        cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n        P current(x, y);\n        \u003cspan class=\"synType\"\u003eint\u003c/span\u003e fx = x / \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e, fy = y / \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e;\n        \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e flg = \u003cspan class=\"synConstant\"\u003etrue\u003c/span\u003e;\n        \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e (\u003cspan class=\"synType\"\u003eint\u003c/span\u003e i = -\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e; i \u0026lt;= \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e \u0026amp;\u0026amp; flg; ++i) {\n            \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e (\u003cspan class=\"synType\"\u003eint\u003c/span\u003e j = -\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e; j \u0026lt;= \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e \u0026amp;\u0026amp; flg; ++j) {\n                \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (fx + i \u0026lt; \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e || fx + i \u0026gt;= \u003cspan class=\"synConstant\"\u003e2000\u003c/span\u003e || fy + j \u0026lt; \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e || fy + j \u0026gt;= \u003cspan class=\"synConstant\"\u003e2000\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003econtinue\u003c/span\u003e;\n                \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e (\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e p: fields[fx + i][fy + j]) {\n                    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (is_on(p, current)) {\n                        flg = \u003cspan class=\"synConstant\"\u003efalse\u003c/span\u003e;\n                        \u003cspan class=\"synStatement\"\u003ebreak\u003c/span\u003e;\n                    }\n                }\n            }\n        }\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (flg) {\n            fields[fx][fy].push_back(current);\n            ans++;\n        }\n    }\n    cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n}\n\u003c/pre\u003e\n\n\u003cp\u003e10 × 10 のマスに区切って、コインが重なる可能性のある部分(つまり隣接するマス)についてのみチェックをするという実装です。\u003cbr/\u003e\n今思ったのですが、10 × 10 のマスに区切ったらその中に存在できるコインの数って多分1子だけですよね？そしたら \u003ccode\u003earray\u0026lt; array\u0026lt;P, 2000\u0026gt;, 2000\u0026gt;\u003c/code\u003e でもよかったかもですね！(あ、でもそれだとコインが存在しないときの値がよくわからなくなるなーoption型とか欲しくなる)\u003c/p\u003e\n\n\u003ch1\u003eまとめ\u003c/h1\u003e\n\n\u003cp\u003eやっぱり出場したかったなーあのコンテストの感じがないと集中しきれないというかｗｗ\u003cbr/\u003e\nコンテストだと出来ない時にすごく悔しくて次回への勉強のモチベーションがあがるんですよね！だから今後極力出場していこうと思います！\u003c/p\u003e\n\n\u003cp\u003e学びとしては、きちんと問題の対象範囲をよく読むことと、検索の範囲を狭めることで解決できる問題の場合はフィールドをマス目状に区切る方法があるということですね！次回に活かします！\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003cp\u003e今週は土日共に予定があって\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\"\u003eAtCoder\u003c/a\u003eさんもyukicoderさんも出場したかったのですが出来ず...\u003c/p\u003e\n\n\u003ch1\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\"\u003eAtCoder\u003c/a\u003e - ARC\u003c/h1\u003e\n\n\u003cp\u003e今週の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\"\u003eAtCoder\u003c/a\u003eさんはABCはなかった？ぽくて, ARCに挑むにはまだちょっと力不足かなと思うので, 一旦保留します\u003c/p\u003e\n\n\u003ch1\u003eyukicoder\u003c/h1\u003e\n\n\u003cp\u003eというわけでyukicoderさんの方の最初の2問についてだけコンテスト後ですが挑戦してみましたー\u003c/p\u003e\n\n\u003ch2\u003e　\u003ca href=\"http://yukicoder.me/problems/436\"\u003eNo.201 yukicoderじゃんけん - yukicoder\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003eゆるふわなじゃんけんですね。じゃんけんといいつつ、手は全く関係ないただの数値比較ですｗｗ\u003cbr/\u003e\nただし、注意しなければならないのが数値の範囲です。\u003ccode\u003e10 ^ 1000\u003c/code\u003e までという非常に大きな数字を扱う必要があるので、単純に実装すると落ちます。\u003cbr/\u003e\n今まであんまりこういった入力数値の範囲について注視していなかったのですが、今回ばっちりひっかかって落ちたので今度からはちゃんと見ないとダメですねｗｗ\u003c/p\u003e\n\n\u003cp\u003eあ、あと今回は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eを使用してみましたー競技プログラミングとは別件で最近\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eをよく利用しているので、その流れでDから一旦変えてみましたー\u003c/p\u003e\n\n\u003cp\u003e非常に大きな数値を扱う場合、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ruby\"\u003eruby\u003c/a\u003eや\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/python\"\u003epython\u003c/a\u003eであれば自動的に\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/BigDecimal\"\u003eBigDecimal\u003c/a\u003eのようなクラスを使用してくれるので素直に実装すればそのまま通ってしまいますが、今回は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eなので文字列として受け取って桁数を比較する方法で実装しました。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;functional\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;algorithm\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#define REP(i,n) \u003c/span\u003e\u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e(\u003c/span\u003e\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e i;i\u0026lt;(n);i++)\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e \u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e std;\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main() {\n    cin.tie(\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e);\n    ios::sync_with_stdio(\u003cspan class=\"synConstant\"\u003efalse\u003c/span\u003e);\n\n    string a, ap, b, bp, g;\n    cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; ap \u0026gt;\u0026gt; g \u0026gt;\u0026gt; b \u0026gt;\u0026gt; bp \u0026gt;\u0026gt; g;\n    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (ap.length() \u0026gt; bp.length())\n        cout \u0026lt;\u0026lt; a;\n    \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (ap.length() \u0026lt; bp.length())\n        cout \u0026lt;\u0026lt; b;\n    \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (ap \u0026gt; bp)\n            cout \u0026lt;\u0026lt; a;\n        \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (ap \u0026lt; bp)\n            cout \u0026lt;\u0026lt; b;\n        \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e\n            cout \u0026lt;\u0026lt; -\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e;\n    }\n    cout \u0026lt;\u0026lt; endl;\n\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n}\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eにもBigInt的なものはあるんですかね？あんまり\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eも詳しくないのでわかりませんが多分あるでしょう。どっちがはやいんだろうなー\u003c/p\u003e\n\n\u003ch2\u003e\u003ca href=\"http://yukicoder.me/problems/476\"\u003eNo.202 1円玉投げ - yukicoder\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003e1円玉を1つずつ投げていって重なったら取り除く、を繰り返した時最後に何枚残っているか、という問題ですね。\u003cbr/\u003e\n最初にとりあえず書いてみた解答がこちら。\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;functional\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;algorithm\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;cmath\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#define REP(i,n) \u003c/span\u003e\u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e(\u003c/span\u003e\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e i=\u003c/span\u003e\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e;i\u0026lt;(n);i++)\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e \u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e std;\n\n\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e is_on(pair\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e,\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u0026amp;a, pair\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u0026amp;b)\n{\n    \u003cspan class=\"synType\"\u003edouble\u003c/span\u003e dist = (a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second);\n    dist = sqrt(dist);\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e dist \u0026lt; \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e;\n}\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main() {\n    cin.tie(\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e);\n    ios::sync_with_stdio(\u003cspan class=\"synConstant\"\u003efalse\u003c/span\u003e);\n\n    \u003cspan class=\"synType\"\u003eint\u003c/span\u003e N;\n    cin \u0026gt;\u0026gt; N;\n    \u003cspan class=\"synType\"\u003eint\u003c/span\u003e x, y;\n    cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n    N--;\n    vector\u0026lt;pair\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u0026gt; coins;\n    coins.emplace_back(x, y);\n\n    REP(i, N) {\n        cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n        \u003cspan class=\"synType\"\u003eauto\u003c/span\u003e p = pair\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e,\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt;(x, y);\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (!any_of(coins.begin(), coins.end(), [\u0026amp;p](pair\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u0026amp;a) \u003cspan class=\"synError\"\u003e{\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e is_on(a, p); })) {\n            coins.push_back(move(p));\n        }\n    }\n    cout \u0026lt;\u0026lt; coins.size() \u0026lt;\u0026lt; endl;\n\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n}\n\u003c/pre\u003e\n\n\u003cp\u003e投げるたびに、今までのコイン達と重なっているかどうかをチェックし、どれとも重なっていなかった場合は追加する、というナイーブな実装です。これだと答えは合うのですが、TLEになってしまいました。\u003cbr/\u003e\nはじめはx軸方向にソートして、x軸方向で20より離れていればチェックの必要がないので、チェックの必要がある部分を二分探索で求めるという方法を考えたのですが、なんかあんまりうまい方法に思えなくて詰まりまくりました。\u003c/p\u003e\n\n\u003cp\u003e0 \u0026lt;= x, y \u0026lt;= 20000 というフィールドを 10 × 10 の細かいフィールドに区切ってチェックするという方法がスタンダードみたいですね！なるほど！ \u003cbr/\u003e\nというわけで実装してみたのがこちら\u003c/p\u003e\n\n\u003cpre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink\u003e\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;functional\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;algorithm\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;cmath\u0026gt;\u003c/span\u003e\n\u003cspan class=\"synPreProc\"\u003e#include \u003c/span\u003e\u003cspan class=\"synConstant\"\u003e\u0026lt;array\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"synPreProc\"\u003e#define REP(i, n) \u003c/span\u003e\u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e(\u003c/span\u003e\u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e i=\u003c/span\u003e\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e\u003cspan class=\"synPreProc\"\u003e;i\u0026lt;(n);i++)\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003eusing\u003c/span\u003e \u003cspan class=\"synType\"\u003enamespace\u003c/span\u003e std;\n\n\u003cspan class=\"synType\"\u003etypedef\u003c/span\u003e pair\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; P;\n\n\u003cspan class=\"synType\"\u003econst\u003c/span\u003e \u003cspan class=\"synType\"\u003eint\u003c/span\u003e MAX_N = \u003cspan class=\"synConstant\"\u003e100000\u003c/span\u003e;\narray\u0026lt;array\u0026lt;vector\u0026lt;P\u0026gt;, \u003cspan class=\"synConstant\"\u003e2000\u003c/span\u003e\u0026gt;, \u003cspan class=\"synConstant\"\u003e20000\u003c/span\u003e / \u003cspan class=\"synConstant\"\u003e10\u003c/span\u003e\u0026gt; fields;\n\n\u003cspan class=\"synType\"\u003ebool\u003c/span\u003e is_on(pair\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u0026amp;a, pair\u0026lt;\u003cspan class=\"synType\"\u003eint\u003c/span\u003e, \u003cspan class=\"synType\"\u003eint\u003c/span\u003e\u0026gt; \u0026amp;b) {\n    \u003cspan class=\"synType\"\u003edouble\u003c/span\u003e dist = (a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second);\n    dist = sqrt(dist);\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e dist \u0026lt; \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e;\n}\n\n\u003cspan class=\"synType\"\u003eint\u003c/span\u003e main() {\n    cin.tie(\u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e);\n    ios::sync_with_stdio(\u003cspan class=\"synConstant\"\u003efalse\u003c/span\u003e);\n\n    \u003cspan class=\"synType\"\u003eint\u003c/span\u003e N;\n    cin \u0026gt;\u0026gt; N;\n    \u003cspan class=\"synType\"\u003eint\u003c/span\u003e x, y;\n    cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n    N--;\n    fields[x / \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e][y / \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e].emplace_back(x, y);\n\n    \u003cspan class=\"synType\"\u003eint\u003c/span\u003e ans = \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e;\n\n    REP(k, N) {\n        cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n        P current(x, y);\n        \u003cspan class=\"synType\"\u003eint\u003c/span\u003e fx = x / \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e, fy = y / \u003cspan class=\"synConstant\"\u003e20\u003c/span\u003e;\n        \u003cspan class=\"synType\"\u003ebool\u003c/span\u003e flg = \u003cspan class=\"synConstant\"\u003etrue\u003c/span\u003e;\n        \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e (\u003cspan class=\"synType\"\u003eint\u003c/span\u003e i = -\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e; i \u0026lt;= \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e \u0026amp;\u0026amp; flg; ++i) {\n            \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e (\u003cspan class=\"synType\"\u003eint\u003c/span\u003e j = -\u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e; j \u0026lt;= \u003cspan class=\"synConstant\"\u003e1\u003c/span\u003e \u0026amp;\u0026amp; flg; ++j) {\n                \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (fx + i \u0026lt; \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e || fx + i \u0026gt;= \u003cspan class=\"synConstant\"\u003e2000\u003c/span\u003e || fy + j \u0026lt; \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e || fy + j \u0026gt;= \u003cspan class=\"synConstant\"\u003e2000\u003c/span\u003e) \u003cspan class=\"synStatement\"\u003econtinue\u003c/span\u003e;\n                \u003cspan class=\"synStatement\"\u003efor\u003c/span\u003e (\u003cspan class=\"synType\"\u003eauto\u003c/span\u003e p: fields[fx + i][fy + j]) {\n                    \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (is_on(p, current)) {\n                        flg = \u003cspan class=\"synConstant\"\u003efalse\u003c/span\u003e;\n                        \u003cspan class=\"synStatement\"\u003ebreak\u003c/span\u003e;\n                    }\n                }\n            }\n        }\n        \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e (flg) {\n            fields[fx][fy].push_back(current);\n            ans++;\n        }\n    }\n    cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;\n\n    \u003cspan class=\"synStatement\"\u003ereturn\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e0\u003c/span\u003e;\n}\n\u003c/pre\u003e\n\n\u003cp\u003e10 × 10 のマスに区切って、コインが重なる可能性のある部分(つまり隣接するマス)についてのみチェックをするという実装です。\u003cbr/\u003e\n今思ったのですが、10 × 10 のマスに区切ったらその中に存在できるコインの数って多分1子だけですよね？そしたら \u003ccode\u003earray\u0026lt; array\u0026lt;P, 2000\u0026gt;, 2000\u0026gt;\u003c/code\u003e でもよかったかもですね！(あ、でもそれだとコインが存在しないときの値がよくわからなくなるなーoption型とか欲しくなる)\u003c/p\u003e\n\n\u003ch1\u003eまとめ\u003c/h1\u003e\n\n\u003cp\u003eやっぱり出場したかったなーあのコンテストの感じがないと集中しきれないというかｗｗ\u003cbr/\u003e\nコンテストだと出来ない時にすごく悔しくて次回への勉強のモチベーションがあがるんですよね！だから今後極力出場していこうと思います！\u003c/p\u003e\n\n\u003cp\u003e学びとしては、きちんと問題の対象範囲をよく読むことと、検索の範囲を狭めることで解決できる問題の場合はフィールドをマス目状に区切る方法があるということですね！次回に活かします！\u003c/p\u003e\n\n---\n\n---\n","slug":"yukicoder_2015_05_03","title":"yukicoder 2015/05/03","timestamp":1430732327000,"tags":[]},{"rawMarkdown":"---\ntitle: \"【yukicoder】yukicoder open 2015 small - 3完\"\ndate: 2015-04-26T15:47:58.000Z\ntags: []\n---\n\n\u003ch1\u003eyukicoder open 2015 small に挑戦してきました！\u003c/h1\u003e\n\n\u003cp\u003e\u003ca href=\"http://yukicoder.me/\"\u003eyukicoder\u003c/a\u003eさん主催のコンテストに初挑戦してきました！\u003cbr/\u003e\n人生二回目のコンテストということで昨日よりは緊張もなく楽しめたかな？\u003cbr/\u003e\n言い訳になりますがちょっと同時並行でやらなきゃいけないことがあったので最初の方が変に時間食ってます...\u003c/p\u003e\n\n\u003ch1\u003e結果\u003c/h1\u003e\n\n\u003cp\u003e3完で\u003cs\u003e44位でしたー\u003c/s\u003e\u003cbr/\u003e\n\u003cstrong\u003e追記\u003c/strong\u003e\nyukicoderさんのチャレンジなる仕様によって順位が繰り上がりましたｗｗ41位という結果になりましたー\u003cbr/\u003e\n\u003cstrong\u003e追記ここまで\u003c/strong\u003e\u003cbr/\u003e\n3問目で変にはまってしまったので辛かった...\u003cbr/\u003e\nけどまぁ解けなきゃいけない問題は解いたかなーという感じ\u003c/p\u003e\n\n\u003ch1\u003e復習\u003c/h1\u003e\n\n\u003ch2\u003e191\u003c/h2\u003e\n\n\u003cp\u003eこれは一旦全部足して1/10の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%EC%A5%C3%A5%B7%A5%E7%A5%EB%A5%C9\"\u003eスレッショルド\u003c/a\u003eを求めてから、超えていないものの数を数えるだけですねー\u003cbr/\u003e\nちゃんとスタートと同時にはじめられて入ればこれはすぐ解けたのになー実際の記録は12分とかかかってますｗｗ\u003c/p\u003e\n\n\u003ch2\u003e192\u003c/h2\u003e\n\n\u003cp\u003e合成数を求める問題です！正の約数を持っていさえすればいいので偶数にしちゃうのが一番簡単ですかねー\u003cbr/\u003e\n僕は奇数だったら1足して出力、偶数だったらそのまま出力としました！\u003cbr/\u003e\n想定解はおしゃれでしたねー 整数型 \u003ccode\u003ex\u003c/code\u003e に対して \u003ccode\u003ex / 2 * 2\u003c/code\u003e を計算すると切り捨てのお陰で必ず偶数になります！\u003cbr/\u003e\n\u003ccode\u003eN\u003c/code\u003e の制約の関係上、偶数の中で唯一合成数でない2のことを考える必要はありません！\u003c/p\u003e\n\n\u003ch2\u003e193\u003c/h2\u003e\n\n\u003cp\u003eチャレンジによって \u003ccode\u003eeval\u003c/code\u003e を使用していたLL勢の多くがWAになっていましたー\u003cbr/\u003e\nLeading Zero を \u003ccode\u003eeval\u003c/code\u003e すると八進数扱いになったりしてしまうようですね！\u003cbr/\u003e\n僕はなんか冗長な気もしたけどうまい方法が他に思いつかなかったので\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BC%EA%BD%F1%A4%AD\"\u003e手書き\u003c/a\u003eでパースしてたので助かりましたね\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/D%B8%C0%B8%EC\"\u003eD言語\u003c/a\u003eを使っていて助かった感がありますｗｗ\u003c/p\u003e\n\n\u003cp\u003e入力 \u003ccode\u003eS\u003c/code\u003e を2つつなげた \u003ccode\u003estring l = S ~ S;\u003c/code\u003e を定義してウィンドウを横にずらしながらひたすら計算していくという解答にしましたー\u003cbr/\u003e\nそしたらなぜか途中からWAになってしまい原因がわからなかったのでウィンドウの作り方を変えてみたり \u003ccode\u003eint\u003c/code\u003e を \u003ccode\u003elong\u003c/code\u003e にしてみたりしました\u003cbr/\u003e\n結局は考えられる最大値が負になる場合を考慮していなかったのが原因でしたー\u003c/p\u003e\n\n\u003ch2\u003e194\u003c/h2\u003e\n\n\u003cp\u003eここから先は全然わかりませんでしたー194に関してはゴリ押しで小さい数字なら求められたのですが、計算量的に全然間に合わないので手が止まってしまいました...\u003cbr/\u003e\n\u003ca href=\"http://kmjp.hatenablog.jp/entry/2015/04/27/0900\"\u003eyukicoder : No.194 フィボナッチ数列の理解(1) - kmjp's blog\u003c/a\u003eで解説してくださっています！\u003c/p\u003e\n\n\u003cp\u003eこれは思いつくのは無理ｗｗｗ\u003cbr/\u003e\nみなさんこれを普通に解いていて驚きますねー...\u003c/p\u003e\n\n\u003ch2\u003e195, 196\u003c/h2\u003e\n\n\u003cp\u003eこの2問は問題文すらろくに見られていないのでまた後日復習したいと思います！\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003ch1\u003eyukicoder open 2015 small に挑戦してきました！\u003c/h1\u003e\n\n\u003cp\u003e\u003ca href=\"http://yukicoder.me/\"\u003eyukicoder\u003c/a\u003eさん主催のコンテストに初挑戦してきました！\u003cbr/\u003e\n人生二回目のコンテストということで昨日よりは緊張もなく楽しめたかな？\u003cbr/\u003e\n言い訳になりますがちょっと同時並行でやらなきゃいけないことがあったので最初の方が変に時間食ってます...\u003c/p\u003e\n\n\u003ch1\u003e結果\u003c/h1\u003e\n\n\u003cp\u003e3完で\u003cs\u003e44位でしたー\u003c/s\u003e\u003cbr/\u003e\n\u003cstrong\u003e追記\u003c/strong\u003e\nyukicoderさんのチャレンジなる仕様によって順位が繰り上がりましたｗｗ41位という結果になりましたー\u003cbr/\u003e\n\u003cstrong\u003e追記ここまで\u003c/strong\u003e\u003cbr/\u003e\n3問目で変にはまってしまったので辛かった...\u003cbr/\u003e\nけどまぁ解けなきゃいけない問題は解いたかなーという感じ\u003c/p\u003e\n\n\u003ch1\u003e復習\u003c/h1\u003e\n\n\u003ch2\u003e191\u003c/h2\u003e\n\n\u003cp\u003eこれは一旦全部足して1/10の\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%EC%A5%C3%A5%B7%A5%E7%A5%EB%A5%C9\"\u003eスレッショルド\u003c/a\u003eを求めてから、超えていないものの数を数えるだけですねー\u003cbr/\u003e\nちゃんとスタートと同時にはじめられて入ればこれはすぐ解けたのになー実際の記録は12分とかかかってますｗｗ\u003c/p\u003e\n\n\u003ch2\u003e192\u003c/h2\u003e\n\n\u003cp\u003e合成数を求める問題です！正の約数を持っていさえすればいいので偶数にしちゃうのが一番簡単ですかねー\u003cbr/\u003e\n僕は奇数だったら1足して出力、偶数だったらそのまま出力としました！\u003cbr/\u003e\n想定解はおしゃれでしたねー 整数型 \u003ccode\u003ex\u003c/code\u003e に対して \u003ccode\u003ex / 2 * 2\u003c/code\u003e を計算すると切り捨てのお陰で必ず偶数になります！\u003cbr/\u003e\n\u003ccode\u003eN\u003c/code\u003e の制約の関係上、偶数の中で唯一合成数でない2のことを考える必要はありません！\u003c/p\u003e\n\n\u003ch2\u003e193\u003c/h2\u003e\n\n\u003cp\u003eチャレンジによって \u003ccode\u003eeval\u003c/code\u003e を使用していたLL勢の多くがWAになっていましたー\u003cbr/\u003e\nLeading Zero を \u003ccode\u003eeval\u003c/code\u003e すると八進数扱いになったりしてしまうようですね！\u003cbr/\u003e\n僕はなんか冗長な気もしたけどうまい方法が他に思いつかなかったので\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BC%EA%BD%F1%A4%AD\"\u003e手書き\u003c/a\u003eでパースしてたので助かりましたね\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/D%B8%C0%B8%EC\"\u003eD言語\u003c/a\u003eを使っていて助かった感がありますｗｗ\u003c/p\u003e\n\n\u003cp\u003e入力 \u003ccode\u003eS\u003c/code\u003e を2つつなげた \u003ccode\u003estring l = S ~ S;\u003c/code\u003e を定義してウィンドウを横にずらしながらひたすら計算していくという解答にしましたー\u003cbr/\u003e\nそしたらなぜか途中からWAになってしまい原因がわからなかったのでウィンドウの作り方を変えてみたり \u003ccode\u003eint\u003c/code\u003e を \u003ccode\u003elong\u003c/code\u003e にしてみたりしました\u003cbr/\u003e\n結局は考えられる最大値が負になる場合を考慮していなかったのが原因でしたー\u003c/p\u003e\n\n\u003ch2\u003e194\u003c/h2\u003e\n\n\u003cp\u003eここから先は全然わかりませんでしたー194に関してはゴリ押しで小さい数字なら求められたのですが、計算量的に全然間に合わないので手が止まってしまいました...\u003cbr/\u003e\n\u003ca href=\"http://kmjp.hatenablog.jp/entry/2015/04/27/0900\"\u003eyukicoder : No.194 フィボナッチ数列の理解(1) - kmjp's blog\u003c/a\u003eで解説してくださっています！\u003c/p\u003e\n\n\u003cp\u003eこれは思いつくのは無理ｗｗｗ\u003cbr/\u003e\nみなさんこれを普通に解いていて驚きますねー...\u003c/p\u003e\n\n\u003ch2\u003e195, 196\u003c/h2\u003e\n\n\u003cp\u003eこの2問は問題文すらろくに見られていないのでまた後日復習したいと思います！\u003c/p\u003e\n\n---\n\n---\n","slug":"【yukicoder】yukicoder_open_2015_small_-_3完","title":"【yukicoder】yukicoder open 2015 small - 3完","timestamp":1430063278000,"tags":[]},{"rawMarkdown":"---\ntitle: \"【AtCoder】ABC022 - 競技プログラミング初挑戦！\"\ndate: 2015-04-25T15:05:47.000Z\ntags: []\n---\n\n\u003ch1\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\"\u003eAtCoder\u003c/a\u003e ABC022に挑戦！\u003c/h1\u003e\n\n\u003cp\u003e人生で初めて競技プログラミングのコンテスト(オンライン)に出場してみました！\u003cbr/\u003e\n使用言語は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eにしようかと思ったのですが、どっちかというと\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/D%B8%C0%B8%EC\"\u003eD言語\u003c/a\u003eのほうがすきだし、Dlangも十分競技プログラミングに向いているっぽかったので\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/D%B8%C0%B8%EC\"\u003eD言語\u003c/a\u003eで出場しました。\u003c/p\u003e\n\n\u003ch1\u003e結果\u003c/h1\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003e2完で121位でした\u003c/em\u003e\u003c/strong\u003e\u003cbr/\u003e\nいやー惨敗でしたねｗｗ\u003cbr/\u003e\nA問題がなんか変に時間食っちゃって、焦りました。そしてB問題がするっと出来て、「おっ！」と思ったら案の定C以降にても足も出ませんでした...\u003cbr/\u003e\nC問題に関してはそもそも問題文を勘違いしていました（勘違いに気がついても結局できなかったｗｗ）\u003c/p\u003e\n\n\u003ch1\u003e復習\u003c/h1\u003e\n\n\u003cp\u003e解説放送も聞いてきましたー\u003c/p\u003e\n\n\u003ch2\u003eA問題\u003c/h2\u003e\n\n\u003cp\u003e普通にたしていった。一回全部入力受けてから計算始めてたけど無駄だったなー受け取りながら計算すればもっと早くなってたはず。\u003cbr/\u003e\n今回は簡単な問題だったのでよかったけど、こういうのでTLEになる場合もあるんだろうな\u003c/p\u003e\n\n\u003ch2\u003eB問題\u003c/h2\u003e\n\n\u003cp\u003eN - (花の種類)というおしゃれ解法もある様子(ただしやることは結局同じで、今まで訪れた花の種類を覚えながら舐める)\u003c/p\u003e\n\n\u003cp\u003eここまでは完答\u003c/p\u003e\n\n\u003ch2\u003eC問題\u003c/h2\u003e\n\n\u003cp\u003e頂点1に隣接する頂点はちょうど2つなので、その2つをつなぐ最短経路を求めればいい！！\u003cbr/\u003e\n発想はなんとなくあってたなー\u003cbr/\u003e\n僕が考えていたのは、頂点1から道が伸びてる頂点Xについて、 1 - X間の道を除いたグラフを考えて、X - 1の最短経路を\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C0%A5%A4%A5%AF%A5%B9%A5%C8%A5%E9\"\u003eダイクストラ\u003c/a\u003eで求めるやり方でした\u003cbr/\u003e\n結局実装力不足で死にましたが...\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%28%A1%AD%A1%A6%A6%D8%A1%A6%60%29\"\u003e(´・ω・`)\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C0%A5%A4%A5%AF%A5%B9%A5%C8%A5%E9\"\u003eダイクストラ\u003c/a\u003eだとO(N\u003csup\u003e2\u003c/sup\u003e) * O(N\u003csup\u003e2\u003c/sup\u003e) = O(N\u003csup\u003e4\u003c/sup\u003e)になっちゃうけど、ワーシャルフロイドを使えばO(N\u003csup\u003e3\u003c/sup\u003e)ですむとのこと。たしかに。\u003cbr/\u003e\nワーシャル\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%ED%A5%A4%A5%C8\"\u003eフロイト\u003c/a\u003eは実装らくちんだもんなー\u003cbr/\u003e\nなるほどだなー悔しいなこれ。あとちょっとだった。\u003c/p\u003e\n\n\u003ch2\u003eD問題\u003c/h2\u003e\n\n\u003cp\u003eC問題でつまづきまくってしまい心が折れてたので全然まともに挑んでいないです...\u003cbr/\u003e\n解説きいたあとだから言いたい放題なんだけど、これ部分点までならとれた気がするｗｗ\u003cbr/\u003e\nいろいろ解法がある様子。とにかく、回転移動や平行移動に惑わされない値に注目してあげれば、相似比は簡単に求まるよねーというお話。\u003cbr/\u003e\nぱっと思いついたのは最遠点だったけど、それだとO(NlogN)で部分点らしい。\u003cbr/\u003e\n最も初心者向けなのは重心からの最遠点までの距離っぽいです。\u003c/p\u003e\n\n\u003ch1\u003e感想などなど\u003c/h1\u003e\n\n\u003cp\u003e初めて競技プログラミングのコンテストに出場しましたがめちゃくちゃ楽しいですねこれ！\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\"\u003eAtCoder\u003c/a\u003eさんの解説放送のおかげでわからなかった問題の理解もできたし、はまりそう.\u003cbr/\u003e\nもともとコンテスト外の問題は練習で少しだけ解いたことがあったのですが、全然別物の面白さでしたー\u003cbr/\u003e\nとりあえず\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C0%A5%A4%A5%AF%A5%B9%A5%C8%A5%E9\"\u003eダイクストラ\u003c/a\u003eとかの基本\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\"\u003eアルゴリズム\u003c/a\u003eに関してはすらすら実装できるようになりたいなー\u003c/p\u003e\n\n\u003cp\u003e明日はyukicoderさんのコンテストがある？のかな？\u003cbr/\u003e\n出場してみたいと思います！\u003c/p\u003e\n\n\u003cp\u003eでは模範解答を写経して寝ます！\u003c/p\u003e\n\n---\n\n---\n","contentMarkdown":"\n\u003ch1\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\"\u003eAtCoder\u003c/a\u003e ABC022に挑戦！\u003c/h1\u003e\n\n\u003cp\u003e人生で初めて競技プログラミングのコンテスト(オンライン)に出場してみました！\u003cbr/\u003e\n使用言語は\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\"\u003eC++\u003c/a\u003eにしようかと思ったのですが、どっちかというと\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/D%B8%C0%B8%EC\"\u003eD言語\u003c/a\u003eのほうがすきだし、Dlangも十分競技プログラミングに向いているっぽかったので\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/D%B8%C0%B8%EC\"\u003eD言語\u003c/a\u003eで出場しました。\u003c/p\u003e\n\n\u003ch1\u003e結果\u003c/h1\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003e2完で121位でした\u003c/em\u003e\u003c/strong\u003e\u003cbr/\u003e\nいやー惨敗でしたねｗｗ\u003cbr/\u003e\nA問題がなんか変に時間食っちゃって、焦りました。そしてB問題がするっと出来て、「おっ！」と思ったら案の定C以降にても足も出ませんでした...\u003cbr/\u003e\nC問題に関してはそもそも問題文を勘違いしていました（勘違いに気がついても結局できなかったｗｗ）\u003c/p\u003e\n\n\u003ch1\u003e復習\u003c/h1\u003e\n\n\u003cp\u003e解説放送も聞いてきましたー\u003c/p\u003e\n\n\u003ch2\u003eA問題\u003c/h2\u003e\n\n\u003cp\u003e普通にたしていった。一回全部入力受けてから計算始めてたけど無駄だったなー受け取りながら計算すればもっと早くなってたはず。\u003cbr/\u003e\n今回は簡単な問題だったのでよかったけど、こういうのでTLEになる場合もあるんだろうな\u003c/p\u003e\n\n\u003ch2\u003eB問題\u003c/h2\u003e\n\n\u003cp\u003eN - (花の種類)というおしゃれ解法もある様子(ただしやることは結局同じで、今まで訪れた花の種類を覚えながら舐める)\u003c/p\u003e\n\n\u003cp\u003eここまでは完答\u003c/p\u003e\n\n\u003ch2\u003eC問題\u003c/h2\u003e\n\n\u003cp\u003e頂点1に隣接する頂点はちょうど2つなので、その2つをつなぐ最短経路を求めればいい！！\u003cbr/\u003e\n発想はなんとなくあってたなー\u003cbr/\u003e\n僕が考えていたのは、頂点1から道が伸びてる頂点Xについて、 1 - X間の道を除いたグラフを考えて、X - 1の最短経路を\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C0%A5%A4%A5%AF%A5%B9%A5%C8%A5%E9\"\u003eダイクストラ\u003c/a\u003eで求めるやり方でした\u003cbr/\u003e\n結局実装力不足で死にましたが...\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%28%A1%AD%A1%A6%A6%D8%A1%A6%60%29\"\u003e(´・ω・`)\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C0%A5%A4%A5%AF%A5%B9%A5%C8%A5%E9\"\u003eダイクストラ\u003c/a\u003eだとO(N\u003csup\u003e2\u003c/sup\u003e) * O(N\u003csup\u003e2\u003c/sup\u003e) = O(N\u003csup\u003e4\u003c/sup\u003e)になっちゃうけど、ワーシャルフロイドを使えばO(N\u003csup\u003e3\u003c/sup\u003e)ですむとのこと。たしかに。\u003cbr/\u003e\nワーシャル\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%ED%A5%A4%A5%C8\"\u003eフロイト\u003c/a\u003eは実装らくちんだもんなー\u003cbr/\u003e\nなるほどだなー悔しいなこれ。あとちょっとだった。\u003c/p\u003e\n\n\u003ch2\u003eD問題\u003c/h2\u003e\n\n\u003cp\u003eC問題でつまづきまくってしまい心が折れてたので全然まともに挑んでいないです...\u003cbr/\u003e\n解説きいたあとだから言いたい放題なんだけど、これ部分点までならとれた気がするｗｗ\u003cbr/\u003e\nいろいろ解法がある様子。とにかく、回転移動や平行移動に惑わされない値に注目してあげれば、相似比は簡単に求まるよねーというお話。\u003cbr/\u003e\nぱっと思いついたのは最遠点だったけど、それだとO(NlogN)で部分点らしい。\u003cbr/\u003e\n最も初心者向けなのは重心からの最遠点までの距離っぽいです。\u003c/p\u003e\n\n\u003ch1\u003e感想などなど\u003c/h1\u003e\n\n\u003cp\u003e初めて競技プログラミングのコンテストに出場しましたがめちゃくちゃ楽しいですねこれ！\u003cbr/\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\"\u003eAtCoder\u003c/a\u003eさんの解説放送のおかげでわからなかった問題の理解もできたし、はまりそう.\u003cbr/\u003e\nもともとコンテスト外の問題は練習で少しだけ解いたことがあったのですが、全然別物の面白さでしたー\u003cbr/\u003e\nとりあえず\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C0%A5%A4%A5%AF%A5%B9%A5%C8%A5%E9\"\u003eダイクストラ\u003c/a\u003eとかの基本\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\"\u003eアルゴリズム\u003c/a\u003eに関してはすらすら実装できるようになりたいなー\u003c/p\u003e\n\n\u003cp\u003e明日はyukicoderさんのコンテストがある？のかな？\u003cbr/\u003e\n出場してみたいと思います！\u003c/p\u003e\n\n\u003cp\u003eでは模範解答を写経して寝ます！\u003c/p\u003e\n\n---\n\n---\n","slug":"【AtCoder】ABC022_-_競技プログラミング初挑戦！","title":"【AtCoder】ABC022 - 競技プログラミング初挑戦！","timestamp":1429974347000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Rustで自作シェルもどきを作る(単純なコマンド実行編)\"\ndate: 2014-12-21T14:55:51+09:00\ntags: [\"Rust\"]\nurl: https://qiita.com/agatan/items/ed2780628d20a0e343b8\n---\n\nコード全文はこちら\n[agatan/rsh](https://github.com/agatan/rsh)\n\n[Rust で自作シェルもどきを作る(字句解析編) - Qiita](http://qiita.com/agatan/items/8a097ead46df1c1659ff)\n\n前回はユーザからの入力を受け付けてパースするところまで実装したので、今回は実際に入力されたコマンドを実行させてみます。  \nただし、いきなりいろいろやるのはきついので、まずは単純なコマンド(パイプやリダイレクトは一旦無視します)の実行をやってみました。\n\n## Command\n\nRust には`std::io::process::Command`という構造体があります。これを使えば簡単にコマンド実行は出来そうです。\n\n\u003e http://doc.rust-lang.org/std/io/process/struct.Command.htmlより引用\n\u003e\n\u003e ```rust\n\u003e use std::io::Command;\n\u003e ```\n\n\u003e let mut process = match Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").spawn() {\n\u003e Ok(p) =\u003e p,\n\u003e Err(e) =\u003e panic!(\"failed to execute process: {}\", e),\n\u003e };\n\n\u003e let output = process.stdout.as_mut().unwrap().read_to_end();\n\n````\n\nいろいろと便利そうな関数が定義されているのですが、今回は最も単純にコマンドを実行させるために、`output`という関数を使用してみました。\n\n```rust:exec.rs\nuse std;\nuse std::io::process::Command;\n\nuse parse::Token;\n\npub fn exec(tokens: Vec\u003cToken\u003e) {\n    if tokens.iter()\n             .find(|\u0026t| match t {\n                 \u0026Token::Str(_) =\u003e false, _ =\u003e true } ).is_some() {\n        panic!(\"Not implemented yet.\");\n    }\n    let first_cmd = tokens.iter()\n                          .take_while(|\u0026t| match t {\n                              \u0026Token::Str(_) =\u003e true,\n                              _ =\u003e false\n                          })\n                          .map(|ref t| match *t {\n                              \u0026Token::Str(ref x) =\u003e x.clone(),\n                              _ =\u003e panic!(\"Shouldn't be reached.\"),\n                          })\n                          .collect::\u003cVec\u003cString\u003e\u003e();\n\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .output() {\n        Ok(p) =\u003e p,\n        Err(e) =\u003e panic!(\"Failed to execute: {}\", e),\n    };\n\n    print!(\"{}\", String::from_utf8_lossy(output.output.as_slice()));\n\n}\n````\n\n`exec`は`Vec\u003cToken\u003e`を受け取る関数です。\n今回はパイプなどは未実装ですから、`Str(_)`以外の`Token`が含まれていたら`panic!`(例外送出)をしています。\n\nさて、`Command`は`new`で実行したいコマンド名を指定し、それに続けて`arg`や`args`で引数を追加していきます。\nユーザからの入力を利用しているので、ひとつずつしか追加できない`arg`よりは、スライスを渡して複数追加できる`args`を使いたいです。\n\nこれらにあわせて`Vec\u003cToken\u003e`を`Vec\u003cString\u003e`もしくは`Vec\u003c\u0026str\u003e`に変換してあげれば良さそうです。\nということで`let first_cmd = ...`という長い文は、その変換を行っています。\n\n正直まだ`\u0026`と`ref`の関係とか所有権の問題はきちんと理解できていないというか書き方がよくわかっていないので、コンパイラに怒ってもらいながらなんとか直してみました。\nコンパイルを通るように、を第一に書いていったので汚かったり効率悪かったりするかもしれません...\n\nあとは`Command`に登録していって、`output`を読んであげれば完了です。\nただし`output`はバイト列を返すみたいなので、`String::from_utf8_lossy`を使って、文字に直してあげます。\n\n#### 追記(2014/12/21)\n\n---\n\nこのままだと標準入力や標準出力、標準エラー出力が子プロセスと結びついておらず、仮想のパイプとつながったような状態になるようです。\nそのため、標準入力から読み取るような関数を実行しようとするとそのプロセスは失敗します。\n\n修正したのが以下のコードです。(`Command`を作成する部分のみ)\n\n```rust\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .stdin(StdioContainer::InheritFd(STDIN_FILENO))\n                              .stdout(StdioContainer::InheritFd(STDOUT_FILENO))\n                              .stderr(StdioContainer::InheritFd(STDERR_FILENO))\n                              .spawn() {\n        Ok(p) =\u003e p,\n        Err(e) =\u003e panic!(\"ERROR: {}\", e)\n                              };\n    match output.wait() {\n        Ok(e) =\u003e println!(\"Exit: {}\", e),\n        Err(e) =\u003e println!(\"Error: {}\", e)\n    }\n```\n\nこのように、`stdout`を標準出力と関連付けることで、前のコードでの`output`から読み取って文字列に変換して出力、という手順は不要になりました。\nC 言語では`fork`したら`wait`しろと言われて育ってきたので、とりあえず`wait`を入れてみていますが、どうも`wait`を入れなくてもゾンビプロセスが残っているようには見えないので謎です。\n調査中です。\n\n### 追記ここまで\n\n## main\n\n先ほどの`exec`関数を`main`で使える形にしてみます。\n\n```rust:main.rs\nuse std::io;\nmod parse;\nmod exec;\n\nfn main() {\n    loop {\n        print!(\"% \u003e \");\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let parser = parse::Parser::new(input);\n        let tokens: Vec\u003cparse::Token\u003e = parser.collect();\n        exec::exec(tokens);\n    }\n}\n```\n\nプロンプトを表示してからユーザーの入力を受付け、パースして`Vec\u003cToken\u003e`になおしてから`exec`に渡しています。\n\n## 実行結果\n\n```\n% \u003e echo hello\nhello\n% \u003e echo \"hello world\"\n\"hello world\"\n% \u003e\n```\n\nあれ？`\"`の扱いなんて考えてなかったのになぜかうまくいってますね。不思議。\n\n検証用に`main.rs`を書き換えて実行してみました。\n\n```\n% \u003e echo hello\nStr(echo)\nStr(hello)\nhello\n% \u003e echo \"hello world\"\nStr(echo)\nStr(\"hello)\nStr(world\")\n\"hello world\"\n% \u003e echo \"hello     world\"\nStr(echo)\nStr(\"hello)\nStr(world\")\n\"hello world\"\n% \u003e\n```\n\n`echo`がうまくやってくれているみたいですね。すごい。\n\n## 今後\n\n次はリダイレクト関連ですかね。パイプや\u0026よりも簡単そうだし。\n毎度のことですが、ご指摘大歓迎です！色々な意見を伺いたくてこれを書いているので、何かありましたらぜひよろしくお願いします！\n\n[agatan/rsh](https://github.com/agatan/rsh)\n","contentMarkdown":"\nコード全文はこちら\n[agatan/rsh](https://github.com/agatan/rsh)\n\n[Rust で自作シェルもどきを作る(字句解析編) - Qiita](http://qiita.com/agatan/items/8a097ead46df1c1659ff)\n\n前回はユーザからの入力を受け付けてパースするところまで実装したので、今回は実際に入力されたコマンドを実行させてみます。  \nただし、いきなりいろいろやるのはきついので、まずは単純なコマンド(パイプやリダイレクトは一旦無視します)の実行をやってみました。\n\n## Command\n\nRust には`std::io::process::Command`という構造体があります。これを使えば簡単にコマンド実行は出来そうです。\n\n\u003e http://doc.rust-lang.org/std/io/process/struct.Command.htmlより引用\n\u003e\n\u003e ```rust\n\u003e use std::io::Command;\n\u003e ```\n\n\u003e let mut process = match Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").spawn() {\n\u003e Ok(p) =\u003e p,\n\u003e Err(e) =\u003e panic!(\"failed to execute process: {}\", e),\n\u003e };\n\n\u003e let output = process.stdout.as_mut().unwrap().read_to_end();\n\n````\n\nいろいろと便利そうな関数が定義されているのですが、今回は最も単純にコマンドを実行させるために、`output`という関数を使用してみました。\n\n```rust:exec.rs\nuse std;\nuse std::io::process::Command;\n\nuse parse::Token;\n\npub fn exec(tokens: Vec\u003cToken\u003e) {\n    if tokens.iter()\n             .find(|\u0026t| match t {\n                 \u0026Token::Str(_) =\u003e false, _ =\u003e true } ).is_some() {\n        panic!(\"Not implemented yet.\");\n    }\n    let first_cmd = tokens.iter()\n                          .take_while(|\u0026t| match t {\n                              \u0026Token::Str(_) =\u003e true,\n                              _ =\u003e false\n                          })\n                          .map(|ref t| match *t {\n                              \u0026Token::Str(ref x) =\u003e x.clone(),\n                              _ =\u003e panic!(\"Shouldn't be reached.\"),\n                          })\n                          .collect::\u003cVec\u003cString\u003e\u003e();\n\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .output() {\n        Ok(p) =\u003e p,\n        Err(e) =\u003e panic!(\"Failed to execute: {}\", e),\n    };\n\n    print!(\"{}\", String::from_utf8_lossy(output.output.as_slice()));\n\n}\n````\n\n`exec`は`Vec\u003cToken\u003e`を受け取る関数です。\n今回はパイプなどは未実装ですから、`Str(_)`以外の`Token`が含まれていたら`panic!`(例外送出)をしています。\n\nさて、`Command`は`new`で実行したいコマンド名を指定し、それに続けて`arg`や`args`で引数を追加していきます。\nユーザからの入力を利用しているので、ひとつずつしか追加できない`arg`よりは、スライスを渡して複数追加できる`args`を使いたいです。\n\nこれらにあわせて`Vec\u003cToken\u003e`を`Vec\u003cString\u003e`もしくは`Vec\u003c\u0026str\u003e`に変換してあげれば良さそうです。\nということで`let first_cmd = ...`という長い文は、その変換を行っています。\n\n正直まだ`\u0026`と`ref`の関係とか所有権の問題はきちんと理解できていないというか書き方がよくわかっていないので、コンパイラに怒ってもらいながらなんとか直してみました。\nコンパイルを通るように、を第一に書いていったので汚かったり効率悪かったりするかもしれません...\n\nあとは`Command`に登録していって、`output`を読んであげれば完了です。\nただし`output`はバイト列を返すみたいなので、`String::from_utf8_lossy`を使って、文字に直してあげます。\n\n#### 追記(2014/12/21)\n\n---\n\nこのままだと標準入力や標準出力、標準エラー出力が子プロセスと結びついておらず、仮想のパイプとつながったような状態になるようです。\nそのため、標準入力から読み取るような関数を実行しようとするとそのプロセスは失敗します。\n\n修正したのが以下のコードです。(`Command`を作成する部分のみ)\n\n```rust\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .stdin(StdioContainer::InheritFd(STDIN_FILENO))\n                              .stdout(StdioContainer::InheritFd(STDOUT_FILENO))\n                              .stderr(StdioContainer::InheritFd(STDERR_FILENO))\n                              .spawn() {\n        Ok(p) =\u003e p,\n        Err(e) =\u003e panic!(\"ERROR: {}\", e)\n                              };\n    match output.wait() {\n        Ok(e) =\u003e println!(\"Exit: {}\", e),\n        Err(e) =\u003e println!(\"Error: {}\", e)\n    }\n```\n\nこのように、`stdout`を標準出力と関連付けることで、前のコードでの`output`から読み取って文字列に変換して出力、という手順は不要になりました。\nC 言語では`fork`したら`wait`しろと言われて育ってきたので、とりあえず`wait`を入れてみていますが、どうも`wait`を入れなくてもゾンビプロセスが残っているようには見えないので謎です。\n調査中です。\n\n### 追記ここまで\n\n## main\n\n先ほどの`exec`関数を`main`で使える形にしてみます。\n\n```rust:main.rs\nuse std::io;\nmod parse;\nmod exec;\n\nfn main() {\n    loop {\n        print!(\"% \u003e \");\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let parser = parse::Parser::new(input);\n        let tokens: Vec\u003cparse::Token\u003e = parser.collect();\n        exec::exec(tokens);\n    }\n}\n```\n\nプロンプトを表示してからユーザーの入力を受付け、パースして`Vec\u003cToken\u003e`になおしてから`exec`に渡しています。\n\n## 実行結果\n\n```\n% \u003e echo hello\nhello\n% \u003e echo \"hello world\"\n\"hello world\"\n% \u003e\n```\n\nあれ？`\"`の扱いなんて考えてなかったのになぜかうまくいってますね。不思議。\n\n検証用に`main.rs`を書き換えて実行してみました。\n\n```\n% \u003e echo hello\nStr(echo)\nStr(hello)\nhello\n% \u003e echo \"hello world\"\nStr(echo)\nStr(\"hello)\nStr(world\")\n\"hello world\"\n% \u003e echo \"hello     world\"\nStr(echo)\nStr(\"hello)\nStr(world\")\n\"hello world\"\n% \u003e\n```\n\n`echo`がうまくやってくれているみたいですね。すごい。\n\n## 今後\n\n次はリダイレクト関連ですかね。パイプや\u0026よりも簡単そうだし。\n毎度のことですが、ご指摘大歓迎です！色々な意見を伺いたくてこれを書いているので、何かありましたらぜひよろしくお願いします！\n\n[agatan/rsh](https://github.com/agatan/rsh)\n","slug":"Rustで自作シェルもどきを作る(単純なコマンド実行編)","title":"Rustで自作シェルもどきを作る(単純なコマンド実行編)","timestamp":1419141351000,"tags":["Rust"]},{"rawMarkdown":"---\ntitle: \"Rustで自作シェルもどきを作る(字句解析編)\"\ndate: 2014-12-21T01:15:19+09:00\ntags: [\"Rust\"]\nurl: https://qiita.com/agatan/items/8a097ead46df1c1659ff\n---\n\nRust が最近とてもおもしろいので、勉強がてら自作シェルみたいなものを作ってみたいと思います。  \nとはいえ、C 言語でさえろくにシステムプログラムを書いたことがないので、道は険しくなりそうです。\n\n## バージョン\n\n0.13.0-nightly を使用しました。\n\nコード全文はこちら\n[agatan/rsh](https://github.com/agatan/rsh)\n\n## 字句解析\n\nさて、シェルといったらまずはユーザの入力を受け付けてパースし、コマンドを実行しなくてはなりません。  \nというわけでまず初めにパース部分についてやってみます。  \nさくっと終わらせたかったのですが、どうもまだ`String`と`\u0026str`とかそのへんで詰まってしまいます...\n\n## Token の規定\n\n`enum`を使って`Token`を列挙します。  \n一応最終的にはパイプやらリダイレクトやらも実装したいなーと思っているので、その辺を考慮に入れた実装にしてみました。\n\n```rust\nenum Token {\n\tStr(String),\n\tPipe,\n\tRedirectTo,\n\tRedirectFrom,\n\tAmpersand,\n}\n```\n\n`Str`は特殊な文字以外の文字列ですから、要素として`String`を保持させておきました。\n\n## parser\n\nパースには(おもしろそうだったので)`iterator`トレイトを実装させることにしました。  \n実際つかうときにはいらない気もしますが、ちょっとためしたかったので。\n\n構造体として`Parser`を作ります。ソースとなる文字列と、現在どこまでパース済みなのかを保持する`current`を持たせました。\n\n```rust\npub struct Parser {\n    src: String,\n    pub current: uint,\n}\n```\n\nこの構造体に`Iterator`トレイトを実装すればよいのですが、補助関数としていくつか実装しておきます。\n\n```rust\nimpl Parser {\n    pub fn new(src: String) -\u003e Parser {\n        Parser { src: src, current: 0 }\n    }\n\n    pub fn current_char(\u0026self) -\u003e char {\n        self.src.char_at(self.current)\n    }\n\n    fn skip_whitespace(\u0026mut self) {\n        while self.current_char().is_whitespace() {\n            self.current += 1;\n            if self.current \u003e= self.src.char_len() {\n                return;\n            }\n        }\n    }\n\n    fn get_pipe(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current_char() == '|' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Pipe)\n        } else {\n            None\n        }\n    }\n\n    fn get_ampersand(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current_char() == '\u0026' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Ampersand)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_to(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current_char() == '\u003e' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectTo)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_from(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current_char() == '\u003c' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectFrom)\n\n    fn get_str(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        let mut i = self.current;\n        while !KEYWORDS.contains_char(self.src.char_at(i)) {\n            i += 1;\n        }\n        if i == self.current {\n            None\n        } else {\n            let result = Some(Token::Str(self.src.slice_chars(self.current, i).to_string()));\n            self.current = i;\n            self.skip_whitespace();\n            result\n        }\n    }\n}\n\n```\n\n`new`は新しいパーサーを生成するための関数です。`Parser`は文字列の所有権を要求していますが、入力された文字列はパースする以外に使い道は無いと思ったので大丈夫と判断しました。\n\n`current_char`は現在注目している文字を返します。\n`skip_whitespace`は空白文字を飛ばすように`self.current`をいじります。パーサーでは、基本的に 1 トークンを読み終えたら空白を飛ばして次のトークンになりうる文字の先頭までジャンプするべきなので、必ずトークンを読んだらこの関数を呼び出します。\n\nのこりの関数は、それぞれの`Token`を取得することを試みる関数です。  \n`Option\u003cToken\u003e`が帰ってくるので、`None`が帰ってきたら今みているトークンは別の種類のものであるといえます。\n\nこれらを用いて`Iterator`を実装しました。\n\n```rust\nimpl std::iter::Iterator\u003cToken\u003e for Parser {\n\n    fn next(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current \u003e= self.src.char_len() {\n            return None;\n        }\n        let mut result: Option\u003cToken\u003e = self.get_pipe();\n        if result.is_some() { return result; }\n        result = self.get_ampersand();\n        if result.is_some() { return result; }\n        result = self.get_redirect_to();\n        if result.is_some() { return result; }\n        result = self.get_redirect_from();\n        if result.is_some() { return result; }\n        result = self.get_str();\n        if result.is_some() { return result; }\n        None\n    }\n}\n```\n\nきれいじゃないコードですが、うまいやり方が他に思いつかなかったので...  \n純粋にある種類のトークンを取得しようと試みて`None`が帰ってきたら別の種類で試す、ということを繰り返しています。\n先頭で末尾まで読み込んだかを判定しています。\nすべての条件に当てはまらなくなったらパース失敗で`None`を返しています。\n\n## 試す\n\n```rust\nuse std::io;\nmod parse;\n\nfn main() {\n    loop {\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let mut parser = parse::Parser::new(input);\n        for token in parser {\n            println!(\"{}\", token);\n        }\n    }\n}\n```\n\n実行結果\n\n```\nls -a | grep foo\nStr(ls)\nStr(-a)\nPipe\nStr(grep)\nStr(foo)\nls -a| grep foo\u003eresult.txt \u0026\nStr(ls)\nStr(-a)\nPipe\nStr(grep)\nStr(foo)\nRedirectTo\nStr(result.txt)\nAmpersand\n```\n\nこのような感じになりました。\n`Iterator`を実装しているので、`for .. in ..`が使えて気持ち良いです。\n\n## 反省点\n\nパースは失敗しうる計算だから`Option`かなーどうせ`Option`かえすなら`Iterator`実装しちゃえばお得かなーとおもって漠然と実装してみましたが、パースは失敗した理由がほしいことがほとんどなのでよく考えたら`Result`を使うべきだった気がしてきました。\n効率とかは正直 Rust での効率のよい書き方がよくわかっていないのであまり気にせず、とりあえず動くものを、と作ってみました。\nあとはパーサを書いたことが殆どなかったので成功法がわからなかったので、もっときれいな書き方があるんじゃないかという気も...\n\n## 今後\n\nとりあえず動くものを、コードをたくさん書こう、の精神で進めてみます。\n次は単純なコマンド実行を実装したいです。\nといっても Rust には`Command`とか`Process`とかがあって、ちょっと読んで見た感じ割りと素直に C 言語の`execvp`とかを呼び出しているようなので、それを使えばそこまで難しくはないのかな？\n\nソースの全文を掲載しますので、Rust 固有であってもそうでなくても、より良い書き方などありましたらご教授いただけると幸いです。よろしくお願いします。\n\n```rust:parse.rs\nuse std;\n\nstatic KEYWORDS: \u0026'static str = \"|\u0026\u003c\u003e \\n\";\n\n#[deriving(Show)]\npub enum Token {\n    Str(String),\n    Pipe,\n    RedirectTo,\n    RedirectFrom,\n    Ampersand,\n}\n\npub struct Parser {\n    src: String,\n    pub current: uint,\n}\n\nimpl Parser {\n\n    pub fn new(src: String) -\u003e Parser {\n        Parser { src: src, current: 0 }\n    }\n\n    pub fn current_char(\u0026self) -\u003e char {\n        self.src.char_at(self.current)\n    }\n\n    fn skip_whitespace(\u0026mut self) {\n        while self.current_char().is_whitespace() {\n            self.current += 1;\n            if self.current \u003e= self.src.char_len() {\n                return;\n            }\n        }\n    }\n\n    fn get_pipe(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current_char() == '|' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Pipe)\n        } else {\n            None\n        }\n    }\n\n    fn get_ampersand(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current_char() == '\u0026' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Ampersand)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_to(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current_char() == '\u003e' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectTo)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_from(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current_char() == '\u003c' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectFrom)\n        } else {\n            None\n        }\n    }\n\n    fn get_str(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        let mut i = self.current;\n        while !KEYWORDS.contains_char(self.src.char_at(i)) {\n            i += 1;\n        }\n        if i == self.current {\n            None\n        } else {\n            let result = Some(Token::Str(self.src.slice_chars(self.current, i).to_string()));\n            self.current = i;\n            self.skip_whitespace();\n            result\n        }\n    }\n}\n\nimpl std::iter::Iterator\u003cToken\u003e for Parser {\n\n    fn next(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current \u003e= self.src.char_len() {\n            return None;\n        }\n        let mut result: Option\u003cToken\u003e = self.get_pipe();\n        if result.is_some() { return result; }\n        result = self.get_ampersand();\n        if result.is_some() { return result; }\n        result = self.get_redirect_to();\n        if result.is_some() { return result; }\n        result = self.get_redirect_from();\n        if result.is_some() { return result; }\n        result = self.get_str();\n        if result.is_some() { return result; }\n        None\n    }\n}\n```\n\n```rust:main.rs\nuse std::io;\nmod parse;\n\nfn main() {\n    loop {\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let mut parser = parse::Parser::new(input);\n        for token in parser {\n            println!(\"{}\", token);\n        }\n    }\n}\n```\n","contentMarkdown":"\nRust が最近とてもおもしろいので、勉強がてら自作シェルみたいなものを作ってみたいと思います。  \nとはいえ、C 言語でさえろくにシステムプログラムを書いたことがないので、道は険しくなりそうです。\n\n## バージョン\n\n0.13.0-nightly を使用しました。\n\nコード全文はこちら\n[agatan/rsh](https://github.com/agatan/rsh)\n\n## 字句解析\n\nさて、シェルといったらまずはユーザの入力を受け付けてパースし、コマンドを実行しなくてはなりません。  \nというわけでまず初めにパース部分についてやってみます。  \nさくっと終わらせたかったのですが、どうもまだ`String`と`\u0026str`とかそのへんで詰まってしまいます...\n\n## Token の規定\n\n`enum`を使って`Token`を列挙します。  \n一応最終的にはパイプやらリダイレクトやらも実装したいなーと思っているので、その辺を考慮に入れた実装にしてみました。\n\n```rust\nenum Token {\n\tStr(String),\n\tPipe,\n\tRedirectTo,\n\tRedirectFrom,\n\tAmpersand,\n}\n```\n\n`Str`は特殊な文字以外の文字列ですから、要素として`String`を保持させておきました。\n\n## parser\n\nパースには(おもしろそうだったので)`iterator`トレイトを実装させることにしました。  \n実際つかうときにはいらない気もしますが、ちょっとためしたかったので。\n\n構造体として`Parser`を作ります。ソースとなる文字列と、現在どこまでパース済みなのかを保持する`current`を持たせました。\n\n```rust\npub struct Parser {\n    src: String,\n    pub current: uint,\n}\n```\n\nこの構造体に`Iterator`トレイトを実装すればよいのですが、補助関数としていくつか実装しておきます。\n\n```rust\nimpl Parser {\n    pub fn new(src: String) -\u003e Parser {\n        Parser { src: src, current: 0 }\n    }\n\n    pub fn current_char(\u0026self) -\u003e char {\n        self.src.char_at(self.current)\n    }\n\n    fn skip_whitespace(\u0026mut self) {\n        while self.current_char().is_whitespace() {\n            self.current += 1;\n            if self.current \u003e= self.src.char_len() {\n                return;\n            }\n        }\n    }\n\n    fn get_pipe(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current_char() == '|' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Pipe)\n        } else {\n            None\n        }\n    }\n\n    fn get_ampersand(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current_char() == '\u0026' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Ampersand)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_to(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current_char() == '\u003e' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectTo)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_from(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current_char() == '\u003c' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectFrom)\n\n    fn get_str(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        let mut i = self.current;\n        while !KEYWORDS.contains_char(self.src.char_at(i)) {\n            i += 1;\n        }\n        if i == self.current {\n            None\n        } else {\n            let result = Some(Token::Str(self.src.slice_chars(self.current, i).to_string()));\n            self.current = i;\n            self.skip_whitespace();\n            result\n        }\n    }\n}\n\n```\n\n`new`は新しいパーサーを生成するための関数です。`Parser`は文字列の所有権を要求していますが、入力された文字列はパースする以外に使い道は無いと思ったので大丈夫と判断しました。\n\n`current_char`は現在注目している文字を返します。\n`skip_whitespace`は空白文字を飛ばすように`self.current`をいじります。パーサーでは、基本的に 1 トークンを読み終えたら空白を飛ばして次のトークンになりうる文字の先頭までジャンプするべきなので、必ずトークンを読んだらこの関数を呼び出します。\n\nのこりの関数は、それぞれの`Token`を取得することを試みる関数です。  \n`Option\u003cToken\u003e`が帰ってくるので、`None`が帰ってきたら今みているトークンは別の種類のものであるといえます。\n\nこれらを用いて`Iterator`を実装しました。\n\n```rust\nimpl std::iter::Iterator\u003cToken\u003e for Parser {\n\n    fn next(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current \u003e= self.src.char_len() {\n            return None;\n        }\n        let mut result: Option\u003cToken\u003e = self.get_pipe();\n        if result.is_some() { return result; }\n        result = self.get_ampersand();\n        if result.is_some() { return result; }\n        result = self.get_redirect_to();\n        if result.is_some() { return result; }\n        result = self.get_redirect_from();\n        if result.is_some() { return result; }\n        result = self.get_str();\n        if result.is_some() { return result; }\n        None\n    }\n}\n```\n\nきれいじゃないコードですが、うまいやり方が他に思いつかなかったので...  \n純粋にある種類のトークンを取得しようと試みて`None`が帰ってきたら別の種類で試す、ということを繰り返しています。\n先頭で末尾まで読み込んだかを判定しています。\nすべての条件に当てはまらなくなったらパース失敗で`None`を返しています。\n\n## 試す\n\n```rust\nuse std::io;\nmod parse;\n\nfn main() {\n    loop {\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let mut parser = parse::Parser::new(input);\n        for token in parser {\n            println!(\"{}\", token);\n        }\n    }\n}\n```\n\n実行結果\n\n```\nls -a | grep foo\nStr(ls)\nStr(-a)\nPipe\nStr(grep)\nStr(foo)\nls -a| grep foo\u003eresult.txt \u0026\nStr(ls)\nStr(-a)\nPipe\nStr(grep)\nStr(foo)\nRedirectTo\nStr(result.txt)\nAmpersand\n```\n\nこのような感じになりました。\n`Iterator`を実装しているので、`for .. in ..`が使えて気持ち良いです。\n\n## 反省点\n\nパースは失敗しうる計算だから`Option`かなーどうせ`Option`かえすなら`Iterator`実装しちゃえばお得かなーとおもって漠然と実装してみましたが、パースは失敗した理由がほしいことがほとんどなのでよく考えたら`Result`を使うべきだった気がしてきました。\n効率とかは正直 Rust での効率のよい書き方がよくわかっていないのであまり気にせず、とりあえず動くものを、と作ってみました。\nあとはパーサを書いたことが殆どなかったので成功法がわからなかったので、もっときれいな書き方があるんじゃないかという気も...\n\n## 今後\n\nとりあえず動くものを、コードをたくさん書こう、の精神で進めてみます。\n次は単純なコマンド実行を実装したいです。\nといっても Rust には`Command`とか`Process`とかがあって、ちょっと読んで見た感じ割りと素直に C 言語の`execvp`とかを呼び出しているようなので、それを使えばそこまで難しくはないのかな？\n\nソースの全文を掲載しますので、Rust 固有であってもそうでなくても、より良い書き方などありましたらご教授いただけると幸いです。よろしくお願いします。\n\n```rust:parse.rs\nuse std;\n\nstatic KEYWORDS: \u0026'static str = \"|\u0026\u003c\u003e \\n\";\n\n#[deriving(Show)]\npub enum Token {\n    Str(String),\n    Pipe,\n    RedirectTo,\n    RedirectFrom,\n    Ampersand,\n}\n\npub struct Parser {\n    src: String,\n    pub current: uint,\n}\n\nimpl Parser {\n\n    pub fn new(src: String) -\u003e Parser {\n        Parser { src: src, current: 0 }\n    }\n\n    pub fn current_char(\u0026self) -\u003e char {\n        self.src.char_at(self.current)\n    }\n\n    fn skip_whitespace(\u0026mut self) {\n        while self.current_char().is_whitespace() {\n            self.current += 1;\n            if self.current \u003e= self.src.char_len() {\n                return;\n            }\n        }\n    }\n\n    fn get_pipe(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current_char() == '|' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Pipe)\n        } else {\n            None\n        }\n    }\n\n    fn get_ampersand(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current_char() == '\u0026' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Ampersand)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_to(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current_char() == '\u003e' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectTo)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_from(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current_char() == '\u003c' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectFrom)\n        } else {\n            None\n        }\n    }\n\n    fn get_str(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        let mut i = self.current;\n        while !KEYWORDS.contains_char(self.src.char_at(i)) {\n            i += 1;\n        }\n        if i == self.current {\n            None\n        } else {\n            let result = Some(Token::Str(self.src.slice_chars(self.current, i).to_string()));\n            self.current = i;\n            self.skip_whitespace();\n            result\n        }\n    }\n}\n\nimpl std::iter::Iterator\u003cToken\u003e for Parser {\n\n    fn next(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if self.current \u003e= self.src.char_len() {\n            return None;\n        }\n        let mut result: Option\u003cToken\u003e = self.get_pipe();\n        if result.is_some() { return result; }\n        result = self.get_ampersand();\n        if result.is_some() { return result; }\n        result = self.get_redirect_to();\n        if result.is_some() { return result; }\n        result = self.get_redirect_from();\n        if result.is_some() { return result; }\n        result = self.get_str();\n        if result.is_some() { return result; }\n        None\n    }\n}\n```\n\n```rust:main.rs\nuse std::io;\nmod parse;\n\nfn main() {\n    loop {\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let mut parser = parse::Parser::new(input);\n        for token in parser {\n            println!(\"{}\", token);\n        }\n    }\n}\n```\n","slug":"Rustで自作シェルもどきを作る(字句解析編)","title":"Rustで自作シェルもどきを作る(字句解析編)","timestamp":1419092119000,"tags":["Rust"]},{"rawMarkdown":"---\ntitle: \"RubyでLinuxコマンドの再実装(tree編)\"\ndate: 2014-10-16T16:20:33+09:00\ntags: [\"Ruby\", \"Linux\"]\nurl: https://qiita.com/agatan/items/4c50554ae22aa4181cc1\n---\n\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## tree\n\n`tree`コマンドに挑戦します。\n`tree`コマンドは, 指定したディレクトリ以下のファイルを木構造にして表示してくれます。\n\n![スクリーンショット 2014-10-16 16.16.08.png](https://qiita-image-store.s3.amazonaws.com/0/39030/b3ca62be-bc22-ec39-a836-70032b76521d.png \"スクリーンショット 2014-10-16 16.16.08.png\")\n\n```tree.rb\n#! /usr/bin/env ruby -w\n#\n# tree: 引数で指定されたディレクトリ以下のファイルを\n#       再帰的に木構造として表示する.\n\nrequire 'optparse'\n\noptions = ARGV.getopts('aF')\n\n# parentは絶対パス.\ndef display_entries(parent, prefix, options)\n  # '.', '..'を除く. 無限に再帰することを防ぐ\n  entries = Dir.entries(parent).delete_if do |entry|\n    entry == '.' or entry == '..' or !options['a'] \u0026\u0026 entry.start_with?('.')\n  end\n\n  entries.each_with_index do |entry, index|\n    fullpath = File.join(parent, entry)\n    entry = f_option(parent, entry) if options['F']\n    # 最後の要素かどうか\n    if index == entries.size - 1\n      puts \"#{prefix}└── #{entry}\"\n      next_prefix = prefix + '    '\n    else\n      puts \"#{prefix}├── #{entry}\"\n      next_prefix = prefix + '│   '\n    end\n    if File.directory? fullpath\n      display_entries(fullpath, next_prefix, options)\n    end\n  end\nend\n\ndef f_option(parent, entry)\n  case File.ftype(File.join(parent, entry))\n  when \"file\"\n    if File.executable? File.join(parent, entry)\n      \"#{entry}*\"\n    else\n      entry\n    end\n  when \"directory\"\n    \"#{entry}/\"\n  when \"link\"\n    \"#{entry}@\"\n  else\n    entry\n  end\nend\n\ntarget = ARGV[0] || '.'\ntarget_fullpath = File.absolute_path target\ninit_prefix = ''\n\nputs target\ndisplay_entries target_fullpath, init_prefix, options\n```\n\nファイルのタイプを調べる際の処理を ls 編とちょっとだけ変えてみました。\nシンボリックリンクのリンク先を表示する修正が必要ですね...\n`color`は`ls`のときとほとんど変わらないので省きました。\n`File.ftype`では実行可能ファイルかどうかは判定できないんですかね??そこがちょっと気になります。\nあとはオプションのあたりなど複雑になってしまっているので綺麗にしたいです。\n","contentMarkdown":"\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## tree\n\n`tree`コマンドに挑戦します。\n`tree`コマンドは, 指定したディレクトリ以下のファイルを木構造にして表示してくれます。\n\n![スクリーンショット 2014-10-16 16.16.08.png](https://qiita-image-store.s3.amazonaws.com/0/39030/b3ca62be-bc22-ec39-a836-70032b76521d.png \"スクリーンショット 2014-10-16 16.16.08.png\")\n\n```tree.rb\n#! /usr/bin/env ruby -w\n#\n# tree: 引数で指定されたディレクトリ以下のファイルを\n#       再帰的に木構造として表示する.\n\nrequire 'optparse'\n\noptions = ARGV.getopts('aF')\n\n# parentは絶対パス.\ndef display_entries(parent, prefix, options)\n  # '.', '..'を除く. 無限に再帰することを防ぐ\n  entries = Dir.entries(parent).delete_if do |entry|\n    entry == '.' or entry == '..' or !options['a'] \u0026\u0026 entry.start_with?('.')\n  end\n\n  entries.each_with_index do |entry, index|\n    fullpath = File.join(parent, entry)\n    entry = f_option(parent, entry) if options['F']\n    # 最後の要素かどうか\n    if index == entries.size - 1\n      puts \"#{prefix}└── #{entry}\"\n      next_prefix = prefix + '    '\n    else\n      puts \"#{prefix}├── #{entry}\"\n      next_prefix = prefix + '│   '\n    end\n    if File.directory? fullpath\n      display_entries(fullpath, next_prefix, options)\n    end\n  end\nend\n\ndef f_option(parent, entry)\n  case File.ftype(File.join(parent, entry))\n  when \"file\"\n    if File.executable? File.join(parent, entry)\n      \"#{entry}*\"\n    else\n      entry\n    end\n  when \"directory\"\n    \"#{entry}/\"\n  when \"link\"\n    \"#{entry}@\"\n  else\n    entry\n  end\nend\n\ntarget = ARGV[0] || '.'\ntarget_fullpath = File.absolute_path target\ninit_prefix = ''\n\nputs target\ndisplay_entries target_fullpath, init_prefix, options\n```\n\nファイルのタイプを調べる際の処理を ls 編とちょっとだけ変えてみました。\nシンボリックリンクのリンク先を表示する修正が必要ですね...\n`color`は`ls`のときとほとんど変わらないので省きました。\n`File.ftype`では実行可能ファイルかどうかは判定できないんですかね??そこがちょっと気になります。\nあとはオプションのあたりなど複雑になってしまっているので綺麗にしたいです。\n","slug":"RubyでLinuxコマンドの再実装(tree編)","title":"RubyでLinuxコマンドの再実装(tree編)","timestamp":1413444033000,"tags":["Ruby","Linux"]},{"rawMarkdown":"---\ntitle: \"RubyでLinuxコマンドの再実装(ls編)\"\ndate: 2014-10-13T23:10:08+09:00\ntags: [\"Ruby\", \"Linux\"]\nurl: https://qiita.com/agatan/items/af0c3bbc881f60667c85\n---\n\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## ls\n\nではまずは`ls`です。簡単そうだったし個人的に一番良く使うコマンドなので。\n\n```rb\n#! /usr/bin/env ruby\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir::entries(target)\n\nentries.select!{|entry| entry[0] != '.'}\n\nentries.map! do |entry|\n  if File::directory?(File.join(target, entry))\n    \"#{entry}/\"\n  else\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\nディレクトリの場合は末尾に`/`をつけるようにしています。\n\n`-a`オプションで隠しファイル隠しディレクトリも表示するようにしたり, `--color`オプションで色をつけたりすることが目標です。\n\nコマンドライン引数の順番や, `-a -l -F`と`-alF`などややこしそうな部分は制約をつけてお茶を濁してしまうかもしれません...\n\n### 追記\n\n---\n\n@riocampos さんにコメントでコマンドライン引数の利用方法を教えていただきました！\n`require 'optparse'`とすればパーサが利用できるようになります。\n\nというわけでこれを反映し修正したものがこちらです。\n\n```ls.rb\n#! /usr/bin/env ruby -w\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\nrequire 'optparse'\n\ndef set_color_and_reset(entry, color)\n  case color\n  when :red\n    \"\\e[31m#{entry}\\e[0m\"\n  when :green\n    \"\\e[32m#{entry}\\e[0m\"\n  when :blue\n    \"\\e[34m#{entry}\\e[0m\"\n  when :cyan\n    \"\\e[36m#{entry}\\e[0m\"\n  else\n    entry\n  end\nend\n\noptions = ARGV.getopts('aF', 'color')\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir.entries(target)\n\nif options['a']\n  options['a'] = false\nelse\n  entries.select! { |entry| entry[0] != '.' }\nend\n\nif options.value? true\n  entries.map! do |entry|\n    fullpath = \"#{target}/#{entry}\"\n    case\n    when File.directory?(fullpath)\n      entry = set_color_and_reset entry, :blue if options['color']\n      entry += '/' if options['F']\n    when File.symlink?(fullpath)\n      entry = set_color_and_reset entry, :cyan if options['color']\n      entry += '@' if options['F']\n    when File.executable?(fullpath)\n      entry = set_color_and_reset entry, :red if options['color']\n      entry += '*' if options['F']\n    end\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\n`-l`オプションは対応していません...`-aF --color`に対応しました。\n表示の桁揃えとかしたほうが綺麗なんでしょうけれど...\n\n次は`tree`に挑戦してみます。\n","contentMarkdown":"\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## ls\n\nではまずは`ls`です。簡単そうだったし個人的に一番良く使うコマンドなので。\n\n```rb\n#! /usr/bin/env ruby\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir::entries(target)\n\nentries.select!{|entry| entry[0] != '.'}\n\nentries.map! do |entry|\n  if File::directory?(File.join(target, entry))\n    \"#{entry}/\"\n  else\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\nディレクトリの場合は末尾に`/`をつけるようにしています。\n\n`-a`オプションで隠しファイル隠しディレクトリも表示するようにしたり, `--color`オプションで色をつけたりすることが目標です。\n\nコマンドライン引数の順番や, `-a -l -F`と`-alF`などややこしそうな部分は制約をつけてお茶を濁してしまうかもしれません...\n\n### 追記\n\n---\n\n@riocampos さんにコメントでコマンドライン引数の利用方法を教えていただきました！\n`require 'optparse'`とすればパーサが利用できるようになります。\n\nというわけでこれを反映し修正したものがこちらです。\n\n```ls.rb\n#! /usr/bin/env ruby -w\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\nrequire 'optparse'\n\ndef set_color_and_reset(entry, color)\n  case color\n  when :red\n    \"\\e[31m#{entry}\\e[0m\"\n  when :green\n    \"\\e[32m#{entry}\\e[0m\"\n  when :blue\n    \"\\e[34m#{entry}\\e[0m\"\n  when :cyan\n    \"\\e[36m#{entry}\\e[0m\"\n  else\n    entry\n  end\nend\n\noptions = ARGV.getopts('aF', 'color')\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir.entries(target)\n\nif options['a']\n  options['a'] = false\nelse\n  entries.select! { |entry| entry[0] != '.' }\nend\n\nif options.value? true\n  entries.map! do |entry|\n    fullpath = \"#{target}/#{entry}\"\n    case\n    when File.directory?(fullpath)\n      entry = set_color_and_reset entry, :blue if options['color']\n      entry += '/' if options['F']\n    when File.symlink?(fullpath)\n      entry = set_color_and_reset entry, :cyan if options['color']\n      entry += '@' if options['F']\n    when File.executable?(fullpath)\n      entry = set_color_and_reset entry, :red if options['color']\n      entry += '*' if options['F']\n    end\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\n`-l`オプションは対応していません...`-aF --color`に対応しました。\n表示の桁揃えとかしたほうが綺麗なんでしょうけれど...\n\n次は`tree`に挑戦してみます。\n","slug":"RubyでLinuxコマンドの再実装(ls編)","title":"RubyでLinuxコマンドの再実装(ls編)","timestamp":1413209408000,"tags":["Ruby","Linux"]},{"rawMarkdown":"---\ntitle: \"QiitaAPIを通じて複数のタグを持つ記事を検索する\"\ndate: 2014-10-13T18:11:43+09:00\ntags: [\"Qiita\", \"Ruby\"]\nurl: https://qiita.com/agatan/items/55dce1d2bc887de0cd71\n---\n\nRuby 初心者なのでなにかお気づきの点がありましたらご教授いただけると幸いです。\n\n## QiitaApiAccessor\n\nQiitaAPI との通信, 受信情報のハッシュ化を担当している。\n`@result_json`をローカル変数にしたいのだけど, `open`ブロック内のローカル変数になってしまうので出来ない...\n`get_with_tag`内のローカル変数にならできるけど結局`result_json = {}`として`open`内で更新みたいな書き方になってしまって綺麗じゃない...\n\n```ruby\nrequire 'open-uri'\nrequire 'json'\n\nclass QiitaApiAccessor\n\n  def initialize\n    @qiita_url = 'http://qiita.com/api/v2'\n    @result_json = {}\n  end\n\n  def get_with_tag(tag_name)\n    open(\"#{@qiita_url}/tags/#{tag_name}/items?page=1\u0026per_page=100\") do |uri|\n      @result_json = JSON.parse(uri.read, symbolize_names: true)\n    end\n    @result_json\n  end\n\nend\n```\n\n## QiitaArticle\n\n一つの記事についての情報を保持する。\n`has_tag?`メソッドでは, 大文字小文字にかかわらず判定が出来るよう`upcase`を使用している。\n\n```rb\nclass QiitaArticle\n\n  def initialize (article_hash)\n    @data = article_hash\n    @title = article_hash[:title]\n    @url = \"http://qiita.com/api/v2/items/#{article_hash[:id]}\"\n    @tags = article_hash[:tags].map { |tag| tag[:name] }\n    @body = article_hash[:body]\n  end\n\n  attr_reader :title, :url, :tags, :body\n\n  def has_tag?(tag_name)\n    tags = @data[:tags]\n    tags.any?{ |tag_info| tag_info[:name].upcase == tag_name.upcase }\n  end\n\nend\n```\n\n## MultiTagsSearcher\n\nこれがメインのクラス。コンストラクタに`QiitaApiAccessor#get_with_tag`の戻り値と検索したいタグのリストを渡してやる。\n`group_by_relevance`によって含んでいる対象タグの数によってグループ化する。\n\n```rb\nclass MultiTagsSearcher\n\n  def initialize(articles_data, tags)\n    @articles = articles_data.map { |data| QiitaArticle.new(data) }\n    @tags = tags\n  end\n\n  attr_reader :articles\n\n  def group_by_relevance\n    @articles.group_by do |article|\n      @tags.count { |tag| article.has_tag?(tag) }\n    end\n  end\n\nend\n```\n\n## 使い方\n\n`QiitaApiAccessor#get_with_tag`にメインとなるキーワードタグを渡す。\nその戻り値と、キーワードタグを含む検索したいタグ名のリストを、`MultiTagsSearcher`に渡して`group_by_relevance`してやる。\nすると`含んでいる対象タグ数 =\u003e [QiitaArticleのインスタンス]`というハッシュが得られるので、適当に`QiitaArticle#url`とかで記事の url を取ってこられます。\n\n## 問題点・改善点\n\nQiitaAPI の都合上一度に 100 件までしか記事の情報を取得できないので, 本当はループで全件取得してから`MultiTagsSearcher`に渡したい。\nが、そうすると 5000 件とか普通に行く場合もあるから`QiitaArticle`のインスタンスが無駄に大量生成されてしまうし、時間もかかる。\nなので、検索の際のキーワードタグには記事数の少なそうなものを選ぶことでお茶を濁す...\n`ruby`ではなく`sinatra`をキーワードにするだけで結果がかなり違ってくる。\nけどそれじゃ根本的な解決になってない。なにか良い方法ありましたら教えて下さい。\n","contentMarkdown":"\nRuby 初心者なのでなにかお気づきの点がありましたらご教授いただけると幸いです。\n\n## QiitaApiAccessor\n\nQiitaAPI との通信, 受信情報のハッシュ化を担当している。\n`@result_json`をローカル変数にしたいのだけど, `open`ブロック内のローカル変数になってしまうので出来ない...\n`get_with_tag`内のローカル変数にならできるけど結局`result_json = {}`として`open`内で更新みたいな書き方になってしまって綺麗じゃない...\n\n```ruby\nrequire 'open-uri'\nrequire 'json'\n\nclass QiitaApiAccessor\n\n  def initialize\n    @qiita_url = 'http://qiita.com/api/v2'\n    @result_json = {}\n  end\n\n  def get_with_tag(tag_name)\n    open(\"#{@qiita_url}/tags/#{tag_name}/items?page=1\u0026per_page=100\") do |uri|\n      @result_json = JSON.parse(uri.read, symbolize_names: true)\n    end\n    @result_json\n  end\n\nend\n```\n\n## QiitaArticle\n\n一つの記事についての情報を保持する。\n`has_tag?`メソッドでは, 大文字小文字にかかわらず判定が出来るよう`upcase`を使用している。\n\n```rb\nclass QiitaArticle\n\n  def initialize (article_hash)\n    @data = article_hash\n    @title = article_hash[:title]\n    @url = \"http://qiita.com/api/v2/items/#{article_hash[:id]}\"\n    @tags = article_hash[:tags].map { |tag| tag[:name] }\n    @body = article_hash[:body]\n  end\n\n  attr_reader :title, :url, :tags, :body\n\n  def has_tag?(tag_name)\n    tags = @data[:tags]\n    tags.any?{ |tag_info| tag_info[:name].upcase == tag_name.upcase }\n  end\n\nend\n```\n\n## MultiTagsSearcher\n\nこれがメインのクラス。コンストラクタに`QiitaApiAccessor#get_with_tag`の戻り値と検索したいタグのリストを渡してやる。\n`group_by_relevance`によって含んでいる対象タグの数によってグループ化する。\n\n```rb\nclass MultiTagsSearcher\n\n  def initialize(articles_data, tags)\n    @articles = articles_data.map { |data| QiitaArticle.new(data) }\n    @tags = tags\n  end\n\n  attr_reader :articles\n\n  def group_by_relevance\n    @articles.group_by do |article|\n      @tags.count { |tag| article.has_tag?(tag) }\n    end\n  end\n\nend\n```\n\n## 使い方\n\n`QiitaApiAccessor#get_with_tag`にメインとなるキーワードタグを渡す。\nその戻り値と、キーワードタグを含む検索したいタグ名のリストを、`MultiTagsSearcher`に渡して`group_by_relevance`してやる。\nすると`含んでいる対象タグ数 =\u003e [QiitaArticleのインスタンス]`というハッシュが得られるので、適当に`QiitaArticle#url`とかで記事の url を取ってこられます。\n\n## 問題点・改善点\n\nQiitaAPI の都合上一度に 100 件までしか記事の情報を取得できないので, 本当はループで全件取得してから`MultiTagsSearcher`に渡したい。\nが、そうすると 5000 件とか普通に行く場合もあるから`QiitaArticle`のインスタンスが無駄に大量生成されてしまうし、時間もかかる。\nなので、検索の際のキーワードタグには記事数の少なそうなものを選ぶことでお茶を濁す...\n`ruby`ではなく`sinatra`をキーワードにするだけで結果がかなり違ってくる。\nけどそれじゃ根本的な解決になってない。なにか良い方法ありましたら教えて下さい。\n","slug":"QiitaAPIを通じて複数のタグを持つ記事を検索する","title":"QiitaAPIを通じて複数のタグを持つ記事を検索する","timestamp":1413191503000,"tags":["Qiita","Ruby"]}]},"__N_SSG":true},"page":"/","query":{},"buildId":"MrBI3Vp9UtpEWQt6jMgGf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>