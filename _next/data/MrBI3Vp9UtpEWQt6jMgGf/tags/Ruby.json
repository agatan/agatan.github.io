{"pageProps":{"tag":"Ruby","postMetas":[{"rawMarkdown":"---\ntitle: \"RubyでLinuxコマンドの再実装(tree編)\"\ndate: 2014-10-16T16:20:33+09:00\ntags: [\"Ruby\", \"Linux\"]\nurl: https://qiita.com/agatan/items/4c50554ae22aa4181cc1\n---\n\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## tree\n\n`tree`コマンドに挑戦します。\n`tree`コマンドは, 指定したディレクトリ以下のファイルを木構造にして表示してくれます。\n\n![スクリーンショット 2014-10-16 16.16.08.png](https://qiita-image-store.s3.amazonaws.com/0/39030/b3ca62be-bc22-ec39-a836-70032b76521d.png \"スクリーンショット 2014-10-16 16.16.08.png\")\n\n```tree.rb\n#! /usr/bin/env ruby -w\n#\n# tree: 引数で指定されたディレクトリ以下のファイルを\n#       再帰的に木構造として表示する.\n\nrequire 'optparse'\n\noptions = ARGV.getopts('aF')\n\n# parentは絶対パス.\ndef display_entries(parent, prefix, options)\n  # '.', '..'を除く. 無限に再帰することを防ぐ\n  entries = Dir.entries(parent).delete_if do |entry|\n    entry == '.' or entry == '..' or !options['a'] && entry.start_with?('.')\n  end\n\n  entries.each_with_index do |entry, index|\n    fullpath = File.join(parent, entry)\n    entry = f_option(parent, entry) if options['F']\n    # 最後の要素かどうか\n    if index == entries.size - 1\n      puts \"#{prefix}└── #{entry}\"\n      next_prefix = prefix + '    '\n    else\n      puts \"#{prefix}├── #{entry}\"\n      next_prefix = prefix + '│   '\n    end\n    if File.directory? fullpath\n      display_entries(fullpath, next_prefix, options)\n    end\n  end\nend\n\ndef f_option(parent, entry)\n  case File.ftype(File.join(parent, entry))\n  when \"file\"\n    if File.executable? File.join(parent, entry)\n      \"#{entry}*\"\n    else\n      entry\n    end\n  when \"directory\"\n    \"#{entry}/\"\n  when \"link\"\n    \"#{entry}@\"\n  else\n    entry\n  end\nend\n\ntarget = ARGV[0] || '.'\ntarget_fullpath = File.absolute_path target\ninit_prefix = ''\n\nputs target\ndisplay_entries target_fullpath, init_prefix, options\n```\n\nファイルのタイプを調べる際の処理を ls 編とちょっとだけ変えてみました。\nシンボリックリンクのリンク先を表示する修正が必要ですね...\n`color`は`ls`のときとほとんど変わらないので省きました。\n`File.ftype`では実行可能ファイルかどうかは判定できないんですかね??そこがちょっと気になります。\nあとはオプションのあたりなど複雑になってしまっているので綺麗にしたいです。\n","contentMarkdown":"\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## tree\n\n`tree`コマンドに挑戦します。\n`tree`コマンドは, 指定したディレクトリ以下のファイルを木構造にして表示してくれます。\n\n![スクリーンショット 2014-10-16 16.16.08.png](https://qiita-image-store.s3.amazonaws.com/0/39030/b3ca62be-bc22-ec39-a836-70032b76521d.png \"スクリーンショット 2014-10-16 16.16.08.png\")\n\n```tree.rb\n#! /usr/bin/env ruby -w\n#\n# tree: 引数で指定されたディレクトリ以下のファイルを\n#       再帰的に木構造として表示する.\n\nrequire 'optparse'\n\noptions = ARGV.getopts('aF')\n\n# parentは絶対パス.\ndef display_entries(parent, prefix, options)\n  # '.', '..'を除く. 無限に再帰することを防ぐ\n  entries = Dir.entries(parent).delete_if do |entry|\n    entry == '.' or entry == '..' or !options['a'] && entry.start_with?('.')\n  end\n\n  entries.each_with_index do |entry, index|\n    fullpath = File.join(parent, entry)\n    entry = f_option(parent, entry) if options['F']\n    # 最後の要素かどうか\n    if index == entries.size - 1\n      puts \"#{prefix}└── #{entry}\"\n      next_prefix = prefix + '    '\n    else\n      puts \"#{prefix}├── #{entry}\"\n      next_prefix = prefix + '│   '\n    end\n    if File.directory? fullpath\n      display_entries(fullpath, next_prefix, options)\n    end\n  end\nend\n\ndef f_option(parent, entry)\n  case File.ftype(File.join(parent, entry))\n  when \"file\"\n    if File.executable? File.join(parent, entry)\n      \"#{entry}*\"\n    else\n      entry\n    end\n  when \"directory\"\n    \"#{entry}/\"\n  when \"link\"\n    \"#{entry}@\"\n  else\n    entry\n  end\nend\n\ntarget = ARGV[0] || '.'\ntarget_fullpath = File.absolute_path target\ninit_prefix = ''\n\nputs target\ndisplay_entries target_fullpath, init_prefix, options\n```\n\nファイルのタイプを調べる際の処理を ls 編とちょっとだけ変えてみました。\nシンボリックリンクのリンク先を表示する修正が必要ですね...\n`color`は`ls`のときとほとんど変わらないので省きました。\n`File.ftype`では実行可能ファイルかどうかは判定できないんですかね??そこがちょっと気になります。\nあとはオプションのあたりなど複雑になってしまっているので綺麗にしたいです。\n","slug":"RubyでLinuxコマンドの再実装(tree編)","title":"RubyでLinuxコマンドの再実装(tree編)","timestamp":1413444033000,"tags":["Ruby","Linux"]},{"rawMarkdown":"---\ntitle: \"RubyでLinuxコマンドの再実装(ls編)\"\ndate: 2014-10-13T23:10:08+09:00\ntags: [\"Ruby\", \"Linux\"]\nurl: https://qiita.com/agatan/items/af0c3bbc881f60667c85\n---\n\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## ls\n\nではまずは`ls`です。簡単そうだったし個人的に一番良く使うコマンドなので。\n\n```rb\n#! /usr/bin/env ruby\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir::entries(target)\n\nentries.select!{|entry| entry[0] != '.'}\n\nentries.map! do |entry|\n  if File::directory?(File.join(target, entry))\n    \"#{entry}/\"\n  else\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\nディレクトリの場合は末尾に`/`をつけるようにしています。\n\n`-a`オプションで隠しファイル隠しディレクトリも表示するようにしたり, `--color`オプションで色をつけたりすることが目標です。\n\nコマンドライン引数の順番や, `-a -l -F`と`-alF`などややこしそうな部分は制約をつけてお茶を濁してしまうかもしれません...\n\n### 追記\n\n---\n\n@riocampos さんにコメントでコマンドライン引数の利用方法を教えていただきました！\n`require 'optparse'`とすればパーサが利用できるようになります。\n\nというわけでこれを反映し修正したものがこちらです。\n\n```ls.rb\n#! /usr/bin/env ruby -w\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\nrequire 'optparse'\n\ndef set_color_and_reset(entry, color)\n  case color\n  when :red\n    \"\\e[31m#{entry}\\e[0m\"\n  when :green\n    \"\\e[32m#{entry}\\e[0m\"\n  when :blue\n    \"\\e[34m#{entry}\\e[0m\"\n  when :cyan\n    \"\\e[36m#{entry}\\e[0m\"\n  else\n    entry\n  end\nend\n\noptions = ARGV.getopts('aF', 'color')\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir.entries(target)\n\nif options['a']\n  options['a'] = false\nelse\n  entries.select! { |entry| entry[0] != '.' }\nend\n\nif options.value? true\n  entries.map! do |entry|\n    fullpath = \"#{target}/#{entry}\"\n    case\n    when File.directory?(fullpath)\n      entry = set_color_and_reset entry, :blue if options['color']\n      entry += '/' if options['F']\n    when File.symlink?(fullpath)\n      entry = set_color_and_reset entry, :cyan if options['color']\n      entry += '@' if options['F']\n    when File.executable?(fullpath)\n      entry = set_color_and_reset entry, :red if options['color']\n      entry += '*' if options['F']\n    end\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\n`-l`オプションは対応していません...`-aF --color`に対応しました。\n表示の桁揃えとかしたほうが綺麗なんでしょうけれど...\n\n次は`tree`に挑戦してみます。\n","contentMarkdown":"\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## ls\n\nではまずは`ls`です。簡単そうだったし個人的に一番良く使うコマンドなので。\n\n```rb\n#! /usr/bin/env ruby\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir::entries(target)\n\nentries.select!{|entry| entry[0] != '.'}\n\nentries.map! do |entry|\n  if File::directory?(File.join(target, entry))\n    \"#{entry}/\"\n  else\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\nディレクトリの場合は末尾に`/`をつけるようにしています。\n\n`-a`オプションで隠しファイル隠しディレクトリも表示するようにしたり, `--color`オプションで色をつけたりすることが目標です。\n\nコマンドライン引数の順番や, `-a -l -F`と`-alF`などややこしそうな部分は制約をつけてお茶を濁してしまうかもしれません...\n\n### 追記\n\n---\n\n@riocampos さんにコメントでコマンドライン引数の利用方法を教えていただきました！\n`require 'optparse'`とすればパーサが利用できるようになります。\n\nというわけでこれを反映し修正したものがこちらです。\n\n```ls.rb\n#! /usr/bin/env ruby -w\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\nrequire 'optparse'\n\ndef set_color_and_reset(entry, color)\n  case color\n  when :red\n    \"\\e[31m#{entry}\\e[0m\"\n  when :green\n    \"\\e[32m#{entry}\\e[0m\"\n  when :blue\n    \"\\e[34m#{entry}\\e[0m\"\n  when :cyan\n    \"\\e[36m#{entry}\\e[0m\"\n  else\n    entry\n  end\nend\n\noptions = ARGV.getopts('aF', 'color')\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir.entries(target)\n\nif options['a']\n  options['a'] = false\nelse\n  entries.select! { |entry| entry[0] != '.' }\nend\n\nif options.value? true\n  entries.map! do |entry|\n    fullpath = \"#{target}/#{entry}\"\n    case\n    when File.directory?(fullpath)\n      entry = set_color_and_reset entry, :blue if options['color']\n      entry += '/' if options['F']\n    when File.symlink?(fullpath)\n      entry = set_color_and_reset entry, :cyan if options['color']\n      entry += '@' if options['F']\n    when File.executable?(fullpath)\n      entry = set_color_and_reset entry, :red if options['color']\n      entry += '*' if options['F']\n    end\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\n`-l`オプションは対応していません...`-aF --color`に対応しました。\n表示の桁揃えとかしたほうが綺麗なんでしょうけれど...\n\n次は`tree`に挑戦してみます。\n","slug":"RubyでLinuxコマンドの再実装(ls編)","title":"RubyでLinuxコマンドの再実装(ls編)","timestamp":1413209408000,"tags":["Ruby","Linux"]},{"rawMarkdown":"---\ntitle: \"QiitaAPIを通じて複数のタグを持つ記事を検索する\"\ndate: 2014-10-13T18:11:43+09:00\ntags: [\"Qiita\", \"Ruby\"]\nurl: https://qiita.com/agatan/items/55dce1d2bc887de0cd71\n---\n\nRuby 初心者なのでなにかお気づきの点がありましたらご教授いただけると幸いです。\n\n## QiitaApiAccessor\n\nQiitaAPI との通信, 受信情報のハッシュ化を担当している。\n`@result_json`をローカル変数にしたいのだけど, `open`ブロック内のローカル変数になってしまうので出来ない...\n`get_with_tag`内のローカル変数にならできるけど結局`result_json = {}`として`open`内で更新みたいな書き方になってしまって綺麗じゃない...\n\n```ruby\nrequire 'open-uri'\nrequire 'json'\n\nclass QiitaApiAccessor\n\n  def initialize\n    @qiita_url = 'http://qiita.com/api/v2'\n    @result_json = {}\n  end\n\n  def get_with_tag(tag_name)\n    open(\"#{@qiita_url}/tags/#{tag_name}/items?page=1&per_page=100\") do |uri|\n      @result_json = JSON.parse(uri.read, symbolize_names: true)\n    end\n    @result_json\n  end\n\nend\n```\n\n## QiitaArticle\n\n一つの記事についての情報を保持する。\n`has_tag?`メソッドでは, 大文字小文字にかかわらず判定が出来るよう`upcase`を使用している。\n\n```rb\nclass QiitaArticle\n\n  def initialize (article_hash)\n    @data = article_hash\n    @title = article_hash[:title]\n    @url = \"http://qiita.com/api/v2/items/#{article_hash[:id]}\"\n    @tags = article_hash[:tags].map { |tag| tag[:name] }\n    @body = article_hash[:body]\n  end\n\n  attr_reader :title, :url, :tags, :body\n\n  def has_tag?(tag_name)\n    tags = @data[:tags]\n    tags.any?{ |tag_info| tag_info[:name].upcase == tag_name.upcase }\n  end\n\nend\n```\n\n## MultiTagsSearcher\n\nこれがメインのクラス。コンストラクタに`QiitaApiAccessor#get_with_tag`の戻り値と検索したいタグのリストを渡してやる。\n`group_by_relevance`によって含んでいる対象タグの数によってグループ化する。\n\n```rb\nclass MultiTagsSearcher\n\n  def initialize(articles_data, tags)\n    @articles = articles_data.map { |data| QiitaArticle.new(data) }\n    @tags = tags\n  end\n\n  attr_reader :articles\n\n  def group_by_relevance\n    @articles.group_by do |article|\n      @tags.count { |tag| article.has_tag?(tag) }\n    end\n  end\n\nend\n```\n\n## 使い方\n\n`QiitaApiAccessor#get_with_tag`にメインとなるキーワードタグを渡す。\nその戻り値と、キーワードタグを含む検索したいタグ名のリストを、`MultiTagsSearcher`に渡して`group_by_relevance`してやる。\nすると`含んでいる対象タグ数 => [QiitaArticleのインスタンス]`というハッシュが得られるので、適当に`QiitaArticle#url`とかで記事の url を取ってこられます。\n\n## 問題点・改善点\n\nQiitaAPI の都合上一度に 100 件までしか記事の情報を取得できないので, 本当はループで全件取得してから`MultiTagsSearcher`に渡したい。\nが、そうすると 5000 件とか普通に行く場合もあるから`QiitaArticle`のインスタンスが無駄に大量生成されてしまうし、時間もかかる。\nなので、検索の際のキーワードタグには記事数の少なそうなものを選ぶことでお茶を濁す...\n`ruby`ではなく`sinatra`をキーワードにするだけで結果がかなり違ってくる。\nけどそれじゃ根本的な解決になってない。なにか良い方法ありましたら教えて下さい。\n","contentMarkdown":"\nRuby 初心者なのでなにかお気づきの点がありましたらご教授いただけると幸いです。\n\n## QiitaApiAccessor\n\nQiitaAPI との通信, 受信情報のハッシュ化を担当している。\n`@result_json`をローカル変数にしたいのだけど, `open`ブロック内のローカル変数になってしまうので出来ない...\n`get_with_tag`内のローカル変数にならできるけど結局`result_json = {}`として`open`内で更新みたいな書き方になってしまって綺麗じゃない...\n\n```ruby\nrequire 'open-uri'\nrequire 'json'\n\nclass QiitaApiAccessor\n\n  def initialize\n    @qiita_url = 'http://qiita.com/api/v2'\n    @result_json = {}\n  end\n\n  def get_with_tag(tag_name)\n    open(\"#{@qiita_url}/tags/#{tag_name}/items?page=1&per_page=100\") do |uri|\n      @result_json = JSON.parse(uri.read, symbolize_names: true)\n    end\n    @result_json\n  end\n\nend\n```\n\n## QiitaArticle\n\n一つの記事についての情報を保持する。\n`has_tag?`メソッドでは, 大文字小文字にかかわらず判定が出来るよう`upcase`を使用している。\n\n```rb\nclass QiitaArticle\n\n  def initialize (article_hash)\n    @data = article_hash\n    @title = article_hash[:title]\n    @url = \"http://qiita.com/api/v2/items/#{article_hash[:id]}\"\n    @tags = article_hash[:tags].map { |tag| tag[:name] }\n    @body = article_hash[:body]\n  end\n\n  attr_reader :title, :url, :tags, :body\n\n  def has_tag?(tag_name)\n    tags = @data[:tags]\n    tags.any?{ |tag_info| tag_info[:name].upcase == tag_name.upcase }\n  end\n\nend\n```\n\n## MultiTagsSearcher\n\nこれがメインのクラス。コンストラクタに`QiitaApiAccessor#get_with_tag`の戻り値と検索したいタグのリストを渡してやる。\n`group_by_relevance`によって含んでいる対象タグの数によってグループ化する。\n\n```rb\nclass MultiTagsSearcher\n\n  def initialize(articles_data, tags)\n    @articles = articles_data.map { |data| QiitaArticle.new(data) }\n    @tags = tags\n  end\n\n  attr_reader :articles\n\n  def group_by_relevance\n    @articles.group_by do |article|\n      @tags.count { |tag| article.has_tag?(tag) }\n    end\n  end\n\nend\n```\n\n## 使い方\n\n`QiitaApiAccessor#get_with_tag`にメインとなるキーワードタグを渡す。\nその戻り値と、キーワードタグを含む検索したいタグ名のリストを、`MultiTagsSearcher`に渡して`group_by_relevance`してやる。\nすると`含んでいる対象タグ数 => [QiitaArticleのインスタンス]`というハッシュが得られるので、適当に`QiitaArticle#url`とかで記事の url を取ってこられます。\n\n## 問題点・改善点\n\nQiitaAPI の都合上一度に 100 件までしか記事の情報を取得できないので, 本当はループで全件取得してから`MultiTagsSearcher`に渡したい。\nが、そうすると 5000 件とか普通に行く場合もあるから`QiitaArticle`のインスタンスが無駄に大量生成されてしまうし、時間もかかる。\nなので、検索の際のキーワードタグには記事数の少なそうなものを選ぶことでお茶を濁す...\n`ruby`ではなく`sinatra`をキーワードにするだけで結果がかなり違ってくる。\nけどそれじゃ根本的な解決になってない。なにか良い方法ありましたら教えて下さい。\n","slug":"QiitaAPIを通じて複数のタグを持つ記事を検索する","title":"QiitaAPIを通じて複数のタグを持つ記事を検索する","timestamp":1413191503000,"tags":["Qiita","Ruby"]}]},"__N_SSG":true}