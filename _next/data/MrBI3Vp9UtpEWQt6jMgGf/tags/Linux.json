{"pageProps":{"tag":"Linux","postMetas":[{"rawMarkdown":"---\ntitle: \"RubyでLinuxコマンドの再実装(tree編)\"\ndate: 2014-10-16T16:20:33+09:00\ntags: [\"Ruby\", \"Linux\"]\nurl: https://qiita.com/agatan/items/4c50554ae22aa4181cc1\n---\n\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## tree\n\n`tree`コマンドに挑戦します。\n`tree`コマンドは, 指定したディレクトリ以下のファイルを木構造にして表示してくれます。\n\n![スクリーンショット 2014-10-16 16.16.08.png](https://qiita-image-store.s3.amazonaws.com/0/39030/b3ca62be-bc22-ec39-a836-70032b76521d.png \"スクリーンショット 2014-10-16 16.16.08.png\")\n\n```tree.rb\n#! /usr/bin/env ruby -w\n#\n# tree: 引数で指定されたディレクトリ以下のファイルを\n#       再帰的に木構造として表示する.\n\nrequire 'optparse'\n\noptions = ARGV.getopts('aF')\n\n# parentは絶対パス.\ndef display_entries(parent, prefix, options)\n  # '.', '..'を除く. 無限に再帰することを防ぐ\n  entries = Dir.entries(parent).delete_if do |entry|\n    entry == '.' or entry == '..' or !options['a'] && entry.start_with?('.')\n  end\n\n  entries.each_with_index do |entry, index|\n    fullpath = File.join(parent, entry)\n    entry = f_option(parent, entry) if options['F']\n    # 最後の要素かどうか\n    if index == entries.size - 1\n      puts \"#{prefix}└── #{entry}\"\n      next_prefix = prefix + '    '\n    else\n      puts \"#{prefix}├── #{entry}\"\n      next_prefix = prefix + '│   '\n    end\n    if File.directory? fullpath\n      display_entries(fullpath, next_prefix, options)\n    end\n  end\nend\n\ndef f_option(parent, entry)\n  case File.ftype(File.join(parent, entry))\n  when \"file\"\n    if File.executable? File.join(parent, entry)\n      \"#{entry}*\"\n    else\n      entry\n    end\n  when \"directory\"\n    \"#{entry}/\"\n  when \"link\"\n    \"#{entry}@\"\n  else\n    entry\n  end\nend\n\ntarget = ARGV[0] || '.'\ntarget_fullpath = File.absolute_path target\ninit_prefix = ''\n\nputs target\ndisplay_entries target_fullpath, init_prefix, options\n```\n\nファイルのタイプを調べる際の処理を ls 編とちょっとだけ変えてみました。\nシンボリックリンクのリンク先を表示する修正が必要ですね...\n`color`は`ls`のときとほとんど変わらないので省きました。\n`File.ftype`では実行可能ファイルかどうかは判定できないんですかね??そこがちょっと気になります。\nあとはオプションのあたりなど複雑になってしまっているので綺麗にしたいです。\n","contentMarkdown":"\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## tree\n\n`tree`コマンドに挑戦します。\n`tree`コマンドは, 指定したディレクトリ以下のファイルを木構造にして表示してくれます。\n\n![スクリーンショット 2014-10-16 16.16.08.png](https://qiita-image-store.s3.amazonaws.com/0/39030/b3ca62be-bc22-ec39-a836-70032b76521d.png \"スクリーンショット 2014-10-16 16.16.08.png\")\n\n```tree.rb\n#! /usr/bin/env ruby -w\n#\n# tree: 引数で指定されたディレクトリ以下のファイルを\n#       再帰的に木構造として表示する.\n\nrequire 'optparse'\n\noptions = ARGV.getopts('aF')\n\n# parentは絶対パス.\ndef display_entries(parent, prefix, options)\n  # '.', '..'を除く. 無限に再帰することを防ぐ\n  entries = Dir.entries(parent).delete_if do |entry|\n    entry == '.' or entry == '..' or !options['a'] && entry.start_with?('.')\n  end\n\n  entries.each_with_index do |entry, index|\n    fullpath = File.join(parent, entry)\n    entry = f_option(parent, entry) if options['F']\n    # 最後の要素かどうか\n    if index == entries.size - 1\n      puts \"#{prefix}└── #{entry}\"\n      next_prefix = prefix + '    '\n    else\n      puts \"#{prefix}├── #{entry}\"\n      next_prefix = prefix + '│   '\n    end\n    if File.directory? fullpath\n      display_entries(fullpath, next_prefix, options)\n    end\n  end\nend\n\ndef f_option(parent, entry)\n  case File.ftype(File.join(parent, entry))\n  when \"file\"\n    if File.executable? File.join(parent, entry)\n      \"#{entry}*\"\n    else\n      entry\n    end\n  when \"directory\"\n    \"#{entry}/\"\n  when \"link\"\n    \"#{entry}@\"\n  else\n    entry\n  end\nend\n\ntarget = ARGV[0] || '.'\ntarget_fullpath = File.absolute_path target\ninit_prefix = ''\n\nputs target\ndisplay_entries target_fullpath, init_prefix, options\n```\n\nファイルのタイプを調べる際の処理を ls 編とちょっとだけ変えてみました。\nシンボリックリンクのリンク先を表示する修正が必要ですね...\n`color`は`ls`のときとほとんど変わらないので省きました。\n`File.ftype`では実行可能ファイルかどうかは判定できないんですかね??そこがちょっと気になります。\nあとはオプションのあたりなど複雑になってしまっているので綺麗にしたいです。\n","slug":"RubyでLinuxコマンドの再実装(tree編)","title":"RubyでLinuxコマンドの再実装(tree編)","timestamp":1413444033000,"tags":["Ruby","Linux"]},{"rawMarkdown":"---\ntitle: \"RubyでLinuxコマンドの再実装(ls編)\"\ndate: 2014-10-13T23:10:08+09:00\ntags: [\"Ruby\", \"Linux\"]\nurl: https://qiita.com/agatan/items/af0c3bbc881f60667c85\n---\n\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## ls\n\nではまずは`ls`です。簡単そうだったし個人的に一番良く使うコマンドなので。\n\n```rb\n#! /usr/bin/env ruby\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir::entries(target)\n\nentries.select!{|entry| entry[0] != '.'}\n\nentries.map! do |entry|\n  if File::directory?(File.join(target, entry))\n    \"#{entry}/\"\n  else\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\nディレクトリの場合は末尾に`/`をつけるようにしています。\n\n`-a`オプションで隠しファイル隠しディレクトリも表示するようにしたり, `--color`オプションで色をつけたりすることが目標です。\n\nコマンドライン引数の順番や, `-a -l -F`と`-alF`などややこしそうな部分は制約をつけてお茶を濁してしまうかもしれません...\n\n### 追記\n\n---\n\n@riocampos さんにコメントでコマンドライン引数の利用方法を教えていただきました！\n`require 'optparse'`とすればパーサが利用できるようになります。\n\nというわけでこれを反映し修正したものがこちらです。\n\n```ls.rb\n#! /usr/bin/env ruby -w\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\nrequire 'optparse'\n\ndef set_color_and_reset(entry, color)\n  case color\n  when :red\n    \"\\e[31m#{entry}\\e[0m\"\n  when :green\n    \"\\e[32m#{entry}\\e[0m\"\n  when :blue\n    \"\\e[34m#{entry}\\e[0m\"\n  when :cyan\n    \"\\e[36m#{entry}\\e[0m\"\n  else\n    entry\n  end\nend\n\noptions = ARGV.getopts('aF', 'color')\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir.entries(target)\n\nif options['a']\n  options['a'] = false\nelse\n  entries.select! { |entry| entry[0] != '.' }\nend\n\nif options.value? true\n  entries.map! do |entry|\n    fullpath = \"#{target}/#{entry}\"\n    case\n    when File.directory?(fullpath)\n      entry = set_color_and_reset entry, :blue if options['color']\n      entry += '/' if options['F']\n    when File.symlink?(fullpath)\n      entry = set_color_and_reset entry, :cyan if options['color']\n      entry += '@' if options['F']\n    when File.executable?(fullpath)\n      entry = set_color_and_reset entry, :red if options['color']\n      entry += '*' if options['F']\n    end\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\n`-l`オプションは対応していません...`-aF --color`に対応しました。\n表示の桁揃えとかしたほうが綺麗なんでしょうけれど...\n\n次は`tree`に挑戦してみます。\n","contentMarkdown":"\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## ls\n\nではまずは`ls`です。簡単そうだったし個人的に一番良く使うコマンドなので。\n\n```rb\n#! /usr/bin/env ruby\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir::entries(target)\n\nentries.select!{|entry| entry[0] != '.'}\n\nentries.map! do |entry|\n  if File::directory?(File.join(target, entry))\n    \"#{entry}/\"\n  else\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\nディレクトリの場合は末尾に`/`をつけるようにしています。\n\n`-a`オプションで隠しファイル隠しディレクトリも表示するようにしたり, `--color`オプションで色をつけたりすることが目標です。\n\nコマンドライン引数の順番や, `-a -l -F`と`-alF`などややこしそうな部分は制約をつけてお茶を濁してしまうかもしれません...\n\n### 追記\n\n---\n\n@riocampos さんにコメントでコマンドライン引数の利用方法を教えていただきました！\n`require 'optparse'`とすればパーサが利用できるようになります。\n\nというわけでこれを反映し修正したものがこちらです。\n\n```ls.rb\n#! /usr/bin/env ruby -w\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\nrequire 'optparse'\n\ndef set_color_and_reset(entry, color)\n  case color\n  when :red\n    \"\\e[31m#{entry}\\e[0m\"\n  when :green\n    \"\\e[32m#{entry}\\e[0m\"\n  when :blue\n    \"\\e[34m#{entry}\\e[0m\"\n  when :cyan\n    \"\\e[36m#{entry}\\e[0m\"\n  else\n    entry\n  end\nend\n\noptions = ARGV.getopts('aF', 'color')\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir.entries(target)\n\nif options['a']\n  options['a'] = false\nelse\n  entries.select! { |entry| entry[0] != '.' }\nend\n\nif options.value? true\n  entries.map! do |entry|\n    fullpath = \"#{target}/#{entry}\"\n    case\n    when File.directory?(fullpath)\n      entry = set_color_and_reset entry, :blue if options['color']\n      entry += '/' if options['F']\n    when File.symlink?(fullpath)\n      entry = set_color_and_reset entry, :cyan if options['color']\n      entry += '@' if options['F']\n    when File.executable?(fullpath)\n      entry = set_color_and_reset entry, :red if options['color']\n      entry += '*' if options['F']\n    end\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\n`-l`オプションは対応していません...`-aF --color`に対応しました。\n表示の桁揃えとかしたほうが綺麗なんでしょうけれど...\n\n次は`tree`に挑戦してみます。\n","slug":"RubyでLinuxコマンドの再実装(ls編)","title":"RubyでLinuxコマンドの再実装(ls編)","timestamp":1413209408000,"tags":["Ruby","Linux"]}]},"__N_SSG":true}