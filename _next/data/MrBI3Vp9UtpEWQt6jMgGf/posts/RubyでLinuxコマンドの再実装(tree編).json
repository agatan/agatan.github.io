{"pageProps":{"post":{"content":"<p>Ruby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。</p>\n<p>少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。</p>\n<p><a href=\"http://qiita.com/agatan/items/af0c3bbc881f60667c85\">Ruby で Linux コマンドの再実装(ls 編) - Qiita</a>\n<a href=\"http://qiita.com/agatan/items/4c50554ae22aa4181cc1\">Ruby で Linux コマンドの再実装(tree 編) - Qiita</a></p>\n<h2>tree</h2>\n<p><code>tree</code>コマンドに挑戦します。\n<code>tree</code>コマンドは, 指定したディレクトリ以下のファイルを木構造にして表示してくれます。</p>\n<p><img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/b3ca62be-bc22-ec39-a836-70032b76521d.png\" alt=\"スクリーンショット 2014-10-16 16.16.08.png\" title=\"スクリーンショット 2014-10-16 16.16.08.png\"></p>\n<div class=\"remark-highlight\"><pre class=\"language-tree\"><code class=\"language-tree\">#! /usr/bin/env ruby -w\n#\n# tree: 引数で指定されたディレクトリ以下のファイルを\n#       再帰的に木構造として表示する.\n\nrequire &#x26;#39;optparse&#x26;#39;\n\noptions = ARGV.getopts(&#x26;#39;aF&#x26;#39;)\n\n# parentは絶対パス.\ndef display_entries(parent, prefix, options)\n  # &#x26;#39;.&#x26;#39;, &#x26;#39;..&#x26;#39;を除く. 無限に再帰することを防ぐ\n  entries = Dir.entries(parent).delete_if do |entry|\n    entry == &#x26;#39;.&#x26;#39; or entry == &#x26;#39;..&#x26;#39; or !options[&#x26;#39;a&#x26;#39;] &#x26;amp;&#x26;amp; entry.start_with?(&#x26;#39;.&#x26;#39;)\n  end\n\n  entries.each_with_index do |entry, index|\n    fullpath = File.join(parent, entry)\n    entry = f_option(parent, entry) if options[&#x26;#39;F&#x26;#39;]\n    # 最後の要素かどうか\n    if index == entries.size - 1\n      puts &#x26;quot;#{prefix}└── #{entry}&#x26;quot;\n      next_prefix = prefix + &#x26;#39;    &#x26;#39;\n    else\n      puts &#x26;quot;#{prefix}├── #{entry}&#x26;quot;\n      next_prefix = prefix + &#x26;#39;│   &#x26;#39;\n    end\n    if File.directory? fullpath\n      display_entries(fullpath, next_prefix, options)\n    end\n  end\nend\n\ndef f_option(parent, entry)\n  case File.ftype(File.join(parent, entry))\n  when &#x26;quot;file&#x26;quot;\n    if File.executable? File.join(parent, entry)\n      &#x26;quot;#{entry}*&#x26;quot;\n    else\n      entry\n    end\n  when &#x26;quot;directory&#x26;quot;\n    &#x26;quot;#{entry}/&#x26;quot;\n  when &#x26;quot;link&#x26;quot;\n    &#x26;quot;#{entry}@&#x26;quot;\n  else\n    entry\n  end\nend\n\ntarget = ARGV[0] || &#x26;#39;.&#x26;#39;\ntarget_fullpath = File.absolute_path target\ninit_prefix = &#x26;#39;&#x26;#39;\n\nputs target\ndisplay_entries target_fullpath, init_prefix, options</code></pre></div>\n<p>ファイルのタイプを調べる際の処理を ls 編とちょっとだけ変えてみました。\nシンボリックリンクのリンク先を表示する修正が必要ですね...\n<code>color</code>は<code>ls</code>のときとほとんど変わらないので省きました。\n<code>File.ftype</code>では実行可能ファイルかどうかは判定できないんですかね??そこがちょっと気になります。\nあとはオプションのあたりなど複雑になってしまっているので綺麗にしたいです。</p>\n","meta":{"rawMarkdown":"---\ntitle: \"RubyでLinuxコマンドの再実装(tree編)\"\ndate: 2014-10-16T16:20:33+09:00\ntags: [\"Ruby\", \"Linux\"]\nurl: https://qiita.com/agatan/items/4c50554ae22aa4181cc1\n---\n\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## tree\n\n`tree`コマンドに挑戦します。\n`tree`コマンドは, 指定したディレクトリ以下のファイルを木構造にして表示してくれます。\n\n![スクリーンショット 2014-10-16 16.16.08.png](https://qiita-image-store.s3.amazonaws.com/0/39030/b3ca62be-bc22-ec39-a836-70032b76521d.png \"スクリーンショット 2014-10-16 16.16.08.png\")\n\n```tree.rb\n#! /usr/bin/env ruby -w\n#\n# tree: 引数で指定されたディレクトリ以下のファイルを\n#       再帰的に木構造として表示する.\n\nrequire 'optparse'\n\noptions = ARGV.getopts('aF')\n\n# parentは絶対パス.\ndef display_entries(parent, prefix, options)\n  # '.', '..'を除く. 無限に再帰することを防ぐ\n  entries = Dir.entries(parent).delete_if do |entry|\n    entry == '.' or entry == '..' or !options['a'] && entry.start_with?('.')\n  end\n\n  entries.each_with_index do |entry, index|\n    fullpath = File.join(parent, entry)\n    entry = f_option(parent, entry) if options['F']\n    # 最後の要素かどうか\n    if index == entries.size - 1\n      puts \"#{prefix}└── #{entry}\"\n      next_prefix = prefix + '    '\n    else\n      puts \"#{prefix}├── #{entry}\"\n      next_prefix = prefix + '│   '\n    end\n    if File.directory? fullpath\n      display_entries(fullpath, next_prefix, options)\n    end\n  end\nend\n\ndef f_option(parent, entry)\n  case File.ftype(File.join(parent, entry))\n  when \"file\"\n    if File.executable? File.join(parent, entry)\n      \"#{entry}*\"\n    else\n      entry\n    end\n  when \"directory\"\n    \"#{entry}/\"\n  when \"link\"\n    \"#{entry}@\"\n  else\n    entry\n  end\nend\n\ntarget = ARGV[0] || '.'\ntarget_fullpath = File.absolute_path target\ninit_prefix = ''\n\nputs target\ndisplay_entries target_fullpath, init_prefix, options\n```\n\nファイルのタイプを調べる際の処理を ls 編とちょっとだけ変えてみました。\nシンボリックリンクのリンク先を表示する修正が必要ですね...\n`color`は`ls`のときとほとんど変わらないので省きました。\n`File.ftype`では実行可能ファイルかどうかは判定できないんですかね??そこがちょっと気になります。\nあとはオプションのあたりなど複雑になってしまっているので綺麗にしたいです。\n","contentMarkdown":"\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## tree\n\n`tree`コマンドに挑戦します。\n`tree`コマンドは, 指定したディレクトリ以下のファイルを木構造にして表示してくれます。\n\n![スクリーンショット 2014-10-16 16.16.08.png](https://qiita-image-store.s3.amazonaws.com/0/39030/b3ca62be-bc22-ec39-a836-70032b76521d.png \"スクリーンショット 2014-10-16 16.16.08.png\")\n\n```tree.rb\n#! /usr/bin/env ruby -w\n#\n# tree: 引数で指定されたディレクトリ以下のファイルを\n#       再帰的に木構造として表示する.\n\nrequire 'optparse'\n\noptions = ARGV.getopts('aF')\n\n# parentは絶対パス.\ndef display_entries(parent, prefix, options)\n  # '.', '..'を除く. 無限に再帰することを防ぐ\n  entries = Dir.entries(parent).delete_if do |entry|\n    entry == '.' or entry == '..' or !options['a'] && entry.start_with?('.')\n  end\n\n  entries.each_with_index do |entry, index|\n    fullpath = File.join(parent, entry)\n    entry = f_option(parent, entry) if options['F']\n    # 最後の要素かどうか\n    if index == entries.size - 1\n      puts \"#{prefix}└── #{entry}\"\n      next_prefix = prefix + '    '\n    else\n      puts \"#{prefix}├── #{entry}\"\n      next_prefix = prefix + '│   '\n    end\n    if File.directory? fullpath\n      display_entries(fullpath, next_prefix, options)\n    end\n  end\nend\n\ndef f_option(parent, entry)\n  case File.ftype(File.join(parent, entry))\n  when \"file\"\n    if File.executable? File.join(parent, entry)\n      \"#{entry}*\"\n    else\n      entry\n    end\n  when \"directory\"\n    \"#{entry}/\"\n  when \"link\"\n    \"#{entry}@\"\n  else\n    entry\n  end\nend\n\ntarget = ARGV[0] || '.'\ntarget_fullpath = File.absolute_path target\ninit_prefix = ''\n\nputs target\ndisplay_entries target_fullpath, init_prefix, options\n```\n\nファイルのタイプを調べる際の処理を ls 編とちょっとだけ変えてみました。\nシンボリックリンクのリンク先を表示する修正が必要ですね...\n`color`は`ls`のときとほとんど変わらないので省きました。\n`File.ftype`では実行可能ファイルかどうかは判定できないんですかね??そこがちょっと気になります。\nあとはオプションのあたりなど複雑になってしまっているので綺麗にしたいです。\n","slug":"RubyでLinuxコマンドの再実装(tree編)","title":"RubyでLinuxコマンドの再実装(tree編)","timestamp":1413444033000,"tags":["Ruby","Linux"]}}},"__N_SSG":true}