{"pageProps":{"post":{"content":"<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> や Rust など多くの強力な型システムを持つ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語</a>は、<code>Either</code> とか <code>Result</code> といった「失敗するかもしれない」計算の値を示す型を持っています。</p>\n<p>現在の <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の標準ライブラリにはこのような型はありませんので、それを自作してみようというわけです。</p>\n<p>ちなみに現在策定中の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>17には <code>std::optional</code> が入ることが決定しているようです。これは、<code>result</code> と同様に失敗するかもしれな値を示しますが、失敗した原因がなんなのかを通知する仕組みを持っていません。</p>\n<h2>そもそもどういう型か</h2>\n<p>Rust の <code>Result</code> 型を例にみてみます。</p>\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">enum</span> <span class=\"synIdentifier\">Result</span><span class=\"synStatement\">&lt;</span>V, E<span class=\"synStatement\">&gt;</span> {\n  <span class=\"synConstant\">Ok</span>(V),\n  <span class=\"synConstant\">Err</span>(E),\n}\n</pre>\n<p>Rust における <code>Result</code> 型はだいたいこんな感じで定義されています。</p>\n<p><code>Result</code> は型引数を２つとります。<code>V</code> が成功時の値で、<code>E</code> が失敗時のエラー情報です。\n例えば、<code>fn parse_int(s: &amp;str) -&gt; Result&lt;isize, String&gt;;</code> は、文字列を受け取り、それが整数としてパース出来れば <code>isize</code> に変換し、<code>Ok(isize)</code> として返します。\nもし整数としてパース出来ないなどのエラーがあれば、それを <code>String</code> で表現し、<code>Err(String)</code> で返します。</p>\n<p>本質的にはこれが全てです。ここに、<code>Result</code> から中身を取り出す(<code>Err</code> なら <code>panic</code> する)関数などを定義してあげれば便利にエラー状態を表現できます。<br/>\n(Rust の <code>try</code> マクロはとても便利ですよね)</p>\n<h2>まずはベースとなる result を作る</h2>\n<p>まずはベースとなる <code>result</code> 型を作ってみます。</p>\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T, <span class=\"synType\">typename</span> E&gt;\n<span class=\"synType\">struct</span> result {\n\n  result(T <span class=\"synType\">const</span>&amp; ok) : t(tag::OK) {\n    ok_ = ok;\n  }\n\n  result(E <span class=\"synType\">const</span>&amp; e) : t(tag::OK) {\n    err_ = e;\n  }\n\n  ~result() {\n    <span class=\"synStatement\">switch</span> (t) {\n      <span class=\"synStatement\">case</span> tag::OK:\n        ok_.~T();\n        <span class=\"synStatement\">break</span>;\n      <span class=\"synStatement\">case</span> tag::ERROR:\n        err_.~E();\n        <span class=\"synStatement\">break</span>;\n    }\n  }\n\n  result(result <span class=\"synType\">const</span>&amp; r): t(r.t) {\n    <span class=\"synStatement\">switch</span> (t) {\n      <span class=\"synStatement\">case</span> tag::OK:\n        ok_ = r.ok_;\n        <span class=\"synStatement\">break</span>;\n      <span class=\"synStatement\">case</span> tag::ERROR:\n        err_ = r.err_;\n        <span class=\"synStatement\">break</span>;\n    }\n  }\n\n  T <span class=\"synType\">const</span>&amp; get() <span class=\"synType\">const</span> {\n    <span class=\"synStatement\">if</span> (t != tag::OK) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;invalid get operation&quot;</span>;\n    }\n    <span class=\"synStatement\">return</span> ok_;\n  }\n\n  E <span class=\"synType\">const</span>&amp; get_error() <span class=\"synType\">const</span> {\n    <span class=\"synStatement\">if</span> (t != tag::ERROR) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;invalid get operation&quot;</span>;\n    }\n    <span class=\"synStatement\">return</span> err_;\n  }\n\n<span class=\"synStatement\">private</span>:\n  <span class=\"synType\">enum</span> <span class=\"synType\">class</span> tag {\n    OK,\n    ERROR,\n  };\n  tag t;\n  <span class=\"synType\">union</span> {\n    T ok_;\n    E err_;\n  };\n\n};\n</pre>\n<p>かなり雑ですが、ざっくりこんな感じになるはずです。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>11 から拡張されて自由度がかなり高くなった <code>union</code> がとても便利です。</p>\n<p>これで <code>result&lt;int, std::string&gt;(1).get()</code> とやれば <code>1</code> が返るし <code>result&lt;int, std::string&gt;(std::string(\"test\")).get_error()</code> で <code>\"test\"</code> が返るはずです。</p>\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でやると何が難しいか</h2>\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> で難しいのは、Rustより弱い<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>が引き起こす問題です。<br/>\nRust では、<code>Ok(1isize)</code> とか <code>Err(\"error!\".to_owned())</code> とすれば、その値がどういう型であることが期待されているのかまで含めて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>や単一化が行われます。\nすなわち、<code>Ok(1isize)</code> だけを見てもエラーの型がわからないため、<code>Result&lt;isize, E&gt;</code> の <code>E</code> を決定することが出来ないが、Rust は強力な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>機構を持つため、これを決定することが出来ます。</p>\n<p>一方、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> では <code>result&lt;int, std::string&gt; f() { return 1; }</code> は <code>int</code> から <code>result&lt;int, std::string&gt;</code> の暗黙変換がきくので可能ですが、<code>result&lt;int, int&gt;</code> などとした瞬間、暗黙変換に頼ることはできなくなります。\nそこで、出来れば <code>ok(1)</code> とか <code>err(\"test\")</code> という感じにしたいのですが、これは一筋縄では行きません。</p>\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T, <span class=\"synType\">typename</span> E&gt; \nresult&lt;T, E&gt; ok(T);\n</pre>\n<p>これだと <code>T</code> は推論されても <code>E</code> が推論されないので、<code>ok&lt;int, std::string&gt;(1)</code> などとしなければなりません。これは使いづらすぎます。</p>\n<h2>じゃあどうするか</h2>\n<p>先ほどとは違う形ですが、やっぱり暗黙の型変換を応用します。</p>\n<p>要するに <code>ok</code> を表す型と <code>error</code> を表す型を区別しつつ、<code>result&lt;V, E&gt;</code> とはなるべくシームレスに変換をしたいというわけですから、それぞれ専用の型を作ってしまえば良いのです。</p>\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">struct</span> ok_value {\n  <span class=\"synType\">explicit</span> ok_value(T t): t(t) {}\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> V, <span class=\"synType\">typename</span> E&gt;\n  <span class=\"synStatement\">operator</span> result&lt;V, E&gt; () <span class=\"synType\">const</span>;\n\n<span class=\"synStatement\">private</span>:\n  T t;\n};\n\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> V, <span class=\"synType\">typename</span> E&gt;\nok_value&lt;T&gt;::<span class=\"synStatement\">operator</span> result&lt;V, E&gt; () <span class=\"synType\">const</span> {\n  <span class=\"synStatement\">return</span> result&lt;V, E&gt;(t);\n}\n\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\nok_value&lt;T&gt; ok(T t) {\n  <span class=\"synStatement\">return</span> ok_value&lt;T&gt;(t);\n}\n</pre>\n<p><code>ok</code> 側だけ示しました。<br/>\n<code>ok</code> 関数はテンプレートになっており、<code>T</code> 型の値をとって <code>ok_value&lt;T&gt;</code> を返します。（本当は値渡し以外にも対応すべきですが、簡単のために値渡しだけ実装しています）</p>\n<p><code>ok_value&lt;T&gt;</code> は型変換<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\">演算子</a> <code>operator result&lt;V, E&gt;() const</code> を持ちます。これによって <code>ok_value</code> から <code>result</code> への暗黙変換が可能になります。</p>\n<p><code>ok_value&lt;T&gt;</code> は <code>result&lt;T, E&gt;</code> に変換出来れば良さそうに見えるのですが、それでは不十分です。<br/>\n<code>ok(\"test\")</code> は <code>ok_value&lt;const char*&gt;</code> を返します。<code>ok_value&lt;T&gt; -&gt; result&lt;T, E&gt;</code> の変換しか提供していない場合は、<code>result&lt;std::string, E&gt;</code> への変換ができなくなってしまいます。これは不便ですよね。<br/>\nそこで新たにテンプレート引数を導入することでこれを解決しています。もっときちんとやるなら <code>std::is_constructible</code> などを使ってチェックをするべきだとは思いますが。</p>\n<p><code>error</code> 側もほぼ同様のコードを書いてやれば、</p>\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>result&lt;<span class=\"synType\">int</span>, std::string&gt; parse_digit(<span class=\"synType\">char</span> c) {\n  <span class=\"synStatement\">if</span> (c &lt; <span class=\"synConstant\">'0'</span> || <span class=\"synConstant\">'9'</span> &lt; c) {\n    <span class=\"synStatement\">return</span> error(<span class=\"synConstant\">&quot;invalid character&quot;</span>);\n  }\n  <span class=\"synStatement\">return</span> ok(c - <span class=\"synConstant\">'0'</span>);\n}\n</pre>\n<p>というように書けます。</p>\n<h2>まとめ</h2>\n<p><code>T</code> から <code>result&lt;T, E&gt;</code> への暗黙変換を許すという方針も全然ありだとは思いますが、個人的に Rust などで <code>ok</code> なら <code>ok</code> と明示するスタイルに慣れているので、こっちのほうが気に入っています。<br/>\n明らかに正常に値を返していそうな感じがコードにあらわれて好きです。</p>\n<p>暗黙の型変換って危険だしあまり良いイメージはないと思うのですが、やっぱりあれば便利ですね。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> を使っている時点で気を抜いたら死なので、「取り扱いを把握して全力で注意しながら使えば危険じゃない」という気持ちで便利に使いたいものです。</p>\n<hr>\n<hr>\n","meta":{"rawMarkdown":"---\ntitle: \"C++ で result 型を作る\"\ndate: 2016-07-01T14:30:09.000Z\ntags: []\n---\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> や Rust など多くの強力な型システムを持つ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語</a>は、<code>Either</code> とか <code>Result</code> といった「失敗するかもしれない」計算の値を示す型を持っています。</p>\n\n<p>現在の <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の標準ライブラリにはこのような型はありませんので、それを自作してみようというわけです。</p>\n\n<p>ちなみに現在策定中の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>17には <code>std::optional</code> が入ることが決定しているようです。これは、<code>result</code> と同様に失敗するかもしれな値を示しますが、失敗した原因がなんなのかを通知する仕組みを持っていません。</p>\n\n<h2>そもそもどういう型か</h2>\n\n<p>Rust の <code>Result</code> 型を例にみてみます。</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">enum</span> <span class=\"synIdentifier\">Result</span><span class=\"synStatement\">&lt;</span>V, E<span class=\"synStatement\">&gt;</span> {\n  <span class=\"synConstant\">Ok</span>(V),\n  <span class=\"synConstant\">Err</span>(E),\n}\n</pre>\n\n<p>Rust における <code>Result</code> 型はだいたいこんな感じで定義されています。</p>\n\n<p><code>Result</code> は型引数を２つとります。<code>V</code> が成功時の値で、<code>E</code> が失敗時のエラー情報です。\n例えば、<code>fn parse_int(s: &amp;str) -&gt; Result&lt;isize, String&gt;;</code> は、文字列を受け取り、それが整数としてパース出来れば <code>isize</code> に変換し、<code>Ok(isize)</code> として返します。\nもし整数としてパース出来ないなどのエラーがあれば、それを <code>String</code> で表現し、<code>Err(String)</code> で返します。</p>\n\n<p>本質的にはこれが全てです。ここに、<code>Result</code> から中身を取り出す(<code>Err</code> なら <code>panic</code> する)関数などを定義してあげれば便利にエラー状態を表現できます。<br/>\n(Rust の <code>try</code> マクロはとても便利ですよね)</p>\n\n<h2>まずはベースとなる result を作る</h2>\n\n<p>まずはベースとなる <code>result</code> 型を作ってみます。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T, <span class=\"synType\">typename</span> E&gt;\n<span class=\"synType\">struct</span> result {\n\n  result(T <span class=\"synType\">const</span>&amp; ok) : t(tag::OK) {\n    ok_ = ok;\n  }\n\n  result(E <span class=\"synType\">const</span>&amp; e) : t(tag::OK) {\n    err_ = e;\n  }\n\n  ~result() {\n    <span class=\"synStatement\">switch</span> (t) {\n      <span class=\"synStatement\">case</span> tag::OK:\n        ok_.~T();\n        <span class=\"synStatement\">break</span>;\n      <span class=\"synStatement\">case</span> tag::ERROR:\n        err_.~E();\n        <span class=\"synStatement\">break</span>;\n    }\n  }\n\n  result(result <span class=\"synType\">const</span>&amp; r): t(r.t) {\n    <span class=\"synStatement\">switch</span> (t) {\n      <span class=\"synStatement\">case</span> tag::OK:\n        ok_ = r.ok_;\n        <span class=\"synStatement\">break</span>;\n      <span class=\"synStatement\">case</span> tag::ERROR:\n        err_ = r.err_;\n        <span class=\"synStatement\">break</span>;\n    }\n  }\n\n  T <span class=\"synType\">const</span>&amp; get() <span class=\"synType\">const</span> {\n    <span class=\"synStatement\">if</span> (t != tag::OK) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;invalid get operation&quot;</span>;\n    }\n    <span class=\"synStatement\">return</span> ok_;\n  }\n\n  E <span class=\"synType\">const</span>&amp; get_error() <span class=\"synType\">const</span> {\n    <span class=\"synStatement\">if</span> (t != tag::ERROR) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;invalid get operation&quot;</span>;\n    }\n    <span class=\"synStatement\">return</span> err_;\n  }\n\n<span class=\"synStatement\">private</span>:\n  <span class=\"synType\">enum</span> <span class=\"synType\">class</span> tag {\n    OK,\n    ERROR,\n  };\n  tag t;\n  <span class=\"synType\">union</span> {\n    T ok_;\n    E err_;\n  };\n\n};\n</pre>\n\n<p>かなり雑ですが、ざっくりこんな感じになるはずです。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>11 から拡張されて自由度がかなり高くなった <code>union</code> がとても便利です。</p>\n\n<p>これで <code>result&lt;int, std::string&gt;(1).get()</code> とやれば <code>1</code> が返るし <code>result&lt;int, std::string&gt;(std::string(\"test\")).get_error()</code> で <code>\"test\"</code> が返るはずです。</p>\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でやると何が難しいか</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> で難しいのは、Rustより弱い<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>が引き起こす問題です。<br/>\nRust では、<code>Ok(1isize)</code> とか <code>Err(\"error!\".to_owned())</code> とすれば、その値がどういう型であることが期待されているのかまで含めて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>や単一化が行われます。\nすなわち、<code>Ok(1isize)</code> だけを見てもエラーの型がわからないため、<code>Result&lt;isize, E&gt;</code> の <code>E</code> を決定することが出来ないが、Rust は強力な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>機構を持つため、これを決定することが出来ます。</p>\n\n<p>一方、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> では <code>result&lt;int, std::string&gt; f() { return 1; }</code> は <code>int</code> から <code>result&lt;int, std::string&gt;</code> の暗黙変換がきくので可能ですが、<code>result&lt;int, int&gt;</code> などとした瞬間、暗黙変換に頼ることはできなくなります。\nそこで、出来れば <code>ok(1)</code> とか <code>err(\"test\")</code> という感じにしたいのですが、これは一筋縄では行きません。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T, <span class=\"synType\">typename</span> E&gt; \nresult&lt;T, E&gt; ok(T);\n</pre>\n\n<p>これだと <code>T</code> は推論されても <code>E</code> が推論されないので、<code>ok&lt;int, std::string&gt;(1)</code> などとしなければなりません。これは使いづらすぎます。</p>\n\n<h2>じゃあどうするか</h2>\n\n<p>先ほどとは違う形ですが、やっぱり暗黙の型変換を応用します。</p>\n\n<p>要するに <code>ok</code> を表す型と <code>error</code> を表す型を区別しつつ、<code>result&lt;V, E&gt;</code> とはなるべくシームレスに変換をしたいというわけですから、それぞれ専用の型を作ってしまえば良いのです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">struct</span> ok_value {\n  <span class=\"synType\">explicit</span> ok_value(T t): t(t) {}\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> V, <span class=\"synType\">typename</span> E&gt;\n  <span class=\"synStatement\">operator</span> result&lt;V, E&gt; () <span class=\"synType\">const</span>;\n\n<span class=\"synStatement\">private</span>:\n  T t;\n};\n\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> V, <span class=\"synType\">typename</span> E&gt;\nok_value&lt;T&gt;::<span class=\"synStatement\">operator</span> result&lt;V, E&gt; () <span class=\"synType\">const</span> {\n  <span class=\"synStatement\">return</span> result&lt;V, E&gt;(t);\n}\n\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\nok_value&lt;T&gt; ok(T t) {\n  <span class=\"synStatement\">return</span> ok_value&lt;T&gt;(t);\n}\n</pre>\n\n<p><code>ok</code> 側だけ示しました。<br/>\n<code>ok</code> 関数はテンプレートになっており、<code>T</code> 型の値をとって <code>ok_value&lt;T&gt;</code> を返します。（本当は値渡し以外にも対応すべきですが、簡単のために値渡しだけ実装しています）</p>\n\n<p><code>ok_value&lt;T&gt;</code> は型変換<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\">演算子</a> <code>operator result&lt;V, E&gt;() const</code> を持ちます。これによって <code>ok_value</code> から <code>result</code> への暗黙変換が可能になります。</p>\n\n<p><code>ok_value&lt;T&gt;</code> は <code>result&lt;T, E&gt;</code> に変換出来れば良さそうに見えるのですが、それでは不十分です。<br/>\n<code>ok(\"test\")</code> は <code>ok_value&lt;const char*&gt;</code> を返します。<code>ok_value&lt;T&gt; -&gt; result&lt;T, E&gt;</code> の変換しか提供していない場合は、<code>result&lt;std::string, E&gt;</code> への変換ができなくなってしまいます。これは不便ですよね。<br/>\nそこで新たにテンプレート引数を導入することでこれを解決しています。もっときちんとやるなら <code>std::is_constructible</code> などを使ってチェックをするべきだとは思いますが。</p>\n\n<p><code>error</code> 側もほぼ同様のコードを書いてやれば、</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>result&lt;<span class=\"synType\">int</span>, std::string&gt; parse_digit(<span class=\"synType\">char</span> c) {\n  <span class=\"synStatement\">if</span> (c &lt; <span class=\"synConstant\">'0'</span> || <span class=\"synConstant\">'9'</span> &lt; c) {\n    <span class=\"synStatement\">return</span> error(<span class=\"synConstant\">&quot;invalid character&quot;</span>);\n  }\n  <span class=\"synStatement\">return</span> ok(c - <span class=\"synConstant\">'0'</span>);\n}\n</pre>\n\n<p>というように書けます。</p>\n\n<h2>まとめ</h2>\n\n<p><code>T</code> から <code>result&lt;T, E&gt;</code> への暗黙変換を許すという方針も全然ありだとは思いますが、個人的に Rust などで <code>ok</code> なら <code>ok</code> と明示するスタイルに慣れているので、こっちのほうが気に入っています。<br/>\n明らかに正常に値を返していそうな感じがコードにあらわれて好きです。</p>\n\n<p>暗黙の型変換って危険だしあまり良いイメージはないと思うのですが、やっぱりあれば便利ですね。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> を使っている時点で気を抜いたら死なので、「取り扱いを把握して全力で注意しながら使えば危険じゃない」という気持ちで便利に使いたいものです。</p>\n\n---\n\n---\n","contentMarkdown":"\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> や Rust など多くの強力な型システムを持つ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語</a>は、<code>Either</code> とか <code>Result</code> といった「失敗するかもしれない」計算の値を示す型を持っています。</p>\n\n<p>現在の <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の標準ライブラリにはこのような型はありませんので、それを自作してみようというわけです。</p>\n\n<p>ちなみに現在策定中の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>17には <code>std::optional</code> が入ることが決定しているようです。これは、<code>result</code> と同様に失敗するかもしれな値を示しますが、失敗した原因がなんなのかを通知する仕組みを持っていません。</p>\n\n<h2>そもそもどういう型か</h2>\n\n<p>Rust の <code>Result</code> 型を例にみてみます。</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">enum</span> <span class=\"synIdentifier\">Result</span><span class=\"synStatement\">&lt;</span>V, E<span class=\"synStatement\">&gt;</span> {\n  <span class=\"synConstant\">Ok</span>(V),\n  <span class=\"synConstant\">Err</span>(E),\n}\n</pre>\n\n<p>Rust における <code>Result</code> 型はだいたいこんな感じで定義されています。</p>\n\n<p><code>Result</code> は型引数を２つとります。<code>V</code> が成功時の値で、<code>E</code> が失敗時のエラー情報です。\n例えば、<code>fn parse_int(s: &amp;str) -&gt; Result&lt;isize, String&gt;;</code> は、文字列を受け取り、それが整数としてパース出来れば <code>isize</code> に変換し、<code>Ok(isize)</code> として返します。\nもし整数としてパース出来ないなどのエラーがあれば、それを <code>String</code> で表現し、<code>Err(String)</code> で返します。</p>\n\n<p>本質的にはこれが全てです。ここに、<code>Result</code> から中身を取り出す(<code>Err</code> なら <code>panic</code> する)関数などを定義してあげれば便利にエラー状態を表現できます。<br/>\n(Rust の <code>try</code> マクロはとても便利ですよね)</p>\n\n<h2>まずはベースとなる result を作る</h2>\n\n<p>まずはベースとなる <code>result</code> 型を作ってみます。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T, <span class=\"synType\">typename</span> E&gt;\n<span class=\"synType\">struct</span> result {\n\n  result(T <span class=\"synType\">const</span>&amp; ok) : t(tag::OK) {\n    ok_ = ok;\n  }\n\n  result(E <span class=\"synType\">const</span>&amp; e) : t(tag::OK) {\n    err_ = e;\n  }\n\n  ~result() {\n    <span class=\"synStatement\">switch</span> (t) {\n      <span class=\"synStatement\">case</span> tag::OK:\n        ok_.~T();\n        <span class=\"synStatement\">break</span>;\n      <span class=\"synStatement\">case</span> tag::ERROR:\n        err_.~E();\n        <span class=\"synStatement\">break</span>;\n    }\n  }\n\n  result(result <span class=\"synType\">const</span>&amp; r): t(r.t) {\n    <span class=\"synStatement\">switch</span> (t) {\n      <span class=\"synStatement\">case</span> tag::OK:\n        ok_ = r.ok_;\n        <span class=\"synStatement\">break</span>;\n      <span class=\"synStatement\">case</span> tag::ERROR:\n        err_ = r.err_;\n        <span class=\"synStatement\">break</span>;\n    }\n  }\n\n  T <span class=\"synType\">const</span>&amp; get() <span class=\"synType\">const</span> {\n    <span class=\"synStatement\">if</span> (t != tag::OK) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;invalid get operation&quot;</span>;\n    }\n    <span class=\"synStatement\">return</span> ok_;\n  }\n\n  E <span class=\"synType\">const</span>&amp; get_error() <span class=\"synType\">const</span> {\n    <span class=\"synStatement\">if</span> (t != tag::ERROR) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;invalid get operation&quot;</span>;\n    }\n    <span class=\"synStatement\">return</span> err_;\n  }\n\n<span class=\"synStatement\">private</span>:\n  <span class=\"synType\">enum</span> <span class=\"synType\">class</span> tag {\n    OK,\n    ERROR,\n  };\n  tag t;\n  <span class=\"synType\">union</span> {\n    T ok_;\n    E err_;\n  };\n\n};\n</pre>\n\n<p>かなり雑ですが、ざっくりこんな感じになるはずです。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>11 から拡張されて自由度がかなり高くなった <code>union</code> がとても便利です。</p>\n\n<p>これで <code>result&lt;int, std::string&gt;(1).get()</code> とやれば <code>1</code> が返るし <code>result&lt;int, std::string&gt;(std::string(\"test\")).get_error()</code> で <code>\"test\"</code> が返るはずです。</p>\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でやると何が難しいか</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> で難しいのは、Rustより弱い<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>が引き起こす問題です。<br/>\nRust では、<code>Ok(1isize)</code> とか <code>Err(\"error!\".to_owned())</code> とすれば、その値がどういう型であることが期待されているのかまで含めて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>や単一化が行われます。\nすなわち、<code>Ok(1isize)</code> だけを見てもエラーの型がわからないため、<code>Result&lt;isize, E&gt;</code> の <code>E</code> を決定することが出来ないが、Rust は強力な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>機構を持つため、これを決定することが出来ます。</p>\n\n<p>一方、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> では <code>result&lt;int, std::string&gt; f() { return 1; }</code> は <code>int</code> から <code>result&lt;int, std::string&gt;</code> の暗黙変換がきくので可能ですが、<code>result&lt;int, int&gt;</code> などとした瞬間、暗黙変換に頼ることはできなくなります。\nそこで、出来れば <code>ok(1)</code> とか <code>err(\"test\")</code> という感じにしたいのですが、これは一筋縄では行きません。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T, <span class=\"synType\">typename</span> E&gt; \nresult&lt;T, E&gt; ok(T);\n</pre>\n\n<p>これだと <code>T</code> は推論されても <code>E</code> が推論されないので、<code>ok&lt;int, std::string&gt;(1)</code> などとしなければなりません。これは使いづらすぎます。</p>\n\n<h2>じゃあどうするか</h2>\n\n<p>先ほどとは違う形ですが、やっぱり暗黙の型変換を応用します。</p>\n\n<p>要するに <code>ok</code> を表す型と <code>error</code> を表す型を区別しつつ、<code>result&lt;V, E&gt;</code> とはなるべくシームレスに変換をしたいというわけですから、それぞれ専用の型を作ってしまえば良いのです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">struct</span> ok_value {\n  <span class=\"synType\">explicit</span> ok_value(T t): t(t) {}\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> V, <span class=\"synType\">typename</span> E&gt;\n  <span class=\"synStatement\">operator</span> result&lt;V, E&gt; () <span class=\"synType\">const</span>;\n\n<span class=\"synStatement\">private</span>:\n  T t;\n};\n\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> V, <span class=\"synType\">typename</span> E&gt;\nok_value&lt;T&gt;::<span class=\"synStatement\">operator</span> result&lt;V, E&gt; () <span class=\"synType\">const</span> {\n  <span class=\"synStatement\">return</span> result&lt;V, E&gt;(t);\n}\n\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\nok_value&lt;T&gt; ok(T t) {\n  <span class=\"synStatement\">return</span> ok_value&lt;T&gt;(t);\n}\n</pre>\n\n<p><code>ok</code> 側だけ示しました。<br/>\n<code>ok</code> 関数はテンプレートになっており、<code>T</code> 型の値をとって <code>ok_value&lt;T&gt;</code> を返します。（本当は値渡し以外にも対応すべきですが、簡単のために値渡しだけ実装しています）</p>\n\n<p><code>ok_value&lt;T&gt;</code> は型変換<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\">演算子</a> <code>operator result&lt;V, E&gt;() const</code> を持ちます。これによって <code>ok_value</code> から <code>result</code> への暗黙変換が可能になります。</p>\n\n<p><code>ok_value&lt;T&gt;</code> は <code>result&lt;T, E&gt;</code> に変換出来れば良さそうに見えるのですが、それでは不十分です。<br/>\n<code>ok(\"test\")</code> は <code>ok_value&lt;const char*&gt;</code> を返します。<code>ok_value&lt;T&gt; -&gt; result&lt;T, E&gt;</code> の変換しか提供していない場合は、<code>result&lt;std::string, E&gt;</code> への変換ができなくなってしまいます。これは不便ですよね。<br/>\nそこで新たにテンプレート引数を導入することでこれを解決しています。もっときちんとやるなら <code>std::is_constructible</code> などを使ってチェックをするべきだとは思いますが。</p>\n\n<p><code>error</code> 側もほぼ同様のコードを書いてやれば、</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>result&lt;<span class=\"synType\">int</span>, std::string&gt; parse_digit(<span class=\"synType\">char</span> c) {\n  <span class=\"synStatement\">if</span> (c &lt; <span class=\"synConstant\">'0'</span> || <span class=\"synConstant\">'9'</span> &lt; c) {\n    <span class=\"synStatement\">return</span> error(<span class=\"synConstant\">&quot;invalid character&quot;</span>);\n  }\n  <span class=\"synStatement\">return</span> ok(c - <span class=\"synConstant\">'0'</span>);\n}\n</pre>\n\n<p>というように書けます。</p>\n\n<h2>まとめ</h2>\n\n<p><code>T</code> から <code>result&lt;T, E&gt;</code> への暗黙変換を許すという方針も全然ありだとは思いますが、個人的に Rust などで <code>ok</code> なら <code>ok</code> と明示するスタイルに慣れているので、こっちのほうが気に入っています。<br/>\n明らかに正常に値を返していそうな感じがコードにあらわれて好きです。</p>\n\n<p>暗黙の型変換って危険だしあまり良いイメージはないと思うのですが、やっぱりあれば便利ですね。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> を使っている時点で気を抜いたら死なので、「取り扱いを把握して全力で注意しながら使えば危険じゃない」という気持ちで便利に使いたいものです。</p>\n\n---\n\n---\n","slug":"C++_で_result_型を作る","title":"C++ で result 型を作る","timestamp":1467383409000,"tags":[]}}},"__N_SSG":true}