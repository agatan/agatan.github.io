{"pageProps":{"tag":"Rust","postMetas":[{"rawMarkdown":"---\ntitle: \"Rustで自作シェルもどきを作る(単純なコマンド実行編)\"\ndate: 2014-12-21T14:55:51+09:00\ntags: [\"Rust\"]\nurl: https://qiita.com/agatan/items/ed2780628d20a0e343b8\n---\n\nコード全文はこちら\n[agatan/rsh](https://github.com/agatan/rsh)\n\n[Rust で自作シェルもどきを作る(字句解析編) - Qiita](http://qiita.com/agatan/items/8a097ead46df1c1659ff)\n\n前回はユーザからの入力を受け付けてパースするところまで実装したので、今回は実際に入力されたコマンドを実行させてみます。  \nただし、いきなりいろいろやるのはきついので、まずは単純なコマンド(パイプやリダイレクトは一旦無視します)の実行をやってみました。\n\n## Command\n\nRust には`std::io::process::Command`という構造体があります。これを使えば簡単にコマンド実行は出来そうです。\n\n> http://doc.rust-lang.org/std/io/process/struct.Command.htmlより引用\n>\n> ```rust\n> use std::io::Command;\n> ```\n\n> let mut process = match Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").spawn() {\n> Ok(p) => p,\n> Err(e) => panic!(\"failed to execute process: {}\", e),\n> };\n\n> let output = process.stdout.as_mut().unwrap().read_to_end();\n\n````\n\nいろいろと便利そうな関数が定義されているのですが、今回は最も単純にコマンドを実行させるために、`output`という関数を使用してみました。\n\n```rust:exec.rs\nuse std;\nuse std::io::process::Command;\n\nuse parse::Token;\n\npub fn exec(tokens: Vec<Token>) {\n    if tokens.iter()\n             .find(|&t| match t {\n                 &Token::Str(_) => false, _ => true } ).is_some() {\n        panic!(\"Not implemented yet.\");\n    }\n    let first_cmd = tokens.iter()\n                          .take_while(|&t| match t {\n                              &Token::Str(_) => true,\n                              _ => false\n                          })\n                          .map(|ref t| match *t {\n                              &Token::Str(ref x) => x.clone(),\n                              _ => panic!(\"Shouldn't be reached.\"),\n                          })\n                          .collect::<Vec<String>>();\n\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .output() {\n        Ok(p) => p,\n        Err(e) => panic!(\"Failed to execute: {}\", e),\n    };\n\n    print!(\"{}\", String::from_utf8_lossy(output.output.as_slice()));\n\n}\n````\n\n`exec`は`Vec<Token>`を受け取る関数です。\n今回はパイプなどは未実装ですから、`Str(_)`以外の`Token`が含まれていたら`panic!`(例外送出)をしています。\n\nさて、`Command`は`new`で実行したいコマンド名を指定し、それに続けて`arg`や`args`で引数を追加していきます。\nユーザからの入力を利用しているので、ひとつずつしか追加できない`arg`よりは、スライスを渡して複数追加できる`args`を使いたいです。\n\nこれらにあわせて`Vec<Token>`を`Vec<String>`もしくは`Vec<&str>`に変換してあげれば良さそうです。\nということで`let first_cmd = ...`という長い文は、その変換を行っています。\n\n正直まだ`&`と`ref`の関係とか所有権の問題はきちんと理解できていないというか書き方がよくわかっていないので、コンパイラに怒ってもらいながらなんとか直してみました。\nコンパイルを通るように、を第一に書いていったので汚かったり効率悪かったりするかもしれません...\n\nあとは`Command`に登録していって、`output`を読んであげれば完了です。\nただし`output`はバイト列を返すみたいなので、`String::from_utf8_lossy`を使って、文字に直してあげます。\n\n#### 追記(2014/12/21)\n\n---\n\nこのままだと標準入力や標準出力、標準エラー出力が子プロセスと結びついておらず、仮想のパイプとつながったような状態になるようです。\nそのため、標準入力から読み取るような関数を実行しようとするとそのプロセスは失敗します。\n\n修正したのが以下のコードです。(`Command`を作成する部分のみ)\n\n```rust\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .stdin(StdioContainer::InheritFd(STDIN_FILENO))\n                              .stdout(StdioContainer::InheritFd(STDOUT_FILENO))\n                              .stderr(StdioContainer::InheritFd(STDERR_FILENO))\n                              .spawn() {\n        Ok(p) => p,\n        Err(e) => panic!(\"ERROR: {}\", e)\n                              };\n    match output.wait() {\n        Ok(e) => println!(\"Exit: {}\", e),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n```\n\nこのように、`stdout`を標準出力と関連付けることで、前のコードでの`output`から読み取って文字列に変換して出力、という手順は不要になりました。\nC 言語では`fork`したら`wait`しろと言われて育ってきたので、とりあえず`wait`を入れてみていますが、どうも`wait`を入れなくてもゾンビプロセスが残っているようには見えないので謎です。\n調査中です。\n\n### 追記ここまで\n\n## main\n\n先ほどの`exec`関数を`main`で使える形にしてみます。\n\n```rust:main.rs\nuse std::io;\nmod parse;\nmod exec;\n\nfn main() {\n    loop {\n        print!(\"% > \");\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let parser = parse::Parser::new(input);\n        let tokens: Vec<parse::Token> = parser.collect();\n        exec::exec(tokens);\n    }\n}\n```\n\nプロンプトを表示してからユーザーの入力を受付け、パースして`Vec<Token>`になおしてから`exec`に渡しています。\n\n## 実行結果\n\n```\n% > echo hello\nhello\n% > echo \"hello world\"\n\"hello world\"\n% >\n```\n\nあれ？`\"`の扱いなんて考えてなかったのになぜかうまくいってますね。不思議。\n\n検証用に`main.rs`を書き換えて実行してみました。\n\n```\n% > echo hello\nStr(echo)\nStr(hello)\nhello\n% > echo \"hello world\"\nStr(echo)\nStr(\"hello)\nStr(world\")\n\"hello world\"\n% > echo \"hello     world\"\nStr(echo)\nStr(\"hello)\nStr(world\")\n\"hello world\"\n% >\n```\n\n`echo`がうまくやってくれているみたいですね。すごい。\n\n## 今後\n\n次はリダイレクト関連ですかね。パイプや&よりも簡単そうだし。\n毎度のことですが、ご指摘大歓迎です！色々な意見を伺いたくてこれを書いているので、何かありましたらぜひよろしくお願いします！\n\n[agatan/rsh](https://github.com/agatan/rsh)\n","contentMarkdown":"\nコード全文はこちら\n[agatan/rsh](https://github.com/agatan/rsh)\n\n[Rust で自作シェルもどきを作る(字句解析編) - Qiita](http://qiita.com/agatan/items/8a097ead46df1c1659ff)\n\n前回はユーザからの入力を受け付けてパースするところまで実装したので、今回は実際に入力されたコマンドを実行させてみます。  \nただし、いきなりいろいろやるのはきついので、まずは単純なコマンド(パイプやリダイレクトは一旦無視します)の実行をやってみました。\n\n## Command\n\nRust には`std::io::process::Command`という構造体があります。これを使えば簡単にコマンド実行は出来そうです。\n\n> http://doc.rust-lang.org/std/io/process/struct.Command.htmlより引用\n>\n> ```rust\n> use std::io::Command;\n> ```\n\n> let mut process = match Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").spawn() {\n> Ok(p) => p,\n> Err(e) => panic!(\"failed to execute process: {}\", e),\n> };\n\n> let output = process.stdout.as_mut().unwrap().read_to_end();\n\n````\n\nいろいろと便利そうな関数が定義されているのですが、今回は最も単純にコマンドを実行させるために、`output`という関数を使用してみました。\n\n```rust:exec.rs\nuse std;\nuse std::io::process::Command;\n\nuse parse::Token;\n\npub fn exec(tokens: Vec<Token>) {\n    if tokens.iter()\n             .find(|&t| match t {\n                 &Token::Str(_) => false, _ => true } ).is_some() {\n        panic!(\"Not implemented yet.\");\n    }\n    let first_cmd = tokens.iter()\n                          .take_while(|&t| match t {\n                              &Token::Str(_) => true,\n                              _ => false\n                          })\n                          .map(|ref t| match *t {\n                              &Token::Str(ref x) => x.clone(),\n                              _ => panic!(\"Shouldn't be reached.\"),\n                          })\n                          .collect::<Vec<String>>();\n\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .output() {\n        Ok(p) => p,\n        Err(e) => panic!(\"Failed to execute: {}\", e),\n    };\n\n    print!(\"{}\", String::from_utf8_lossy(output.output.as_slice()));\n\n}\n````\n\n`exec`は`Vec<Token>`を受け取る関数です。\n今回はパイプなどは未実装ですから、`Str(_)`以外の`Token`が含まれていたら`panic!`(例外送出)をしています。\n\nさて、`Command`は`new`で実行したいコマンド名を指定し、それに続けて`arg`や`args`で引数を追加していきます。\nユーザからの入力を利用しているので、ひとつずつしか追加できない`arg`よりは、スライスを渡して複数追加できる`args`を使いたいです。\n\nこれらにあわせて`Vec<Token>`を`Vec<String>`もしくは`Vec<&str>`に変換してあげれば良さそうです。\nということで`let first_cmd = ...`という長い文は、その変換を行っています。\n\n正直まだ`&`と`ref`の関係とか所有権の問題はきちんと理解できていないというか書き方がよくわかっていないので、コンパイラに怒ってもらいながらなんとか直してみました。\nコンパイルを通るように、を第一に書いていったので汚かったり効率悪かったりするかもしれません...\n\nあとは`Command`に登録していって、`output`を読んであげれば完了です。\nただし`output`はバイト列を返すみたいなので、`String::from_utf8_lossy`を使って、文字に直してあげます。\n\n#### 追記(2014/12/21)\n\n---\n\nこのままだと標準入力や標準出力、標準エラー出力が子プロセスと結びついておらず、仮想のパイプとつながったような状態になるようです。\nそのため、標準入力から読み取るような関数を実行しようとするとそのプロセスは失敗します。\n\n修正したのが以下のコードです。(`Command`を作成する部分のみ)\n\n```rust\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .stdin(StdioContainer::InheritFd(STDIN_FILENO))\n                              .stdout(StdioContainer::InheritFd(STDOUT_FILENO))\n                              .stderr(StdioContainer::InheritFd(STDERR_FILENO))\n                              .spawn() {\n        Ok(p) => p,\n        Err(e) => panic!(\"ERROR: {}\", e)\n                              };\n    match output.wait() {\n        Ok(e) => println!(\"Exit: {}\", e),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n```\n\nこのように、`stdout`を標準出力と関連付けることで、前のコードでの`output`から読み取って文字列に変換して出力、という手順は不要になりました。\nC 言語では`fork`したら`wait`しろと言われて育ってきたので、とりあえず`wait`を入れてみていますが、どうも`wait`を入れなくてもゾンビプロセスが残っているようには見えないので謎です。\n調査中です。\n\n### 追記ここまで\n\n## main\n\n先ほどの`exec`関数を`main`で使える形にしてみます。\n\n```rust:main.rs\nuse std::io;\nmod parse;\nmod exec;\n\nfn main() {\n    loop {\n        print!(\"% > \");\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let parser = parse::Parser::new(input);\n        let tokens: Vec<parse::Token> = parser.collect();\n        exec::exec(tokens);\n    }\n}\n```\n\nプロンプトを表示してからユーザーの入力を受付け、パースして`Vec<Token>`になおしてから`exec`に渡しています。\n\n## 実行結果\n\n```\n% > echo hello\nhello\n% > echo \"hello world\"\n\"hello world\"\n% >\n```\n\nあれ？`\"`の扱いなんて考えてなかったのになぜかうまくいってますね。不思議。\n\n検証用に`main.rs`を書き換えて実行してみました。\n\n```\n% > echo hello\nStr(echo)\nStr(hello)\nhello\n% > echo \"hello world\"\nStr(echo)\nStr(\"hello)\nStr(world\")\n\"hello world\"\n% > echo \"hello     world\"\nStr(echo)\nStr(\"hello)\nStr(world\")\n\"hello world\"\n% >\n```\n\n`echo`がうまくやってくれているみたいですね。すごい。\n\n## 今後\n\n次はリダイレクト関連ですかね。パイプや&よりも簡単そうだし。\n毎度のことですが、ご指摘大歓迎です！色々な意見を伺いたくてこれを書いているので、何かありましたらぜひよろしくお願いします！\n\n[agatan/rsh](https://github.com/agatan/rsh)\n","slug":"Rustで自作シェルもどきを作る(単純なコマンド実行編)","title":"Rustで自作シェルもどきを作る(単純なコマンド実行編)","timestamp":1419141351000,"tags":["Rust"]},{"rawMarkdown":"---\ntitle: \"Rustで自作シェルもどきを作る(字句解析編)\"\ndate: 2014-12-21T01:15:19+09:00\ntags: [\"Rust\"]\nurl: https://qiita.com/agatan/items/8a097ead46df1c1659ff\n---\n\nRust が最近とてもおもしろいので、勉強がてら自作シェルみたいなものを作ってみたいと思います。  \nとはいえ、C 言語でさえろくにシステムプログラムを書いたことがないので、道は険しくなりそうです。\n\n## バージョン\n\n0.13.0-nightly を使用しました。\n\nコード全文はこちら\n[agatan/rsh](https://github.com/agatan/rsh)\n\n## 字句解析\n\nさて、シェルといったらまずはユーザの入力を受け付けてパースし、コマンドを実行しなくてはなりません。  \nというわけでまず初めにパース部分についてやってみます。  \nさくっと終わらせたかったのですが、どうもまだ`String`と`&str`とかそのへんで詰まってしまいます...\n\n## Token の規定\n\n`enum`を使って`Token`を列挙します。  \n一応最終的にはパイプやらリダイレクトやらも実装したいなーと思っているので、その辺を考慮に入れた実装にしてみました。\n\n```rust\nenum Token {\n\tStr(String),\n\tPipe,\n\tRedirectTo,\n\tRedirectFrom,\n\tAmpersand,\n}\n```\n\n`Str`は特殊な文字以外の文字列ですから、要素として`String`を保持させておきました。\n\n## parser\n\nパースには(おもしろそうだったので)`iterator`トレイトを実装させることにしました。  \n実際つかうときにはいらない気もしますが、ちょっとためしたかったので。\n\n構造体として`Parser`を作ります。ソースとなる文字列と、現在どこまでパース済みなのかを保持する`current`を持たせました。\n\n```rust\npub struct Parser {\n    src: String,\n    pub current: uint,\n}\n```\n\nこの構造体に`Iterator`トレイトを実装すればよいのですが、補助関数としていくつか実装しておきます。\n\n```rust\nimpl Parser {\n    pub fn new(src: String) -> Parser {\n        Parser { src: src, current: 0 }\n    }\n\n    pub fn current_char(&self) -> char {\n        self.src.char_at(self.current)\n    }\n\n    fn skip_whitespace(&mut self) {\n        while self.current_char().is_whitespace() {\n            self.current += 1;\n            if self.current >= self.src.char_len() {\n                return;\n            }\n        }\n    }\n\n    fn get_pipe(&mut self) -> Option<Token> {\n        if self.current_char() == '|' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Pipe)\n        } else {\n            None\n        }\n    }\n\n    fn get_ampersand(&mut self) -> Option<Token> {\n        if self.current_char() == '&' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Ampersand)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_to(&mut self) -> Option<Token> {\n        if self.current_char() == '>' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectTo)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_from(&mut self) -> Option<Token> {\n        if self.current_char() == '<' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectFrom)\n\n    fn get_str(&mut self) -> Option<Token> {\n        let mut i = self.current;\n        while !KEYWORDS.contains_char(self.src.char_at(i)) {\n            i += 1;\n        }\n        if i == self.current {\n            None\n        } else {\n            let result = Some(Token::Str(self.src.slice_chars(self.current, i).to_string()));\n            self.current = i;\n            self.skip_whitespace();\n            result\n        }\n    }\n}\n\n```\n\n`new`は新しいパーサーを生成するための関数です。`Parser`は文字列の所有権を要求していますが、入力された文字列はパースする以外に使い道は無いと思ったので大丈夫と判断しました。\n\n`current_char`は現在注目している文字を返します。\n`skip_whitespace`は空白文字を飛ばすように`self.current`をいじります。パーサーでは、基本的に 1 トークンを読み終えたら空白を飛ばして次のトークンになりうる文字の先頭までジャンプするべきなので、必ずトークンを読んだらこの関数を呼び出します。\n\nのこりの関数は、それぞれの`Token`を取得することを試みる関数です。  \n`Option<Token>`が帰ってくるので、`None`が帰ってきたら今みているトークンは別の種類のものであるといえます。\n\nこれらを用いて`Iterator`を実装しました。\n\n```rust\nimpl std::iter::Iterator<Token> for Parser {\n\n    fn next(&mut self) -> Option<Token> {\n        if self.current >= self.src.char_len() {\n            return None;\n        }\n        let mut result: Option<Token> = self.get_pipe();\n        if result.is_some() { return result; }\n        result = self.get_ampersand();\n        if result.is_some() { return result; }\n        result = self.get_redirect_to();\n        if result.is_some() { return result; }\n        result = self.get_redirect_from();\n        if result.is_some() { return result; }\n        result = self.get_str();\n        if result.is_some() { return result; }\n        None\n    }\n}\n```\n\nきれいじゃないコードですが、うまいやり方が他に思いつかなかったので...  \n純粋にある種類のトークンを取得しようと試みて`None`が帰ってきたら別の種類で試す、ということを繰り返しています。\n先頭で末尾まで読み込んだかを判定しています。\nすべての条件に当てはまらなくなったらパース失敗で`None`を返しています。\n\n## 試す\n\n```rust\nuse std::io;\nmod parse;\n\nfn main() {\n    loop {\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let mut parser = parse::Parser::new(input);\n        for token in parser {\n            println!(\"{}\", token);\n        }\n    }\n}\n```\n\n実行結果\n\n```\nls -a | grep foo\nStr(ls)\nStr(-a)\nPipe\nStr(grep)\nStr(foo)\nls -a| grep foo>result.txt &\nStr(ls)\nStr(-a)\nPipe\nStr(grep)\nStr(foo)\nRedirectTo\nStr(result.txt)\nAmpersand\n```\n\nこのような感じになりました。\n`Iterator`を実装しているので、`for .. in ..`が使えて気持ち良いです。\n\n## 反省点\n\nパースは失敗しうる計算だから`Option`かなーどうせ`Option`かえすなら`Iterator`実装しちゃえばお得かなーとおもって漠然と実装してみましたが、パースは失敗した理由がほしいことがほとんどなのでよく考えたら`Result`を使うべきだった気がしてきました。\n効率とかは正直 Rust での効率のよい書き方がよくわかっていないのであまり気にせず、とりあえず動くものを、と作ってみました。\nあとはパーサを書いたことが殆どなかったので成功法がわからなかったので、もっときれいな書き方があるんじゃないかという気も...\n\n## 今後\n\nとりあえず動くものを、コードをたくさん書こう、の精神で進めてみます。\n次は単純なコマンド実行を実装したいです。\nといっても Rust には`Command`とか`Process`とかがあって、ちょっと読んで見た感じ割りと素直に C 言語の`execvp`とかを呼び出しているようなので、それを使えばそこまで難しくはないのかな？\n\nソースの全文を掲載しますので、Rust 固有であってもそうでなくても、より良い書き方などありましたらご教授いただけると幸いです。よろしくお願いします。\n\n```rust:parse.rs\nuse std;\n\nstatic KEYWORDS: &'static str = \"|&<> \\n\";\n\n#[deriving(Show)]\npub enum Token {\n    Str(String),\n    Pipe,\n    RedirectTo,\n    RedirectFrom,\n    Ampersand,\n}\n\npub struct Parser {\n    src: String,\n    pub current: uint,\n}\n\nimpl Parser {\n\n    pub fn new(src: String) -> Parser {\n        Parser { src: src, current: 0 }\n    }\n\n    pub fn current_char(&self) -> char {\n        self.src.char_at(self.current)\n    }\n\n    fn skip_whitespace(&mut self) {\n        while self.current_char().is_whitespace() {\n            self.current += 1;\n            if self.current >= self.src.char_len() {\n                return;\n            }\n        }\n    }\n\n    fn get_pipe(&mut self) -> Option<Token> {\n        if self.current_char() == '|' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Pipe)\n        } else {\n            None\n        }\n    }\n\n    fn get_ampersand(&mut self) -> Option<Token> {\n        if self.current_char() == '&' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Ampersand)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_to(&mut self) -> Option<Token> {\n        if self.current_char() == '>' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectTo)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_from(&mut self) -> Option<Token> {\n        if self.current_char() == '<' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectFrom)\n        } else {\n            None\n        }\n    }\n\n    fn get_str(&mut self) -> Option<Token> {\n        let mut i = self.current;\n        while !KEYWORDS.contains_char(self.src.char_at(i)) {\n            i += 1;\n        }\n        if i == self.current {\n            None\n        } else {\n            let result = Some(Token::Str(self.src.slice_chars(self.current, i).to_string()));\n            self.current = i;\n            self.skip_whitespace();\n            result\n        }\n    }\n}\n\nimpl std::iter::Iterator<Token> for Parser {\n\n    fn next(&mut self) -> Option<Token> {\n        if self.current >= self.src.char_len() {\n            return None;\n        }\n        let mut result: Option<Token> = self.get_pipe();\n        if result.is_some() { return result; }\n        result = self.get_ampersand();\n        if result.is_some() { return result; }\n        result = self.get_redirect_to();\n        if result.is_some() { return result; }\n        result = self.get_redirect_from();\n        if result.is_some() { return result; }\n        result = self.get_str();\n        if result.is_some() { return result; }\n        None\n    }\n}\n```\n\n```rust:main.rs\nuse std::io;\nmod parse;\n\nfn main() {\n    loop {\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let mut parser = parse::Parser::new(input);\n        for token in parser {\n            println!(\"{}\", token);\n        }\n    }\n}\n```\n","contentMarkdown":"\nRust が最近とてもおもしろいので、勉強がてら自作シェルみたいなものを作ってみたいと思います。  \nとはいえ、C 言語でさえろくにシステムプログラムを書いたことがないので、道は険しくなりそうです。\n\n## バージョン\n\n0.13.0-nightly を使用しました。\n\nコード全文はこちら\n[agatan/rsh](https://github.com/agatan/rsh)\n\n## 字句解析\n\nさて、シェルといったらまずはユーザの入力を受け付けてパースし、コマンドを実行しなくてはなりません。  \nというわけでまず初めにパース部分についてやってみます。  \nさくっと終わらせたかったのですが、どうもまだ`String`と`&str`とかそのへんで詰まってしまいます...\n\n## Token の規定\n\n`enum`を使って`Token`を列挙します。  \n一応最終的にはパイプやらリダイレクトやらも実装したいなーと思っているので、その辺を考慮に入れた実装にしてみました。\n\n```rust\nenum Token {\n\tStr(String),\n\tPipe,\n\tRedirectTo,\n\tRedirectFrom,\n\tAmpersand,\n}\n```\n\n`Str`は特殊な文字以外の文字列ですから、要素として`String`を保持させておきました。\n\n## parser\n\nパースには(おもしろそうだったので)`iterator`トレイトを実装させることにしました。  \n実際つかうときにはいらない気もしますが、ちょっとためしたかったので。\n\n構造体として`Parser`を作ります。ソースとなる文字列と、現在どこまでパース済みなのかを保持する`current`を持たせました。\n\n```rust\npub struct Parser {\n    src: String,\n    pub current: uint,\n}\n```\n\nこの構造体に`Iterator`トレイトを実装すればよいのですが、補助関数としていくつか実装しておきます。\n\n```rust\nimpl Parser {\n    pub fn new(src: String) -> Parser {\n        Parser { src: src, current: 0 }\n    }\n\n    pub fn current_char(&self) -> char {\n        self.src.char_at(self.current)\n    }\n\n    fn skip_whitespace(&mut self) {\n        while self.current_char().is_whitespace() {\n            self.current += 1;\n            if self.current >= self.src.char_len() {\n                return;\n            }\n        }\n    }\n\n    fn get_pipe(&mut self) -> Option<Token> {\n        if self.current_char() == '|' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Pipe)\n        } else {\n            None\n        }\n    }\n\n    fn get_ampersand(&mut self) -> Option<Token> {\n        if self.current_char() == '&' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Ampersand)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_to(&mut self) -> Option<Token> {\n        if self.current_char() == '>' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectTo)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_from(&mut self) -> Option<Token> {\n        if self.current_char() == '<' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectFrom)\n\n    fn get_str(&mut self) -> Option<Token> {\n        let mut i = self.current;\n        while !KEYWORDS.contains_char(self.src.char_at(i)) {\n            i += 1;\n        }\n        if i == self.current {\n            None\n        } else {\n            let result = Some(Token::Str(self.src.slice_chars(self.current, i).to_string()));\n            self.current = i;\n            self.skip_whitespace();\n            result\n        }\n    }\n}\n\n```\n\n`new`は新しいパーサーを生成するための関数です。`Parser`は文字列の所有権を要求していますが、入力された文字列はパースする以外に使い道は無いと思ったので大丈夫と判断しました。\n\n`current_char`は現在注目している文字を返します。\n`skip_whitespace`は空白文字を飛ばすように`self.current`をいじります。パーサーでは、基本的に 1 トークンを読み終えたら空白を飛ばして次のトークンになりうる文字の先頭までジャンプするべきなので、必ずトークンを読んだらこの関数を呼び出します。\n\nのこりの関数は、それぞれの`Token`を取得することを試みる関数です。  \n`Option<Token>`が帰ってくるので、`None`が帰ってきたら今みているトークンは別の種類のものであるといえます。\n\nこれらを用いて`Iterator`を実装しました。\n\n```rust\nimpl std::iter::Iterator<Token> for Parser {\n\n    fn next(&mut self) -> Option<Token> {\n        if self.current >= self.src.char_len() {\n            return None;\n        }\n        let mut result: Option<Token> = self.get_pipe();\n        if result.is_some() { return result; }\n        result = self.get_ampersand();\n        if result.is_some() { return result; }\n        result = self.get_redirect_to();\n        if result.is_some() { return result; }\n        result = self.get_redirect_from();\n        if result.is_some() { return result; }\n        result = self.get_str();\n        if result.is_some() { return result; }\n        None\n    }\n}\n```\n\nきれいじゃないコードですが、うまいやり方が他に思いつかなかったので...  \n純粋にある種類のトークンを取得しようと試みて`None`が帰ってきたら別の種類で試す、ということを繰り返しています。\n先頭で末尾まで読み込んだかを判定しています。\nすべての条件に当てはまらなくなったらパース失敗で`None`を返しています。\n\n## 試す\n\n```rust\nuse std::io;\nmod parse;\n\nfn main() {\n    loop {\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let mut parser = parse::Parser::new(input);\n        for token in parser {\n            println!(\"{}\", token);\n        }\n    }\n}\n```\n\n実行結果\n\n```\nls -a | grep foo\nStr(ls)\nStr(-a)\nPipe\nStr(grep)\nStr(foo)\nls -a| grep foo>result.txt &\nStr(ls)\nStr(-a)\nPipe\nStr(grep)\nStr(foo)\nRedirectTo\nStr(result.txt)\nAmpersand\n```\n\nこのような感じになりました。\n`Iterator`を実装しているので、`for .. in ..`が使えて気持ち良いです。\n\n## 反省点\n\nパースは失敗しうる計算だから`Option`かなーどうせ`Option`かえすなら`Iterator`実装しちゃえばお得かなーとおもって漠然と実装してみましたが、パースは失敗した理由がほしいことがほとんどなのでよく考えたら`Result`を使うべきだった気がしてきました。\n効率とかは正直 Rust での効率のよい書き方がよくわかっていないのであまり気にせず、とりあえず動くものを、と作ってみました。\nあとはパーサを書いたことが殆どなかったので成功法がわからなかったので、もっときれいな書き方があるんじゃないかという気も...\n\n## 今後\n\nとりあえず動くものを、コードをたくさん書こう、の精神で進めてみます。\n次は単純なコマンド実行を実装したいです。\nといっても Rust には`Command`とか`Process`とかがあって、ちょっと読んで見た感じ割りと素直に C 言語の`execvp`とかを呼び出しているようなので、それを使えばそこまで難しくはないのかな？\n\nソースの全文を掲載しますので、Rust 固有であってもそうでなくても、より良い書き方などありましたらご教授いただけると幸いです。よろしくお願いします。\n\n```rust:parse.rs\nuse std;\n\nstatic KEYWORDS: &'static str = \"|&<> \\n\";\n\n#[deriving(Show)]\npub enum Token {\n    Str(String),\n    Pipe,\n    RedirectTo,\n    RedirectFrom,\n    Ampersand,\n}\n\npub struct Parser {\n    src: String,\n    pub current: uint,\n}\n\nimpl Parser {\n\n    pub fn new(src: String) -> Parser {\n        Parser { src: src, current: 0 }\n    }\n\n    pub fn current_char(&self) -> char {\n        self.src.char_at(self.current)\n    }\n\n    fn skip_whitespace(&mut self) {\n        while self.current_char().is_whitespace() {\n            self.current += 1;\n            if self.current >= self.src.char_len() {\n                return;\n            }\n        }\n    }\n\n    fn get_pipe(&mut self) -> Option<Token> {\n        if self.current_char() == '|' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Pipe)\n        } else {\n            None\n        }\n    }\n\n    fn get_ampersand(&mut self) -> Option<Token> {\n        if self.current_char() == '&' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Ampersand)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_to(&mut self) -> Option<Token> {\n        if self.current_char() == '>' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectTo)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_from(&mut self) -> Option<Token> {\n        if self.current_char() == '<' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectFrom)\n        } else {\n            None\n        }\n    }\n\n    fn get_str(&mut self) -> Option<Token> {\n        let mut i = self.current;\n        while !KEYWORDS.contains_char(self.src.char_at(i)) {\n            i += 1;\n        }\n        if i == self.current {\n            None\n        } else {\n            let result = Some(Token::Str(self.src.slice_chars(self.current, i).to_string()));\n            self.current = i;\n            self.skip_whitespace();\n            result\n        }\n    }\n}\n\nimpl std::iter::Iterator<Token> for Parser {\n\n    fn next(&mut self) -> Option<Token> {\n        if self.current >= self.src.char_len() {\n            return None;\n        }\n        let mut result: Option<Token> = self.get_pipe();\n        if result.is_some() { return result; }\n        result = self.get_ampersand();\n        if result.is_some() { return result; }\n        result = self.get_redirect_to();\n        if result.is_some() { return result; }\n        result = self.get_redirect_from();\n        if result.is_some() { return result; }\n        result = self.get_str();\n        if result.is_some() { return result; }\n        None\n    }\n}\n```\n\n```rust:main.rs\nuse std::io;\nmod parse;\n\nfn main() {\n    loop {\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let mut parser = parse::Parser::new(input);\n        for token in parser {\n            println!(\"{}\", token);\n        }\n    }\n}\n```\n","slug":"Rustで自作シェルもどきを作る(字句解析編)","title":"Rustで自作シェルもどきを作る(字句解析編)","timestamp":1419092119000,"tags":["Rust"]}]},"__N_SSG":true}