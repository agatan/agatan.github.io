{"pageProps":{"tag":"Qiita","postMetas":[{"rawMarkdown":"---\ntitle: \"QiitaAPIを通じて複数のタグを持つ記事を検索する\"\ndate: 2014-10-13T18:11:43+09:00\ntags: [\"Qiita\", \"Ruby\"]\nurl: https://qiita.com/agatan/items/55dce1d2bc887de0cd71\n---\n\nRuby 初心者なのでなにかお気づきの点がありましたらご教授いただけると幸いです。\n\n## QiitaApiAccessor\n\nQiitaAPI との通信, 受信情報のハッシュ化を担当している。\n`@result_json`をローカル変数にしたいのだけど, `open`ブロック内のローカル変数になってしまうので出来ない...\n`get_with_tag`内のローカル変数にならできるけど結局`result_json = {}`として`open`内で更新みたいな書き方になってしまって綺麗じゃない...\n\n```ruby\nrequire 'open-uri'\nrequire 'json'\n\nclass QiitaApiAccessor\n\n  def initialize\n    @qiita_url = 'http://qiita.com/api/v2'\n    @result_json = {}\n  end\n\n  def get_with_tag(tag_name)\n    open(\"#{@qiita_url}/tags/#{tag_name}/items?page=1&per_page=100\") do |uri|\n      @result_json = JSON.parse(uri.read, symbolize_names: true)\n    end\n    @result_json\n  end\n\nend\n```\n\n## QiitaArticle\n\n一つの記事についての情報を保持する。\n`has_tag?`メソッドでは, 大文字小文字にかかわらず判定が出来るよう`upcase`を使用している。\n\n```rb\nclass QiitaArticle\n\n  def initialize (article_hash)\n    @data = article_hash\n    @title = article_hash[:title]\n    @url = \"http://qiita.com/api/v2/items/#{article_hash[:id]}\"\n    @tags = article_hash[:tags].map { |tag| tag[:name] }\n    @body = article_hash[:body]\n  end\n\n  attr_reader :title, :url, :tags, :body\n\n  def has_tag?(tag_name)\n    tags = @data[:tags]\n    tags.any?{ |tag_info| tag_info[:name].upcase == tag_name.upcase }\n  end\n\nend\n```\n\n## MultiTagsSearcher\n\nこれがメインのクラス。コンストラクタに`QiitaApiAccessor#get_with_tag`の戻り値と検索したいタグのリストを渡してやる。\n`group_by_relevance`によって含んでいる対象タグの数によってグループ化する。\n\n```rb\nclass MultiTagsSearcher\n\n  def initialize(articles_data, tags)\n    @articles = articles_data.map { |data| QiitaArticle.new(data) }\n    @tags = tags\n  end\n\n  attr_reader :articles\n\n  def group_by_relevance\n    @articles.group_by do |article|\n      @tags.count { |tag| article.has_tag?(tag) }\n    end\n  end\n\nend\n```\n\n## 使い方\n\n`QiitaApiAccessor#get_with_tag`にメインとなるキーワードタグを渡す。\nその戻り値と、キーワードタグを含む検索したいタグ名のリストを、`MultiTagsSearcher`に渡して`group_by_relevance`してやる。\nすると`含んでいる対象タグ数 => [QiitaArticleのインスタンス]`というハッシュが得られるので、適当に`QiitaArticle#url`とかで記事の url を取ってこられます。\n\n## 問題点・改善点\n\nQiitaAPI の都合上一度に 100 件までしか記事の情報を取得できないので, 本当はループで全件取得してから`MultiTagsSearcher`に渡したい。\nが、そうすると 5000 件とか普通に行く場合もあるから`QiitaArticle`のインスタンスが無駄に大量生成されてしまうし、時間もかかる。\nなので、検索の際のキーワードタグには記事数の少なそうなものを選ぶことでお茶を濁す...\n`ruby`ではなく`sinatra`をキーワードにするだけで結果がかなり違ってくる。\nけどそれじゃ根本的な解決になってない。なにか良い方法ありましたら教えて下さい。\n","contentMarkdown":"\nRuby 初心者なのでなにかお気づきの点がありましたらご教授いただけると幸いです。\n\n## QiitaApiAccessor\n\nQiitaAPI との通信, 受信情報のハッシュ化を担当している。\n`@result_json`をローカル変数にしたいのだけど, `open`ブロック内のローカル変数になってしまうので出来ない...\n`get_with_tag`内のローカル変数にならできるけど結局`result_json = {}`として`open`内で更新みたいな書き方になってしまって綺麗じゃない...\n\n```ruby\nrequire 'open-uri'\nrequire 'json'\n\nclass QiitaApiAccessor\n\n  def initialize\n    @qiita_url = 'http://qiita.com/api/v2'\n    @result_json = {}\n  end\n\n  def get_with_tag(tag_name)\n    open(\"#{@qiita_url}/tags/#{tag_name}/items?page=1&per_page=100\") do |uri|\n      @result_json = JSON.parse(uri.read, symbolize_names: true)\n    end\n    @result_json\n  end\n\nend\n```\n\n## QiitaArticle\n\n一つの記事についての情報を保持する。\n`has_tag?`メソッドでは, 大文字小文字にかかわらず判定が出来るよう`upcase`を使用している。\n\n```rb\nclass QiitaArticle\n\n  def initialize (article_hash)\n    @data = article_hash\n    @title = article_hash[:title]\n    @url = \"http://qiita.com/api/v2/items/#{article_hash[:id]}\"\n    @tags = article_hash[:tags].map { |tag| tag[:name] }\n    @body = article_hash[:body]\n  end\n\n  attr_reader :title, :url, :tags, :body\n\n  def has_tag?(tag_name)\n    tags = @data[:tags]\n    tags.any?{ |tag_info| tag_info[:name].upcase == tag_name.upcase }\n  end\n\nend\n```\n\n## MultiTagsSearcher\n\nこれがメインのクラス。コンストラクタに`QiitaApiAccessor#get_with_tag`の戻り値と検索したいタグのリストを渡してやる。\n`group_by_relevance`によって含んでいる対象タグの数によってグループ化する。\n\n```rb\nclass MultiTagsSearcher\n\n  def initialize(articles_data, tags)\n    @articles = articles_data.map { |data| QiitaArticle.new(data) }\n    @tags = tags\n  end\n\n  attr_reader :articles\n\n  def group_by_relevance\n    @articles.group_by do |article|\n      @tags.count { |tag| article.has_tag?(tag) }\n    end\n  end\n\nend\n```\n\n## 使い方\n\n`QiitaApiAccessor#get_with_tag`にメインとなるキーワードタグを渡す。\nその戻り値と、キーワードタグを含む検索したいタグ名のリストを、`MultiTagsSearcher`に渡して`group_by_relevance`してやる。\nすると`含んでいる対象タグ数 => [QiitaArticleのインスタンス]`というハッシュが得られるので、適当に`QiitaArticle#url`とかで記事の url を取ってこられます。\n\n## 問題点・改善点\n\nQiitaAPI の都合上一度に 100 件までしか記事の情報を取得できないので, 本当はループで全件取得してから`MultiTagsSearcher`に渡したい。\nが、そうすると 5000 件とか普通に行く場合もあるから`QiitaArticle`のインスタンスが無駄に大量生成されてしまうし、時間もかかる。\nなので、検索の際のキーワードタグには記事数の少なそうなものを選ぶことでお茶を濁す...\n`ruby`ではなく`sinatra`をキーワードにするだけで結果がかなり違ってくる。\nけどそれじゃ根本的な解決になってない。なにか良い方法ありましたら教えて下さい。\n","slug":"QiitaAPIを通じて複数のタグを持つ記事を検索する","title":"QiitaAPIを通じて複数のタグを持つ記事を検索する","timestamp":1413191503000,"tags":["Qiita","Ruby"]}]},"__N_SSG":true}