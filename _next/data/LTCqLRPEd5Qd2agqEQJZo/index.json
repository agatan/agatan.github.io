{"pageProps":{"postMetas":[{"rawMarkdown":"---\ntitle: pgjdbc の SQLException.getErrorCode() は常に 0 を返す\ndate: 2021-06-23\ntags:\n  - Java\n  - Kotlin\n---\n\n最近になって仕事で初めて JVM 上で動く言語を書いています。\nそこでちょっとハマったことがあり、色々調べて解決したのでメモがてら共有しようと思い、記事にすることにしました。\nもっと遭遇している人多そうなんですが、パッとググった限り日本語でこの問題について言及している記事が見当たらなかったので、有用だと信じています。（経験ある JDBC ユーザにとっては当たり前なんですかね？）\n\n## TL;DR\n\nhttps://github.com/pgjdbc/pgjdbc を使っていると、 `java.sql.SQLException.getErrorCode()` が常に 0 になる。\n代わりに `java.sql.SQLException.getSQLState()` を使おう。\n\n## 問題\n\nUNIQUE 制約をはったテーブルに対して「レコードがすでにあればそれを SELECT する。なければ新規に作る。」という操作をしたいことがあります。\nそういったときに、文字通り「1. まず SELECT し、 2. なかったら INSERT」というふうに実装してしまうと、同時に二つ以上のリクエストが処理されると想定通りの挙動になりません。（1. と 2. の間に別のリクエストによって 2. が実行されるかもしれない。）\nそこで、こういったケースでは「1. まず INSERT を試み、 2. UNIQUE 制約に引っ掛かったら SELECT」というふうに実装するのが正しいです。（Rails 的にいうと `find_or_create_by` ではなく、 `create_or_find_by` しよう、という話です。）\n\n```kotlin\nval record = try {\n    Users.insertAndGet(...)\n} catch (ex: SQLException) {\n    if ( /* ex が UNIQUE VIOLATION である */ ) {\n\t    Users.select(...)\n\t} else {\n\t    throw ex\n\t}\n}\n```\n\nこんな感じです。（疑似コードですが）\n\nさて、ここで `/* ex が UNIQUE VIOLATION である */` ことの確認をする方法が必要です。\n[`java.sql.SQLException` のドキュメント](https://docs.oracle.com/en/java/javase/13/docs/api/java.sql/java/sql/SQLException.html) を見てみると、`int getErrorCode()` という API があるので、これを使ってみます。vendor-specific exception code が取得できる、と説明があります。\n[PostgreSQL のエラーコード一覧](https://www.postgresql.org/docs/13/errcodes-appendix.html) によると、23505 が `unique_violation` らしいので、以下のようなコードで判定できるように見えます。\n\n```kotlin\nconst val UNIQUE_VIOLATION = 23505\nif (ex.errorCode == UNIQUE_VIOLATION) {\n    ...\n}\n```\n\n## 動かない！\n\nこれでテスト書いてうまく動くことを確かめよう〜と思ったら、なぜか全然テストが通らない！\nしかも `SQLException` が投げられていて、その内容が完全に UNIQUE 制約に引っ掛かっているというエラーでした。\n何事...\n\nデバッガで追ってみると、 `ex.errorCode == UNIQUE_VIOLATION` が false になっているようです。エラーは確かに `unique_violation` だというのに。\n\nさらにデバッガでよく見てみると、なんと `ex.errorCode` が 0 になっています。\n何事...\n\n## pgjdbc は getErrorCode に対応していなかった\n\n[PSQLException の実装](https://github.com/pgjdbc/pgjdbc/blob/master/pgjdbc/src/main/java/org/postgresql/util/PSQLException.java) をよく見てみると、そもそも `getErrorCode` の定義がありません。どうやら常にデフォルトの 0 を返すようです。\n\nhttps://github.com/pgjdbc/pgjdbc/pull/623 で対応が試みられていますが Close されています。\nPostgreSQL のエラーコードはアルファベットを含むものもあり、全てを統一的に `getErrorCode` で返すことができないというのが理由でした。\n言われてみれば当たり前だし、確かによくみると [PostgreSQL のエラーコード一覧](https://www.postgresql.org/docs/13/errcodes-appendix.html) にはちらほらアルファベットがありますね...\n\n## 対応\n\n`String SQLException.getSQLState()` を使います。\nさらに [PSQLState](https://github.com/pgjdbc/pgjdbc/blob/master/pgjdbc/src/main/java/org/postgresql/util/PSQLState.java) という enum が定義されているので、これを併用して\n\n```kotlin\nif (ex.sqlState == PSQLState.UNIQUE\\_VIOLATION.state) {\n    ...\n}\n```\n\nとすれば期待通りの挙動になります。\n\n## まとめ\n\nしかしこの挙動、もうちょっとドキュメントとかに書いてくれていてもいいんじゃないかなぁと思ったんですがどうなんでしょう。\n`PSQLException` のドキュメントを見ても何も書いていないんですよね。\nPostgreSQL のドキュメントをちゃんと見れば Error Code が int で表現しきれないことは自明だ、と言われればそれはそうなんですが。\n\npgjdbc の話からは逸れますが、こういう「統一インターフェースを標準で提供するから内部実装は各自ライブラリでやって差し替える」系のライブラリ、統一インターフェースの方のドキュメントばかり読んでしまって個々のライブラリのドキュメントをあまり読まなくても使えてしまうので、こういう罠があるとハマりますね。よくできているということでもあると思います。\n（まぁ今回は個々のライブラリのドキュメントを見ても何も書いていないと思うのですが...）\n\npgjdbc には別の問題でもハマっていて、そっちは PR 出して無事マージ & リリースされたので、いつかその問題についても書いてみようと思います。\n","contentMarkdown":"\n最近になって仕事で初めて JVM 上で動く言語を書いています。\nそこでちょっとハマったことがあり、色々調べて解決したのでメモがてら共有しようと思い、記事にすることにしました。\nもっと遭遇している人多そうなんですが、パッとググった限り日本語でこの問題について言及している記事が見当たらなかったので、有用だと信じています。（経験ある JDBC ユーザにとっては当たり前なんですかね？）\n\n## TL;DR\n\nhttps://github.com/pgjdbc/pgjdbc を使っていると、 `java.sql.SQLException.getErrorCode()` が常に 0 になる。\n代わりに `java.sql.SQLException.getSQLState()` を使おう。\n\n## 問題\n\nUNIQUE 制約をはったテーブルに対して「レコードがすでにあればそれを SELECT する。なければ新規に作る。」という操作をしたいことがあります。\nそういったときに、文字通り「1. まず SELECT し、 2. なかったら INSERT」というふうに実装してしまうと、同時に二つ以上のリクエストが処理されると想定通りの挙動になりません。（1. と 2. の間に別のリクエストによって 2. が実行されるかもしれない。）\nそこで、こういったケースでは「1. まず INSERT を試み、 2. UNIQUE 制約に引っ掛かったら SELECT」というふうに実装するのが正しいです。（Rails 的にいうと `find_or_create_by` ではなく、 `create_or_find_by` しよう、という話です。）\n\n```kotlin\nval record = try {\n    Users.insertAndGet(...)\n} catch (ex: SQLException) {\n    if ( /* ex が UNIQUE VIOLATION である */ ) {\n\t    Users.select(...)\n\t} else {\n\t    throw ex\n\t}\n}\n```\n\nこんな感じです。（疑似コードですが）\n\nさて、ここで `/* ex が UNIQUE VIOLATION である */` ことの確認をする方法が必要です。\n[`java.sql.SQLException` のドキュメント](https://docs.oracle.com/en/java/javase/13/docs/api/java.sql/java/sql/SQLException.html) を見てみると、`int getErrorCode()` という API があるので、これを使ってみます。vendor-specific exception code が取得できる、と説明があります。\n[PostgreSQL のエラーコード一覧](https://www.postgresql.org/docs/13/errcodes-appendix.html) によると、23505 が `unique_violation` らしいので、以下のようなコードで判定できるように見えます。\n\n```kotlin\nconst val UNIQUE_VIOLATION = 23505\nif (ex.errorCode == UNIQUE_VIOLATION) {\n    ...\n}\n```\n\n## 動かない！\n\nこれでテスト書いてうまく動くことを確かめよう〜と思ったら、なぜか全然テストが通らない！\nしかも `SQLException` が投げられていて、その内容が完全に UNIQUE 制約に引っ掛かっているというエラーでした。\n何事...\n\nデバッガで追ってみると、 `ex.errorCode == UNIQUE_VIOLATION` が false になっているようです。エラーは確かに `unique_violation` だというのに。\n\nさらにデバッガでよく見てみると、なんと `ex.errorCode` が 0 になっています。\n何事...\n\n## pgjdbc は getErrorCode に対応していなかった\n\n[PSQLException の実装](https://github.com/pgjdbc/pgjdbc/blob/master/pgjdbc/src/main/java/org/postgresql/util/PSQLException.java) をよく見てみると、そもそも `getErrorCode` の定義がありません。どうやら常にデフォルトの 0 を返すようです。\n\nhttps://github.com/pgjdbc/pgjdbc/pull/623 で対応が試みられていますが Close されています。\nPostgreSQL のエラーコードはアルファベットを含むものもあり、全てを統一的に `getErrorCode` で返すことができないというのが理由でした。\n言われてみれば当たり前だし、確かによくみると [PostgreSQL のエラーコード一覧](https://www.postgresql.org/docs/13/errcodes-appendix.html) にはちらほらアルファベットがありますね...\n\n## 対応\n\n`String SQLException.getSQLState()` を使います。\nさらに [PSQLState](https://github.com/pgjdbc/pgjdbc/blob/master/pgjdbc/src/main/java/org/postgresql/util/PSQLState.java) という enum が定義されているので、これを併用して\n\n```kotlin\nif (ex.sqlState == PSQLState.UNIQUE\\_VIOLATION.state) {\n    ...\n}\n```\n\nとすれば期待通りの挙動になります。\n\n## まとめ\n\nしかしこの挙動、もうちょっとドキュメントとかに書いてくれていてもいいんじゃないかなぁと思ったんですがどうなんでしょう。\n`PSQLException` のドキュメントを見ても何も書いていないんですよね。\nPostgreSQL のドキュメントをちゃんと見れば Error Code が int で表現しきれないことは自明だ、と言われればそれはそうなんですが。\n\npgjdbc の話からは逸れますが、こういう「統一インターフェースを標準で提供するから内部実装は各自ライブラリでやって差し替える」系のライブラリ、統一インターフェースの方のドキュメントばかり読んでしまって個々のライブラリのドキュメントをあまり読まなくても使えてしまうので、こういう罠があるとハマりますね。よくできているということでもあると思います。\n（まぁ今回は個々のライブラリのドキュメントを見ても何も書いていないと思うのですが...）\n\npgjdbc には別の問題でもハマっていて、そっちは PR 出して無事マージ & リリースされたので、いつかその問題についても書いてみようと思います。\n","slug":"pgjdbc-error-code","title":"pgjdbc の SQLException.getErrorCode() は常に 0 を返す","timestamp":1624406400000,"tags":["Java","Kotlin"]},{"rawMarkdown":"---\ntitle: \"atmaCup #5 に参加してきて Private 29 位（Public 27 位）でした！\"\ndate: 2020-06-07T11:00:00.000Z\ntags: []\n---\n\n<p>atmaCup #5 に参加してきました！\n<iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fatma.connpass.com%2Fevent%2F175139%2F\" title=\"【おうちで】atmaCup オンサイトデータコンペ#5 (2020/05/29 18:00〜)\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://atma.connpass.com/event/175139/\">atma.connpass.com</a></cite></p>\n\n<p>Kaggle 以外のコンペに参加したのは初めてだったのですが、お祭り感があってとても楽しかったです！\n参加者・運営全体で盛り上げていく雰囲気があったので、初参加でしたが最後までモチベーション高く取り組み続けることができました。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Twitter\">Twitter</a> TL でよく見かける方々と競えるので燃えました。</p>\n\n<p>運営のみなさま、本当にありがとうございました！ぜひまた参加したいです！</p>\n\n<h3>問題設定</h3>\n\n<p>2 値分類タスクで、評価指標は PR-AUC でした。\n正例が少なく、指標も PR-AUC だったので、CV / LB が安定しなかったのが悩ましいところでした。</p>\n\n<h3>コンペ中の動き</h3>\n\n<p>1 週間の開催で短期決戦だったので、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C9%A5%E1%A5%A4%A5%F3\">ドメイン</a>知識の獲得から始める余裕はないと判断して、CNN 様に抽出していただく戦略を取りました。（結果的にそこそこ NN チューニングに時間を使ったので、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C9%A5%E1%A5%A4%A5%F3\">ドメイン</a>知識をちゃんと学びに行けばよかったとやや後悔しています）\nまた、短期決戦前提の書き殴り実験をしまくってしまったので、自分が何をやっていたのか正確な記録が無く終盤若干混乱しました。1 週間だったのでギリギリなんとかなりましたが、Kaggle みたいな長期戦は厳しそうなので、そっちに挑む際はもうちょっと丁寧に生きた方が良さそう。仮に入賞したとしても再現できるようにするコストがものすごく高い実装になってしまっていました...</p>\n\n<p>実験管理を mlflow でやったのですが、結構よかったです。\n最終日はローカルを投げ捨てて <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GPU\">GPU</a> 使い始めたので、今までローカルに積み上げてきた実験との比較が若干厄介でした。（統合せず、別の <code>mlflow ui</code> をタブで開いて眺めていました...）\nただ、CV 戦略を変えたり評価指標をいじったときに、同条件で単純比較できない実験にもかかわらずそれが同じテーブルに並んでしまうのが悩ましいなと思いました。\n時系列で並んでいるうちは良いのですが、指標ごとにソートすると本当にどれが信じられる結果なのかわかり辛くなってしまいました。\nこのあたりはタグなどを活用すると良いのかもしれない？もしくは CV などの設計が変わった時点できちんと experiment のレベルで分離すべきだった気がします。</p>\n\n<p>また、実は事前にちょこっとだけ準備していて、「学習データ、テストデータ、CV、モデル、評価関数」あたりを渡すと mlflow にログを書きつつ CV 評価して oof と test の prediction をはく薄い wrapper を書いていました。\n最初はまぁ使えていたんですが、NN のことを全く想定していなかったので NN に移った時点で全く使えなくなってしまったのと、細かいことをやりだすとやっぱり wrap された内部に手を入れたくなってしまって厳しかったです。\n予想はしていたので相当薄めに作ったつもりだったのですが、それでもこうなっちゃうか〜という感じでちょっと辛い。\nライブラリとしての作りにしたのが間違いだったのかもと思っています。ライブラリだと内部にコンペ固有の変更を入れるのは厳しいので。\n単なる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%CB%A5%DA%A5%C3%A5%C8\">スニペット</a>集にしておいて、コンペ中はゴリゴリ内部も書き換える前提で使った方が良さそう。</p>\n\n<h3>やったこと</h3>\n\n<p>以下は Discussion にも投稿した内容とほぼ同じですが、こちらにも書いておきます。</p>\n\n<p><a href=\"https://guruguru.ml/competitions/10/discussions/34d99be1-ab52-4868-a46c-45a24fac8308/\">&#x3050;&#x308B;&#x3050;&#x308B;</a></p>\n\n<p>中盤まで CV スコアすら安定せず、ちょっとシードを変えるだけで大きくスコアが変動してしまっていました。\nそのため、正直何が効いていて何が効かなかったのかの判断を誤っていた可能性が高いです...</p>\n\n<p>何をやっても安定しなかったので、最終盤にやけになってアンサンブルで誤魔化す作戦に出たのですが、これは結果的によかったと思います。\n特に、CV がある程度安定して比較可能になったおかげで、打つべき手の選択を見誤り辛くなったのが大きかったです。\n逆にいえばもっと早くこれをやっておけば、もう少し良いモデルを作れたかも？と反省しています。次回に活かしたいです。</p>\n\n<p>最終サブは CNN と、それをベースに stacking した LightGBM の 2 つを出していました。</p>\n\n<h4>CNN</h4>\n\n<ul>\n<li>正規化 / Scaling を全くせずナイーブに Conv1D ベースの NN に突っ込む\n\n<ul>\n<li><code>((Skip Connection + Conv1D (kernel_size=5) → BatchNorm (or GroupNorm) → ReLU) * 2 → AveragePooling1D (pool_size=2, strides=2)) * 3 → GlobalAveragePooling と GlobalMaxPooling の concat</code></li>\n</ul>\n</li>\n<li>テーブル特徴量は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/MLP\">MLP</a> を通して CNN の出力に Concatenate した\n\n<ul>\n<li>採用した特徴量は beta, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/rms\">rms</a>, params1 ~ 6, tsfresh の特徴量たちの中から LightGBM での feature importance が上位 100 以内だったものを取ってきただけ</li>\n</ul>\n</li>\n<li>テーブル特徴量を <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/MLP\">MLP</a> に通したものを CNN の途中でに足したらなぜかスコアが上がったので採用\n\n<ul>\n<li>本当はテーブル特徴量を使って、どの領域に注目するかの Attention の計算をしようと思っていたが、そちらはスコアが上がらず...</li>\n<li>悔しいので惰性で試した加算がなぜか効いた</li>\n</ul>\n</li>\n<li>始めは BN を使っていたが安定しなかった。極端に大きい入力が入ってきたときに BN の statistics がぶっ飛ぶのが悪いのでは、とあたりをつけて GN に変更したところ、伸びはしなかったが安定性が増したように見えたので採用。</li>\n<li>Optimizer は AdamW を使っていたが安定しなかったので、SWA / Lookahead を試したところどちらも安定性の向上を確認できた。最終性能はほぼ変わらなかったが、Lookahead の方が収束が速かったのと個人的に好きだったので採用。\n\n<ul>\n<li>Lookahead 採用後は BN でも安定したので、最終的には BN / GN 両方のモデルを作って rank average した。</li>\n<li>&amp; CosineDecay with linear warmup</li>\n<li>val prauc で early stopping</li>\n</ul>\n</li>\n<li>学習中に checkpoint をとっておき、val loss がよかった 5 epoch 分のモデルの出力の平均を使用</li>\n<li>class weight つき binary crossentropy loss\n\n<ul>\n<li>class imbalance については <a href=\"https://www.tensorflow.org/tutorials/structured_data/imbalanced_data#train_on_the_oversampled_data\">https://www.tensorflow.org/tutorials/structured_data/imbalanced_data#train_on_the_oversampled_data</a> をベースに戦略を立てていました</li>\n<li>いくつか試しましたが、結局シンプルな class weight が一番よかったです</li>\n</ul>\n</li>\n<li>CV 戦略は StratifiedKFold(k=5)\n\n<ul>\n<li>タスク的には StratifiedKFold じゃまずそうと思いつつも、Group, StratifiedGroup は CV / LB の相関が取れなかったのと、seed を変えた時の暴れ方がすごくて断念</li>\n</ul>\n</li>\n</ul>\n\n<h4>LightGBM</h4>\n\n<p>こちらは最終日にもう何も思い付かず、とはいえサブを余らせて終わるのも悔しかったので、やってみるかぁという惰性で挑戦したものでした。\nCV は Stacking した LightGBM の方がかなり高かったので興奮したのですが、流石に怖かったので CNN も提出していました。\n結論としてはどちらも  Public / Private 共にほぼ差はなかったです。</p>\n\n<p>時間がなかったのであまり検証はできず、勘で良さそうな構成を選ぶしかなかったのですが、最終的に採用したのは以下のような構成です。</p>\n\n<ul>\n<li>CNN (BN, GN) の出力を rank にしたもの + テーブル特徴量全部盛り</li>\n<li>optuna の LightGBMCVTuner でハイパラ選択</li>\n<li>2 Seed Average (Rank Average)</li>\n<li>imbalance 対策は undersampling + bagging\n\n<ul>\n<li>1 : 10 になるように undersampling したデータで普通に 20 モデル作り、単純に平均をとった</li>\n<li>1:1 にしたり <code>is_unbalance=True</code> にしたりいくつか実験しましたが、これがもっとも CV が高かったです</li>\n</ul>\n</li>\n</ul>\n\n<h3>うまくいかなかったこと</h3>\n\n<ul>\n<li>Attention\n\n<ul>\n<li>Transformer ベースのモデルと、Conv ベースモデルに MultiHeadAttention を足したものの両方を試しましたが、どちらも work せず</li>\n</ul>\n</li>\n<li>Squeeze and Excitation</li>\n<li>SeparableConv1D にして層を増やす</li>\n<li>Kernel Size を増やす</li>\n<li>NN で Undersampling + Bagging</li>\n<li>生データの scaling\n\n<ul>\n<li>Standardize や 99.9%ile で clip した方が学習は安定したが、スコアがものすごく下がった...</li>\n</ul>\n</li>\n<li>(Denoising) Variational Auto Encoder\n\n<ul>\n<li>train/test で chip が違うことがわかっていたので、教師なし事前学習 → <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/finetune\">finetune</a> したら LB 上がるのでは、という目論見</li>\n<li>Reconstruction Error と Encoder の出力 64 次元ベクトルを LightGBM に食わせるのも試したが work せず</li>\n</ul>\n</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C8%F9%CA%AC\">微分</a>して入力チャネルに追加して CNN に通す</li>\n</ul>\n\n---\n\n---\n","contentMarkdown":"\n<p>atmaCup #5 に参加してきました！\n<iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fatma.connpass.com%2Fevent%2F175139%2F\" title=\"【おうちで】atmaCup オンサイトデータコンペ#5 (2020/05/29 18:00〜)\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://atma.connpass.com/event/175139/\">atma.connpass.com</a></cite></p>\n\n<p>Kaggle 以外のコンペに参加したのは初めてだったのですが、お祭り感があってとても楽しかったです！\n参加者・運営全体で盛り上げていく雰囲気があったので、初参加でしたが最後までモチベーション高く取り組み続けることができました。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Twitter\">Twitter</a> TL でよく見かける方々と競えるので燃えました。</p>\n\n<p>運営のみなさま、本当にありがとうございました！ぜひまた参加したいです！</p>\n\n<h3>問題設定</h3>\n\n<p>2 値分類タスクで、評価指標は PR-AUC でした。\n正例が少なく、指標も PR-AUC だったので、CV / LB が安定しなかったのが悩ましいところでした。</p>\n\n<h3>コンペ中の動き</h3>\n\n<p>1 週間の開催で短期決戦だったので、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C9%A5%E1%A5%A4%A5%F3\">ドメイン</a>知識の獲得から始める余裕はないと判断して、CNN 様に抽出していただく戦略を取りました。（結果的にそこそこ NN チューニングに時間を使ったので、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C9%A5%E1%A5%A4%A5%F3\">ドメイン</a>知識をちゃんと学びに行けばよかったとやや後悔しています）\nまた、短期決戦前提の書き殴り実験をしまくってしまったので、自分が何をやっていたのか正確な記録が無く終盤若干混乱しました。1 週間だったのでギリギリなんとかなりましたが、Kaggle みたいな長期戦は厳しそうなので、そっちに挑む際はもうちょっと丁寧に生きた方が良さそう。仮に入賞したとしても再現できるようにするコストがものすごく高い実装になってしまっていました...</p>\n\n<p>実験管理を mlflow でやったのですが、結構よかったです。\n最終日はローカルを投げ捨てて <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GPU\">GPU</a> 使い始めたので、今までローカルに積み上げてきた実験との比較が若干厄介でした。（統合せず、別の <code>mlflow ui</code> をタブで開いて眺めていました...）\nただ、CV 戦略を変えたり評価指標をいじったときに、同条件で単純比較できない実験にもかかわらずそれが同じテーブルに並んでしまうのが悩ましいなと思いました。\n時系列で並んでいるうちは良いのですが、指標ごとにソートすると本当にどれが信じられる結果なのかわかり辛くなってしまいました。\nこのあたりはタグなどを活用すると良いのかもしれない？もしくは CV などの設計が変わった時点できちんと experiment のレベルで分離すべきだった気がします。</p>\n\n<p>また、実は事前にちょこっとだけ準備していて、「学習データ、テストデータ、CV、モデル、評価関数」あたりを渡すと mlflow にログを書きつつ CV 評価して oof と test の prediction をはく薄い wrapper を書いていました。\n最初はまぁ使えていたんですが、NN のことを全く想定していなかったので NN に移った時点で全く使えなくなってしまったのと、細かいことをやりだすとやっぱり wrap された内部に手を入れたくなってしまって厳しかったです。\n予想はしていたので相当薄めに作ったつもりだったのですが、それでもこうなっちゃうか〜という感じでちょっと辛い。\nライブラリとしての作りにしたのが間違いだったのかもと思っています。ライブラリだと内部にコンペ固有の変更を入れるのは厳しいので。\n単なる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%CB%A5%DA%A5%C3%A5%C8\">スニペット</a>集にしておいて、コンペ中はゴリゴリ内部も書き換える前提で使った方が良さそう。</p>\n\n<h3>やったこと</h3>\n\n<p>以下は Discussion にも投稿した内容とほぼ同じですが、こちらにも書いておきます。</p>\n\n<p><a href=\"https://guruguru.ml/competitions/10/discussions/34d99be1-ab52-4868-a46c-45a24fac8308/\">&#x3050;&#x308B;&#x3050;&#x308B;</a></p>\n\n<p>中盤まで CV スコアすら安定せず、ちょっとシードを変えるだけで大きくスコアが変動してしまっていました。\nそのため、正直何が効いていて何が効かなかったのかの判断を誤っていた可能性が高いです...</p>\n\n<p>何をやっても安定しなかったので、最終盤にやけになってアンサンブルで誤魔化す作戦に出たのですが、これは結果的によかったと思います。\n特に、CV がある程度安定して比較可能になったおかげで、打つべき手の選択を見誤り辛くなったのが大きかったです。\n逆にいえばもっと早くこれをやっておけば、もう少し良いモデルを作れたかも？と反省しています。次回に活かしたいです。</p>\n\n<p>最終サブは CNN と、それをベースに stacking した LightGBM の 2 つを出していました。</p>\n\n<h4>CNN</h4>\n\n<ul>\n<li>正規化 / Scaling を全くせずナイーブに Conv1D ベースの NN に突っ込む\n\n<ul>\n<li><code>((Skip Connection + Conv1D (kernel_size=5) → BatchNorm (or GroupNorm) → ReLU) * 2 → AveragePooling1D (pool_size=2, strides=2)) * 3 → GlobalAveragePooling と GlobalMaxPooling の concat</code></li>\n</ul>\n</li>\n<li>テーブル特徴量は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/MLP\">MLP</a> を通して CNN の出力に Concatenate した\n\n<ul>\n<li>採用した特徴量は beta, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/rms\">rms</a>, params1 ~ 6, tsfresh の特徴量たちの中から LightGBM での feature importance が上位 100 以内だったものを取ってきただけ</li>\n</ul>\n</li>\n<li>テーブル特徴量を <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/MLP\">MLP</a> に通したものを CNN の途中でに足したらなぜかスコアが上がったので採用\n\n<ul>\n<li>本当はテーブル特徴量を使って、どの領域に注目するかの Attention の計算をしようと思っていたが、そちらはスコアが上がらず...</li>\n<li>悔しいので惰性で試した加算がなぜか効いた</li>\n</ul>\n</li>\n<li>始めは BN を使っていたが安定しなかった。極端に大きい入力が入ってきたときに BN の statistics がぶっ飛ぶのが悪いのでは、とあたりをつけて GN に変更したところ、伸びはしなかったが安定性が増したように見えたので採用。</li>\n<li>Optimizer は AdamW を使っていたが安定しなかったので、SWA / Lookahead を試したところどちらも安定性の向上を確認できた。最終性能はほぼ変わらなかったが、Lookahead の方が収束が速かったのと個人的に好きだったので採用。\n\n<ul>\n<li>Lookahead 採用後は BN でも安定したので、最終的には BN / GN 両方のモデルを作って rank average した。</li>\n<li>&amp; CosineDecay with linear warmup</li>\n<li>val prauc で early stopping</li>\n</ul>\n</li>\n<li>学習中に checkpoint をとっておき、val loss がよかった 5 epoch 分のモデルの出力の平均を使用</li>\n<li>class weight つき binary crossentropy loss\n\n<ul>\n<li>class imbalance については <a href=\"https://www.tensorflow.org/tutorials/structured_data/imbalanced_data#train_on_the_oversampled_data\">https://www.tensorflow.org/tutorials/structured_data/imbalanced_data#train_on_the_oversampled_data</a> をベースに戦略を立てていました</li>\n<li>いくつか試しましたが、結局シンプルな class weight が一番よかったです</li>\n</ul>\n</li>\n<li>CV 戦略は StratifiedKFold(k=5)\n\n<ul>\n<li>タスク的には StratifiedKFold じゃまずそうと思いつつも、Group, StratifiedGroup は CV / LB の相関が取れなかったのと、seed を変えた時の暴れ方がすごくて断念</li>\n</ul>\n</li>\n</ul>\n\n<h4>LightGBM</h4>\n\n<p>こちらは最終日にもう何も思い付かず、とはいえサブを余らせて終わるのも悔しかったので、やってみるかぁという惰性で挑戦したものでした。\nCV は Stacking した LightGBM の方がかなり高かったので興奮したのですが、流石に怖かったので CNN も提出していました。\n結論としてはどちらも  Public / Private 共にほぼ差はなかったです。</p>\n\n<p>時間がなかったのであまり検証はできず、勘で良さそうな構成を選ぶしかなかったのですが、最終的に採用したのは以下のような構成です。</p>\n\n<ul>\n<li>CNN (BN, GN) の出力を rank にしたもの + テーブル特徴量全部盛り</li>\n<li>optuna の LightGBMCVTuner でハイパラ選択</li>\n<li>2 Seed Average (Rank Average)</li>\n<li>imbalance 対策は undersampling + bagging\n\n<ul>\n<li>1 : 10 になるように undersampling したデータで普通に 20 モデル作り、単純に平均をとった</li>\n<li>1:1 にしたり <code>is_unbalance=True</code> にしたりいくつか実験しましたが、これがもっとも CV が高かったです</li>\n</ul>\n</li>\n</ul>\n\n<h3>うまくいかなかったこと</h3>\n\n<ul>\n<li>Attention\n\n<ul>\n<li>Transformer ベースのモデルと、Conv ベースモデルに MultiHeadAttention を足したものの両方を試しましたが、どちらも work せず</li>\n</ul>\n</li>\n<li>Squeeze and Excitation</li>\n<li>SeparableConv1D にして層を増やす</li>\n<li>Kernel Size を増やす</li>\n<li>NN で Undersampling + Bagging</li>\n<li>生データの scaling\n\n<ul>\n<li>Standardize や 99.9%ile で clip した方が学習は安定したが、スコアがものすごく下がった...</li>\n</ul>\n</li>\n<li>(Denoising) Variational Auto Encoder\n\n<ul>\n<li>train/test で chip が違うことがわかっていたので、教師なし事前学習 → <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/finetune\">finetune</a> したら LB 上がるのでは、という目論見</li>\n<li>Reconstruction Error と Encoder の出力 64 次元ベクトルを LightGBM に食わせるのも試したが work せず</li>\n</ul>\n</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C8%F9%CA%AC\">微分</a>して入力チャネルに追加して CNN に通す</li>\n</ul>\n\n---\n\n---\n","slug":"atmacup5th","title":"atmaCup #5 に参加してきて Private 29 位（Public 27 位）でした！","timestamp":1591527600000,"tags":[]},{"rawMarkdown":"---\ntitle: \"【論文読み】 Multi-Oriented Scene Text Detection via Corner Localization and Region Segmentation\"\ndate: 2019-02-13T00:12:22+09:00\ntags: [\"画像処理\", \"DeepLearning\", \"OCR\", \"論文読み\"]\nurl: https://qiita.com/agatan/items/afbdb922688984283775\n---\n\n画像中の文字領域検出における 2 つの主流な手法のいいとこ取りを目指した論文、 Multi-Oriented Scene Text Detection via Corner Localization and Region Segmentation を読んでみました。\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Reference\n\n- Multi-Oriented Scene Text Detection via Corner Localization and Region Segmentation [Pengyuan Lyu, Cong Yao, Wenhao Wu, Shuicheng Yan, Xiang Bai. CVPR 2018]\n- https://arxiv.org/abs/1802.08948\n\n（文中の図表は論文より引用しています）\n\n## Scene Text Detection\n\nScene Text Detection は、風景写真のなかにある文字領域（かんばん、ポスターなど）を検出するタスクです。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/a78b72da-8550-641f-819b-ed024d9be7fa.png)\n(Figure 6.)\n\nCNN を活用した研究が進んでおり、現在では 2 つのアプローチが主流となっています。（このあたりは [【論文読み】Semi-convolutional Operators for Instance Segmentation](https://qiita.com/agatan/items/2cf1209b7370db45eba5) や [[論文紹介] Focal Loss for Dense Object Detection](https://qiita.com/agatan/items/53fe8d21f2147b0ac982) でもすこし触れています）\n\n1 つ目は、文字領域検出を、一般的な物体検知(Object Detection)の特殊系とみなして解く手法です。\n物体検知に対するアプローチとして主流なのは bounding box の座標を regression として解くというものです。\nこの場合、bounding box 形式で当てに行くので、歪んだ形状への対応が難しく、縦横比が大きく偏った文字領域に弱いといった問題があります。\n[EAST: An Efficient and Accurate Scene Text Detector](https://arxiv.org/abs/1704.03155) [X. Zhou et al., CVPR 2018] はこちらのアプローチを採用しています。\n\n2 つ目は、Instance Segmentation として解くアプローチです。\nピクセル単位で文字領域かどうかの 2 クラス分類 + なんらかの方法でインスタンスの分離を行うという方法ですが、インスタンスの分離には複雑な後処理を要するケースが多く、複雑さや実行時間に問題があります。\n[PixelLink: Detecting Scene Text via Instance Segmentation](https://arxiv.org/abs/1801.01315) [D. Deng et al., AAAI 2018] が代表例です。（論文中で refer されているのは Multi-oriented Text Detection with Fully Convolutional Networks [Z. Zhang et al., CVPR 2016])\n\nこの論文ではこれらの 2 つの手法をいいとこ取りした Scene Text Detector を提案しています。\n\n## Network Architecture\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/281d3451-0e23-c20b-bb18-88b46495da15.png)\n\n全体像は ↑ の図のようになっています。\n**Corner Detection** と **Position Sensitive Segmentation** の 2 つからなる architecture です。\n\nCorner Detection はその名の通り、文字領域の角の位置を予測します。ただし、「角である」ことだけを考慮し、「どの 4 つの組み合わせが 1 領域を表しているのか」は考えません。\nCorner Detection が予測した大量の「角」たちを sampling & grouping し、大量の「文字領域候補」をつくります。\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/d62ec4c7-2e8b-56e9-045c-af825dfac279.png)\n（Corner Detection は概念的にはわかりやすいですが、実際には default box を用意して offset 計算して...と、SSD や YOLO と同程度には複雑なことをしています。詳細は論文をご参照ください...）\n\nCorner Detection と並行して、Position Sensitive Segmentation 側では、各ピクセルを「文字領域の右上」「右下」「左上」「左下」の 4 クラス（+ 背景）に分類します。\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/f8a4b98a-a428-48be-2d97-f57246f53a5a.png)\nそれぞれ、白が「左上」、赤が「右上」、青が「左下」、緑が「右下」に分類された領域です。\n\nさいごに、Corner Detection によって生成された大量の「文字領域候補」を、Position Sensitive Segmentation の結果との整合性に応じてスコアづけします。\n「文字領域候補」の左上にあるピクセルが Segmentation によって「左上」に分類されていればいるほど高いスコアになります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/aad5fe04-8bad-c758-fa7a-fd037c62f877.png)\n\n## 感想\n\nInstance Segmentation 方式は後処理が複雑すぎる、という問題提起のわりには、提案手法の後処理も相当大変そうという印象があります。\nまた、Corner Detection 部分はやけに複雑で、なぜこんなに複雑なことをしているのかあんまり理解できませんでした。\n一方、Object Detection 系のやり方と Segmentation 系のやり方を組み合わせる手法としては概念的にもわかりやすい構成で面白かったです。\nPosition Sensitive Segmentation というアプローチもこの論文を読むまで知らなかったので勉強になりました。\n\nこの論文の少しあとに ECCV 2018 に通った論文で関連していそうなものとして、CornerNet と PixelLink という論文があります。\n[CornerNet: Detecting Objects as Paired Keypoints](https://arxiv.org/abs/1808.01244) は、 Corner を予測 + ピクセル単位の Embedding を計算 → Embedding の距離に応じて Corner のペアを作っていくという手法で、よりシンプルに Corner のグルーピングを実現しています。\nまた、[PixelLink: Detecting Scene Text via Instance Segmentation](https://arxiv.org/abs/1801.01315) は text/non-text の segmentation + 隣接ピクセルと連結するかしないかの 2 クラス分類を組み合わせて Instance Segmentation をし、文字領域検出を行っています。\nどちらもとてもおもしろい論文なのでおすすめです。\n","contentMarkdown":"\n画像中の文字領域検出における 2 つの主流な手法のいいとこ取りを目指した論文、 Multi-Oriented Scene Text Detection via Corner Localization and Region Segmentation を読んでみました。\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Reference\n\n- Multi-Oriented Scene Text Detection via Corner Localization and Region Segmentation [Pengyuan Lyu, Cong Yao, Wenhao Wu, Shuicheng Yan, Xiang Bai. CVPR 2018]\n- https://arxiv.org/abs/1802.08948\n\n（文中の図表は論文より引用しています）\n\n## Scene Text Detection\n\nScene Text Detection は、風景写真のなかにある文字領域（かんばん、ポスターなど）を検出するタスクです。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/a78b72da-8550-641f-819b-ed024d9be7fa.png)\n(Figure 6.)\n\nCNN を活用した研究が進んでおり、現在では 2 つのアプローチが主流となっています。（このあたりは [【論文読み】Semi-convolutional Operators for Instance Segmentation](https://qiita.com/agatan/items/2cf1209b7370db45eba5) や [[論文紹介] Focal Loss for Dense Object Detection](https://qiita.com/agatan/items/53fe8d21f2147b0ac982) でもすこし触れています）\n\n1 つ目は、文字領域検出を、一般的な物体検知(Object Detection)の特殊系とみなして解く手法です。\n物体検知に対するアプローチとして主流なのは bounding box の座標を regression として解くというものです。\nこの場合、bounding box 形式で当てに行くので、歪んだ形状への対応が難しく、縦横比が大きく偏った文字領域に弱いといった問題があります。\n[EAST: An Efficient and Accurate Scene Text Detector](https://arxiv.org/abs/1704.03155) [X. Zhou et al., CVPR 2018] はこちらのアプローチを採用しています。\n\n2 つ目は、Instance Segmentation として解くアプローチです。\nピクセル単位で文字領域かどうかの 2 クラス分類 + なんらかの方法でインスタンスの分離を行うという方法ですが、インスタンスの分離には複雑な後処理を要するケースが多く、複雑さや実行時間に問題があります。\n[PixelLink: Detecting Scene Text via Instance Segmentation](https://arxiv.org/abs/1801.01315) [D. Deng et al., AAAI 2018] が代表例です。（論文中で refer されているのは Multi-oriented Text Detection with Fully Convolutional Networks [Z. Zhang et al., CVPR 2016])\n\nこの論文ではこれらの 2 つの手法をいいとこ取りした Scene Text Detector を提案しています。\n\n## Network Architecture\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/281d3451-0e23-c20b-bb18-88b46495da15.png)\n\n全体像は ↑ の図のようになっています。\n**Corner Detection** と **Position Sensitive Segmentation** の 2 つからなる architecture です。\n\nCorner Detection はその名の通り、文字領域の角の位置を予測します。ただし、「角である」ことだけを考慮し、「どの 4 つの組み合わせが 1 領域を表しているのか」は考えません。\nCorner Detection が予測した大量の「角」たちを sampling & grouping し、大量の「文字領域候補」をつくります。\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/d62ec4c7-2e8b-56e9-045c-af825dfac279.png)\n（Corner Detection は概念的にはわかりやすいですが、実際には default box を用意して offset 計算して...と、SSD や YOLO と同程度には複雑なことをしています。詳細は論文をご参照ください...）\n\nCorner Detection と並行して、Position Sensitive Segmentation 側では、各ピクセルを「文字領域の右上」「右下」「左上」「左下」の 4 クラス（+ 背景）に分類します。\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/f8a4b98a-a428-48be-2d97-f57246f53a5a.png)\nそれぞれ、白が「左上」、赤が「右上」、青が「左下」、緑が「右下」に分類された領域です。\n\nさいごに、Corner Detection によって生成された大量の「文字領域候補」を、Position Sensitive Segmentation の結果との整合性に応じてスコアづけします。\n「文字領域候補」の左上にあるピクセルが Segmentation によって「左上」に分類されていればいるほど高いスコアになります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/aad5fe04-8bad-c758-fa7a-fd037c62f877.png)\n\n## 感想\n\nInstance Segmentation 方式は後処理が複雑すぎる、という問題提起のわりには、提案手法の後処理も相当大変そうという印象があります。\nまた、Corner Detection 部分はやけに複雑で、なぜこんなに複雑なことをしているのかあんまり理解できませんでした。\n一方、Object Detection 系のやり方と Segmentation 系のやり方を組み合わせる手法としては概念的にもわかりやすい構成で面白かったです。\nPosition Sensitive Segmentation というアプローチもこの論文を読むまで知らなかったので勉強になりました。\n\nこの論文の少しあとに ECCV 2018 に通った論文で関連していそうなものとして、CornerNet と PixelLink という論文があります。\n[CornerNet: Detecting Objects as Paired Keypoints](https://arxiv.org/abs/1808.01244) は、 Corner を予測 + ピクセル単位の Embedding を計算 → Embedding の距離に応じて Corner のペアを作っていくという手法で、よりシンプルに Corner のグルーピングを実現しています。\nまた、[PixelLink: Detecting Scene Text via Instance Segmentation](https://arxiv.org/abs/1801.01315) は text/non-text の segmentation + 隣接ピクセルと連結するかしないかの 2 クラス分類を組み合わせて Instance Segmentation をし、文字領域検出を行っています。\nどちらもとてもおもしろい論文なのでおすすめです。\n","slug":"【論文読み】_Multi-Oriented_Scene_Text_Detection_via_Corner_Localization_and_Region_Segmentation","title":"【論文読み】 Multi-Oriented Scene Text Detection via Corner Localization and Region Segmentation","timestamp":1549984342000,"tags":["画像処理","DeepLearning","OCR","論文読み"]},{"rawMarkdown":"---\ntitle: \"【論文読み】Semi-convolutional Operators for Instance Segmentation\"\ndate: 2019-02-11T16:59:46+09:00\ntags: [\"DeepLearning\", \"論文読み\"]\nurl: https://qiita.com/agatan/items/2cf1209b7370db45eba5\n---\n\nInstance Segmentation のタスクに対する手法を整理・分解し、精度をより向上する `Semi-convolutional operators` を提案した論文です。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/8164ed4c-3f5d-c772-e21d-7d02d5146461.png)\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Reference\n\n- Semi-convolutional Operators for Instance Segmentation [David Novotny, Samuel Albanie, Diane Larlus, and Andrea Vedaldi. ECCV 2018]\n- https://arxiv.org/abs/1807.10712\n\n（文中の図表は論文より引用しています）\n\n## Instance Segmentation\n\nまずはじめに簡単に Instance Segmentation というタスクと、現在主流とされているアプローチについて述べます。\n\nInstance Segmentation とは、画像の各 Pixel について、 **どのクラスに属すか、どのインスタンスに属するか** を予測するタスクです。\n入力画像を「この領域は人、この領域は車、...」というように色塗りしていくタスクです。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/146f0988-659b-4f15-df32-e065ddae5e70.png)(Fig. 5 より)\n\nInstance Segmentation において重要なのが **どのインスタンスに属するか** も予測しなければならないという点です。\nたとえば人が 3 人で肩を組んでいるような画像の場合、どこからどこまでが 1 人目かを予測しなければなりません。\n一方、インスタンスを考慮せず色塗りをしていくようなタスクを Semantic Segmentation といいます。\n\nSemantic Segmentation の場合は、入力画像の各 Pixel について多クラス分類を行えば Segmentation の完成になります。\nInstance Segmentation ではそれに加えて個々のインスタンスを区別するような仕組みが必要になります。\n\n### propose & verify\n\nInstance Segmentation タスクへのアプローチとして、現在主流とされているのは Mask R-CNN [^1] に代表される Region based な手法です。\n（Mask R-CNN は FAIR から出ている論文で、 OSS として公開されている Detectron に実装が含まれています。 https://github.com/facebookresearch/Detectron ）\n\n[^1]: K. He, et al., https://arxiv.org/abs/1703.06870\n\nMask R-CNN は、物体のクラスと bounding box だけを予測する Object Detection タスクへのアプローチを応用しています。\nまず Object Detection をすることで「この bounding box に人間が 1 人いる」ということを予測し、その後 bounding box 内を色塗りしていきます。\nObject Detection として bounding box を予測している時点で Instance を分離することが出来ています。色塗りのフェーズでは、すでに Instance が分離されているので単なる Pixel 単位の 2 クラス分類をやればよいことになります。\n\nはじめに Region を提案し、その中を精査するこれらの手法を、この論文では _propose & verify_ (P&V) と呼んでいます。\n\nここで、 **P&V は必ず一度矩形で切り取ってから色塗りをしなければならない** という点が問題になります。\n予測したい物体は必ずしも矩形で近似できるような形状をしているとは限りません。\n実際の形状と極端にかけ離れた場合、bounding box を予測すること自体が難しく、また Instance の分離も難しくなります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/39b808c2-cc63-a245-73c1-5b6ebc89c9be.png)\n\n### instance coloring\n\nP&V の問題点を解決する方法として、Pixel ごとに **ラベル + Instance の identifier となる何か** を予測する方法があります。\nこれらをこの論文では _instance coloring_ (IC) と呼んでいます。\n\n「Instance の identifier となる何か」 は、連番などではうまく学習できません（どの Object が ID 1 なのか ID 2 なのかわからない）。\nそこで、 Pixel ごとに低次元の embedding を出力し、**同じ Instance に所属する Pixel の embedding たちが似たものになるように学習します**。\n入力画像に対して、Pixel ごとのラベルと embedding を出力し、embedding を基に Pixel たちをクラスタリングすることで Instance を分離します。\n\nIC の良いところは、典型的な image-to-image の問題と同じネットワーク構造を利用できるところです。\nSemantic Segmetation, Style Transfer など、画像を入力とし同じサイズの feature map を出力とするタスクは他にも数多くあり、それらと同じ構造をシンプルに流用できるのは大きな利点になります。\n（P&V の場合は Region Proposal + Region ごとの Coloring が必要で、ネットワーク構造としてはかなり複雑かつ独特なものになります）\n\n一方、IC であまり精度が出ない大きな理由の一つに **画像的に似た領域が繰り返されると Instance の分離に失敗する** という問題があります。\nimage-to-image のネットワークは通常 Convolutional operators をベースにしていますが、CNN の出力は、入力である pixel の特徴量にのみ依存し、 **座標は全く結果に影響を及ぼしません** 。\nそのため、画像的にそっくりな領域が複数あると、それらの pixel に対する embedding は同じような値になってしまい、クラスタリングがうまくいきません。\n\n## Semi-convolutional operators\n\n一般的な IC では、出力された embedding が次の条件をみたすことを目標とします。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/00e031cb-860d-d25c-af24-213ad5fd8565.png)\n\nここで、 $\\Omega$ は全 Pixel の集合、 $x$ は入力画像、 $\\Phi$ は学習したい関数（NN）、 $S_k$ はクラス k の segmentation mask、 $M$ はマージン （hyperparameter） です。\n言葉で説明すると、 **同じクラスに属する Pixel $u$, $v$ の embedding の距離をより近づけ、違うクラスに属する場合はより遠ざける** という感じです。\n$M$ は分離境界をよりくっきりさせるためのパラメータです。\n\nさきほど述べたように $\\Phi$ は CNN であり、座標情報を加味できません。\nSemi-convolutinal 版では、 $\\Phi$ の代わりに次のような $\\Psi$ を考えます。\n\n```math\n\\Psi_u(x) = f(\\Phi_u(x), u)\n```\n\nここで、 $u$ は Pixel の座標を表し、 $f$ は $\\Phi$ の結果と座標情報を合成するなんらかの関数です。\n$f$ の簡単な例としては、単純な足し算が考えられます。\n$\\Psi$ は、CNN の結果に加えて座標情報も持ち合わせているため、IC の弱点を克服できています。\n$f$ を単純な加算とし、うまく学習が成功した場合、各 Instance ごとに centroid $c_k$ が決定され、\n\n```math\n\\forall u \\in S_k: \\Phi_u(x) + u = c_k\n```\n\nとなるように $\\Phi$ が学習されます。\nこれを可視化すると次の画像のようになります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/74875b7b-be1b-4eb3-0e3d-f3c53fced5a8.png)\n(Fig.2 より)\n\n各インスタンス内の Pixel から、なんとなく中心っぽい場所へベクトルが伸びているのがわかります。\n\n実際の学習の際の損失関数は次のようになります。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/914e8f93-3c56-8d39-270e-1a5f3703bc79.png\" width=\"60%\">\n\n同じインスタンスに属する Pixel の embedding たちを平均値になるべく近づける、というのが損失関数になります。\n（マージンの考えも含まれていないし、「違うインスタンスとの距離を取る」という損失も含まれていないですが、これで十分に良い学習ができたと述べられています。）\n\n実際にはもうちょっと複雑な $\\Psi$ や距離の定義を使っていますが、概要としては上記のようなものを Semi-convolutional operators として提案しています。\n\n## Experiments\n\nMask R-CNN との統合もこの論文の重要な topic なのですが、ぶっちゃけ論文を読んだほうがわかりやすいので飛ばして実験結果をざーっと眺めてみます。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/e7516b68-9a66-154b-45ae-61199e0de90a.png)(Fig. 3 より)\n\nまずはじめに、 画像的にそっくりな領域が繰り返されてもうまく Instance を分離できることを確認しています。\n(c) は通常の Conv. のみを使って IC を行った場合の結果です。クラスタリングに大失敗していることがわかります。\n一方 (d) の Semi-conv. 版ではきれいな分離が実現されています。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/09bb8f76-5ba7-ad51-af97-2dbfc902cd66.png)\n\nつぎに線虫の segmentation です。こちらは P&V のように矩形で認識するタイプの手法がニガテとするようなタスクです。\n現在主流である Mask RCNN よりも良い結果が示されています。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/77a2f7fe-ee56-13ae-f49b-faf825cbf406.png)\n\nより一般的なデータである PASCAL VOC2012 に対しても Mask RCNN より良い結果となっています（Mask RCNN に Semi-conv. の仕組みを組み込んだもので比較しています。）\n\n## まとめと感想\n\ninstance coloring の手法をまったく知らなかったのですが、 [CornerNet: Detecting Objects as Paired Keypoints](https://arxiv.org/abs/1808.01244) で Pixel ごとの embedding をクラスタリングしてペアを作るという手法を知り、興味を持ったのでその関連で読んでみた論文です。\nP&V 形式はかなり複雑な構造になるので、それを避けられるならすごく面白いなと思ったのですが、この論文では Mask R-CNN と組み合わせることで精度向上と言っているので、まだまだ IC 単体で勝てる感じではないのでしょうか？\n\n同じタスクに対して全く違う 2 つのアプローチが（比較対象になるくらいには）同じような成果を出しているのも面白いところです。segmentation は主流ではなかった分、まだまだ改善がありそうで楽しみです。\n","contentMarkdown":"\nInstance Segmentation のタスクに対する手法を整理・分解し、精度をより向上する `Semi-convolutional operators` を提案した論文です。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/8164ed4c-3f5d-c772-e21d-7d02d5146461.png)\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Reference\n\n- Semi-convolutional Operators for Instance Segmentation [David Novotny, Samuel Albanie, Diane Larlus, and Andrea Vedaldi. ECCV 2018]\n- https://arxiv.org/abs/1807.10712\n\n（文中の図表は論文より引用しています）\n\n## Instance Segmentation\n\nまずはじめに簡単に Instance Segmentation というタスクと、現在主流とされているアプローチについて述べます。\n\nInstance Segmentation とは、画像の各 Pixel について、 **どのクラスに属すか、どのインスタンスに属するか** を予測するタスクです。\n入力画像を「この領域は人、この領域は車、...」というように色塗りしていくタスクです。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/146f0988-659b-4f15-df32-e065ddae5e70.png)(Fig. 5 より)\n\nInstance Segmentation において重要なのが **どのインスタンスに属するか** も予測しなければならないという点です。\nたとえば人が 3 人で肩を組んでいるような画像の場合、どこからどこまでが 1 人目かを予測しなければなりません。\n一方、インスタンスを考慮せず色塗りをしていくようなタスクを Semantic Segmentation といいます。\n\nSemantic Segmentation の場合は、入力画像の各 Pixel について多クラス分類を行えば Segmentation の完成になります。\nInstance Segmentation ではそれに加えて個々のインスタンスを区別するような仕組みが必要になります。\n\n### propose & verify\n\nInstance Segmentation タスクへのアプローチとして、現在主流とされているのは Mask R-CNN [^1] に代表される Region based な手法です。\n（Mask R-CNN は FAIR から出ている論文で、 OSS として公開されている Detectron に実装が含まれています。 https://github.com/facebookresearch/Detectron ）\n\n[^1]: K. He, et al., https://arxiv.org/abs/1703.06870\n\nMask R-CNN は、物体のクラスと bounding box だけを予測する Object Detection タスクへのアプローチを応用しています。\nまず Object Detection をすることで「この bounding box に人間が 1 人いる」ということを予測し、その後 bounding box 内を色塗りしていきます。\nObject Detection として bounding box を予測している時点で Instance を分離することが出来ています。色塗りのフェーズでは、すでに Instance が分離されているので単なる Pixel 単位の 2 クラス分類をやればよいことになります。\n\nはじめに Region を提案し、その中を精査するこれらの手法を、この論文では _propose & verify_ (P&V) と呼んでいます。\n\nここで、 **P&V は必ず一度矩形で切り取ってから色塗りをしなければならない** という点が問題になります。\n予測したい物体は必ずしも矩形で近似できるような形状をしているとは限りません。\n実際の形状と極端にかけ離れた場合、bounding box を予測すること自体が難しく、また Instance の分離も難しくなります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/39b808c2-cc63-a245-73c1-5b6ebc89c9be.png)\n\n### instance coloring\n\nP&V の問題点を解決する方法として、Pixel ごとに **ラベル + Instance の identifier となる何か** を予測する方法があります。\nこれらをこの論文では _instance coloring_ (IC) と呼んでいます。\n\n「Instance の identifier となる何か」 は、連番などではうまく学習できません（どの Object が ID 1 なのか ID 2 なのかわからない）。\nそこで、 Pixel ごとに低次元の embedding を出力し、**同じ Instance に所属する Pixel の embedding たちが似たものになるように学習します**。\n入力画像に対して、Pixel ごとのラベルと embedding を出力し、embedding を基に Pixel たちをクラスタリングすることで Instance を分離します。\n\nIC の良いところは、典型的な image-to-image の問題と同じネットワーク構造を利用できるところです。\nSemantic Segmetation, Style Transfer など、画像を入力とし同じサイズの feature map を出力とするタスクは他にも数多くあり、それらと同じ構造をシンプルに流用できるのは大きな利点になります。\n（P&V の場合は Region Proposal + Region ごとの Coloring が必要で、ネットワーク構造としてはかなり複雑かつ独特なものになります）\n\n一方、IC であまり精度が出ない大きな理由の一つに **画像的に似た領域が繰り返されると Instance の分離に失敗する** という問題があります。\nimage-to-image のネットワークは通常 Convolutional operators をベースにしていますが、CNN の出力は、入力である pixel の特徴量にのみ依存し、 **座標は全く結果に影響を及ぼしません** 。\nそのため、画像的にそっくりな領域が複数あると、それらの pixel に対する embedding は同じような値になってしまい、クラスタリングがうまくいきません。\n\n## Semi-convolutional operators\n\n一般的な IC では、出力された embedding が次の条件をみたすことを目標とします。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/00e031cb-860d-d25c-af24-213ad5fd8565.png)\n\nここで、 $\\Omega$ は全 Pixel の集合、 $x$ は入力画像、 $\\Phi$ は学習したい関数（NN）、 $S_k$ はクラス k の segmentation mask、 $M$ はマージン （hyperparameter） です。\n言葉で説明すると、 **同じクラスに属する Pixel $u$, $v$ の embedding の距離をより近づけ、違うクラスに属する場合はより遠ざける** という感じです。\n$M$ は分離境界をよりくっきりさせるためのパラメータです。\n\nさきほど述べたように $\\Phi$ は CNN であり、座標情報を加味できません。\nSemi-convolutinal 版では、 $\\Phi$ の代わりに次のような $\\Psi$ を考えます。\n\n```math\n\\Psi_u(x) = f(\\Phi_u(x), u)\n```\n\nここで、 $u$ は Pixel の座標を表し、 $f$ は $\\Phi$ の結果と座標情報を合成するなんらかの関数です。\n$f$ の簡単な例としては、単純な足し算が考えられます。\n$\\Psi$ は、CNN の結果に加えて座標情報も持ち合わせているため、IC の弱点を克服できています。\n$f$ を単純な加算とし、うまく学習が成功した場合、各 Instance ごとに centroid $c_k$ が決定され、\n\n```math\n\\forall u \\in S_k: \\Phi_u(x) + u = c_k\n```\n\nとなるように $\\Phi$ が学習されます。\nこれを可視化すると次の画像のようになります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/74875b7b-be1b-4eb3-0e3d-f3c53fced5a8.png)\n(Fig.2 より)\n\n各インスタンス内の Pixel から、なんとなく中心っぽい場所へベクトルが伸びているのがわかります。\n\n実際の学習の際の損失関数は次のようになります。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/914e8f93-3c56-8d39-270e-1a5f3703bc79.png\" width=\"60%\">\n\n同じインスタンスに属する Pixel の embedding たちを平均値になるべく近づける、というのが損失関数になります。\n（マージンの考えも含まれていないし、「違うインスタンスとの距離を取る」という損失も含まれていないですが、これで十分に良い学習ができたと述べられています。）\n\n実際にはもうちょっと複雑な $\\Psi$ や距離の定義を使っていますが、概要としては上記のようなものを Semi-convolutional operators として提案しています。\n\n## Experiments\n\nMask R-CNN との統合もこの論文の重要な topic なのですが、ぶっちゃけ論文を読んだほうがわかりやすいので飛ばして実験結果をざーっと眺めてみます。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/e7516b68-9a66-154b-45ae-61199e0de90a.png)(Fig. 3 より)\n\nまずはじめに、 画像的にそっくりな領域が繰り返されてもうまく Instance を分離できることを確認しています。\n(c) は通常の Conv. のみを使って IC を行った場合の結果です。クラスタリングに大失敗していることがわかります。\n一方 (d) の Semi-conv. 版ではきれいな分離が実現されています。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/09bb8f76-5ba7-ad51-af97-2dbfc902cd66.png)\n\nつぎに線虫の segmentation です。こちらは P&V のように矩形で認識するタイプの手法がニガテとするようなタスクです。\n現在主流である Mask RCNN よりも良い結果が示されています。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/77a2f7fe-ee56-13ae-f49b-faf825cbf406.png)\n\nより一般的なデータである PASCAL VOC2012 に対しても Mask RCNN より良い結果となっています（Mask RCNN に Semi-conv. の仕組みを組み込んだもので比較しています。）\n\n## まとめと感想\n\ninstance coloring の手法をまったく知らなかったのですが、 [CornerNet: Detecting Objects as Paired Keypoints](https://arxiv.org/abs/1808.01244) で Pixel ごとの embedding をクラスタリングしてペアを作るという手法を知り、興味を持ったのでその関連で読んでみた論文です。\nP&V 形式はかなり複雑な構造になるので、それを避けられるならすごく面白いなと思ったのですが、この論文では Mask R-CNN と組み合わせることで精度向上と言っているので、まだまだ IC 単体で勝てる感じではないのでしょうか？\n\n同じタスクに対して全く違う 2 つのアプローチが（比較対象になるくらいには）同じような成果を出しているのも面白いところです。segmentation は主流ではなかった分、まだまだ改善がありそうで楽しみです。\n","slug":"【論文読み】Semi-convolutional_Operators_for_Instance_Segmentation","title":"【論文読み】Semi-convolutional Operators for Instance Segmentation","timestamp":1549871986000,"tags":["DeepLearning","論文読み"]},{"rawMarkdown":"---\ntitle: \"【論文紹介】Concurrent Spatial and Channel Squeeze & Excitation in Fully Convolutional Networks\"\ndate: 2019-01-04T14:51:07+09:00\ntags: [\"Python\", \"DeepLearning\", \"Keras\", \"TensorFlow\", \"論文読み\"]\nurl: https://qiita.com/agatan/items/61546d71e7ea7ad14b11\n---\n\nFully Convolutional Network (FCN) の性能を enhance する Concurrent Spatial and Channel Squeeze & Excitation (scSE) というモジュールを提案した論文です。\n既存の良いとされてきたモデルたちに計算量をそこまで増やさずに & 簡単に組み込むことができ、 Image Segmentation などのタスクで性能を向上させることができます。\n\n[ILSVRC 2017 画像分類 Top の手法 Squeeze-and-Excitation Networks - Qiita](https://qiita.com/agatan/items/8cf2566908228eaa5450) で紹介した SE モジュールの後継にあたります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/f606f8d0-9510-f251-31d8-e9091ed031b9.png)\n\n## Reference\n\n- Abhijit Guha Roy, et al., MICCAI 2018\n- https://arxiv.org/abs/1803.02579\n\n文中の図表は論文から引用しています。\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Squeeze and Excitation を Image Segmentation に応用する\n\nSqueeze and Excitation (SE) モジュールは、[Squeeze-and-Excitation Networks](https://arxiv.org/abs/1709.01507) で提案されたもので、 ILSVRC 2017 でトップのスコアを記録しています。\nSE は Channel 間の関係性を考慮できるようにしたい、というモチベーションで、 チャンネルごとに画像全体の activation の平均を取り（Squeeze)、それをもとにチャンネル間の Attention をとる（Excitation）というものでした。（[ILSVRC 2017 画像分類 Top の手法 Squeeze-and-Excitation Networks - Qiita](https://qiita.com/agatan/items/8cf2566908228eaa5450)）\n本論文ではこのオリジナルの SE モジュールのことを channel SE (Spatial Squeeze and Channel Excitation, cSE) と呼んでいます。\n\n```python\nfrom tensorflow.python.keras.layers import GlovelAveragePooling2D, Dense, multiply\n\ndef spatial_squeeze_and_channel_excitation(x, ch, ratio=16):\n    squeeze = GlobalAveragePooling2D()(x)\n    z = Dense(ch // ratio, activation='relu')(squeeze)\n    excitation = Dense(ch, activation='sigmoid')(x)\n    return multiply([x, excitation])\n```\n\n本論文では Image Classification の性能を大きく向上した SE モジュールを、 Image Segmentation に応用することを考えます。\nImage Segmentation のタスクでは、Fully Convolutional な Architecture がよく採用されます。\nこの論文では、U-Net[^1] やそこから派生した SkipDeconv-Net[^2]， Fully Convolutional DenseNet[^3] などに対して SE モジュール的な考え方で性能を向上できないか実験しています。\n\n[^1]: Ronneberger O, Fischer P, Brox T. U-net: Convolutional networks for biomedical image segmentation. In Proc. MICCAI, Springer 2015, pp. 234-241.\n[^2]: Roy, A.G., Conjeti, S., Sheet, D., Katouzian, A., Navab, N. and Wachinger, C., 2017, September. Error Corrective Boosting for Learning Fully Convolutional Networks with Limited Data. In MICCAI, pp. 231-239, Springer.\n[^3]: J ́egou, S., Drozdzal, M., Vazquez, D., Romero, A. and Bengio, Y., 2017, July. The one hundred layers tiramisu: Fully convolutional densenets for semantic segmentation. In CVPR Workshop, pp. 1175-1183, IEEE.\n\nが、実際に SE モジュールをこれらの FCN に組み込んでみると、 Image Classification のときよりも性能が上がりづらいという結果が得られています。\nこの論文では、 「Image Segmentation は pixel-wise の情報が重要であり、チャンネルごとに画像全体から平均を取る cSE ではピクセル単位の情報をうまく enhance できていないのでは」という仮説を立てています。\n\n## Channel Squeeze and Spatial Excitation Block (sSE)\n\nそこでこの論文で提案されているので、 sSE です。\n名前のとおりですが、 Channel 方向に Squeeze し、Pixel ごとに Excitation を計算します。\ncSE は画像全体（Spatial）で Squeeze し、Channel ごとの Excitation を計算しているので、その逆をやっているというイメージです。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/7c6f2822-ff51-c4f6-2d3f-6c0422dca3fa.png\" width=\"60%\">\n\n実装はものすごく単純です。以下に `tf.keras` をつかった場合の実装例を載せます。\n\n```python\nimport tensorflow as tf\n\ndef channel_squeeze_and_spatial_excitation(x):\n    excitation = tf.keras.layers.Conv2D(filters=1, kernel_size=1, activation='sigmoid')(x)\n    return tf.keras.layers.multiply([x, excitation])\n```\n\n`Conv2D(filters=1, kernel_size=1, activation='sigmoid')` で、pixel ごとに 1 チャンネルの値を 0~1 で出力させます。\nこれが「ある pixel における excitation」になります。出力は、入力である feature map と excitation の element-wise な積です。\n\n## Spatial and Channel Squeeze & Excitation (scSE)\n\nまた、提案手法である sSE とオリジナルの cSE は conflict しないので、両方採用してしまおう、というのが scSE です。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/fcbc2c76-3947-f587-eb8a-4422b4a28b7e.png\" width=\"70%\">\n\nこの図の上部が sSE、下部が cSE です。同じ入力からそれぞれを計算し、最後に単純に足し算したものを scSE と呼んでいます。\n\n```python\ndef _concurrent_spartial_and_channel_se(input_feature, ch, ratio=16):\n    cse = _spatial_squeeze_and_channel_excitation(input_feature, ch, ratio=ratio)\n    sse = _channel_squeeze_and_spatial_excitation(input_feature)\n    return tf.keras.layers.Add()([cse, sse])\n```\n\nこの論文で実験に使われている U-Net の場合、 scSE を使った場合でも計算量は 1.5% 程度の増加で済んでいます。\n\n## Experiments\n\nいくつかのネットワークについて、「素の状態」「cSE」「sSE」「scSE」の 4 パターンで実験しています。\nここでは DenseNet のケースについてまとめた図を論文中の Fig.2 から引用します。\n詳細や全体像は論文を参照してください。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/31a9cee5-5d22-b682-1400-b3f98bfe5ae3.png)\n\n横軸はタスク名です。\nタスクにもよりますが、概ね `DenseNets` < `DenseNets + cSE` < `DenseNets + sSE` < `DenseNets + scSE` になっているように見えます。\ncSE だけをいれると素の状態より性能が悪くなっているケースも見られるのが面白いところです。\n\n## まとめと感想\n\nタスクの特性を見て仮説を立て、実際にそれがうまくハマっているという論文で、よみやすいし納得感のある論文でした。\n実装の容易さと試しやすさ（既存モデルへ着脱できる）がうれしい手法で、実際に活用しているモデルに組み込まれています。\n","contentMarkdown":"\nFully Convolutional Network (FCN) の性能を enhance する Concurrent Spatial and Channel Squeeze & Excitation (scSE) というモジュールを提案した論文です。\n既存の良いとされてきたモデルたちに計算量をそこまで増やさずに & 簡単に組み込むことができ、 Image Segmentation などのタスクで性能を向上させることができます。\n\n[ILSVRC 2017 画像分類 Top の手法 Squeeze-and-Excitation Networks - Qiita](https://qiita.com/agatan/items/8cf2566908228eaa5450) で紹介した SE モジュールの後継にあたります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/f606f8d0-9510-f251-31d8-e9091ed031b9.png)\n\n## Reference\n\n- Abhijit Guha Roy, et al., MICCAI 2018\n- https://arxiv.org/abs/1803.02579\n\n文中の図表は論文から引用しています。\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Squeeze and Excitation を Image Segmentation に応用する\n\nSqueeze and Excitation (SE) モジュールは、[Squeeze-and-Excitation Networks](https://arxiv.org/abs/1709.01507) で提案されたもので、 ILSVRC 2017 でトップのスコアを記録しています。\nSE は Channel 間の関係性を考慮できるようにしたい、というモチベーションで、 チャンネルごとに画像全体の activation の平均を取り（Squeeze)、それをもとにチャンネル間の Attention をとる（Excitation）というものでした。（[ILSVRC 2017 画像分類 Top の手法 Squeeze-and-Excitation Networks - Qiita](https://qiita.com/agatan/items/8cf2566908228eaa5450)）\n本論文ではこのオリジナルの SE モジュールのことを channel SE (Spatial Squeeze and Channel Excitation, cSE) と呼んでいます。\n\n```python\nfrom tensorflow.python.keras.layers import GlovelAveragePooling2D, Dense, multiply\n\ndef spatial_squeeze_and_channel_excitation(x, ch, ratio=16):\n    squeeze = GlobalAveragePooling2D()(x)\n    z = Dense(ch // ratio, activation='relu')(squeeze)\n    excitation = Dense(ch, activation='sigmoid')(x)\n    return multiply([x, excitation])\n```\n\n本論文では Image Classification の性能を大きく向上した SE モジュールを、 Image Segmentation に応用することを考えます。\nImage Segmentation のタスクでは、Fully Convolutional な Architecture がよく採用されます。\nこの論文では、U-Net[^1] やそこから派生した SkipDeconv-Net[^2]， Fully Convolutional DenseNet[^3] などに対して SE モジュール的な考え方で性能を向上できないか実験しています。\n\n[^1]: Ronneberger O, Fischer P, Brox T. U-net: Convolutional networks for biomedical image segmentation. In Proc. MICCAI, Springer 2015, pp. 234-241.\n[^2]: Roy, A.G., Conjeti, S., Sheet, D., Katouzian, A., Navab, N. and Wachinger, C., 2017, September. Error Corrective Boosting for Learning Fully Convolutional Networks with Limited Data. In MICCAI, pp. 231-239, Springer.\n[^3]: J ́egou, S., Drozdzal, M., Vazquez, D., Romero, A. and Bengio, Y., 2017, July. The one hundred layers tiramisu: Fully convolutional densenets for semantic segmentation. In CVPR Workshop, pp. 1175-1183, IEEE.\n\nが、実際に SE モジュールをこれらの FCN に組み込んでみると、 Image Classification のときよりも性能が上がりづらいという結果が得られています。\nこの論文では、 「Image Segmentation は pixel-wise の情報が重要であり、チャンネルごとに画像全体から平均を取る cSE ではピクセル単位の情報をうまく enhance できていないのでは」という仮説を立てています。\n\n## Channel Squeeze and Spatial Excitation Block (sSE)\n\nそこでこの論文で提案されているので、 sSE です。\n名前のとおりですが、 Channel 方向に Squeeze し、Pixel ごとに Excitation を計算します。\ncSE は画像全体（Spatial）で Squeeze し、Channel ごとの Excitation を計算しているので、その逆をやっているというイメージです。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/7c6f2822-ff51-c4f6-2d3f-6c0422dca3fa.png\" width=\"60%\">\n\n実装はものすごく単純です。以下に `tf.keras` をつかった場合の実装例を載せます。\n\n```python\nimport tensorflow as tf\n\ndef channel_squeeze_and_spatial_excitation(x):\n    excitation = tf.keras.layers.Conv2D(filters=1, kernel_size=1, activation='sigmoid')(x)\n    return tf.keras.layers.multiply([x, excitation])\n```\n\n`Conv2D(filters=1, kernel_size=1, activation='sigmoid')` で、pixel ごとに 1 チャンネルの値を 0~1 で出力させます。\nこれが「ある pixel における excitation」になります。出力は、入力である feature map と excitation の element-wise な積です。\n\n## Spatial and Channel Squeeze & Excitation (scSE)\n\nまた、提案手法である sSE とオリジナルの cSE は conflict しないので、両方採用してしまおう、というのが scSE です。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/fcbc2c76-3947-f587-eb8a-4422b4a28b7e.png\" width=\"70%\">\n\nこの図の上部が sSE、下部が cSE です。同じ入力からそれぞれを計算し、最後に単純に足し算したものを scSE と呼んでいます。\n\n```python\ndef _concurrent_spartial_and_channel_se(input_feature, ch, ratio=16):\n    cse = _spatial_squeeze_and_channel_excitation(input_feature, ch, ratio=ratio)\n    sse = _channel_squeeze_and_spatial_excitation(input_feature)\n    return tf.keras.layers.Add()([cse, sse])\n```\n\nこの論文で実験に使われている U-Net の場合、 scSE を使った場合でも計算量は 1.5% 程度の増加で済んでいます。\n\n## Experiments\n\nいくつかのネットワークについて、「素の状態」「cSE」「sSE」「scSE」の 4 パターンで実験しています。\nここでは DenseNet のケースについてまとめた図を論文中の Fig.2 から引用します。\n詳細や全体像は論文を参照してください。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/31a9cee5-5d22-b682-1400-b3f98bfe5ae3.png)\n\n横軸はタスク名です。\nタスクにもよりますが、概ね `DenseNets` < `DenseNets + cSE` < `DenseNets + sSE` < `DenseNets + scSE` になっているように見えます。\ncSE だけをいれると素の状態より性能が悪くなっているケースも見られるのが面白いところです。\n\n## まとめと感想\n\nタスクの特性を見て仮説を立て、実際にそれがうまくハマっているという論文で、よみやすいし納得感のある論文でした。\n実装の容易さと試しやすさ（既存モデルへ着脱できる）がうれしい手法で、実際に活用しているモデルに組み込まれています。\n","slug":"【論文紹介】Concurrent_Spatial_and_Channel_Squeeze_&_Excitation_in_Fully_Convolutional_Networks","title":"【論文紹介】Concurrent Spatial and Channel Squeeze & Excitation in Fully Convolutional Networks","timestamp":1546581067000,"tags":["Python","DeepLearning","Keras","TensorFlow","論文読み"]},{"rawMarkdown":"---\ntitle: \"DKN: Deep Knowledge-Aware Network for News Recommendation\"\ndate: 2018-12-19T21:02:20+09:00\ntags: [\"DeepLearning\", \"WWW\", \"Recommendation\", \"論文読み\"]\nurl: https://qiita.com/agatan/items/24c6d8e00f2fc861bb04\n---\n\nニュースの推薦に \"Knowledge Graph\" を活用する論文です。\nMicrosoft Research Asia のチームが WWW 2018 に投稿しています。\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Reference\n\n- DKN: Deep Knowledge-Aware Network for News Recommendation\n  - Hongwei Wang, Fuzheng Zhang, Xing Xie and Minyi Guo, et al., WWW 2018\n  - https://www2018.thewebconf.org/proceedings/#indus-922\n\n文中の図表は論文より引用しています。\n\n### 概要\n\n一般にニュース中の言葉は、常識的知識を仮定していて凝縮された文章になっています。\n一方で推薦系の既存手法は ニュース中に現れない知識を取り扱えておらず、潜在的なニュース間の関係を活かした探索が出来ていないという問題がありました。\n\nこの論文は、knowledge graph を活用した content-based な recommendation framework である _deep knowledge-aware network_ (DKN) を提案しています。\n\nknowledge graph とは、様々なエンティティを様々なエッジでつないだ heterogeneous なグラフで、たとえば \"モナリザ -[の作者」-> ダ・ヴィンチ\" のような情報を溜め込んだ巨大なグラフです。\nGoogle Search の裏でも活躍しているらしく、一般的な「知識」を構造化された形で表現する方法としてよく使われています。\nknowledge graph を使うことで、 \"Donald Trump\" という単語そのものだけからはわからない、 \"United States\" という単語との関連、\"Politician\" という単語との関連などを導くことができます。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/6967d5d1-0708-7e59-51c8-db107866ea63.png)\n\n### 何が難しいか\n\nこの論文では、ニュース推薦の難しさとして以下のようなものを挙げています。\n\n- news の推薦は movie などと違って、リアルタイム性が高い問題（いつ publish されたニュースかが重要）であり、news 間の関係性もすぐにダメになる。\n  - なので ID ベースの既存手法（協調フィルタリングなど）は効果が弱い\n- news はユーザによって興味範囲が違うし、ユーザは複数の興味範囲を持っていることがほとんど。\n- news の文言は凝縮されている。\n  - 常識、大量の既知の entity を仮定している。\n  - “Boris Johnson Has Warned Donald Trump To Stick To The Iran Nuclear Deal\" というニュースは “Boris Johnson”, “Donald Trump”, “Iran\", “Nuclear” を知っている前提で書かれている\n  - ↑ に興味のあるユーザはきっと “North Korean EMP Attack Would Cause Mass U.S. Starvation, Says Congressional Report” にも興味があるが、単語レベルでの関係性はほぼ無い\n\nこれらを Knowledge Graph を活用しつつ解決していきます。\n\n### Knowledge Graph Embedding\n\nKnowledge Graph Embedding 自体はこの研究の contribution ではありませんが重要なので簡単に紹介します。\nKnowledge Graph Embedding は、通常の network embedding に近い問題設定で、 knowledge graph における各エンティティとエッジの低次元な embedding を求めるという問題です。\n`(head, relation, trail)` という triplet 構造をなるべく維持したまま、`h, r, t` それぞれを低次元空間で表現することが目標です。\nDKN は translation-based knowledge graph embedding というのを使っています。\n一番簡単な手法は `h + r = t` になるように embedding を定める手法です。\n（他にもいくつか紹介、実験されているけど大体発想は同じなので省略。）\nまずランダムな値で各エンティティ、エッジの embedding を初期化し、 `h + r = t` を満たすように gradient descent で embedding を微調整していきます。\nこれによって、エンティティやエッジ（＝関係性）の低次元なベクトルを得ることができました。\n\n### Deep Knowledge-aware Network (DKN)\n\nDKN 自体は\n\n入力: 候補ニュースと、あるユーザの過去に見たニュースたち\n出力: クリック率\n\nとなるような CTR 予測モデルです。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/f64784da-f8b9-4620-c0b5-5a3db5640417.png)\n\n候補となるニュースの特徴量をベクトルとして得るために、通常であれば単語の embedding を RNN や CNN でまとめ上げて固定長のベクトルに変換します。\nDKN ではここに Knowledge Graph Embedding によって得た特徴量を加えます。\n出現する単語ごとに Knowledge Graph 上のエンティティを探し、もし見つかったならそのエンティティ自体の embedding + 周辺のエンティティ embedding の平均を context vector として単語レベルの embedding に concat します。\nもしエンティティが見つからなければ 0 埋めでサイズをあわせます。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/8e4f7cc4-89ee-5b3a-7343-245f33fa0b51.png)\n\n#### Attention-based User Interest Extraction\n\nつぎに、「ユーザが過去に見た記事」という情報をどのように活用するかを考えます。（＝ユーザの特徴をどのようにベクトル化するか）\n記事ごとのベクトルは ↑ で求められたので、単純に過去クリックした記事のベクトルの平均値を使うという方法が考えられますが、ユーザの興味は複数にまたがりうるので単純に平均を取るのは適しているとは言えません。\n（たとえば「プログラミング」「テニス」「ラーメン」の記事をクリックしたユーザに対して、「プログラミング」系の記事を推薦するのは多分良いはずだけど、平均をとってしまっているとその寄与が薄まる。）\n「今推薦の候補に考えている記事」について過去見た記事それぞれがどう関わっているかを表現できる方法でなければならないと言っています。\n\nそこで、 Attention Module をつかっています。\n候補の記事と過去に見た記事たちとの間の attention を計算し、過去に見た記事たちのベクトルの重み付き和をとることで、興味分野が複数にまたがっていても候補記事との関連をうまく見出したベクトルが作り出せます。\nAttention Module の入力は「候補記事のベクトル」と「過去に見た記事のベクトル」で、出力はその記事の寄与度になります。過去に見たすべての記事に対してそれぞれ network に入れて寄与度を計算し、softmax にかけたうで記事ベクトルの重み付き和をとっています。\n\n## 感想\n\nニュースタイトルは単語数が少なく固有名詞も多いので、単純な単語の embedding ではなかなか扱いづらいという問題を抱えていたので、 knowledge graph を使うというのはすごく納得の行く選択だなと思いました。\nただ、結果を見てみると Gain に対して複雑さや Knowledge Graph 自体を用意するコストが見合うかというとやはり厳しいかなという印象があります。（Microsoft はすでに自前の knowledge graph を持っているので...）\n\nKnowledge Graph Embedding については全く知らなかったのですが、面白い問題設定ですね。\n色々工夫されているようですが、 `h + r = t` というわかりやすく単純な方法でもそれなりに上手く行っていて面白かったです。\n\nまた、ユーザごとのベクトル表現の作り方の部分は Knowledge Graph の活用部分よりも簡単かつ一般的なので、この部分だけでも応用できそうだなと思いました。\n","contentMarkdown":"\nニュースの推薦に \"Knowledge Graph\" を活用する論文です。\nMicrosoft Research Asia のチームが WWW 2018 に投稿しています。\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Reference\n\n- DKN: Deep Knowledge-Aware Network for News Recommendation\n  - Hongwei Wang, Fuzheng Zhang, Xing Xie and Minyi Guo, et al., WWW 2018\n  - https://www2018.thewebconf.org/proceedings/#indus-922\n\n文中の図表は論文より引用しています。\n\n### 概要\n\n一般にニュース中の言葉は、常識的知識を仮定していて凝縮された文章になっています。\n一方で推薦系の既存手法は ニュース中に現れない知識を取り扱えておらず、潜在的なニュース間の関係を活かした探索が出来ていないという問題がありました。\n\nこの論文は、knowledge graph を活用した content-based な recommendation framework である _deep knowledge-aware network_ (DKN) を提案しています。\n\nknowledge graph とは、様々なエンティティを様々なエッジでつないだ heterogeneous なグラフで、たとえば \"モナリザ -[の作者」-> ダ・ヴィンチ\" のような情報を溜め込んだ巨大なグラフです。\nGoogle Search の裏でも活躍しているらしく、一般的な「知識」を構造化された形で表現する方法としてよく使われています。\nknowledge graph を使うことで、 \"Donald Trump\" という単語そのものだけからはわからない、 \"United States\" という単語との関連、\"Politician\" という単語との関連などを導くことができます。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/6967d5d1-0708-7e59-51c8-db107866ea63.png)\n\n### 何が難しいか\n\nこの論文では、ニュース推薦の難しさとして以下のようなものを挙げています。\n\n- news の推薦は movie などと違って、リアルタイム性が高い問題（いつ publish されたニュースかが重要）であり、news 間の関係性もすぐにダメになる。\n  - なので ID ベースの既存手法（協調フィルタリングなど）は効果が弱い\n- news はユーザによって興味範囲が違うし、ユーザは複数の興味範囲を持っていることがほとんど。\n- news の文言は凝縮されている。\n  - 常識、大量の既知の entity を仮定している。\n  - “Boris Johnson Has Warned Donald Trump To Stick To The Iran Nuclear Deal\" というニュースは “Boris Johnson”, “Donald Trump”, “Iran\", “Nuclear” を知っている前提で書かれている\n  - ↑ に興味のあるユーザはきっと “North Korean EMP Attack Would Cause Mass U.S. Starvation, Says Congressional Report” にも興味があるが、単語レベルでの関係性はほぼ無い\n\nこれらを Knowledge Graph を活用しつつ解決していきます。\n\n### Knowledge Graph Embedding\n\nKnowledge Graph Embedding 自体はこの研究の contribution ではありませんが重要なので簡単に紹介します。\nKnowledge Graph Embedding は、通常の network embedding に近い問題設定で、 knowledge graph における各エンティティとエッジの低次元な embedding を求めるという問題です。\n`(head, relation, trail)` という triplet 構造をなるべく維持したまま、`h, r, t` それぞれを低次元空間で表現することが目標です。\nDKN は translation-based knowledge graph embedding というのを使っています。\n一番簡単な手法は `h + r = t` になるように embedding を定める手法です。\n（他にもいくつか紹介、実験されているけど大体発想は同じなので省略。）\nまずランダムな値で各エンティティ、エッジの embedding を初期化し、 `h + r = t` を満たすように gradient descent で embedding を微調整していきます。\nこれによって、エンティティやエッジ（＝関係性）の低次元なベクトルを得ることができました。\n\n### Deep Knowledge-aware Network (DKN)\n\nDKN 自体は\n\n入力: 候補ニュースと、あるユーザの過去に見たニュースたち\n出力: クリック率\n\nとなるような CTR 予測モデルです。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/f64784da-f8b9-4620-c0b5-5a3db5640417.png)\n\n候補となるニュースの特徴量をベクトルとして得るために、通常であれば単語の embedding を RNN や CNN でまとめ上げて固定長のベクトルに変換します。\nDKN ではここに Knowledge Graph Embedding によって得た特徴量を加えます。\n出現する単語ごとに Knowledge Graph 上のエンティティを探し、もし見つかったならそのエンティティ自体の embedding + 周辺のエンティティ embedding の平均を context vector として単語レベルの embedding に concat します。\nもしエンティティが見つからなければ 0 埋めでサイズをあわせます。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/8e4f7cc4-89ee-5b3a-7343-245f33fa0b51.png)\n\n#### Attention-based User Interest Extraction\n\nつぎに、「ユーザが過去に見た記事」という情報をどのように活用するかを考えます。（＝ユーザの特徴をどのようにベクトル化するか）\n記事ごとのベクトルは ↑ で求められたので、単純に過去クリックした記事のベクトルの平均値を使うという方法が考えられますが、ユーザの興味は複数にまたがりうるので単純に平均を取るのは適しているとは言えません。\n（たとえば「プログラミング」「テニス」「ラーメン」の記事をクリックしたユーザに対して、「プログラミング」系の記事を推薦するのは多分良いはずだけど、平均をとってしまっているとその寄与が薄まる。）\n「今推薦の候補に考えている記事」について過去見た記事それぞれがどう関わっているかを表現できる方法でなければならないと言っています。\n\nそこで、 Attention Module をつかっています。\n候補の記事と過去に見た記事たちとの間の attention を計算し、過去に見た記事たちのベクトルの重み付き和をとることで、興味分野が複数にまたがっていても候補記事との関連をうまく見出したベクトルが作り出せます。\nAttention Module の入力は「候補記事のベクトル」と「過去に見た記事のベクトル」で、出力はその記事の寄与度になります。過去に見たすべての記事に対してそれぞれ network に入れて寄与度を計算し、softmax にかけたうで記事ベクトルの重み付き和をとっています。\n\n## 感想\n\nニュースタイトルは単語数が少なく固有名詞も多いので、単純な単語の embedding ではなかなか扱いづらいという問題を抱えていたので、 knowledge graph を使うというのはすごく納得の行く選択だなと思いました。\nただ、結果を見てみると Gain に対して複雑さや Knowledge Graph 自体を用意するコストが見合うかというとやはり厳しいかなという印象があります。（Microsoft はすでに自前の knowledge graph を持っているので...）\n\nKnowledge Graph Embedding については全く知らなかったのですが、面白い問題設定ですね。\n色々工夫されているようですが、 `h + r = t` というわかりやすく単純な方法でもそれなりに上手く行っていて面白かったです。\n\nまた、ユーザごとのベクトル表現の作り方の部分は Knowledge Graph の活用部分よりも簡単かつ一般的なので、この部分だけでも応用できそうだなと思いました。\n","slug":"DKN:_Deep_Knowledge-Aware_Network_for_News_Recommendation","title":"DKN: Deep Knowledge-Aware Network for News Recommendation","timestamp":1545220940000,"tags":["DeepLearning","WWW","Recommendation","論文読み"]},{"rawMarkdown":"---\ntitle: \"ILSVRC 2017 画像分類 Top の手法 Squeeze-and-Excitation Networks\"\ndate: 2018-12-13T22:25:45+09:00\ntags: [\"画像処理\", \"ComputerVision\", \"MachineLearning\", \"DeepLearning\", \"CNN\"]\nurl: https://qiita.com/agatan/items/8cf2566908228eaa5450\n---\n\nILSVRC 2017 の画像分類タスクでは Squeeze-and-Excitation という手法が 1 位を記録しました。\nシンプルなアイディア・実装で、既存モデルの拡張にも利用できるうえ、精度も 2016 年の top 1 と比べてエラー率を約 25% 減らすという大きな成果をあげています。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/20b939b8-c65b-ce06-4525-37ccfe19c7a2.png)\n\n### Reference\n\n- Jie Hu, et al., https://arxiv.org/pdf/1709.01507.pdf\n\n文中の図表は論文から引用しています。\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Squeeze and Excitation\n\nこの論文では、SE block というブロックを提案しています。\nSE block は特定のネットワーク全体の設計の提案ではなく、ネットワーク中の 1 component として振る舞うものです。\nSE block を既存のいろいろなネットワークやモジュール（ResNet、Inception、...）に組み込むことで精度が向上することを実験で確かめています。\n\nSE block は非常に実装が簡単なので先に実装を見てしまったほうがわかりやすいかもしれません。\n\n```python\ndef se_block(input, channels):\n    \"\"\"\n    Args:\n        input: (N, H, W, C)\n        channels: C\n    Returns:\n        tensor: (N, H, W, C)\n    \"\"\"\n    # Squeeze\n    x = GlobalAveragePooling2D()(input)  # (N, C)\n    # Excitation\n    x = Dense(channels // 16, activation='relu')(x)\n    x = Dense(channels, activation='sigmoid')(x) # (N, C)\n    return Multiply()([input, x])\n```\n\nSE block は、通常の convolution の出力をそのまま使うのではなく、 **各 channel の出力を重み付けして使う** ようにすることで、チャンネル間の関係性の学習を可能にするブロックです。\n\n### Squeeze\n\n既存のモデルは、convolution と activation を重ねることで、局所的な特徴を獲得していきます。\n層が深くなったり pooling したりすると、局所的といいつつも広い視野を持っていくことになりますが、視野を一歩こえた先の情報などはまったく考慮できず、画像全体におけるチャンネル間の関係性を表すことはできません。\nそこで、画像全体の特徴を活用するために、 global average pooling を利用します。（Spatial Squeeze）\n\n### Excitation\n\nそうして得た「画像全体のチャンネルの状況」をいくつかの layer に通したのち、sigmoid に通します。\n最後にブロックに入力されてきた値 `input` に、 sigmoid 関数を通して 0~1 の範囲に収めた「各チャンネルの重み」を掛けて出力しています。\nこの部分が Excitation とよばれる部分です。\n\n## 既存モデルへの組み込み\n\nSE block は既存のモデルへの組み込みが容易であることも大きな強みです。\nいくつかの組み込み方が提案・実験されています。\n\n<table>\n<tr>\n<td>\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/76082379-9db4-4f02-7236-355f6804908b.png\">\n</td>\n<td>\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/4c3fa967-234c-57ee-36a9-1c15fca7c603.png\">\n</td>\n</tr>\n</table>\n\n組み込み方もシンプルで簡単に試せるのですばらしいですね。\n\n## まとめと感想\n\nかなりいろんなセットアップで実験をしているので、詳細は論文を参照ください。\nWantedly People で使われているモデルにも実験的に組みこんでみたところ、確かに数%の改善が確認できました。\nこの論文の続編的なものとして、segmentation タスクなどの fully convolutional networks 用の SE block 亜種が提案されています。\nこの advent calendar のどこかでそちらの紹介もできればと思います。\n","contentMarkdown":"\nILSVRC 2017 の画像分類タスクでは Squeeze-and-Excitation という手法が 1 位を記録しました。\nシンプルなアイディア・実装で、既存モデルの拡張にも利用できるうえ、精度も 2016 年の top 1 と比べてエラー率を約 25% 減らすという大きな成果をあげています。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/20b939b8-c65b-ce06-4525-37ccfe19c7a2.png)\n\n### Reference\n\n- Jie Hu, et al., https://arxiv.org/pdf/1709.01507.pdf\n\n文中の図表は論文から引用しています。\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Squeeze and Excitation\n\nこの論文では、SE block というブロックを提案しています。\nSE block は特定のネットワーク全体の設計の提案ではなく、ネットワーク中の 1 component として振る舞うものです。\nSE block を既存のいろいろなネットワークやモジュール（ResNet、Inception、...）に組み込むことで精度が向上することを実験で確かめています。\n\nSE block は非常に実装が簡単なので先に実装を見てしまったほうがわかりやすいかもしれません。\n\n```python\ndef se_block(input, channels):\n    \"\"\"\n    Args:\n        input: (N, H, W, C)\n        channels: C\n    Returns:\n        tensor: (N, H, W, C)\n    \"\"\"\n    # Squeeze\n    x = GlobalAveragePooling2D()(input)  # (N, C)\n    # Excitation\n    x = Dense(channels // 16, activation='relu')(x)\n    x = Dense(channels, activation='sigmoid')(x) # (N, C)\n    return Multiply()([input, x])\n```\n\nSE block は、通常の convolution の出力をそのまま使うのではなく、 **各 channel の出力を重み付けして使う** ようにすることで、チャンネル間の関係性の学習を可能にするブロックです。\n\n### Squeeze\n\n既存のモデルは、convolution と activation を重ねることで、局所的な特徴を獲得していきます。\n層が深くなったり pooling したりすると、局所的といいつつも広い視野を持っていくことになりますが、視野を一歩こえた先の情報などはまったく考慮できず、画像全体におけるチャンネル間の関係性を表すことはできません。\nそこで、画像全体の特徴を活用するために、 global average pooling を利用します。（Spatial Squeeze）\n\n### Excitation\n\nそうして得た「画像全体のチャンネルの状況」をいくつかの layer に通したのち、sigmoid に通します。\n最後にブロックに入力されてきた値 `input` に、 sigmoid 関数を通して 0~1 の範囲に収めた「各チャンネルの重み」を掛けて出力しています。\nこの部分が Excitation とよばれる部分です。\n\n## 既存モデルへの組み込み\n\nSE block は既存のモデルへの組み込みが容易であることも大きな強みです。\nいくつかの組み込み方が提案・実験されています。\n\n<table>\n<tr>\n<td>\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/76082379-9db4-4f02-7236-355f6804908b.png\">\n</td>\n<td>\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/4c3fa967-234c-57ee-36a9-1c15fca7c603.png\">\n</td>\n</tr>\n</table>\n\n組み込み方もシンプルで簡単に試せるのですばらしいですね。\n\n## まとめと感想\n\nかなりいろんなセットアップで実験をしているので、詳細は論文を参照ください。\nWantedly People で使われているモデルにも実験的に組みこんでみたところ、確かに数%の改善が確認できました。\nこの論文の続編的なものとして、segmentation タスクなどの fully convolutional networks 用の SE block 亜種が提案されています。\nこの advent calendar のどこかでそちらの紹介もできればと思います。\n","slug":"ILSVRC_2017_画像分類_Top_の手法_Squeeze-and-Excitation_Networks","title":"ILSVRC 2017 画像分類 Top の手法 Squeeze-and-Excitation Networks","timestamp":1544707545000,"tags":["画像処理","ComputerVision","MachineLearning","DeepLearning","CNN"]},{"rawMarkdown":"---\ntitle: \"Object 間の関係を使って後処理 0 の物体検出を実現する: Relation Networks for Object Detection\"\ndate: 2018-12-10T23:35:40+09:00\ntags: [\"画像処理\", \"DeepLearning\", \"論文読み\", \"物体検出\"]\nurl: https://qiita.com/agatan/items/1c2cadeaabfc9f122f6f\n---\n\nObject Detection は、一枚の画像中の「どこに」「なにが」うつっているかを当てるタスクです。\n典型的な手法では、オブジェクトごとの bounding box を予測し、それぞれがどのクラスに分類されるかを**個別で**予測します。\nまた、ひとつのオブジェクトに対してすこしずつ座標のずれた box を複数予測してしまう可能性があるという問題があり、1 object 1 box になるように重複を削除しなければなりません。\nこれには nox maximum supression という方法を使うことが多いですが、これはヒューリスティックに基づく後処理になってしまっています。\n\nこの論文では、予測した box 間の関係に着目することで、分類精度を向上し、後処理 0 の完全 End-to-End での物体検出ネットワークを構築しています。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/9b80d772-3b27-5b14-2eac-2d1c1275492e.png)\n\n（青い box について分類する際に、オレンジの box との関連が強く活用されている）\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Reference\n\n- Relation Networks for Object Detection\n  - Han Hu, Jiayuan Gu, Zheng Zhang, Jifeng Dai, Yichen Wei, et al., CVPR 2018\n- https://arxiv.org/abs/1711.11575\n\n文中の図表は論文より引用しています。\n\n## モチベーション\n\n自然言語処理の世界では、Attention module が非常に強力な武器として大活躍しており、特に Transformer[^1] 以降の SoTA モデルたちは大体 Attention の仕組みを組み込んでいるといっても良いくらいの活躍ぶりです。\n[^1]: https://arxiv.org/abs/1706.03762\n雑に言えば Attention は、ある entity と他の entity の関係性を 0~1 で出力し、その値をもとに entity を表す何らかのベクトルの加重和をとるといった操作をします。関係性を表す 0~1 を計算するためのパラメータも学習されます。\nまた画像に対応するタイトルを自動生成する Image Captioning の世界でも Attention は活躍しており、活用されるフィールドがどんどん増してきています。\n\nそこで、Attention を Object Detection の世界にもってこよう、というのがこの論文です。\nAttention module を用いて box 間の関係性を表し、object detection の精度向上を達成しています。\n\n## End-to-End\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/4c30de7e-8f64-60fb-0bd6-712c33a990df.png)\n\n概観でいうと Region Proposal network + RoI Pooling + relation module という構造を採用しています。\nrelation module は box 間の attention をとる module です。\n\n完全に後処理をなくすためには、大量の box のなかから採用すべき box だけを残す必要があります。（通常は non maximum supression で、スコアの高い box を優先的に残しつつ、重複した領域の大きい box はすてる）\nそこでこの論文では、Attention module をいくつか通したのち、box ごとに 0~1 の値を出力し、残すべき box は 1 になり捨てるべき box は 0 になるように学習します。\n\n## Object Relation Module\n\n物体間の関係には 2 つの意味があります。1 つは意味的な関連で、もう一つは座標的な関連です。\nボールっぽいものとバットっぽいものがあったとしても、ものすごく離れた場所にあるのであれば無関係かもしれないですが、近くにあればきっとボールとバットのペアと予測するのが正しそうです。\nしかし、通常の attention は、意味的な関連しか扱えていません。すべての box をなんらかの vector にしてしまっていますし、convolution や pooling は座標に依存しない操作なのでその vector に座標そのものの情報は埋め込まれません。\n\nそこでこの論文ではふつうの Attention をちょっといじった object relation module というものを提案しています。\n\n物体 m, n 間の attention を算出する式を見てみます。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/2e19515d-72ea-f065-e517-f8c7fe466fb8.png\" width=\"50%\">\n\n$\\omega_A^{mn}$ は通常の Attention と同じで、object m と n を表すベクトル（を線形変換したもの）の内積です。\n$\\omega_G$ の部分を無視すれば、この式は単に各 object ごとに内積をとったものを softmax にかけている = ふつうの Attention の計算式と一致します。\n\n$\\omega_G$ は、座標的な関係を考慮するためのパラメータです。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/9a24daf8-38cc-a765-af2f-7efa141cdad9.png\" width=\"50%\">\n\n$f_G^m$ は object m の座標情報 (x,y, w, h) を表します。\n$\\varepsilon_G$ はふたつの object の座標情報からそれらの座標的関係を計算する関数です。\n\n```math\n\\varepsilon(f_G^m, f_G^n) = (\\log(\\frac{|x_m - x_n|}{w_m}), \\log(\\frac{|y_m - y_n|}{h_m}), \\log(\\frac{w_n}{w_m}), \\log(\\frac{h_n}{h_m}))\n```\n\nさらに、 $max{0, ...}$ をとることで、ReLU 的な働きをし、まったく座標的に関係のない object からの影響を 0 にしています。\n\n## まとめと感想\n\n実験と結果はもと論文を読むのが一番くわしいのでそちらを参照ください。\n「一枚の画像から X を取得したいが、画像の主体となるような X だけを取りたい」といったケースにも応用できる手法かなと思っていて、実験してみたいと思いつつ、本当に end-to-end でやるのはちょっと大変そうすぎるという印象もあります。\n（また論文中には end-to-end が 0 から学習する際の問題にも触れられています。）\nとはいえ完全に end-to-end というのはやっぱり夢があって好きです。\n","contentMarkdown":"\nObject Detection は、一枚の画像中の「どこに」「なにが」うつっているかを当てるタスクです。\n典型的な手法では、オブジェクトごとの bounding box を予測し、それぞれがどのクラスに分類されるかを**個別で**予測します。\nまた、ひとつのオブジェクトに対してすこしずつ座標のずれた box を複数予測してしまう可能性があるという問題があり、1 object 1 box になるように重複を削除しなければなりません。\nこれには nox maximum supression という方法を使うことが多いですが、これはヒューリスティックに基づく後処理になってしまっています。\n\nこの論文では、予測した box 間の関係に着目することで、分類精度を向上し、後処理 0 の完全 End-to-End での物体検出ネットワークを構築しています。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/9b80d772-3b27-5b14-2eac-2d1c1275492e.png)\n\n（青い box について分類する際に、オレンジの box との関連が強く活用されている）\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n## Reference\n\n- Relation Networks for Object Detection\n  - Han Hu, Jiayuan Gu, Zheng Zhang, Jifeng Dai, Yichen Wei, et al., CVPR 2018\n- https://arxiv.org/abs/1711.11575\n\n文中の図表は論文より引用しています。\n\n## モチベーション\n\n自然言語処理の世界では、Attention module が非常に強力な武器として大活躍しており、特に Transformer[^1] 以降の SoTA モデルたちは大体 Attention の仕組みを組み込んでいるといっても良いくらいの活躍ぶりです。\n[^1]: https://arxiv.org/abs/1706.03762\n雑に言えば Attention は、ある entity と他の entity の関係性を 0~1 で出力し、その値をもとに entity を表す何らかのベクトルの加重和をとるといった操作をします。関係性を表す 0~1 を計算するためのパラメータも学習されます。\nまた画像に対応するタイトルを自動生成する Image Captioning の世界でも Attention は活躍しており、活用されるフィールドがどんどん増してきています。\n\nそこで、Attention を Object Detection の世界にもってこよう、というのがこの論文です。\nAttention module を用いて box 間の関係性を表し、object detection の精度向上を達成しています。\n\n## End-to-End\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/4c30de7e-8f64-60fb-0bd6-712c33a990df.png)\n\n概観でいうと Region Proposal network + RoI Pooling + relation module という構造を採用しています。\nrelation module は box 間の attention をとる module です。\n\n完全に後処理をなくすためには、大量の box のなかから採用すべき box だけを残す必要があります。（通常は non maximum supression で、スコアの高い box を優先的に残しつつ、重複した領域の大きい box はすてる）\nそこでこの論文では、Attention module をいくつか通したのち、box ごとに 0~1 の値を出力し、残すべき box は 1 になり捨てるべき box は 0 になるように学習します。\n\n## Object Relation Module\n\n物体間の関係には 2 つの意味があります。1 つは意味的な関連で、もう一つは座標的な関連です。\nボールっぽいものとバットっぽいものがあったとしても、ものすごく離れた場所にあるのであれば無関係かもしれないですが、近くにあればきっとボールとバットのペアと予測するのが正しそうです。\nしかし、通常の attention は、意味的な関連しか扱えていません。すべての box をなんらかの vector にしてしまっていますし、convolution や pooling は座標に依存しない操作なのでその vector に座標そのものの情報は埋め込まれません。\n\nそこでこの論文ではふつうの Attention をちょっといじった object relation module というものを提案しています。\n\n物体 m, n 間の attention を算出する式を見てみます。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/2e19515d-72ea-f065-e517-f8c7fe466fb8.png\" width=\"50%\">\n\n$\\omega_A^{mn}$ は通常の Attention と同じで、object m と n を表すベクトル（を線形変換したもの）の内積です。\n$\\omega_G$ の部分を無視すれば、この式は単に各 object ごとに内積をとったものを softmax にかけている = ふつうの Attention の計算式と一致します。\n\n$\\omega_G$ は、座標的な関係を考慮するためのパラメータです。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/9a24daf8-38cc-a765-af2f-7efa141cdad9.png\" width=\"50%\">\n\n$f_G^m$ は object m の座標情報 (x,y, w, h) を表します。\n$\\varepsilon_G$ はふたつの object の座標情報からそれらの座標的関係を計算する関数です。\n\n```math\n\\varepsilon(f_G^m, f_G^n) = (\\log(\\frac{|x_m - x_n|}{w_m}), \\log(\\frac{|y_m - y_n|}{h_m}), \\log(\\frac{w_n}{w_m}), \\log(\\frac{h_n}{h_m}))\n```\n\nさらに、 $max{0, ...}$ をとることで、ReLU 的な働きをし、まったく座標的に関係のない object からの影響を 0 にしています。\n\n## まとめと感想\n\n実験と結果はもと論文を読むのが一番くわしいのでそちらを参照ください。\n「一枚の画像から X を取得したいが、画像の主体となるような X だけを取りたい」といったケースにも応用できる手法かなと思っていて、実験してみたいと思いつつ、本当に end-to-end でやるのはちょっと大変そうすぎるという印象もあります。\n（また論文中には end-to-end が 0 から学習する際の問題にも触れられています。）\nとはいえ完全に end-to-end というのはやっぱり夢があって好きです。\n","slug":"Object_間の関係を使って後処理_0_の物体検出を実現する:_Relation_Networks_for_Object_Detection","title":"Object 間の関係を使って後処理 0 の物体検出を実現する: Relation Networks for Object Detection","timestamp":1544452540000,"tags":["画像処理","DeepLearning","論文読み","物体検出"]},{"rawMarkdown":"---\ntitle: \"簡単な問題は省エネで解き、難しい問題には全力を出すネットワーク: Multi-Scale Dense Networks\"\ndate: 2018-12-07T22:34:37+09:00\ntags: [\"DeepLearning\", \"論文読み\"]\nurl: https://qiita.com/agatan/items/9ea14206bf7a3881ed6d\n---\n\nCNN による画像分類を現実のアプリケーションで使う際には、限られた計算資源で推論をする必要があります。\n推論を待って処理するような場合は latency が重要になり、バッチ処理でも throughput を最大化したいという要求があります。\n\n各タスクで SoTA を達成しているようなモデルはとても Deep であり、毎回走らせるには大きすぎます。\nとはいえ浅いネットワークでは精度に限界もあるので、速度と精度のトレードオフを常に考える必要があります。\n計算量を抑えつつ精度を向上するネットワークを設計する、という方向で MobileNet や SqueezeNet などが提案されています。\n\n今回紹介する論文は、ちょっと別のアプローチで計算資源の問題に立ち向かっています。\nひとことでまとめると **分類が十分に簡単だった場合は早期 exit し、難しいケースだけ深く計算する** という構造をとります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/763043e9-c89d-1521-011a-2ae6905eb2fe.png)\n\n（この図の \"easy\" と書かれている行の画像は省エネで、 \"hard\" と書かれている行の画像は全力で予測する）\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n### Reference\n\n- Multi-Scale Dense Networks for Resource Efficient Image Classification - Gao Huang, Danlu Chen, Tianhong Li, Felix Wu, Laurens van der Maaten, Kilian Q. Weinberger, et al., ICLR 2018\n- https://arxiv.org/abs/1703.09844\n\n文中の図表は論文より引用しています。\n\n### モチベーション\n\n先にも書きましたが、DNN は計算量の大きなアルゴリズムであり、実際に利用するケースを考えると、その速度や計算効率が気になってきます。\n現実の入力画像は様々な難易度のものがあるので、簡単な画像は浅いネットワークで解きたくなりますし、難しい画像は深いネットワークで解きたくなります。\n\nこう表現すると単純そうに見えますが、これを実現するためには「この画像は簡単か（浅いネットワークで解くべきか）、難しいか（深いネットワークで解くべきか）」を決定しなければなりません。\n実際に解く前に難易度を推定するのは難しく、事前に 2 つの model を定義しておく方法ではうまくいきません。\n\nMulti-Scale Dense Networks は、ひとつのモデルで逐次的に推論結果を出しつつ、十分に精度が出せそうであれば早期に Exit し、それ以降の計算を省略します。\n\n### アーキテクチャ\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/c6304ac6-1ccc-369b-0de0-2654fe5cef8d.png)\n↑ がモデルのイメージです。\n`classifier` と書かれた module が複数回出てきているように、それぞれが逐次的な推論結果を出す module になります。\n\nこのような構造を単純にとると以下の２点が問題になります。\n\n1. 粒度の大きい特徴を捉えづらい\n2. 浅い層の classifier が深い層の classifier の精度を下げてしまう\n\n#### 粒度の大きい特徴を捉えづらい\n\n典型的な画像分類のネットワークでは、浅い層で細かい粒度の特徴を獲得し、多くの Convolution や Pooling を経たあとの深い層で荒い粒度の特徴を獲得しています。\n浅い層で分類をやってしまうと解像度の大きい特徴を獲得することができていないため、エラー率が高くなってしまいます。\n次の図は、 ResNet や DenseNet の浅い層に分類器をつけて学習させた場合のエラー率をプロットしています。（損失関数は最終層の分類器の損失と浅い層の分類器の損失の和です。）\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/f0488839-0129-0b45-74c4-159779694ade.png\" width=\"60%\">\n\n横軸は全体の深さに対して「どの深さに分類器をつけるか」を表しています。\n浅い層につけた分類器ほどエラー率が高くなっていることがわかります。\n\nreceptive field を大きく取った視野の広い特徴を効率的に獲得するためには feature map の解像度を下げる operation （2x2, stride 2 の convolution や pooling など）がよく使われますが、浅いうちにそれらの operation をやってしまうと、細かい粒度の特徴を獲得しづらくなってしまいます。\n\n##### 解決策\n\nMulti-Scale Dense Networks では、複数の解像度の feature map を各深さごとに用意するという解決方法をとっています。\nアーキテクチャの全体像の図で縦に 3 種類のスケールの feature map が並んでいます。\n各層では、以下の２つの operation の concatenate を分類器につなげます。\n\n1. 一つ前の層のもっとも解像度の低い feature map\n2. 一つ前の層の一段細かい feature map を畳み込んで解像度を荒くしたもの\n\nこれによって、細かい粒度の特徴の獲得を維持しつつ、視野の広い特徴を分類器に流すことを可能にしています。\n\n#### 浅い層の classifier が深い層の classifier の精度を下げてしまう\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/9dd54945-ba86-d438-882b-9636fced2451.png\" width=\"60%\">\n\nこのグラフは ResNet や DenseNet の浅い層に分類器をつけたときの **最終層の分類器の精度** を表したものです。\n縦軸は最終層の分類器のみで学習したときの精度の相対精度です。\n特に ResNet で顕著ですが、浅い層に分類器をつけてしまうと **最終層の分類器の精度が悪くなる** ことがわかります。\n浅い層の分類器を最適化するために、細かい粒度の特徴が失われ、深い層にその特徴が伝わらないことが問題になっています。\n\n##### 解決策\n\n**Dense connectivity** によってこの問題を解決しています。\nDense connectiviy は DenseNet で提案されたもので、あるブロック内の中間層をすべて concatenate するブロックです。\nResNet で提案された Residual Module は、入力とそれを convolution などに通したものを足し合わせるというものでしたが、更にその考えを推し進めたのが DenseNet です。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/d19184ee-8412-8705-e8a6-b92f1ab00108.png)\n\nこれによって、浅い層の結果がそのまま深い層に直結するため、一度細かい特徴を失っても浅い層の出力で recovery することができます。\n\n### まとめと感想\n\n僕らも Wantedly People というスマートフォンのカメラを使ったアプリケーションを提供しているので、モバイル上での推論をしたいというモチベーションがあって読んだ論文でした。\nDenseNet の特徴をきれいに活用していて面白い論文だなと思いました。\nDenseBlock の有効性をちゃんと検証していてこの論文の提案のいいところがわかりやすいのも好きなところです。\n","contentMarkdown":"\nCNN による画像分類を現実のアプリケーションで使う際には、限られた計算資源で推論をする必要があります。\n推論を待って処理するような場合は latency が重要になり、バッチ処理でも throughput を最大化したいという要求があります。\n\n各タスクで SoTA を達成しているようなモデルはとても Deep であり、毎回走らせるには大きすぎます。\nとはいえ浅いネットワークでは精度に限界もあるので、速度と精度のトレードオフを常に考える必要があります。\n計算量を抑えつつ精度を向上するネットワークを設計する、という方向で MobileNet や SqueezeNet などが提案されています。\n\n今回紹介する論文は、ちょっと別のアプローチで計算資源の問題に立ち向かっています。\nひとことでまとめると **分類が十分に簡単だった場合は早期 exit し、難しいケースだけ深く計算する** という構造をとります。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/763043e9-c89d-1521-011a-2ae6905eb2fe.png)\n\n（この図の \"easy\" と書かれている行の画像は省エネで、 \"hard\" と書かれている行の画像は全力で予測する）\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n### Reference\n\n- Multi-Scale Dense Networks for Resource Efficient Image Classification - Gao Huang, Danlu Chen, Tianhong Li, Felix Wu, Laurens van der Maaten, Kilian Q. Weinberger, et al., ICLR 2018\n- https://arxiv.org/abs/1703.09844\n\n文中の図表は論文より引用しています。\n\n### モチベーション\n\n先にも書きましたが、DNN は計算量の大きなアルゴリズムであり、実際に利用するケースを考えると、その速度や計算効率が気になってきます。\n現実の入力画像は様々な難易度のものがあるので、簡単な画像は浅いネットワークで解きたくなりますし、難しい画像は深いネットワークで解きたくなります。\n\nこう表現すると単純そうに見えますが、これを実現するためには「この画像は簡単か（浅いネットワークで解くべきか）、難しいか（深いネットワークで解くべきか）」を決定しなければなりません。\n実際に解く前に難易度を推定するのは難しく、事前に 2 つの model を定義しておく方法ではうまくいきません。\n\nMulti-Scale Dense Networks は、ひとつのモデルで逐次的に推論結果を出しつつ、十分に精度が出せそうであれば早期に Exit し、それ以降の計算を省略します。\n\n### アーキテクチャ\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/c6304ac6-1ccc-369b-0de0-2654fe5cef8d.png)\n↑ がモデルのイメージです。\n`classifier` と書かれた module が複数回出てきているように、それぞれが逐次的な推論結果を出す module になります。\n\nこのような構造を単純にとると以下の２点が問題になります。\n\n1. 粒度の大きい特徴を捉えづらい\n2. 浅い層の classifier が深い層の classifier の精度を下げてしまう\n\n#### 粒度の大きい特徴を捉えづらい\n\n典型的な画像分類のネットワークでは、浅い層で細かい粒度の特徴を獲得し、多くの Convolution や Pooling を経たあとの深い層で荒い粒度の特徴を獲得しています。\n浅い層で分類をやってしまうと解像度の大きい特徴を獲得することができていないため、エラー率が高くなってしまいます。\n次の図は、 ResNet や DenseNet の浅い層に分類器をつけて学習させた場合のエラー率をプロットしています。（損失関数は最終層の分類器の損失と浅い層の分類器の損失の和です。）\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/f0488839-0129-0b45-74c4-159779694ade.png\" width=\"60%\">\n\n横軸は全体の深さに対して「どの深さに分類器をつけるか」を表しています。\n浅い層につけた分類器ほどエラー率が高くなっていることがわかります。\n\nreceptive field を大きく取った視野の広い特徴を効率的に獲得するためには feature map の解像度を下げる operation （2x2, stride 2 の convolution や pooling など）がよく使われますが、浅いうちにそれらの operation をやってしまうと、細かい粒度の特徴を獲得しづらくなってしまいます。\n\n##### 解決策\n\nMulti-Scale Dense Networks では、複数の解像度の feature map を各深さごとに用意するという解決方法をとっています。\nアーキテクチャの全体像の図で縦に 3 種類のスケールの feature map が並んでいます。\n各層では、以下の２つの operation の concatenate を分類器につなげます。\n\n1. 一つ前の層のもっとも解像度の低い feature map\n2. 一つ前の層の一段細かい feature map を畳み込んで解像度を荒くしたもの\n\nこれによって、細かい粒度の特徴の獲得を維持しつつ、視野の広い特徴を分類器に流すことを可能にしています。\n\n#### 浅い層の classifier が深い層の classifier の精度を下げてしまう\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/9dd54945-ba86-d438-882b-9636fced2451.png\" width=\"60%\">\n\nこのグラフは ResNet や DenseNet の浅い層に分類器をつけたときの **最終層の分類器の精度** を表したものです。\n縦軸は最終層の分類器のみで学習したときの精度の相対精度です。\n特に ResNet で顕著ですが、浅い層に分類器をつけてしまうと **最終層の分類器の精度が悪くなる** ことがわかります。\n浅い層の分類器を最適化するために、細かい粒度の特徴が失われ、深い層にその特徴が伝わらないことが問題になっています。\n\n##### 解決策\n\n**Dense connectivity** によってこの問題を解決しています。\nDense connectiviy は DenseNet で提案されたもので、あるブロック内の中間層をすべて concatenate するブロックです。\nResNet で提案された Residual Module は、入力とそれを convolution などに通したものを足し合わせるというものでしたが、更にその考えを推し進めたのが DenseNet です。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/d19184ee-8412-8705-e8a6-b92f1ab00108.png)\n\nこれによって、浅い層の結果がそのまま深い層に直結するため、一度細かい特徴を失っても浅い層の出力で recovery することができます。\n\n### まとめと感想\n\n僕らも Wantedly People というスマートフォンのカメラを使ったアプリケーションを提供しているので、モバイル上での推論をしたいというモチベーションがあって読んだ論文でした。\nDenseNet の特徴をきれいに活用していて面白い論文だなと思いました。\nDenseBlock の有効性をちゃんと検証していてこの論文の提案のいいところがわかりやすいのも好きなところです。\n","slug":"簡単な問題は省エネで解き、難しい問題には全力を出すネットワーク:_Multi-Scale_Dense_Networks","title":"簡単な問題は省エネで解き、難しい問題には全力を出すネットワーク: Multi-Scale Dense Networks","timestamp":1544189677000,"tags":["DeepLearning","論文読み"]},{"rawMarkdown":"---\ntitle: \"[論文紹介] Focal Loss for Dense Object Detection\"\ndate: 2018-12-03\ntags:\n  - MachineLearning\n  - paper\n---\n\n高速かつ高精度に物体検出を行う RetinaNet に使われている **Focal Loss** という損失関数を提案した論文を読んだので紹介します。\nFAIR(Facebook AI Research) が書いた論文で ICCV 2017 に採択されています。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/38ab1ef6-c4c5-fd78-d903-0954479143a6.png\" width=\"60%\">\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n#### Reference\n\n- Focal Loss for Dense Object Detection [Tsung-Yi Lin, Priya Goyal, Ross Girshick, Kaiming He, Piotr Dollár @ ICCV 2017]\n- https://arxiv.org/abs/1708.02002\n\n（文中の図表は論文より引用）\n\n### モチベーション\n\n精度の良い object detector の多くは R-CNN[^1] ベースの two-stage object detector の構成を取っています。\n[^1]: [Rich feature hierarchies for accurate object detection and semantic segmentation](https://arxiv.org/abs/1311.2524) [Ross Girshick, et al.]\nR-CNN は、 まず物体のある bounding box の候補集合を提案し、その後 2nd stage で提案された各 box について classification を行うという構成になっています。\ntwo-stage object detector は高い精度を記録していますが、一方で複雑さと推論速度に問題がありました。\n\nそこで、 YOLO[^2][^3] や SSD[^4][^5] のような one-stage で高速に物体検出を行うネットワークが提案されてきました。\n[^2]: [You Only Look Once: Unified, Real-Time Object Detection](https://arxiv.org/abs/1506.02640) [J. Redmon, et al.]\n[^3]: [YOLO9000: Better, Faster, Stronger](https://arxiv.org/abs/1612.08242) [J. Redmon, et al.]\n[^4]: [SSD: Single Shot MultiBox Detector](https://arxiv.org/abs/1512.02325) [W. Liu, et al.]\n[^5]: [DSSD : Deconvolutional Single Shot Detector](https://arxiv.org/abs/1701.06659) [C.-Y. Fu, et al.]\n\nしかし、これらの one-stage detector は高速な一方で（当時の） state-of-the-art methods と比べると精度は劣るという課題がありました。\n\nこの論文では one-stage detector が two-stage detector と並ぶ精度を出せないのは「クラス間の不均衡」が原因であるという仮説をたてています。\n画像のほとんどの pixel は background であり、foreground（背景以外のクラス）に属する pixel の数と比べると圧倒的な不均衡があるため、学習のほとんどが簡単な background 判定に支配されてしまいます。\n（two-stage の場合は 1st stage で注目すべき部分を限定しているため、background の多くは 1st stage でフィルタリングされ、2nd stage は不均衡が解決された状態で学習することができます。）\n\nそこで登場するのが **Focal Loss** です。\n\n### Focal Loss\n\nFocal Loss は通常の cross entropy loss (CE) を動的に scaling させる損失関数です。\n通常の CE と比較したのが次の図です。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/77bb8c08-0a47-d77a-fed7-17038e29a8cf.png\" width=\"60%\">\n\n通常の CE は以下のようなものです(binary cross entropy の場合）。\n\n```math\n{\\rm CE}(p_t) = -{\\rm log}(p_t).  \\\\\n\np_t = \\left\\{\n\\begin{array}{ll}\np & {\\rm if}\\: y = 1 \\\\\n1 - p & {\\rm otherwise.} \\\\\n\\end{array}\n\\right.\n```\n\nさきほどの図の `γ = 0` の青い曲線は通常の CE を `p` を x 軸にグラフにしたものです。\n図からわかるように、 0.6 といった十分に分類できている probability を出力したとしても、損失は無視できない値になっています。\nそのため、簡単に background と分類できていても大量の exmaple が積み重なって、 foreground の損失よりも強くなってしまいます。\n\nFocal Loss は、easy example （簡単に分類に成功している example）の損失を小さく scale します。\n\n```math\n{\\rm FL}(p_t) = -(1 - p_t) ^ \\gamma {\\rm log} (p_t).\n```\n\n`γ` はパラメータで、どのくらい easy example の損失を decay するかを決定します。\n簡単に分類に成功している example では\n\n```math\n(1 - p_t) ^ \\gamma\n```\n\nが小さい値になるため、損失への寄与が小さくなります。\nこれによって、より難しい focus すべき example が学習に強く寄与できるようになります。\n（論文中の実験では `γ = 2` を採用しています。）\n\nこの論文では RetinaNet というアーキテクチャを設計し Focal Loss を用いて学習させています。\nRetinaNet の設計の詳細は省きますが、精度を既存の object detector と比較したのが冒頭の図と次の表です。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/d711797c-f160-08c3-97b8-027f34bbf373.png)\n\ntwo-stage detector と同等（以上）の精度を達成しています。\n\n### 感想\n\nアイディアがシンプルで、 object detection 以外のタスクに対しても応用可能な手法ですごく好きな論文です。\n実装も簡単なので試しやすく良い結果がでたので、何度かお世話になっています。\n\nちなみにこの論文のあとに書かれた YOLOv3[^6] では Focal Loss を採用していませんが、 RetinaNet と精度・速度を比較していて Focal Loss に関する考察も書かれています。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/d2caf698-0c58-c03d-4fa4-085e63ccb24c.png\" width=\"60%\">\n\n[^6]: [YOLOv3: An Incremental Improvement](https://arxiv.org/abs/1804.02767) [J. Redmon, et al.]\n\nまた、facebook が公開している [Detectron](https://github.com/facebookresearch/Detectron) にも RetineNet の実装が含まれているので簡単に利用することもできそうです。\n","contentMarkdown":"\n高速かつ高精度に物体検出を行う RetinaNet に使われている **Focal Loss** という損失関数を提案した論文を読んだので紹介します。\nFAIR(Facebook AI Research) が書いた論文で ICCV 2017 に採択されています。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/38ab1ef6-c4c5-fd78-d903-0954479143a6.png\" width=\"60%\">\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n#### Reference\n\n- Focal Loss for Dense Object Detection [Tsung-Yi Lin, Priya Goyal, Ross Girshick, Kaiming He, Piotr Dollár @ ICCV 2017]\n- https://arxiv.org/abs/1708.02002\n\n（文中の図表は論文より引用）\n\n### モチベーション\n\n精度の良い object detector の多くは R-CNN[^1] ベースの two-stage object detector の構成を取っています。\n[^1]: [Rich feature hierarchies for accurate object detection and semantic segmentation](https://arxiv.org/abs/1311.2524) [Ross Girshick, et al.]\nR-CNN は、 まず物体のある bounding box の候補集合を提案し、その後 2nd stage で提案された各 box について classification を行うという構成になっています。\ntwo-stage object detector は高い精度を記録していますが、一方で複雑さと推論速度に問題がありました。\n\nそこで、 YOLO[^2][^3] や SSD[^4][^5] のような one-stage で高速に物体検出を行うネットワークが提案されてきました。\n[^2]: [You Only Look Once: Unified, Real-Time Object Detection](https://arxiv.org/abs/1506.02640) [J. Redmon, et al.]\n[^3]: [YOLO9000: Better, Faster, Stronger](https://arxiv.org/abs/1612.08242) [J. Redmon, et al.]\n[^4]: [SSD: Single Shot MultiBox Detector](https://arxiv.org/abs/1512.02325) [W. Liu, et al.]\n[^5]: [DSSD : Deconvolutional Single Shot Detector](https://arxiv.org/abs/1701.06659) [C.-Y. Fu, et al.]\n\nしかし、これらの one-stage detector は高速な一方で（当時の） state-of-the-art methods と比べると精度は劣るという課題がありました。\n\nこの論文では one-stage detector が two-stage detector と並ぶ精度を出せないのは「クラス間の不均衡」が原因であるという仮説をたてています。\n画像のほとんどの pixel は background であり、foreground（背景以外のクラス）に属する pixel の数と比べると圧倒的な不均衡があるため、学習のほとんどが簡単な background 判定に支配されてしまいます。\n（two-stage の場合は 1st stage で注目すべき部分を限定しているため、background の多くは 1st stage でフィルタリングされ、2nd stage は不均衡が解決された状態で学習することができます。）\n\nそこで登場するのが **Focal Loss** です。\n\n### Focal Loss\n\nFocal Loss は通常の cross entropy loss (CE) を動的に scaling させる損失関数です。\n通常の CE と比較したのが次の図です。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/77bb8c08-0a47-d77a-fed7-17038e29a8cf.png\" width=\"60%\">\n\n通常の CE は以下のようなものです(binary cross entropy の場合）。\n\n```math\n{\\rm CE}(p_t) = -{\\rm log}(p_t).  \\\\\n\np_t = \\left\\{\n\\begin{array}{ll}\np & {\\rm if}\\: y = 1 \\\\\n1 - p & {\\rm otherwise.} \\\\\n\\end{array}\n\\right.\n```\n\nさきほどの図の `γ = 0` の青い曲線は通常の CE を `p` を x 軸にグラフにしたものです。\n図からわかるように、 0.6 といった十分に分類できている probability を出力したとしても、損失は無視できない値になっています。\nそのため、簡単に background と分類できていても大量の exmaple が積み重なって、 foreground の損失よりも強くなってしまいます。\n\nFocal Loss は、easy example （簡単に分類に成功している example）の損失を小さく scale します。\n\n```math\n{\\rm FL}(p_t) = -(1 - p_t) ^ \\gamma {\\rm log} (p_t).\n```\n\n`γ` はパラメータで、どのくらい easy example の損失を decay するかを決定します。\n簡単に分類に成功している example では\n\n```math\n(1 - p_t) ^ \\gamma\n```\n\nが小さい値になるため、損失への寄与が小さくなります。\nこれによって、より難しい focus すべき example が学習に強く寄与できるようになります。\n（論文中の実験では `γ = 2` を採用しています。）\n\nこの論文では RetinaNet というアーキテクチャを設計し Focal Loss を用いて学習させています。\nRetinaNet の設計の詳細は省きますが、精度を既存の object detector と比較したのが冒頭の図と次の表です。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/d711797c-f160-08c3-97b8-027f34bbf373.png)\n\ntwo-stage detector と同等（以上）の精度を達成しています。\n\n### 感想\n\nアイディアがシンプルで、 object detection 以外のタスクに対しても応用可能な手法ですごく好きな論文です。\n実装も簡単なので試しやすく良い結果がでたので、何度かお世話になっています。\n\nちなみにこの論文のあとに書かれた YOLOv3[^6] では Focal Loss を採用していませんが、 RetinaNet と精度・速度を比較していて Focal Loss に関する考察も書かれています。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/d2caf698-0c58-c03d-4fa4-085e63ccb24c.png\" width=\"60%\">\n\n[^6]: [YOLOv3: An Incremental Improvement](https://arxiv.org/abs/1804.02767) [J. Redmon, et al.]\n\nまた、facebook が公開している [Detectron](https://github.com/facebookresearch/Detectron) にも RetineNet の実装が含まれているので簡単に利用することもできそうです。\n","slug":"focal-loss","title":"[論文紹介] Focal Loss for Dense Object Detection","timestamp":1543795200000,"tags":["MachineLearning","paper"]},{"rawMarkdown":"---\ntitle: \"[論文紹介] Focal Loss for Dense Object Detection\"\ndate: 2018-12-02T18:41:00+09:00\ntags: [\"DeepLearning\", \"論文読み\", \"ICCV\"]\nurl: https://qiita.com/agatan/items/53fe8d21f2147b0ac982\n---\n\n高速かつ高精度に物体検出を行う RetinaNet に使われている **Focal Loss** という損失関数を提案した論文を読んだので紹介します。\nFAIR(Facebook AI Research) が書いた論文で ICCV 2017 に採択されています。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/38ab1ef6-c4c5-fd78-d903-0954479143a6.png\" width=\"60%\">\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n#### Reference\n\n- Focal Loss for Dense Object Detection [Tsung-Yi Lin, Priya Goyal, Ross Girshick, Kaiming He, Piotr Dollár @ ICCV 2017]\n- https://arxiv.org/abs/1708.02002\n\n（文中の図表は論文より引用）\n\n### モチベーション\n\n精度の良い object detector の多くは R-CNN[^1] ベースの two-stage object detector の構成を取っています。\n[^1]: [Rich feature hierarchies for accurate object detection and semantic segmentation](https://arxiv.org/abs/1311.2524) [Ross Girshick, et al.]\nR-CNN は、 まず物体のある bounding box の候補集合を提案し、その後 2nd stage で提案された各 box について classification を行うという構成になっています。\ntwo-stage object detector は高い精度を記録していますが、一方で複雑さと推論速度に問題がありました。\n\nそこで、 YOLO[^2][^3] や SSD[^4][^5] のような one-stage で高速に物体検出を行うネットワークが提案されてきました。\n[^2]: [You Only Look Once: Unified, Real-Time Object Detection](https://arxiv.org/abs/1506.02640) [J. Redmon, et al.]\n[^3]: [YOLO9000: Better, Faster, Stronger](https://arxiv.org/abs/1612.08242) [J. Redmon, et al.]\n[^4]: [SSD: Single Shot MultiBox Detector](https://arxiv.org/abs/1512.02325) [W. Liu, et al.]\n[^5]: [DSSD : Deconvolutional Single Shot Detector](https://arxiv.org/abs/1701.06659) [C.-Y. Fu, et al.]\n\nしかし、これらの one-stage detector は高速な一方で（当時の） state-of-the-art methods と比べると精度は劣るという課題がありました。\n\nこの論文では one-stage detector が two-stage detector と並ぶ精度を出せないのは「クラス間の不均衡」が原因であるという仮説をたてています。\n画像のほとんどの pixel は background であり、foreground（背景以外のクラス）に属する pixel の数と比べると圧倒的な不均衡があるため、学習のほとんどが簡単な background 判定に支配されてしまいます。\n（two-stage の場合は 1st stage で注目すべき部分を限定しているため、background の多くは 1st stage でフィルタリングされ、2nd stage は不均衡が解決された状態で学習することができます。）\n\nそこで登場するのが **Focal Loss** です。\n\n### Focal Loss\n\nFocal Loss は通常の cross entropy loss (CE) を動的に scaling させる損失関数です。\n通常の CE と比較したのが次の図です。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/77bb8c08-0a47-d77a-fed7-17038e29a8cf.png\" width=\"60%\">\n\n通常の CE は以下のようなものです(binary cross entropy の場合）。\n\n```math\n{\\rm CE}(p_t) = -{\\rm log}(p_t).  \\\\\n\np_t = \\left\\{\n\\begin{array}{ll}\np & {\\rm if}\\: y = 1 \\\\\n1 - p & {\\rm otherwise.} \\\\\n\\end{array}\n\\right.\n```\n\nさきほどの図の `γ = 0` の青い曲線は通常の CE を `p` を x 軸にグラフにしたものです。\n図からわかるように、 0.6 といった十分に分類できている probability を出力したとしても、損失は無視できない値になっています。\nそのため、簡単に background と分類できていても大量の exmaple が積み重なって、 foreground の損失よりも強くなってしまいます。\n\nFocal Loss は、easy example （簡単に分類に成功している example）の損失を小さく scale します。\n\n```math\n{\\rm FL}(p_t) = -(1 - p_t) ^ \\gamma {\\rm log} (p_t).\n```\n\n`γ` はパラメータで、どのくらい easy example の損失を decay するかを決定します。\n簡単に分類に成功している example では\n\n```math\n(1 - p_t) ^ \\gamma\n```\n\nが小さい値になるため、損失への寄与が小さくなります。\nこれによって、より難しい focus すべき example が学習に強く寄与できるようになります。\n（論文中の実験では `γ = 2` を採用しています。）\n\nこの論文では RetinaNet というアーキテクチャを設計し Focal Loss を用いて学習させています。\nRetinaNet の設計の詳細は省きますが、精度を既存の object detector と比較したのが冒頭の図と次の表です。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/d711797c-f160-08c3-97b8-027f34bbf373.png)\n\ntwo-stage detector と同等（以上）の精度を達成しています。\n\n### 感想\n\nアイディアがシンプルで、 object detection 以外のタスクに対しても応用可能な手法ですごく好きな論文です。\n実装も簡単なので試しやすく良い結果がでたので、何度かお世話になっています。\n\nちなみにこの論文のあとに書かれた YOLOv3[^6] では Focal Loss を採用していませんが、 RetinaNet と精度・速度を比較していて Focal Loss に関する考察も書かれています。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/d2caf698-0c58-c03d-4fa4-085e63ccb24c.png\" width=\"60%\">\n\n[^6]: [YOLOv3: An Incremental Improvement](https://arxiv.org/abs/1804.02767) [J. Redmon, et al.]\n\nまた、facebook が公開している [Detectron](https://github.com/facebookresearch/Detectron) にも RetineNet の実装が含まれているので簡単に利用することもできそうです。\n","contentMarkdown":"\n高速かつ高精度に物体検出を行う RetinaNet に使われている **Focal Loss** という損失関数を提案した論文を読んだので紹介します。\nFAIR(Facebook AI Research) が書いた論文で ICCV 2017 に採択されています。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/38ab1ef6-c4c5-fd78-d903-0954479143a6.png\" width=\"60%\">\n\nこの記事は、Wantedly の勉強会で取り上げられた論文・技術をまとめたものです。\n[2018 年に読んだ機械学習系論文・技術まとめ at Wantedly Advent Calendar 2018 - Qiita](https://qiita.com/advent-calendar/2018/wantedly_ml)\n\n#### Reference\n\n- Focal Loss for Dense Object Detection [Tsung-Yi Lin, Priya Goyal, Ross Girshick, Kaiming He, Piotr Dollár @ ICCV 2017]\n- https://arxiv.org/abs/1708.02002\n\n（文中の図表は論文より引用）\n\n### モチベーション\n\n精度の良い object detector の多くは R-CNN[^1] ベースの two-stage object detector の構成を取っています。\n[^1]: [Rich feature hierarchies for accurate object detection and semantic segmentation](https://arxiv.org/abs/1311.2524) [Ross Girshick, et al.]\nR-CNN は、 まず物体のある bounding box の候補集合を提案し、その後 2nd stage で提案された各 box について classification を行うという構成になっています。\ntwo-stage object detector は高い精度を記録していますが、一方で複雑さと推論速度に問題がありました。\n\nそこで、 YOLO[^2][^3] や SSD[^4][^5] のような one-stage で高速に物体検出を行うネットワークが提案されてきました。\n[^2]: [You Only Look Once: Unified, Real-Time Object Detection](https://arxiv.org/abs/1506.02640) [J. Redmon, et al.]\n[^3]: [YOLO9000: Better, Faster, Stronger](https://arxiv.org/abs/1612.08242) [J. Redmon, et al.]\n[^4]: [SSD: Single Shot MultiBox Detector](https://arxiv.org/abs/1512.02325) [W. Liu, et al.]\n[^5]: [DSSD : Deconvolutional Single Shot Detector](https://arxiv.org/abs/1701.06659) [C.-Y. Fu, et al.]\n\nしかし、これらの one-stage detector は高速な一方で（当時の） state-of-the-art methods と比べると精度は劣るという課題がありました。\n\nこの論文では one-stage detector が two-stage detector と並ぶ精度を出せないのは「クラス間の不均衡」が原因であるという仮説をたてています。\n画像のほとんどの pixel は background であり、foreground（背景以外のクラス）に属する pixel の数と比べると圧倒的な不均衡があるため、学習のほとんどが簡単な background 判定に支配されてしまいます。\n（two-stage の場合は 1st stage で注目すべき部分を限定しているため、background の多くは 1st stage でフィルタリングされ、2nd stage は不均衡が解決された状態で学習することができます。）\n\nそこで登場するのが **Focal Loss** です。\n\n### Focal Loss\n\nFocal Loss は通常の cross entropy loss (CE) を動的に scaling させる損失関数です。\n通常の CE と比較したのが次の図です。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/77bb8c08-0a47-d77a-fed7-17038e29a8cf.png\" width=\"60%\">\n\n通常の CE は以下のようなものです(binary cross entropy の場合）。\n\n```math\n{\\rm CE}(p_t) = -{\\rm log}(p_t).  \\\\\n\np_t = \\left\\{\n\\begin{array}{ll}\np & {\\rm if}\\: y = 1 \\\\\n1 - p & {\\rm otherwise.} \\\\\n\\end{array}\n\\right.\n```\n\nさきほどの図の `γ = 0` の青い曲線は通常の CE を `p` を x 軸にグラフにしたものです。\n図からわかるように、 0.6 といった十分に分類できている probability を出力したとしても、損失は無視できない値になっています。\nそのため、簡単に background と分類できていても大量の exmaple が積み重なって、 foreground の損失よりも強くなってしまいます。\n\nFocal Loss は、easy example （簡単に分類に成功している example）の損失を小さく scale します。\n\n```math\n{\\rm FL}(p_t) = -(1 - p_t) ^ \\gamma {\\rm log} (p_t).\n```\n\n`γ` はパラメータで、どのくらい easy example の損失を decay するかを決定します。\n簡単に分類に成功している example では\n\n```math\n(1 - p_t) ^ \\gamma\n```\n\nが小さい値になるため、損失への寄与が小さくなります。\nこれによって、より難しい focus すべき example が学習に強く寄与できるようになります。\n（論文中の実験では `γ = 2` を採用しています。）\n\nこの論文では RetinaNet というアーキテクチャを設計し Focal Loss を用いて学習させています。\nRetinaNet の設計の詳細は省きますが、精度を既存の object detector と比較したのが冒頭の図と次の表です。\n\n![image.png](https://qiita-image-store.s3.amazonaws.com/0/39030/d711797c-f160-08c3-97b8-027f34bbf373.png)\n\ntwo-stage detector と同等（以上）の精度を達成しています。\n\n### 感想\n\nアイディアがシンプルで、 object detection 以外のタスクに対しても応用可能な手法ですごく好きな論文です。\n実装も簡単なので試しやすく良い結果がでたので、何度かお世話になっています。\n\nちなみにこの論文のあとに書かれた YOLOv3[^6] では Focal Loss を採用していませんが、 RetinaNet と精度・速度を比較していて Focal Loss に関する考察も書かれています。\n\n<img src=\"https://qiita-image-store.s3.amazonaws.com/0/39030/d2caf698-0c58-c03d-4fa4-085e63ccb24c.png\" width=\"60%\">\n\n[^6]: [YOLOv3: An Incremental Improvement](https://arxiv.org/abs/1804.02767) [J. Redmon, et al.]\n\nまた、facebook が公開している [Detectron](https://github.com/facebookresearch/Detectron) にも RetineNet の実装が含まれているので簡単に利用することもできそうです。\n","slug":"[論文紹介]_Focal_Loss_for_Dense_Object_Detection","title":"[論文紹介] Focal Loss for Dense Object Detection","timestamp":1543743660000,"tags":["DeepLearning","論文読み","ICCV"]},{"rawMarkdown":"---\ntitle: \"&quot;Applying Deep Learning To Airbnb Search&quot;  を読んだ\"\ndate: 2018-11-21T12:52:58.000Z\ntags: []\n---\n\n<p><a href=\"https://arxiv.org/abs/1810.09591\">[1810.09591] Applying Deep Learning To Airbnb Search</a> を読んだときのメモをそのまま出してみます。面白かった。\n本当にメモなので、詳細は原文を読んでください。</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/airbnb\">airbnb</a> の search ranking に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/deep%20learning\">deep learning</a> を導入していく過程を論文っぽくしたもの。</p>\n\n<p>おしゃれな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E2%A5%C7%A5%EA%A5%F3%A5%B0\">モデリング</a>手法の提案とかじゃなくて、現実の問題に対して NN を適用していくにあたって発見した良かったこと・悪かったことについてまとめた文章になっている。</p>\n\n<h2>Motivation</h2>\n\n<p>もともと Gradient Boosted Decision Tree でやっていて結構うまく行っていたが、gain が停滞してきたのでそれの突破口を探していた。</p>\n\n<h2>Model Evolution</h2>\n\n<p>評価指標は NDCG (Normalized Discounted Cumulative Gain) を使っている。</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20181121/20181121214034.png\" alt=\"f:id:agtn:20181121214034p:plain\" title=\"f:id:agtn:20181121214034p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>\"Convolutional Neural Networks for Visual Recognition\" を書いた A. Kaypathy が \"don't be a hero\" と言っている（複雑なモデルを扱えると思わないほうがいいよ、みたいな意味？）が、\"Why can't we be <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/heroes\">heroes</a>?\" と言いながら複雑なモデルに爆進したらしい</p>\n\n<p>その結果、無限に時間を持っていかれて全然うまくいかなかった。</p>\n\n<p>結局、最初に production に入ったモデルはめちゃくちゃシンプルな NN だった。</p>\n\n<blockquote><p>a simple single hidden layer NN with 32 fully connected ReLU activations that proved booking neutral against the GBDT model.</p></blockquote>\n\n<p>入力や目的関数も GBDT と全く同じにしている。（booking するかしないかの L2 regression loss）</p>\n\n<p>ものすごく gain があったわけではないけれど、NN が production でうごく、live traffic をちゃんとさばけるという pipeline を整えるためにこの step 自体は良かったと言っている。</p>\n\n<p>やりすぎないことで先に進むことはできたが、すごくよくもなっていなかった。つぎの breakthrough は LambdaRank + NN を組み合わせたことだった。LambdaRank は Learning to Rank の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\">アルゴリズム</a>で、簡単にいえばロス関数に直接評価指標（ここでは NDCG）を組み込める（ここまでは learning to rank 的なアプローチはまったく取っていなかった。単にクリック率をよく予測し、それを上から出すことで NDCG を最適化していた）。</p>\n\n<p>これらをやりながらも Factorization Machine と GBDT は research を続けていて、NN と comparable な成果が出せることはわかっていた。comparable な成果が出ている一方で出力される list は全然別物だったので、組み合わせたらもっと良くなるのではということで、FM や GBDT の結果を特徴量に含む NN を学習させて利用することにした。</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20181121/20181121214010.png\" alt=\"f:id:agtn:20181121214010p:plain\" title=\"f:id:agtn:20181121214010p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>この時点でもうモデルの複雑さは結構なものになっていて、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A1%B3%A3%B3%D8%BD%AC\">機械学習</a>の技術的負債問題が顔をだしつつあった。そこで、 ensamble などをすべて捨てて、単に DNN を大量のデータ（いままでの 10x）で学習させるというシンプルな解法に舵を切った（DNN とはいえ 2 hidden layers）。入力の次元は 195 次元、1st hidden layer = 127, 2nd = 83 というモデル。入力の特徴量はシンプルなもので、価格、アメニティ、過去の booking 数、などなど。ほぼ feature engineering をせずに入力した（これが DNN にする目的だった）。</p>\n\n<h2>Failed Models</h2>\n\n<p>失敗についても言及してくれていてすごく嬉しい。</p>\n\n<ul>\n<li>ID を使ったモデルは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%E1%B3%D8%BD%AC\">過学習</a>がひどくて使えなかった\n\n<ul>\n<li>扱っているアイテムの都合上、ある ID に対してたくさんのデータが取れることがない\n\n<ul>\n<li>どれだけ人気でも年間 365 までしかコンバージョンしない</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>詳細ページへの遷移は booking よりはるかに多いし dense なので、それを使うモデルも作ったがうまくいかなかった\n\n<ul>\n<li>multi task 学習で、booking prediction と long view prediction を予測させた</li>\n</ul>\n</li>\n</ul>\n\n<p>あとは NN は特徴量を normalize したほうがいいよねとか、特徴量の distribution を観察しましょうとか、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> 上で TensorFlow のモデル動かすの大変でしたとか、いろいろ現実っぽい話が並ぶ。\nもっといろいろ言ってるけど、詳細は本文を読んだほうが良い。</p>\n\n<p>画像とかじゃない領域で DNN を production にいれるにはこういうステップを経るんだなというのが伝わってくるし、この話から得るべき学びがかなりある。光景が目に浮かぶ良い文章だなと思いました。</p>\n\n---\n\n---\n","contentMarkdown":"\n<p><a href=\"https://arxiv.org/abs/1810.09591\">[1810.09591] Applying Deep Learning To Airbnb Search</a> を読んだときのメモをそのまま出してみます。面白かった。\n本当にメモなので、詳細は原文を読んでください。</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/airbnb\">airbnb</a> の search ranking に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/deep%20learning\">deep learning</a> を導入していく過程を論文っぽくしたもの。</p>\n\n<p>おしゃれな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E2%A5%C7%A5%EA%A5%F3%A5%B0\">モデリング</a>手法の提案とかじゃなくて、現実の問題に対して NN を適用していくにあたって発見した良かったこと・悪かったことについてまとめた文章になっている。</p>\n\n<h2>Motivation</h2>\n\n<p>もともと Gradient Boosted Decision Tree でやっていて結構うまく行っていたが、gain が停滞してきたのでそれの突破口を探していた。</p>\n\n<h2>Model Evolution</h2>\n\n<p>評価指標は NDCG (Normalized Discounted Cumulative Gain) を使っている。</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20181121/20181121214034.png\" alt=\"f:id:agtn:20181121214034p:plain\" title=\"f:id:agtn:20181121214034p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>\"Convolutional Neural Networks for Visual Recognition\" を書いた A. Kaypathy が \"don't be a hero\" と言っている（複雑なモデルを扱えると思わないほうがいいよ、みたいな意味？）が、\"Why can't we be <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/heroes\">heroes</a>?\" と言いながら複雑なモデルに爆進したらしい</p>\n\n<p>その結果、無限に時間を持っていかれて全然うまくいかなかった。</p>\n\n<p>結局、最初に production に入ったモデルはめちゃくちゃシンプルな NN だった。</p>\n\n<blockquote><p>a simple single hidden layer NN with 32 fully connected ReLU activations that proved booking neutral against the GBDT model.</p></blockquote>\n\n<p>入力や目的関数も GBDT と全く同じにしている。（booking するかしないかの L2 regression loss）</p>\n\n<p>ものすごく gain があったわけではないけれど、NN が production でうごく、live traffic をちゃんとさばけるという pipeline を整えるためにこの step 自体は良かったと言っている。</p>\n\n<p>やりすぎないことで先に進むことはできたが、すごくよくもなっていなかった。つぎの breakthrough は LambdaRank + NN を組み合わせたことだった。LambdaRank は Learning to Rank の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\">アルゴリズム</a>で、簡単にいえばロス関数に直接評価指標（ここでは NDCG）を組み込める（ここまでは learning to rank 的なアプローチはまったく取っていなかった。単にクリック率をよく予測し、それを上から出すことで NDCG を最適化していた）。</p>\n\n<p>これらをやりながらも Factorization Machine と GBDT は research を続けていて、NN と comparable な成果が出せることはわかっていた。comparable な成果が出ている一方で出力される list は全然別物だったので、組み合わせたらもっと良くなるのではということで、FM や GBDT の結果を特徴量に含む NN を学習させて利用することにした。</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20181121/20181121214010.png\" alt=\"f:id:agtn:20181121214010p:plain\" title=\"f:id:agtn:20181121214010p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>この時点でもうモデルの複雑さは結構なものになっていて、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A1%B3%A3%B3%D8%BD%AC\">機械学習</a>の技術的負債問題が顔をだしつつあった。そこで、 ensamble などをすべて捨てて、単に DNN を大量のデータ（いままでの 10x）で学習させるというシンプルな解法に舵を切った（DNN とはいえ 2 hidden layers）。入力の次元は 195 次元、1st hidden layer = 127, 2nd = 83 というモデル。入力の特徴量はシンプルなもので、価格、アメニティ、過去の booking 数、などなど。ほぼ feature engineering をせずに入力した（これが DNN にする目的だった）。</p>\n\n<h2>Failed Models</h2>\n\n<p>失敗についても言及してくれていてすごく嬉しい。</p>\n\n<ul>\n<li>ID を使ったモデルは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%E1%B3%D8%BD%AC\">過学習</a>がひどくて使えなかった\n\n<ul>\n<li>扱っているアイテムの都合上、ある ID に対してたくさんのデータが取れることがない\n\n<ul>\n<li>どれだけ人気でも年間 365 までしかコンバージョンしない</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>詳細ページへの遷移は booking よりはるかに多いし dense なので、それを使うモデルも作ったがうまくいかなかった\n\n<ul>\n<li>multi task 学習で、booking prediction と long view prediction を予測させた</li>\n</ul>\n</li>\n</ul>\n\n<p>あとは NN は特徴量を normalize したほうがいいよねとか、特徴量の distribution を観察しましょうとか、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> 上で TensorFlow のモデル動かすの大変でしたとか、いろいろ現実っぽい話が並ぶ。\nもっといろいろ言ってるけど、詳細は本文を読んだほうが良い。</p>\n\n<p>画像とかじゃない領域で DNN を production にいれるにはこういうステップを経るんだなというのが伝わってくるし、この話から得るべき学びがかなりある。光景が目に浮かぶ良い文章だなと思いました。</p>\n\n---\n\n---\n","slug":"applying-deeplearning-to-airbnb-search-papser","title":"&quot;Applying Deep Learning To Airbnb Search&quot;  を読んだ","timestamp":1542804778000,"tags":[]},{"rawMarkdown":"---\ntitle: \"個人のメモ・ノートを保存するサービス選び\"\ndate: 2018-01-19T09:13:16.000Z\ntags: []\n---\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dropbox\">Dropbox</a> Paper と <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Google\">Google</a> Keep を併用してメモとかを取っていた．\n長期的な記録とか人に見せうるもの，長めの文章は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dropbox\">Dropbox</a> Paper に，\n一時的なメモとかリマインダ的なものは Keep に，\nと使い分けていた．</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dropbox\">Dropbox</a> Paper すごく好きだったんだけど，</p>\n\n<ul>\n<li>なんか重い気がする</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/WYSIWYG\">WYSIWYG</a> なので <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> で書いているつもりでもちょこちょこ変なことが起きる\n\n<ul>\n<li>バッククオートをおした時の挙動とか</li>\n</ul>\n</li>\n<li>ブラウザでしか開けない</li>\n</ul>\n\n<p>というのが使いにくく感じてしまった．\n基本的にグループで使うものだと思うので，僕は使わない機能がいっぱいあるなぁという感じもした．</p>\n\n<p>Keep は Keep で好きだし，使い分ければそんなに嫌なこともなかったので続投したい．\nその上で，長期的に残しておきたいメモやノートを書くサービスを探してみた．</p>\n\n<h1>ほしい要件</h1>\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> で書ける</li>\n<li>端末間同期</li>\n<li>画像を D&amp;D で貼れる &amp; 保存できる</li>\n<li>グループ分け．<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リを切るくらいの機能で十分</li>\n<li>Archive</li>\n<li>検索</li>\n<li>ブラウザ以外のアプリケーションとして閲覧できる\n\n<ul>\n<li>別に Electron でもなんでも良いけど，ブラウザとは独立したアプリケーションとして動いて欲しい</li>\n</ul>\n</li>\n<li>mobile app</li>\n<li>細かい一時的なメモを取るのは keep.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/google\">google</a>.com でやる</li>\n<li>ToDo もいらない</li>\n</ul>\n\n<h1>比較</h1>\n\n<h2><a href=\"https://dropbox.com/paper\">Dropbox Paper</a></h2>\n\n<h3>Pros</h3>\n\n<ul>\n<li>サービスの大きさ・信頼性</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> + <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/WYSIWYG\">WYSIWYG</a> なエディタであること</li>\n<li>人にパッと見せられるくらいキレイにメモがとれる</li>\n<li>presentation mode（個人で使ってたらあんまりいらないかも）</li>\n</ul>\n\n<h3>Cons</h3>\n\n<ul>\n<li>重い...</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/WYSIWYG\">WYSIWYG</a> であること</li>\n<li>ブラウザでしか開けない</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> で書いているのに <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> として export すると微妙に modify されている...</li>\n</ul>\n\n<h2><a href=\"https://keep.google.com/\">Google Keep</a></h2>\n\n<h3>Pros</h3>\n\n<ul>\n<li>さくさく</li>\n<li>シンプル</li>\n<li>リマインダとの連携とか</li>\n</ul>\n\n<h3>Cons</h3>\n\n<ul>\n<li>長期的に残しておきたいドキュメントとかノートを書くためのものではない</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> で書けない</li>\n</ul>\n\n<h2><a href=\"https://evernote.com/\">evernote</a></h2>\n\n<p>お金は払う前提で考える</p>\n\n<h3>Pros</h3>\n\n<ul>\n<li>圧倒的コミュニティ．連携の広さとか tips が転がりまくっている．</li>\n<li>web clip とかちょっとした pdf や画像をポンポンぶち込んでおける</li>\n<li>短いメモみたいなものも躊躇なくいれておけそう</li>\n</ul>\n\n<h3>Cons</h3>\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> が使えない問題がでかい</li>\n<li>長めの文章を書く感じじゃなさそう</li>\n<li>機能が多すぎてごちゃつきそうというイメージもある</li>\n</ul>\n\n<h2><a href=\"https://boostnote.io/\">Boostnote</a></h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OSS\">OSS</a> になっているエディタで，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/dropbox\">dropbox</a> みたいな外部<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%A6%A5%C9\">クラウド</a>ストレージを使って同期をはかるやつ．</p>\n\n<h3>Pros</h3>\n\n<ul>\n<li>UI</li>\n<li>要件はほぼ満たしている</li>\n<li>外部ストレージを使っているので，サービス停止のリスクは外部ストレージに依存する\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/dropbox\">dropbox</a> / <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/google%20drive\">google drive</a> / one drive とか代替も結構あるのでサービス停止を気にする必要がなさそう</li>\n</ul>\n</li>\n</ul>\n\n<h3>Cons</h3>\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dropbox\">Dropbox</a> などのストレージを圧迫する</li>\n<li>Boostnote 独自のフォーマット（フォーマットとしては cson だけど）で保存されるので，別に外部ストレージにそのまま md が吐かれるとかではない\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> として export はできる</li>\n</ul>\n</li>\n</ul>\n\n<h2><a href=\"https://www.inkdrop.info/\">Inkdrop</a></h2>\n\n<h3>Pros</h3>\n\n<ul>\n<li>UI</li>\n<li>要件は満たしている</li>\n<li>status と tag 機能は便利そう．</li>\n<li>一番普通に整理が出来る構造になっている気がする</li>\n<li>Data <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Access\">Access</a> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> が使える</li>\n</ul>\n\n<h3>Cons</h3>\n\n<ul>\n<li>個人開発なのでサービス停止がこわい\n\n<ul>\n<li>とはいえ <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> なので移行は容易い</li>\n</ul>\n</li>\n</ul>\n\n<h1>結論</h1>\n\n<p>要件を満たしているといえるのは Inkdrop と Boostnote くらいだろうか．\nBoostnote よりも Inkdrop のほうが first impression では好みだった．\nとりあえず 60 日 free なので Inkdrop を使ってみる．\n今この文章も Inkdrop 上で書いている．普通に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> を書けばいいのでまあ書くのは楽．</p>\n\n---\n\n---\n","contentMarkdown":"\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dropbox\">Dropbox</a> Paper と <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Google\">Google</a> Keep を併用してメモとかを取っていた．\n長期的な記録とか人に見せうるもの，長めの文章は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dropbox\">Dropbox</a> Paper に，\n一時的なメモとかリマインダ的なものは Keep に，\nと使い分けていた．</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dropbox\">Dropbox</a> Paper すごく好きだったんだけど，</p>\n\n<ul>\n<li>なんか重い気がする</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/WYSIWYG\">WYSIWYG</a> なので <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> で書いているつもりでもちょこちょこ変なことが起きる\n\n<ul>\n<li>バッククオートをおした時の挙動とか</li>\n</ul>\n</li>\n<li>ブラウザでしか開けない</li>\n</ul>\n\n<p>というのが使いにくく感じてしまった．\n基本的にグループで使うものだと思うので，僕は使わない機能がいっぱいあるなぁという感じもした．</p>\n\n<p>Keep は Keep で好きだし，使い分ければそんなに嫌なこともなかったので続投したい．\nその上で，長期的に残しておきたいメモやノートを書くサービスを探してみた．</p>\n\n<h1>ほしい要件</h1>\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> で書ける</li>\n<li>端末間同期</li>\n<li>画像を D&amp;D で貼れる &amp; 保存できる</li>\n<li>グループ分け．<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リを切るくらいの機能で十分</li>\n<li>Archive</li>\n<li>検索</li>\n<li>ブラウザ以外のアプリケーションとして閲覧できる\n\n<ul>\n<li>別に Electron でもなんでも良いけど，ブラウザとは独立したアプリケーションとして動いて欲しい</li>\n</ul>\n</li>\n<li>mobile app</li>\n<li>細かい一時的なメモを取るのは keep.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/google\">google</a>.com でやる</li>\n<li>ToDo もいらない</li>\n</ul>\n\n<h1>比較</h1>\n\n<h2><a href=\"https://dropbox.com/paper\">Dropbox Paper</a></h2>\n\n<h3>Pros</h3>\n\n<ul>\n<li>サービスの大きさ・信頼性</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> + <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/WYSIWYG\">WYSIWYG</a> なエディタであること</li>\n<li>人にパッと見せられるくらいキレイにメモがとれる</li>\n<li>presentation mode（個人で使ってたらあんまりいらないかも）</li>\n</ul>\n\n<h3>Cons</h3>\n\n<ul>\n<li>重い...</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/WYSIWYG\">WYSIWYG</a> であること</li>\n<li>ブラウザでしか開けない</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> で書いているのに <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> として export すると微妙に modify されている...</li>\n</ul>\n\n<h2><a href=\"https://keep.google.com/\">Google Keep</a></h2>\n\n<h3>Pros</h3>\n\n<ul>\n<li>さくさく</li>\n<li>シンプル</li>\n<li>リマインダとの連携とか</li>\n</ul>\n\n<h3>Cons</h3>\n\n<ul>\n<li>長期的に残しておきたいドキュメントとかノートを書くためのものではない</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> で書けない</li>\n</ul>\n\n<h2><a href=\"https://evernote.com/\">evernote</a></h2>\n\n<p>お金は払う前提で考える</p>\n\n<h3>Pros</h3>\n\n<ul>\n<li>圧倒的コミュニティ．連携の広さとか tips が転がりまくっている．</li>\n<li>web clip とかちょっとした pdf や画像をポンポンぶち込んでおける</li>\n<li>短いメモみたいなものも躊躇なくいれておけそう</li>\n</ul>\n\n<h3>Cons</h3>\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> が使えない問題がでかい</li>\n<li>長めの文章を書く感じじゃなさそう</li>\n<li>機能が多すぎてごちゃつきそうというイメージもある</li>\n</ul>\n\n<h2><a href=\"https://boostnote.io/\">Boostnote</a></h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OSS\">OSS</a> になっているエディタで，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/dropbox\">dropbox</a> みたいな外部<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%A6%A5%C9\">クラウド</a>ストレージを使って同期をはかるやつ．</p>\n\n<h3>Pros</h3>\n\n<ul>\n<li>UI</li>\n<li>要件はほぼ満たしている</li>\n<li>外部ストレージを使っているので，サービス停止のリスクは外部ストレージに依存する\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/dropbox\">dropbox</a> / <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/google%20drive\">google drive</a> / one drive とか代替も結構あるのでサービス停止を気にする必要がなさそう</li>\n</ul>\n</li>\n</ul>\n\n<h3>Cons</h3>\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dropbox\">Dropbox</a> などのストレージを圧迫する</li>\n<li>Boostnote 独自のフォーマット（フォーマットとしては cson だけど）で保存されるので，別に外部ストレージにそのまま md が吐かれるとかではない\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> として export はできる</li>\n</ul>\n</li>\n</ul>\n\n<h2><a href=\"https://www.inkdrop.info/\">Inkdrop</a></h2>\n\n<h3>Pros</h3>\n\n<ul>\n<li>UI</li>\n<li>要件は満たしている</li>\n<li>status と tag 機能は便利そう．</li>\n<li>一番普通に整理が出来る構造になっている気がする</li>\n<li>Data <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Access\">Access</a> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> が使える</li>\n</ul>\n\n<h3>Cons</h3>\n\n<ul>\n<li>個人開発なのでサービス停止がこわい\n\n<ul>\n<li>とはいえ <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> なので移行は容易い</li>\n</ul>\n</li>\n</ul>\n\n<h1>結論</h1>\n\n<p>要件を満たしているといえるのは Inkdrop と Boostnote くらいだろうか．\nBoostnote よりも Inkdrop のほうが first impression では好みだった．\nとりあえず 60 日 free なので Inkdrop を使ってみる．\n今この文章も Inkdrop 上で書いている．普通に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/markdown\">markdown</a> を書けばいいのでまあ書くのは楽．</p>\n\n---\n\n---\n","slug":"個人のメモ・ノートを保存するサービス選び","title":"個人のメモ・ノートを保存するサービス選び","timestamp":1516353196000,"tags":[]},{"rawMarkdown":"---\ntitle: \"golang でテストのために時間を操作するライブラリ timejump\"\ndate: 2017-12-14T14:21:24.000Z\ntags: []\n---\n\n<p>現在時刻に依存するコードをテストするとき，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> で <code>time.Now</code> を普通に使っているとモックできずうまくテストが書けないという問題があります．\n時間の操作は time パッケージをそのまま使えば良いのですが，time.Now だけはモックできるようにしたいところです．</p>\n\n<p>解決方法としては，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%ED%A1%BC%A5%D0%A5%EB%CA%D1%BF%F4\">グローバル変数</a>に <code>var NowFunc func() time.Time</code> を置いておいて，テスト時に入れ替えるという方法があり，ORM である gorm などが実際にこれを行っています．</p>\n\n<p><a href=\"https://github.com/jinzhu/gorm/blob/2a1463811ee1dc85d168fd639a2d4251d030e6e5/utils.go#L21\">gorm/utils.go at 2a1463811ee1dc85d168fd639a2d4251d030e6e5 &middot; jinzhu/gorm &middot; GitHub</a></p>\n\n<p>例:</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">var</span> NowFunc = time.Now\n\n<span class=\"synStatement\">func</span> Do() <span class=\"synType\">string</span> {\n    <span class=\"synStatement\">return</span> NowFunc().String()\n}\n\n<span class=\"synStatement\">func</span> TestDo(t *testing.T) {\n    now := time.Date(<span class=\"synConstant\">2009</span>, time.November, <span class=\"synConstant\">10</span>, <span class=\"synConstant\">23</span>, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">0</span>, time.UTC)\n    NowFunc = <span class=\"synType\">func</span>() time.Time {\n        <span class=\"synStatement\">return</span> now\n    }\n    got := Do()\n    <span class=\"synStatement\">if</span> got != now.String() {\n        t.Fail()\n    }\n}\n</pre>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> の使用上，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\">Ruby</a> の timecop のようなことは出来ないので，こういう工夫をするしかありません．</p>\n\n<p>なんとなく<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%ED%A1%BC%A5%D0%A5%EB%CA%D1%BF%F4\">グローバル変数</a>をテストのために置いて書き換えるのが嫌なのと，なんにも考えずに <code>t.Parallel()</code> を置けなくなるのがちょっと嫌だなと思っていました．\nまた，時間経過をシミュレーションしたい場合は，そういう <code>NowFunc</code> を毎回書く必要があり，結構面倒です．\nあとパッケージをまたぐと厄介だし毎回書くのも嫌．</p>\n\n<p>そこで，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\">Ruby</a> の timecop のように現在時刻をいじくり回せるようにするライブラリを作ってみました．</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Ftimejump\" title=\"agatan/timejump\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://github.com/agatan/timejump\">github.com</a></cite></p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgodoc.org%2Fgithub.com%2Fagatan%2Ftimejump\" title=\"Package timejump\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://godoc.org/github.com/agatan/timejump\">godoc.org</a></cite></p>\n\n<p>使用する際は <code>time.Now</code> をすべて <code>timejump.Now</code> に置き換える必要があります．（ <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\">Ruby</a> と違って <code>time.Now</code> を直接上書きできないので...）\n普段は <code>timejump.Now</code> と <code>time.Now</code> は <code>if !active { ... }</code> が一段挟まるだけなのでパフォーマンスに影響はほとんどないはずです．</p>\n\n<p>テスト時は，<code>timejump.Now</code> の挙動を変えたいテストの頭で</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">func</span> TestDo(t *testing.T) {\n    timejump.Activate()\n    <span class=\"synStatement\">defer</span> timejump.Deactivate()\n    ...\n}\n</pre>\n\n<p>とします．</p>\n\n<p><code>timejump.Activate</code> な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B6%E8%B4%D6\">区間</a>はロックをとっているので，テストを並列で走らせても並列に走らなくなります．</p>\n\n<p><code>timejump.Stop()</code> で時間停止，<code>timejump.Jump</code> で時間移動，<code>timejump.Move</code> で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BF%A5%A4%A5%E0%A5%BE%A1%BC%A5%F3\">タイムゾーン</a>の移動，<code>timejump.Scale</code> で時間の経過速度をいじれます．</p>\n\n<p>時間を止めたいだけの場合は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%ED%A1%BC%A5%D0%A5%EB%CA%D1%BF%F4\">グローバル変数</a>に <code>NowFunc</code> を持っておいて <code>t.Parallel</code> を間違って置かないように気をつけるほうが正直楽だとは思いますが，時間経過をテストしたい場合にはちょっと楽になるはずです．</p>\n\n<p>もともとあるパッケージのテストをするために書いたパッケージだったのですが，目的だったテストを書く前にテストしたいパッケージが御役御免になってしまったので，timejump も御役御免になってしまいました．\nいつか使う日が来る気がするので，ここに寝かせておきます．</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>現在時刻に依存するコードをテストするとき，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> で <code>time.Now</code> を普通に使っているとモックできずうまくテストが書けないという問題があります．\n時間の操作は time パッケージをそのまま使えば良いのですが，time.Now だけはモックできるようにしたいところです．</p>\n\n<p>解決方法としては，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%ED%A1%BC%A5%D0%A5%EB%CA%D1%BF%F4\">グローバル変数</a>に <code>var NowFunc func() time.Time</code> を置いておいて，テスト時に入れ替えるという方法があり，ORM である gorm などが実際にこれを行っています．</p>\n\n<p><a href=\"https://github.com/jinzhu/gorm/blob/2a1463811ee1dc85d168fd639a2d4251d030e6e5/utils.go#L21\">gorm/utils.go at 2a1463811ee1dc85d168fd639a2d4251d030e6e5 &middot; jinzhu/gorm &middot; GitHub</a></p>\n\n<p>例:</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">var</span> NowFunc = time.Now\n\n<span class=\"synStatement\">func</span> Do() <span class=\"synType\">string</span> {\n    <span class=\"synStatement\">return</span> NowFunc().String()\n}\n\n<span class=\"synStatement\">func</span> TestDo(t *testing.T) {\n    now := time.Date(<span class=\"synConstant\">2009</span>, time.November, <span class=\"synConstant\">10</span>, <span class=\"synConstant\">23</span>, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">0</span>, time.UTC)\n    NowFunc = <span class=\"synType\">func</span>() time.Time {\n        <span class=\"synStatement\">return</span> now\n    }\n    got := Do()\n    <span class=\"synStatement\">if</span> got != now.String() {\n        t.Fail()\n    }\n}\n</pre>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> の使用上，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\">Ruby</a> の timecop のようなことは出来ないので，こういう工夫をするしかありません．</p>\n\n<p>なんとなく<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%ED%A1%BC%A5%D0%A5%EB%CA%D1%BF%F4\">グローバル変数</a>をテストのために置いて書き換えるのが嫌なのと，なんにも考えずに <code>t.Parallel()</code> を置けなくなるのがちょっと嫌だなと思っていました．\nまた，時間経過をシミュレーションしたい場合は，そういう <code>NowFunc</code> を毎回書く必要があり，結構面倒です．\nあとパッケージをまたぐと厄介だし毎回書くのも嫌．</p>\n\n<p>そこで，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\">Ruby</a> の timecop のように現在時刻をいじくり回せるようにするライブラリを作ってみました．</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Ftimejump\" title=\"agatan/timejump\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://github.com/agatan/timejump\">github.com</a></cite></p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgodoc.org%2Fgithub.com%2Fagatan%2Ftimejump\" title=\"Package timejump\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://godoc.org/github.com/agatan/timejump\">godoc.org</a></cite></p>\n\n<p>使用する際は <code>time.Now</code> をすべて <code>timejump.Now</code> に置き換える必要があります．（ <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\">Ruby</a> と違って <code>time.Now</code> を直接上書きできないので...）\n普段は <code>timejump.Now</code> と <code>time.Now</code> は <code>if !active { ... }</code> が一段挟まるだけなのでパフォーマンスに影響はほとんどないはずです．</p>\n\n<p>テスト時は，<code>timejump.Now</code> の挙動を変えたいテストの頭で</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">func</span> TestDo(t *testing.T) {\n    timejump.Activate()\n    <span class=\"synStatement\">defer</span> timejump.Deactivate()\n    ...\n}\n</pre>\n\n<p>とします．</p>\n\n<p><code>timejump.Activate</code> な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B6%E8%B4%D6\">区間</a>はロックをとっているので，テストを並列で走らせても並列に走らなくなります．</p>\n\n<p><code>timejump.Stop()</code> で時間停止，<code>timejump.Jump</code> で時間移動，<code>timejump.Move</code> で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BF%A5%A4%A5%E0%A5%BE%A1%BC%A5%F3\">タイムゾーン</a>の移動，<code>timejump.Scale</code> で時間の経過速度をいじれます．</p>\n\n<p>時間を止めたいだけの場合は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%ED%A1%BC%A5%D0%A5%EB%CA%D1%BF%F4\">グローバル変数</a>に <code>NowFunc</code> を持っておいて <code>t.Parallel</code> を間違って置かないように気をつけるほうが正直楽だとは思いますが，時間経過をテストしたい場合にはちょっと楽になるはずです．</p>\n\n<p>もともとあるパッケージのテストをするために書いたパッケージだったのですが，目的だったテストを書く前にテストしたいパッケージが御役御免になってしまったので，timejump も御役御免になってしまいました．\nいつか使う日が来る気がするので，ここに寝かせておきます．</p>\n\n---\n\n---\n","slug":"golang_でテストのために時間を操作するライブラリ_timejump","title":"golang でテストのために時間を操作するライブラリ timejump","timestamp":1513261284000,"tags":[]},{"rawMarkdown":"---\ntitle: \"ISUCON 7 本戦出場してきました 「都営三田線東急目黒線直通急行日吉行」\"\ndate: 2017-11-26T05:18:59.000Z\ntags: []\n---\n\n<p>ISUCON 7 お疲れ様でした！</p>\n\n<p>僕らのチーム，「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%D4%B1%C4%BB%B0%C5%C4%C0%FE\">都営三田線</a><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%EC%B5%DE%CC%DC%B9%F5%C0%FE\">東急目黒線</a>直通急行日吉行」は学生枠 2 位，全体で 10 位という結果でした．</p>\n\n<p>予選の結果が異常によかったので完全に調子に乗っていたんですが，本戦はやっぱり難しかったですね... 本戦でも社会人上位勢と戦えるくらいのスコアを出すのと学生枠優勝が目標だったのでやっぱりくやしい．</p>\n\n<h3>やったこと</h3>\n\n<p>結局テンパりすぎてスコア記録を残せていないので，なんとなく記憶を頼りに...</p>\n\n<p>Go 実装でいきました．</p>\n\n<ul>\n<li>room 名から ws をつなぎに行くホストが一台に固定されるように\n\n<ul>\n<li>同じルームの action は全部同じホストにいくように</li>\n<li>これでオンメモリに出来るようにした（結局ほとんどオンメモリにデータは持たなかった）</li>\n</ul>\n</li>\n<li>ルーム名から適当な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%CF%A5%C3%A5%B7%A5%E5%C3%CD\">ハッシュ値</a>を計算してふるようにしていたけれど，ルームによってアクセス頻度とかがちがうっぽい？ことに気がつく\n\n<ul>\n<li>3 台に振ってるはずなのに，CPU 使用率を見ると 2 台しか使われていないとか</li>\n<li>負荷分散が<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%BF%A5%B2%A1%BC\">運ゲー</a>になっていて改善の結果が見にくかったので，とりあえず 1 台しか使わないように</li>\n</ul>\n</li>\n<li>ホストごとの接続数を redis に入れて，空いていそうなところに振り分けるように\n\n<ul>\n<li>前段のサーバに nginx + app + redis を入れて，そこの redis に room -> host の対応情報を入れた</li>\n<li>CPU 使用率で振り分けたほうが良かったかもしれない</li>\n</ul>\n</li>\n<li>schedule の計算過程を最適化出来る気がしなかったので，結果をキャッシュしようと試みる\n\n<ul>\n<li>どうやっても事後検証をパスできなかったので捨てることに...</li>\n</ul>\n</li>\n<li>部屋ごとにロックをとってすべての操作を直列にした\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A5%E9%A5%F3%A5%B6%A5%AF%A5%B7%A5%E7%A5%F3\">トランザクション</a>とかが複雑すぎていじれる気がしなかったので，一旦直列にして考えることを減らそうとした</li>\n<li>rollback 考えなくて良くなったのでこれ自体は良かった気がする</li>\n</ul>\n</li>\n<li>@izumin5210 が adding/buying を redis にいれたり，過去の adding をまとめてくれた\n\n<ul>\n<li>ここは完全におまかせしてしまった</li>\n<li>最終的にまともに効いたのはこれだけだったのでは</li>\n</ul>\n</li>\n<li>終盤はベンチマーカに弾かれる原因をひたすら探していた\n\n<ul>\n<li>安全側に倒そうということで，色んな所でひたすらロックを取るようにしてなんとかパスした</li>\n</ul>\n</li>\n</ul>\n\n<p>という感じで，最高スコアが 17000 くらい，最終スコアが 16700 で終了しました．</p>\n\n<h3>反省</h3>\n\n<ul>\n<li>チーム名が長すぎた\n\n<ul>\n<li>名札のチーム名部分のフォントが他のチームより小さかった気がする（ご迷惑おかけしていたらすみません...）</li>\n<li>手書きで書くのがつらすぎる</li>\n<li>来年は気をつけます</li>\n</ul>\n</li>\n<li>テストがせっかく用意されていたのにまったく使わなかった\n\n<ul>\n<li>テスト使っていたらもうちょっと計算過程の最適化にも手を出せたかもしれない</li>\n</ul>\n</li>\n<li>なにも操作がなくても 500ms ごとに status を計算していたところの最適化を入れきることができなかった\n\n<ul>\n<li>この計算は room ごとに一回やれば良いはずなのにコネクション一個につき一回計算していた</li>\n<li>room ごとにひたすら status を計算し続ける goroutine を起動してそこから返す実装を書いていたが，終盤の fail 祭りにびびっていれられなかった...</li>\n<li>意味があったかどうかはよくわからない．</li>\n</ul>\n</li>\n<li>CPU profile をみて，bigint の計算がやばいことはわかっていたのに，手が出せなかった\n\n<ul>\n<li>この複雑さは結果をキャッシュしろってことだな！って勝手に思い込んでいたけど，結果のキャッシュも複雑で無理だった</li>\n<li>他のチームの方の話を聞く限り，そんなに無茶な最適化じゃなくても地道に最適化していたらそれなりにスコアに効いたのかもと思った（これはやってみないとわからないけど）</li>\n</ul>\n</li>\n</ul>\n\n<p>予選のときも練習のときも，「遅いのはわかっているけど複雑そうでやりたくない」部分を触らないとだめっていう教訓は得ていたはずなんだけど，結局そこでやられてしまったのが一番くやしいですね...</p>\n\n<p>来年は学生枠ではなくなるのですが，社会人枠でも本戦にでて勝ちたいです！</p>\n\n<p>去年に引き続き本戦に出られたのはほんとうに良かったし，またまた勉強になる良い経験でした！運営の皆様お疲れ様でした ＆ ありがとうございました！</p>\n\n---\n\nCOMMENT:\nAUTHOR: davidcruise\nIP: 117.98.190.10\nDATE: 11/27/2017 21:25:12\n<a href='https://www.kikforpcapp.com/kik-for-pc-windows-xp788-110-free-download/'>pc kik</a> article on an innovative messaging amenity that is continually on, permanently linked with fast and unswerving than any added applications that are existing due to some of the following reasons.\n\n---\n\n---\n","contentMarkdown":"\n<p>ISUCON 7 お疲れ様でした！</p>\n\n<p>僕らのチーム，「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%D4%B1%C4%BB%B0%C5%C4%C0%FE\">都営三田線</a><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%EC%B5%DE%CC%DC%B9%F5%C0%FE\">東急目黒線</a>直通急行日吉行」は学生枠 2 位，全体で 10 位という結果でした．</p>\n\n<p>予選の結果が異常によかったので完全に調子に乗っていたんですが，本戦はやっぱり難しかったですね... 本戦でも社会人上位勢と戦えるくらいのスコアを出すのと学生枠優勝が目標だったのでやっぱりくやしい．</p>\n\n<h3>やったこと</h3>\n\n<p>結局テンパりすぎてスコア記録を残せていないので，なんとなく記憶を頼りに...</p>\n\n<p>Go 実装でいきました．</p>\n\n<ul>\n<li>room 名から ws をつなぎに行くホストが一台に固定されるように\n\n<ul>\n<li>同じルームの action は全部同じホストにいくように</li>\n<li>これでオンメモリに出来るようにした（結局ほとんどオンメモリにデータは持たなかった）</li>\n</ul>\n</li>\n<li>ルーム名から適当な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%CF%A5%C3%A5%B7%A5%E5%C3%CD\">ハッシュ値</a>を計算してふるようにしていたけれど，ルームによってアクセス頻度とかがちがうっぽい？ことに気がつく\n\n<ul>\n<li>3 台に振ってるはずなのに，CPU 使用率を見ると 2 台しか使われていないとか</li>\n<li>負荷分散が<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%BF%A5%B2%A1%BC\">運ゲー</a>になっていて改善の結果が見にくかったので，とりあえず 1 台しか使わないように</li>\n</ul>\n</li>\n<li>ホストごとの接続数を redis に入れて，空いていそうなところに振り分けるように\n\n<ul>\n<li>前段のサーバに nginx + app + redis を入れて，そこの redis に room -> host の対応情報を入れた</li>\n<li>CPU 使用率で振り分けたほうが良かったかもしれない</li>\n</ul>\n</li>\n<li>schedule の計算過程を最適化出来る気がしなかったので，結果をキャッシュしようと試みる\n\n<ul>\n<li>どうやっても事後検証をパスできなかったので捨てることに...</li>\n</ul>\n</li>\n<li>部屋ごとにロックをとってすべての操作を直列にした\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A5%E9%A5%F3%A5%B6%A5%AF%A5%B7%A5%E7%A5%F3\">トランザクション</a>とかが複雑すぎていじれる気がしなかったので，一旦直列にして考えることを減らそうとした</li>\n<li>rollback 考えなくて良くなったのでこれ自体は良かった気がする</li>\n</ul>\n</li>\n<li>@izumin5210 が adding/buying を redis にいれたり，過去の adding をまとめてくれた\n\n<ul>\n<li>ここは完全におまかせしてしまった</li>\n<li>最終的にまともに効いたのはこれだけだったのでは</li>\n</ul>\n</li>\n<li>終盤はベンチマーカに弾かれる原因をひたすら探していた\n\n<ul>\n<li>安全側に倒そうということで，色んな所でひたすらロックを取るようにしてなんとかパスした</li>\n</ul>\n</li>\n</ul>\n\n<p>という感じで，最高スコアが 17000 くらい，最終スコアが 16700 で終了しました．</p>\n\n<h3>反省</h3>\n\n<ul>\n<li>チーム名が長すぎた\n\n<ul>\n<li>名札のチーム名部分のフォントが他のチームより小さかった気がする（ご迷惑おかけしていたらすみません...）</li>\n<li>手書きで書くのがつらすぎる</li>\n<li>来年は気をつけます</li>\n</ul>\n</li>\n<li>テストがせっかく用意されていたのにまったく使わなかった\n\n<ul>\n<li>テスト使っていたらもうちょっと計算過程の最適化にも手を出せたかもしれない</li>\n</ul>\n</li>\n<li>なにも操作がなくても 500ms ごとに status を計算していたところの最適化を入れきることができなかった\n\n<ul>\n<li>この計算は room ごとに一回やれば良いはずなのにコネクション一個につき一回計算していた</li>\n<li>room ごとにひたすら status を計算し続ける goroutine を起動してそこから返す実装を書いていたが，終盤の fail 祭りにびびっていれられなかった...</li>\n<li>意味があったかどうかはよくわからない．</li>\n</ul>\n</li>\n<li>CPU profile をみて，bigint の計算がやばいことはわかっていたのに，手が出せなかった\n\n<ul>\n<li>この複雑さは結果をキャッシュしろってことだな！って勝手に思い込んでいたけど，結果のキャッシュも複雑で無理だった</li>\n<li>他のチームの方の話を聞く限り，そんなに無茶な最適化じゃなくても地道に最適化していたらそれなりにスコアに効いたのかもと思った（これはやってみないとわからないけど）</li>\n</ul>\n</li>\n</ul>\n\n<p>予選のときも練習のときも，「遅いのはわかっているけど複雑そうでやりたくない」部分を触らないとだめっていう教訓は得ていたはずなんだけど，結局そこでやられてしまったのが一番くやしいですね...</p>\n\n<p>来年は学生枠ではなくなるのですが，社会人枠でも本戦にでて勝ちたいです！</p>\n\n<p>去年に引き続き本戦に出られたのはほんとうに良かったし，またまた勉強になる良い経験でした！運営の皆様お疲れ様でした ＆ ありがとうございました！</p>\n\n---\n\nCOMMENT:\nAUTHOR: davidcruise\nIP: 117.98.190.10\nDATE: 11/27/2017 21:25:12\n<a href='https://www.kikforpcapp.com/kik-for-pc-windows-xp788-110-free-download/'>pc kik</a> article on an innovative messaging amenity that is continually on, permanently linked with fast and unswerving than any added applications that are existing due to some of the following reasons.\n\n---\n\n---\n","slug":"ISUCON_7_本戦出場してきました_「都営三田線東急目黒線直通急行日吉行」","title":"ISUCON 7 本戦出場してきました 「都営三田線東急目黒線直通急行日吉行」","timestamp":1511673539000,"tags":[]},{"rawMarkdown":"---\ntitle: \"ISUCON7予選1日目に「都営三田線」で参加して通過できた話\"\ndate: 2017-10-23T11:33:42.000Z\ntags: []\n---\n\n<p>ISUCON7 予選お疲れ様でした！\nタイトルどおりですが，「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%D4%B1%C4%BB%B0%C5%C4%C0%FE\">都営三田線</a><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%EC%B5%DE%CC%DC%B9%F5%C0%FE\">東急目黒線</a>直通急行日吉行」という学生チームで参加し，1日目3位枠で通過することができました．\nチーム編成は，去年2人チームで参加したときの相方である <a href=\"https://github.com/0gajun\">0gajun</a> と，僕の内定先の同期の <a href=\"https://github.com/izumin5210\">izumin</a> の 3 人チームでした．</p>\n\n<p>何をやったかとかスコアの変遷は別で記録したいと思います（僕一人で把握しきれていないので）が，とりあえず<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ</a>はここです．</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2FISUCON7-qualify\" title=\"agatan/isucon7-qualify\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://github.com/agatan/ISUCON7-qualify\">github.com</a></cite></p>\n\n<p>追記: タイムラインと詳細はこっちに書きました</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fwww.wantedly.com%2Fusers%2F17993775%2Fpost_articles%2F81190\" title=\"ISUCON7予選に学生チームで参加して1日目3位枠で突破しました！\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://www.wantedly.com/users/17993775/post_articles/81190\">www.wantedly.com</a></cite></p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20171023/20171023153909.png\" alt=\"f:id:agtn:20171023153909p:plain\" title=\"f:id:agtn:20171023153909p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>去年2人で参加した時は学生枠で予選通過はできたものの，一般枠との圧倒的なスコア差にだいぶ打ちひしがれていました．\nもともと，「0gajun がインフラ，僕がインフラ寄りのアプリ」というチームだったので，アプリ側をがつがついじれる izumin が加わったことで，チームバランスが良くなった + 手数が圧倒的に増えたと思います．</p>\n\n<p>去年とくらべてメンバーも増えたし学生とはいえ一年間で成長している（はず）というのもあったので，夢として「学生枠だけど一般枠と戦えるスコアを出したい」というのがありました．\n結果，予選1日目上位3チーム枠で本戦出場を決められて本当にうれしかったです．2日目の上位が圧倒的なスコアだったのでちょっと凹みましたが，全体でも 10 位くらいだったと思うので，目標は達成できたと思います．\nまた，無理やり ISUCON 特化な高速化を入れたりすることなく良いスコアを出せたと思うので，そこも良かったなと思っています．\n本戦でも良いスコアが出せるように頑張るぞー！</p>\n\n<p>最後に，ISUCON 運営の皆様，本当にお疲れ様でした &amp; ありがとうございました！\n予選から複数台構成で面食らいましたが，複数台は難しい分，楽しさも増すし勉強になることもたくさんありました！\n本戦も楽しみにしています！</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>ISUCON7 予選お疲れ様でした！\nタイトルどおりですが，「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%D4%B1%C4%BB%B0%C5%C4%C0%FE\">都営三田線</a><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%EC%B5%DE%CC%DC%B9%F5%C0%FE\">東急目黒線</a>直通急行日吉行」という学生チームで参加し，1日目3位枠で通過することができました．\nチーム編成は，去年2人チームで参加したときの相方である <a href=\"https://github.com/0gajun\">0gajun</a> と，僕の内定先の同期の <a href=\"https://github.com/izumin5210\">izumin</a> の 3 人チームでした．</p>\n\n<p>何をやったかとかスコアの変遷は別で記録したいと思います（僕一人で把握しきれていないので）が，とりあえず<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ</a>はここです．</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2FISUCON7-qualify\" title=\"agatan/isucon7-qualify\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://github.com/agatan/ISUCON7-qualify\">github.com</a></cite></p>\n\n<p>追記: タイムラインと詳細はこっちに書きました</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fwww.wantedly.com%2Fusers%2F17993775%2Fpost_articles%2F81190\" title=\"ISUCON7予選に学生チームで参加して1日目3位枠で突破しました！\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://www.wantedly.com/users/17993775/post_articles/81190\">www.wantedly.com</a></cite></p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20171023/20171023153909.png\" alt=\"f:id:agtn:20171023153909p:plain\" title=\"f:id:agtn:20171023153909p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>去年2人で参加した時は学生枠で予選通過はできたものの，一般枠との圧倒的なスコア差にだいぶ打ちひしがれていました．\nもともと，「0gajun がインフラ，僕がインフラ寄りのアプリ」というチームだったので，アプリ側をがつがついじれる izumin が加わったことで，チームバランスが良くなった + 手数が圧倒的に増えたと思います．</p>\n\n<p>去年とくらべてメンバーも増えたし学生とはいえ一年間で成長している（はず）というのもあったので，夢として「学生枠だけど一般枠と戦えるスコアを出したい」というのがありました．\n結果，予選1日目上位3チーム枠で本戦出場を決められて本当にうれしかったです．2日目の上位が圧倒的なスコアだったのでちょっと凹みましたが，全体でも 10 位くらいだったと思うので，目標は達成できたと思います．\nまた，無理やり ISUCON 特化な高速化を入れたりすることなく良いスコアを出せたと思うので，そこも良かったなと思っています．\n本戦でも良いスコアが出せるように頑張るぞー！</p>\n\n<p>最後に，ISUCON 運営の皆様，本当にお疲れ様でした &amp; ありがとうございました！\n予選から複数台構成で面食らいましたが，複数台は難しい分，楽しさも増すし勉強になることもたくさんありました！\n本戦も楽しみにしています！</p>\n\n---\n\n---\n","slug":"ISUCON7予選1日目に「都営三田線」で参加して通過できた話","title":"ISUCON7予選1日目に「都営三田線」で参加して通過できた話","timestamp":1508758422000,"tags":[]},{"rawMarkdown":"---\ntitle: \"go generate する時のバイナリのバージョンを固定したい\"\ndate: 2017-08-05T16:58:13.000Z\ntags: []\n---\n\n<p><a href=\"https://github.com/golang/mock\">https://github.com/golang/mock</a> は <code>mockgen</code> というコマンドを提供しています．\nこれは，interface から mock を自動生成するコマンドで <code>go generate</code> と合わせて使うと interface に追従する mock がとても簡単に作れます．</p>\n\n<p>他にも <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/yacc\">yacc</a> とかリソースをバイナリに埋め込むとか，色々便利ツールがあり，<code>go generate</code> でコード生成をするのは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> のアプリケーションではよくあることだと思います．</p>\n\n<p>しかし，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> の <code>vendor/</code> の仕組みは基本的に package として使うことを考えて作られているので，プロジェクトごとに <code>mockgen</code> などの生成コマンドのバージョンを固定するためには使えません．</p>\n\n<p>ここで，<code>go generate</code> で使うバイナリのバージョンが固定されていないと起こりうる問題として</p>\n\n<ul>\n<li>生成されたコードに毎回 diff が出る\n\n<ul>\n<li>気軽に <code>git add .</code> 出来ないし，コミット漏れや無駄コミットにつながる</li>\n</ul>\n</li>\n<li>バージョンAのコマンドとバージョンBのコマンドによって生成されたコードが混ざる</li>\n<li>ライブラリのバージョンと生成コマンドのバージョンが一致しないためバグる\n\n<ul>\n<li><code>github.com/golang/mock/mockgen</code> は <code>github.com/golang/mock/gomock</code> というライブラリとセットで使うので，<code>gomock</code> package と <code>mockgen</code> バイナリのバージョンは揃えたい</li>\n</ul>\n</li>\n</ul>\n\n<p>などがあります．</p>\n\n<p>これ結構嫌な問題だと思ったのですが，パッとぐぐってみてもあまり困っている声を聞かないので普通どうやって解決しているのか気になっています．\n(もしかして僕が知らないだけで普通に解決されている問題だったりするのだろうか&hellip;)</p>\n\n<p>とりあえず <code>vendor</code> 以下の package をビルドしたり固定されたバージョンのバイナリをぱぱっと実行するために</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fbindor\" title=\"agatan/bindor\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://github.com/agatan/bindor\">github.com</a></cite></p>\n\n<p>を作ってみました．</p>\n\n<p>shell script で書けそうな単純な仕事しかしていませんが，go で実装されています．</p>\n\n<p><code>bindor build github.com/golang/mock/mockgen</code> で <code>./.bindor/mockgen</code> というバイナリが出来ます．\n<code>bindor exec command args...</code> とやると <code>PATH=./.bindor:$PATH</code> した環境下で <code>command args...</code> を実行します．</p>\n\n<pre class=\"code lang-sh\" data-lang=\"sh\" data-unlink>$ glide get github.com/golang/mock\n$ bindor build github.com/golang/mock/mockgen\n$ bindor <span class=\"synStatement\">exec</span> which mockgen\n/path/to/current/.bindor/mockgen\n</pre>\n\n<p>という感じです．</p>\n\n<p><code>//go:generate bindor mockgen</code> としてもいいですが，<code>bindor exec go generate</code> とすれば<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>を書き換えなくても <code>.bindor</code> 以下のバイナリを使うようになるはずです．</p>\n\n<p><code>bindor</code> 自体にバージョンを固定する仕組みは入れていません．glide とかがやってくれている仕事を分散させても管理が面倒になるだけでメリットがなさそうだし，ライブラリとしても使う package の場合はどうせ glide で管理するので，<code>vendor</code> 以下の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リの奪い合いになってしまいます．</p>\n\n<p>というわけでバイナリを vendoring する <code>bindor</code> を作った話でした．もっといい解決方法があったら教えてください．</p>\n\n---\n\n---\n","contentMarkdown":"\n<p><a href=\"https://github.com/golang/mock\">https://github.com/golang/mock</a> は <code>mockgen</code> というコマンドを提供しています．\nこれは，interface から mock を自動生成するコマンドで <code>go generate</code> と合わせて使うと interface に追従する mock がとても簡単に作れます．</p>\n\n<p>他にも <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/yacc\">yacc</a> とかリソースをバイナリに埋め込むとか，色々便利ツールがあり，<code>go generate</code> でコード生成をするのは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> のアプリケーションではよくあることだと思います．</p>\n\n<p>しかし，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> の <code>vendor/</code> の仕組みは基本的に package として使うことを考えて作られているので，プロジェクトごとに <code>mockgen</code> などの生成コマンドのバージョンを固定するためには使えません．</p>\n\n<p>ここで，<code>go generate</code> で使うバイナリのバージョンが固定されていないと起こりうる問題として</p>\n\n<ul>\n<li>生成されたコードに毎回 diff が出る\n\n<ul>\n<li>気軽に <code>git add .</code> 出来ないし，コミット漏れや無駄コミットにつながる</li>\n</ul>\n</li>\n<li>バージョンAのコマンドとバージョンBのコマンドによって生成されたコードが混ざる</li>\n<li>ライブラリのバージョンと生成コマンドのバージョンが一致しないためバグる\n\n<ul>\n<li><code>github.com/golang/mock/mockgen</code> は <code>github.com/golang/mock/gomock</code> というライブラリとセットで使うので，<code>gomock</code> package と <code>mockgen</code> バイナリのバージョンは揃えたい</li>\n</ul>\n</li>\n</ul>\n\n<p>などがあります．</p>\n\n<p>これ結構嫌な問題だと思ったのですが，パッとぐぐってみてもあまり困っている声を聞かないので普通どうやって解決しているのか気になっています．\n(もしかして僕が知らないだけで普通に解決されている問題だったりするのだろうか&hellip;)</p>\n\n<p>とりあえず <code>vendor</code> 以下の package をビルドしたり固定されたバージョンのバイナリをぱぱっと実行するために</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fbindor\" title=\"agatan/bindor\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://github.com/agatan/bindor\">github.com</a></cite></p>\n\n<p>を作ってみました．</p>\n\n<p>shell script で書けそうな単純な仕事しかしていませんが，go で実装されています．</p>\n\n<p><code>bindor build github.com/golang/mock/mockgen</code> で <code>./.bindor/mockgen</code> というバイナリが出来ます．\n<code>bindor exec command args...</code> とやると <code>PATH=./.bindor:$PATH</code> した環境下で <code>command args...</code> を実行します．</p>\n\n<pre class=\"code lang-sh\" data-lang=\"sh\" data-unlink>$ glide get github.com/golang/mock\n$ bindor build github.com/golang/mock/mockgen\n$ bindor <span class=\"synStatement\">exec</span> which mockgen\n/path/to/current/.bindor/mockgen\n</pre>\n\n<p>という感じです．</p>\n\n<p><code>//go:generate bindor mockgen</code> としてもいいですが，<code>bindor exec go generate</code> とすれば<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>を書き換えなくても <code>.bindor</code> 以下のバイナリを使うようになるはずです．</p>\n\n<p><code>bindor</code> 自体にバージョンを固定する仕組みは入れていません．glide とかがやってくれている仕事を分散させても管理が面倒になるだけでメリットがなさそうだし，ライブラリとしても使う package の場合はどうせ glide で管理するので，<code>vendor</code> 以下の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リの奪い合いになってしまいます．</p>\n\n<p>というわけでバイナリを vendoring する <code>bindor</code> を作った話でした．もっといい解決方法があったら教えてください．</p>\n\n---\n\n---\n","slug":"go_generate_する時のバイナリのバージョンを固定したい","title":"go generate する時のバイナリのバージョンを固定したい","timestamp":1501952293000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Rust で Unix のシグナルを channel 経由でキャッチする\"\ndate: 2017-07-10T11:59:04.000Z\ntags: []\n---\n\n<p>Rust でシグナルハンドリングをする必要があったのですが，あまり自分の用途にあるライブラリがなかったので作りました．\n僕が <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Windows\">Windows</a> のことをほとんどわからないので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Windows\">Windows</a> 未対応です．</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fsignal-notify\" title=\"agatan/signal-notify\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://github.com/agatan/signal-notify\">github.com</a></cite></p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fdocs.rs%2Fsignal-notify%2F0.1.2%2Fsignal_notify%2F\" title=\"signal_notify - Rust\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://docs.rs/signal-notify/0.1.2/signal_notify/\">docs.rs</a></cite></p>\n\n<p><a href=\"https://crates.io/crates/signal-notify\">https://crates.io/crates/signal-notify</a></p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> の <code>signal.Notify</code> に寄せた <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> になっていて，標準ライブラリの <code>std::sync::mpsc::{Sender, Receiver}</code> 経由でシグナルを待ち受けることができます．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">extern</span> <span class=\"synStatement\">crate</span> <span class=\"synIdentifier\">signal_notify</span>;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">signal_notify</span><span class=\"synSpecial\">::</span>{notify, Signal};\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">std</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">sync</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">mpsc</span><span class=\"synSpecial\">::</span>Receiver;\n\n<span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">main</span>() {\n    <span class=\"synStatement\">let</span> rx: Receiver<span class=\"synStatement\">&lt;</span>Signal<span class=\"synStatement\">&gt;</span> <span class=\"synStatement\">=</span> <span class=\"synIdentifier\">notify</span>(<span class=\"synType\">&amp;</span>[<span class=\"synPreProc\">Signal</span><span class=\"synSpecial\">::</span>INT, <span class=\"synPreProc\">Signal</span><span class=\"synSpecial\">::</span>USR1]);\n    <span class=\"synStatement\">for</span> sig <span class=\"synStatement\">in</span> rx.<span class=\"synIdentifier\">iter</span>() {\n        <span class=\"synStatement\">match</span> sig {\n            <span class=\"synPreProc\">Signal</span><span class=\"synSpecial\">::</span>INT <span class=\"synStatement\">=&gt;</span> {\n                <span class=\"synPreProc\">println!</span>(<span class=\"synConstant\">&quot;Interrupted!&quot;</span>);\n                <span class=\"synStatement\">break</span>;\n            }\n            <span class=\"synPreProc\">Signal</span><span class=\"synSpecial\">::</span>USR1 <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">println!</span>(<span class=\"synConstant\">&quot;Got SIGUSR1!&quot;</span>),\n        }\n    }\n}\n</pre>\n\n<p>Rust で <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Unix\">Unix</a> シグナルを取るライブラリとしては <a href=\"https://github.com/BurntSushi/chan-signal\">GitHub - BurntSushi/chan-signal: Respond to OS signals with channels.</a> というのが有名です．\nこちらは標準ライブラリの <code>mpsc::channel</code> ではなく，<code>chan</code> クレイトの <code>channel</code> を使っています．\n<code>chan</code> クレイトはケースによってはかなり便利で，</p>\n\n<ol>\n<li>複数の consumer を作れる (<code>receiver.clone()</code> ができる)</li>\n<li><code>chan_select!</code> マクロによって <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> の <code>select</code> 的なことができる</li>\n</ol>\n\n<p>という利点があります．</p>\n\n<p>一方で複数 consumer にする必要がない &amp; <code>chan_select!</code> が必要ないケースでは，シグナルハンドリングのためだけに <code>chan</code> にも依存するのもなんとなくはばかられるという気持ちがありました．\nまた，自分の目的として「<code>SIGWINCH</code> と <code>SIGIO</code> が取りたい」というのがあったのですが，<code>chan-signal</code> の仕組みだとデフォルトで無視されるシグナルをキャッチできない(<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/macOS\">macOS</a> だけ)という問題もありました．\n報告するときに方法を考えていたのですが，あまり自信がなかったのとほとんど完全に仕組みを書きなおす形になりそうだったので，自分の手元で <code>std::sync::mpsc</code> を使って実験してみたという経緯です．</p>\n\n<h2>仕組み</h2>\n\n<ol>\n<li>初期化時にパイプを作る</li>\n<li>シグナルごとに通知すべき <code>Sender</code> を覚えておく</li>\n<li>シグナルごとに <code>sigaction</code> でハンドラをセットする\n\n<ul>\n<li>シグナルが来たらそれをパイプに <code>write(2)</code> する</li>\n</ul>\n</li>\n<li>シグナル待受＆通知用のスレッドを起動する\n\n<ul>\n<li>パイプからシグナル番号を読んで，適切な <code>Sender</code> に <code>send</code> する</li>\n</ul>\n</li>\n</ol>\n\n<p>という仕組みで動いています．\n自信がなかったのは，「シグナルハンドラでやっていいこと一覧」をちゃんと把握していないという点です．\n一応 <code>sigaction</code> の man を見ると <code>write</code> は読んでもいい関数一覧にいる気がするし，実際動いてはいるのでセーフだろうと判断しました．\n（もしアウトだったら教えてください）</p>\n\n<p>ちなみに <code>chan-signal</code> の方は，</p>\n\n<ol>\n<li>シグナルごとに通知すべき <code>Sender</code> を覚えておく</li>\n<li>監視用スレッドを起動し，メインスレッドでは <code>pthread_sigmask</code> を使ってシグナルをブロックする\n\n<ul>\n<li>シグナルがすべて監視用スレッドに渡るようにする</li>\n</ul>\n</li>\n<li>監視用スレッドで <code>sigwait</code> して適切な <code>Sender</code> に <code>send</code> する</li>\n</ol>\n\n<p>という仕組みで動いているようです．\n<code>sigwait</code> は指定したシグナルが投げられるまでブロックします．\nただし，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/macOS\">macOS</a> で <code>sigwait</code> の man を見ると，</p>\n\n<blockquote><p>Processes which call sigwait() on ignored signals will wait indefinitely. Ignored signals are dropped immediately by the system, before delivery to a waiting process.</p></blockquote>\n\n<p>とあって，無視されるシグナルを <code>sigwait</code> で待っても補足できないようです．\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Linux\">Linux</a> の man を見るとそんなことは書いていないし，普通に動くっぽいです．</p>\n\n<p>今の実装だと，シグナルを受け取る <code>Receiver</code> がすべて閉じても，監視スレッドは動き続けるしハンドラも残り続けるので，これはなんとかしたいなぁと思っています．\nアプリケーションの実行時間のうち，ある期間だけシグナルをとってそれ以外はスルーしたいというケースもそんなにないかなというのと，内部的な変更にしかならないので <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> が変わらないというのがあるので，この状態でとりあえず public にしました．</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLI\">CLI</a> を書いていると意外と普通に <code>SIGINT</code> は取りたくなることがあると思うので，ぜひ使ってみてください．\nissue 報告等お待ちしています．</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>Rust でシグナルハンドリングをする必要があったのですが，あまり自分の用途にあるライブラリがなかったので作りました．\n僕が <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Windows\">Windows</a> のことをほとんどわからないので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Windows\">Windows</a> 未対応です．</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fsignal-notify\" title=\"agatan/signal-notify\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://github.com/agatan/signal-notify\">github.com</a></cite></p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fdocs.rs%2Fsignal-notify%2F0.1.2%2Fsignal_notify%2F\" title=\"signal_notify - Rust\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://docs.rs/signal-notify/0.1.2/signal_notify/\">docs.rs</a></cite></p>\n\n<p><a href=\"https://crates.io/crates/signal-notify\">https://crates.io/crates/signal-notify</a></p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> の <code>signal.Notify</code> に寄せた <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> になっていて，標準ライブラリの <code>std::sync::mpsc::{Sender, Receiver}</code> 経由でシグナルを待ち受けることができます．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">extern</span> <span class=\"synStatement\">crate</span> <span class=\"synIdentifier\">signal_notify</span>;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">signal_notify</span><span class=\"synSpecial\">::</span>{notify, Signal};\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">std</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">sync</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">mpsc</span><span class=\"synSpecial\">::</span>Receiver;\n\n<span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">main</span>() {\n    <span class=\"synStatement\">let</span> rx: Receiver<span class=\"synStatement\">&lt;</span>Signal<span class=\"synStatement\">&gt;</span> <span class=\"synStatement\">=</span> <span class=\"synIdentifier\">notify</span>(<span class=\"synType\">&amp;</span>[<span class=\"synPreProc\">Signal</span><span class=\"synSpecial\">::</span>INT, <span class=\"synPreProc\">Signal</span><span class=\"synSpecial\">::</span>USR1]);\n    <span class=\"synStatement\">for</span> sig <span class=\"synStatement\">in</span> rx.<span class=\"synIdentifier\">iter</span>() {\n        <span class=\"synStatement\">match</span> sig {\n            <span class=\"synPreProc\">Signal</span><span class=\"synSpecial\">::</span>INT <span class=\"synStatement\">=&gt;</span> {\n                <span class=\"synPreProc\">println!</span>(<span class=\"synConstant\">&quot;Interrupted!&quot;</span>);\n                <span class=\"synStatement\">break</span>;\n            }\n            <span class=\"synPreProc\">Signal</span><span class=\"synSpecial\">::</span>USR1 <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">println!</span>(<span class=\"synConstant\">&quot;Got SIGUSR1!&quot;</span>),\n        }\n    }\n}\n</pre>\n\n<p>Rust で <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Unix\">Unix</a> シグナルを取るライブラリとしては <a href=\"https://github.com/BurntSushi/chan-signal\">GitHub - BurntSushi/chan-signal: Respond to OS signals with channels.</a> というのが有名です．\nこちらは標準ライブラリの <code>mpsc::channel</code> ではなく，<code>chan</code> クレイトの <code>channel</code> を使っています．\n<code>chan</code> クレイトはケースによってはかなり便利で，</p>\n\n<ol>\n<li>複数の consumer を作れる (<code>receiver.clone()</code> ができる)</li>\n<li><code>chan_select!</code> マクロによって <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> の <code>select</code> 的なことができる</li>\n</ol>\n\n<p>という利点があります．</p>\n\n<p>一方で複数 consumer にする必要がない &amp; <code>chan_select!</code> が必要ないケースでは，シグナルハンドリングのためだけに <code>chan</code> にも依存するのもなんとなくはばかられるという気持ちがありました．\nまた，自分の目的として「<code>SIGWINCH</code> と <code>SIGIO</code> が取りたい」というのがあったのですが，<code>chan-signal</code> の仕組みだとデフォルトで無視されるシグナルをキャッチできない(<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/macOS\">macOS</a> だけ)という問題もありました．\n報告するときに方法を考えていたのですが，あまり自信がなかったのとほとんど完全に仕組みを書きなおす形になりそうだったので，自分の手元で <code>std::sync::mpsc</code> を使って実験してみたという経緯です．</p>\n\n<h2>仕組み</h2>\n\n<ol>\n<li>初期化時にパイプを作る</li>\n<li>シグナルごとに通知すべき <code>Sender</code> を覚えておく</li>\n<li>シグナルごとに <code>sigaction</code> でハンドラをセットする\n\n<ul>\n<li>シグナルが来たらそれをパイプに <code>write(2)</code> する</li>\n</ul>\n</li>\n<li>シグナル待受＆通知用のスレッドを起動する\n\n<ul>\n<li>パイプからシグナル番号を読んで，適切な <code>Sender</code> に <code>send</code> する</li>\n</ul>\n</li>\n</ol>\n\n<p>という仕組みで動いています．\n自信がなかったのは，「シグナルハンドラでやっていいこと一覧」をちゃんと把握していないという点です．\n一応 <code>sigaction</code> の man を見ると <code>write</code> は読んでもいい関数一覧にいる気がするし，実際動いてはいるのでセーフだろうと判断しました．\n（もしアウトだったら教えてください）</p>\n\n<p>ちなみに <code>chan-signal</code> の方は，</p>\n\n<ol>\n<li>シグナルごとに通知すべき <code>Sender</code> を覚えておく</li>\n<li>監視用スレッドを起動し，メインスレッドでは <code>pthread_sigmask</code> を使ってシグナルをブロックする\n\n<ul>\n<li>シグナルがすべて監視用スレッドに渡るようにする</li>\n</ul>\n</li>\n<li>監視用スレッドで <code>sigwait</code> して適切な <code>Sender</code> に <code>send</code> する</li>\n</ol>\n\n<p>という仕組みで動いているようです．\n<code>sigwait</code> は指定したシグナルが投げられるまでブロックします．\nただし，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/macOS\">macOS</a> で <code>sigwait</code> の man を見ると，</p>\n\n<blockquote><p>Processes which call sigwait() on ignored signals will wait indefinitely. Ignored signals are dropped immediately by the system, before delivery to a waiting process.</p></blockquote>\n\n<p>とあって，無視されるシグナルを <code>sigwait</code> で待っても補足できないようです．\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Linux\">Linux</a> の man を見るとそんなことは書いていないし，普通に動くっぽいです．</p>\n\n<p>今の実装だと，シグナルを受け取る <code>Receiver</code> がすべて閉じても，監視スレッドは動き続けるしハンドラも残り続けるので，これはなんとかしたいなぁと思っています．\nアプリケーションの実行時間のうち，ある期間だけシグナルをとってそれ以外はスルーしたいというケースもそんなにないかなというのと，内部的な変更にしかならないので <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> が変わらないというのがあるので，この状態でとりあえず public にしました．</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLI\">CLI</a> を書いていると意外と普通に <code>SIGINT</code> は取りたくなることがあると思うので，ぜひ使ってみてください．\nissue 報告等お待ちしています．</p>\n\n---\n\n---\n","slug":"Rust_で_Unix_のシグナルを_channel_経由でキャッチする","title":"Rust で Unix のシグナルを channel 経由でキャッチする","timestamp":1499687944000,"tags":[]},{"rawMarkdown":"---\ntitle: \"BK-tree を golang で実装した\"\ndate: 2017-05-13T09:33:10.000Z\ntags: []\n---\n\n<p>先日はてぶに  <a href=\"http://postd.cc/bk-tree/\">&#x8208;&#x5473;&#x6DF1;&#x3044;&#x30C7;&#x30FC;&#x30BF;&#x69CB;&#x9020;&#xFF1A;BK&#x6728; | &#x30D7;&#x30ED;&#x30B0;&#x30E9;&#x30DF;&#x30F3;&#x30B0; | POSTD</a> という翻訳記事 ( 元記事 <a href=\"http://signal-to-noise.xyz/post/bk-tree/\">http://signal-to-noise.xyz/post/bk-tree/</a>) があがっているのをみて初めて BK-tree というものを知ったので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> で実装してみました．</p>\n\n<p><iframe src=\"//hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fbktree\" title=\"agatan/bktree\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://github.com/agatan/bktree\">github.com</a></cite></p>\n\n<h2>BK-tree とは</h2>\n\n<p>先程の記事に全部書いてあるのですが&hellip;\nBK-tree は，ある<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%F7%CE%A5%B6%F5%B4%D6\">距離空間</a>内で近傍点探索を効率的に行えるデータ構造です．利用例としてはスペルチェックや類似画像検索などがあります．</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%F7%CE%A5%B6%F5%B4%D6\">距離空間</a>とは，なにかしらの距離を計算することができる空間のことで，距離としてハミング距離やマンハッタン距離，レーベンシュタイン距離，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\">ユークリッド</a>距離などなどが挙げられます．\n例えば，いわゆる普通の 3 次元の空間は，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\">ユークリッド</a>距離を距離関数に持つ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%F7%CE%A5%B6%F5%B4%D6\">距離空間</a>と考えられます．</p>\n\n<p>近傍点探索は，要するにある点に対して，近くにある点を探すことです．</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20170513/20170513183241.png\" alt=\"f:id:agtn:20170513183241p:plain\" title=\"f:id:agtn:20170513183241p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>ものすごく単純に近傍点探索をやろうと思うと，全要素を線形に探索して距離を計算していく必要があります．\nそこで BK-tree を使うともっと計算量が減らせるというわけなのです．(ちなみに僕は BK-tree を使った場合の計算量がよくわかっていません．実験的に速いことを確認しただけです．正確な計算量は考えてもよくわかりませんでした&hellip;)</p>\n\n<p>構造や仕組みは元記事などをご参照ください．</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> での bk-tree 実装は実はいくつかあったのですが，単純に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\">アルゴリズム</a>を理解するために実装したかったのと，レーベンシュタイン距離を距離関数として使うことを前提にしていたりとちょっと自分の用途に合っていない気がしたので，別で作ってみました．</p>\n\n<p>このパッケージでは，スペルチェックそのものや距離関数を提供していません．BK-tree というデータ構造だけを提供しています．</p>\n\n<h2>使用例</h2>\n\n<p>16 bit 整数を要素，ハミング距離を距離関数とした例です．</p>\n\n<p>要素となる型は <code>bktree.Entry</code> interface を満たす必要があります．これは <code>Distance(Entry) int</code> を要求する interface です．<br/>\n本当は <code>distance&lt;T: Entry&gt;(x: T) -&gt; int</code> みたいな形にしたいのですが，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> だと出来ないので，実装側で <code>e.(hashValue)</code> のように型<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%B5%A1%BC%A5%B7%A5%E7%A5%F3\">アサーション</a>する必要があります．<br/>\nここでは <code>uint16</code> に戻してハミング距離を計算しています．</p>\n\n<p>要素の追加は <code>Add(e Entry)</code> です．<br/>\nここでは 0 ~ 0xffff までを突っ込んでいます．</p>\n\n<p>探索は <code>Search(e Entry, tolerance int) []*Result</code> です．\n第一引数がキー，第二引数が許容する距離の最大値です．</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">package</span> main\n\n<span class=\"synStatement\">import</span> (\n    <span class=\"synConstant\">&quot;fmt&quot;</span>\n\n    <span class=\"synConstant\">&quot;github.com/agatan/bktree&quot;</span>\n)\n\n<span class=\"synStatement\">type</span> hashValue <span class=\"synType\">uint16</span>\n\n<span class=\"synComment\">// Distance calculates hamming distance.</span>\n<span class=\"synStatement\">func</span> (h hashValue) Distance(e bktree.Entry) <span class=\"synType\">int</span> {\n    a := <span class=\"synType\">uint16</span>(h)\n    b := <span class=\"synType\">uint16</span>(e.(hashValue))\n\n    d := <span class=\"synConstant\">0</span>\n    <span class=\"synStatement\">var</span> k <span class=\"synType\">uint16</span> = <span class=\"synConstant\">1</span>\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; <span class=\"synConstant\">16</span>; i++ {\n        <span class=\"synStatement\">if</span> a&amp;k != b&amp;k {\n            d++\n        }\n        k &lt;&lt;= <span class=\"synConstant\">1</span>\n    }\n    <span class=\"synStatement\">return</span> d\n}\n\n<span class=\"synStatement\">func</span> main() {\n    <span class=\"synStatement\">var</span> tree bktree.BKTree\n\n    <span class=\"synComment\">// add 0x0000 to 0xffff to the tree.</span>\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; <span class=\"synConstant\">0xffff</span>; i++ {\n        tree.Add(hashValue(i))\n    }\n\n    <span class=\"synComment\">// search neighbors of 0x0000 whose distances are less than or equal to 1.</span>\n    results := tree.Search(hashValue(<span class=\"synConstant\">0</span>), <span class=\"synConstant\">1</span>)\n    <span class=\"synStatement\">for</span> _, result := <span class=\"synStatement\">range</span> results {\n        fmt.Printf(<span class=\"synConstant\">&quot;%016b (distance: %d)</span><span class=\"synSpecial\">\\n</span><span class=\"synConstant\">&quot;</span>, result.Entry.(hashValue), result.Distance)\n    }\n}\n</pre>\n\n<p>これを実行すると，</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>0000000000000000 (distance: 0)\n0000000000000001 (distance: 1)\n0000000000000010 (distance: 1)\n0000000000000100 (distance: 1)\n0000000000001000 (distance: 1)\n0000000000010000 (distance: 1)\n0000000000100000 (distance: 1)\n0000000001000000 (distance: 1)\n0000000010000000 (distance: 1)\n0000000100000000 (distance: 1)\n0000001000000000 (distance: 1)\n0000010000000000 (distance: 1)\n0000100000000000 (distance: 1)\n0001000000000000 (distance: 1)\n0010000000000000 (distance: 1)\n0100000000000000 (distance: 1)\n1000000000000000 (distance: 1)</pre>\n\n<p>という感じで 0x0000 とのハミング距離が 0 ~ 1 である要素がとれます．</p>\n\n<h2>パフォーマンス</h2>\n\n<p>単純な線形探索との比較をする<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\">ベンチマーク</a>をおいてあります．<br/>\n64 bit 整数，距離関数はハミング距離，データ量 1,000,000 件での結果が以下のようになりました．</p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left;\"> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\">ベンチマーク</a> </th>\n<th style=\"text-align:left;\"> 実行時間 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left;\"> BK-tree (完全一致) </td>\n<td style=\"text-align:left;\">                          1108 ns/op </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> BK-tree (fuzziness 1) </td>\n<td style=\"text-align:left;\">          29468 ns/op </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> BK-tree (fuzziness 2) </td>\n<td style=\"text-align:left;\">           328753 ns/op </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> BK-tree (fuzziness 4) </td>\n<td style=\"text-align:left;\"> 5490888 ns/op </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> BK-tree (fuzziness 8) </td>\n<td style=\"text-align:left;\">     68182122 ns/op </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> BK-tree (fuzziness 32) </td>\n<td style=\"text-align:left;\">         353715305 ns/op </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> Linear Search </td>\n<td style=\"text-align:left;\">          4132926 ns/op </td>\n</tr>\n</tbody>\n</table>\n\n<p>fuzziness が小さければ小さいほど ( = tolerance が小さければ小さいほど ) 高速に探索できることが分かります．</p>\n\n<p>また，データ量が増えるほど Linear Search より有利になるので，距離に対してデータが十分に大量にある場合はかなり有効といえそうです．</p>\n\n<h2>おまけ</h2>\n\n<p>tree の構築にかかるコストがそこそこ大きかったので pprof で見つつチューニングする必要がありました．\n学びとして，「map が重い」「interface が重い」というのがありました．</p>\n\n<p>各ノードの部分木は，そのノードからの距離 d を key として，<code>map[int]*Node</code> としていました．\ntree を構築する際には，allocate + read + write をかなりの回数行うのですが，これがまぁ遅い．<br/>\n最終的にこの部分はスライスでもっておいて，d を key として部分木をとりたい時は線形探索をするようにしました．<br/>\n<code>next, ok := n.children[d]</code> としていた部分が</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">type</span> elem <span class=\"synStatement\">struct</span>\n    distance <span class=\"synType\">int</span>\n    node *node\n}\n\n<span class=\"synStatement\">for</span> _, c := <span class=\"synStatement\">range</span> n.children {\n    <span class=\"synStatement\">if</span> c.distance == d {\n        <span class=\"synStatement\">return</span> c.node\n    }\n}\n<span class=\"synStatement\">return</span> <span class=\"synStatement\">nil</span>\n</pre>\n\n<p>という感じになります．あんまりきれいではないんですが，こっちの方がほとんどのケース倍以上速かったので，こちらを採用しました．<br/>\n部分木の数が増えてくると，map のほうが速いと思われるのですが，ハミング距離の場合最大でも bit 数までしか部分木が増えないので．<br/>\nレーベンシュタイン距離を用いたスペルチェックの場合でも，単語の最大文字数以上の距離にはなりません．\n2 次元 / 3 次元程度の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%F7%CE%A5%B6%F5%B4%D6\">距離空間</a>なら kd-tree などもっと他に良い方法があるきがするので，レーベンシュタイン距離やハミング距離を使うケースをメインに考えました．</p>\n\n<p>その結果，実行時間のかなりの割合が <code>Entry</code> interface を介した関数呼び出しのオーバヘッドとか，inteface の allocation になってしまいました．<br/>\nデータ構造を <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> で提供する以上このオーバヘッドは避けられないです．( もちろん BK-tree そのものを，自分の利用形態に特化して作れば回避できますが&hellip; )<br/>\nちょっと Rust や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> で書きたくなりました．十分速いし書きやすいので良いんですが&hellip;</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>先日はてぶに  <a href=\"http://postd.cc/bk-tree/\">&#x8208;&#x5473;&#x6DF1;&#x3044;&#x30C7;&#x30FC;&#x30BF;&#x69CB;&#x9020;&#xFF1A;BK&#x6728; | &#x30D7;&#x30ED;&#x30B0;&#x30E9;&#x30DF;&#x30F3;&#x30B0; | POSTD</a> という翻訳記事 ( 元記事 <a href=\"http://signal-to-noise.xyz/post/bk-tree/\">http://signal-to-noise.xyz/post/bk-tree/</a>) があがっているのをみて初めて BK-tree というものを知ったので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> で実装してみました．</p>\n\n<p><iframe src=\"//hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fbktree\" title=\"agatan/bktree\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://github.com/agatan/bktree\">github.com</a></cite></p>\n\n<h2>BK-tree とは</h2>\n\n<p>先程の記事に全部書いてあるのですが&hellip;\nBK-tree は，ある<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%F7%CE%A5%B6%F5%B4%D6\">距離空間</a>内で近傍点探索を効率的に行えるデータ構造です．利用例としてはスペルチェックや類似画像検索などがあります．</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%F7%CE%A5%B6%F5%B4%D6\">距離空間</a>とは，なにかしらの距離を計算することができる空間のことで，距離としてハミング距離やマンハッタン距離，レーベンシュタイン距離，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\">ユークリッド</a>距離などなどが挙げられます．\n例えば，いわゆる普通の 3 次元の空間は，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\">ユークリッド</a>距離を距離関数に持つ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%F7%CE%A5%B6%F5%B4%D6\">距離空間</a>と考えられます．</p>\n\n<p>近傍点探索は，要するにある点に対して，近くにある点を探すことです．</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20170513/20170513183241.png\" alt=\"f:id:agtn:20170513183241p:plain\" title=\"f:id:agtn:20170513183241p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>ものすごく単純に近傍点探索をやろうと思うと，全要素を線形に探索して距離を計算していく必要があります．\nそこで BK-tree を使うともっと計算量が減らせるというわけなのです．(ちなみに僕は BK-tree を使った場合の計算量がよくわかっていません．実験的に速いことを確認しただけです．正確な計算量は考えてもよくわかりませんでした&hellip;)</p>\n\n<p>構造や仕組みは元記事などをご参照ください．</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> での bk-tree 実装は実はいくつかあったのですが，単純に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\">アルゴリズム</a>を理解するために実装したかったのと，レーベンシュタイン距離を距離関数として使うことを前提にしていたりとちょっと自分の用途に合っていない気がしたので，別で作ってみました．</p>\n\n<p>このパッケージでは，スペルチェックそのものや距離関数を提供していません．BK-tree というデータ構造だけを提供しています．</p>\n\n<h2>使用例</h2>\n\n<p>16 bit 整数を要素，ハミング距離を距離関数とした例です．</p>\n\n<p>要素となる型は <code>bktree.Entry</code> interface を満たす必要があります．これは <code>Distance(Entry) int</code> を要求する interface です．<br/>\n本当は <code>distance&lt;T: Entry&gt;(x: T) -&gt; int</code> みたいな形にしたいのですが，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> だと出来ないので，実装側で <code>e.(hashValue)</code> のように型<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%B5%A1%BC%A5%B7%A5%E7%A5%F3\">アサーション</a>する必要があります．<br/>\nここでは <code>uint16</code> に戻してハミング距離を計算しています．</p>\n\n<p>要素の追加は <code>Add(e Entry)</code> です．<br/>\nここでは 0 ~ 0xffff までを突っ込んでいます．</p>\n\n<p>探索は <code>Search(e Entry, tolerance int) []*Result</code> です．\n第一引数がキー，第二引数が許容する距離の最大値です．</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">package</span> main\n\n<span class=\"synStatement\">import</span> (\n    <span class=\"synConstant\">&quot;fmt&quot;</span>\n\n    <span class=\"synConstant\">&quot;github.com/agatan/bktree&quot;</span>\n)\n\n<span class=\"synStatement\">type</span> hashValue <span class=\"synType\">uint16</span>\n\n<span class=\"synComment\">// Distance calculates hamming distance.</span>\n<span class=\"synStatement\">func</span> (h hashValue) Distance(e bktree.Entry) <span class=\"synType\">int</span> {\n    a := <span class=\"synType\">uint16</span>(h)\n    b := <span class=\"synType\">uint16</span>(e.(hashValue))\n\n    d := <span class=\"synConstant\">0</span>\n    <span class=\"synStatement\">var</span> k <span class=\"synType\">uint16</span> = <span class=\"synConstant\">1</span>\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; <span class=\"synConstant\">16</span>; i++ {\n        <span class=\"synStatement\">if</span> a&amp;k != b&amp;k {\n            d++\n        }\n        k &lt;&lt;= <span class=\"synConstant\">1</span>\n    }\n    <span class=\"synStatement\">return</span> d\n}\n\n<span class=\"synStatement\">func</span> main() {\n    <span class=\"synStatement\">var</span> tree bktree.BKTree\n\n    <span class=\"synComment\">// add 0x0000 to 0xffff to the tree.</span>\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; <span class=\"synConstant\">0xffff</span>; i++ {\n        tree.Add(hashValue(i))\n    }\n\n    <span class=\"synComment\">// search neighbors of 0x0000 whose distances are less than or equal to 1.</span>\n    results := tree.Search(hashValue(<span class=\"synConstant\">0</span>), <span class=\"synConstant\">1</span>)\n    <span class=\"synStatement\">for</span> _, result := <span class=\"synStatement\">range</span> results {\n        fmt.Printf(<span class=\"synConstant\">&quot;%016b (distance: %d)</span><span class=\"synSpecial\">\\n</span><span class=\"synConstant\">&quot;</span>, result.Entry.(hashValue), result.Distance)\n    }\n}\n</pre>\n\n<p>これを実行すると，</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>0000000000000000 (distance: 0)\n0000000000000001 (distance: 1)\n0000000000000010 (distance: 1)\n0000000000000100 (distance: 1)\n0000000000001000 (distance: 1)\n0000000000010000 (distance: 1)\n0000000000100000 (distance: 1)\n0000000001000000 (distance: 1)\n0000000010000000 (distance: 1)\n0000000100000000 (distance: 1)\n0000001000000000 (distance: 1)\n0000010000000000 (distance: 1)\n0000100000000000 (distance: 1)\n0001000000000000 (distance: 1)\n0010000000000000 (distance: 1)\n0100000000000000 (distance: 1)\n1000000000000000 (distance: 1)</pre>\n\n<p>という感じで 0x0000 とのハミング距離が 0 ~ 1 である要素がとれます．</p>\n\n<h2>パフォーマンス</h2>\n\n<p>単純な線形探索との比較をする<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\">ベンチマーク</a>をおいてあります．<br/>\n64 bit 整数，距離関数はハミング距離，データ量 1,000,000 件での結果が以下のようになりました．</p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left;\"> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\">ベンチマーク</a> </th>\n<th style=\"text-align:left;\"> 実行時間 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left;\"> BK-tree (完全一致) </td>\n<td style=\"text-align:left;\">                          1108 ns/op </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> BK-tree (fuzziness 1) </td>\n<td style=\"text-align:left;\">          29468 ns/op </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> BK-tree (fuzziness 2) </td>\n<td style=\"text-align:left;\">           328753 ns/op </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> BK-tree (fuzziness 4) </td>\n<td style=\"text-align:left;\"> 5490888 ns/op </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> BK-tree (fuzziness 8) </td>\n<td style=\"text-align:left;\">     68182122 ns/op </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> BK-tree (fuzziness 32) </td>\n<td style=\"text-align:left;\">         353715305 ns/op </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> Linear Search </td>\n<td style=\"text-align:left;\">          4132926 ns/op </td>\n</tr>\n</tbody>\n</table>\n\n<p>fuzziness が小さければ小さいほど ( = tolerance が小さければ小さいほど ) 高速に探索できることが分かります．</p>\n\n<p>また，データ量が増えるほど Linear Search より有利になるので，距離に対してデータが十分に大量にある場合はかなり有効といえそうです．</p>\n\n<h2>おまけ</h2>\n\n<p>tree の構築にかかるコストがそこそこ大きかったので pprof で見つつチューニングする必要がありました．\n学びとして，「map が重い」「interface が重い」というのがありました．</p>\n\n<p>各ノードの部分木は，そのノードからの距離 d を key として，<code>map[int]*Node</code> としていました．\ntree を構築する際には，allocate + read + write をかなりの回数行うのですが，これがまぁ遅い．<br/>\n最終的にこの部分はスライスでもっておいて，d を key として部分木をとりたい時は線形探索をするようにしました．<br/>\n<code>next, ok := n.children[d]</code> としていた部分が</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">type</span> elem <span class=\"synStatement\">struct</span>\n    distance <span class=\"synType\">int</span>\n    node *node\n}\n\n<span class=\"synStatement\">for</span> _, c := <span class=\"synStatement\">range</span> n.children {\n    <span class=\"synStatement\">if</span> c.distance == d {\n        <span class=\"synStatement\">return</span> c.node\n    }\n}\n<span class=\"synStatement\">return</span> <span class=\"synStatement\">nil</span>\n</pre>\n\n<p>という感じになります．あんまりきれいではないんですが，こっちの方がほとんどのケース倍以上速かったので，こちらを採用しました．<br/>\n部分木の数が増えてくると，map のほうが速いと思われるのですが，ハミング距離の場合最大でも bit 数までしか部分木が増えないので．<br/>\nレーベンシュタイン距離を用いたスペルチェックの場合でも，単語の最大文字数以上の距離にはなりません．\n2 次元 / 3 次元程度の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%F7%CE%A5%B6%F5%B4%D6\">距離空間</a>なら kd-tree などもっと他に良い方法があるきがするので，レーベンシュタイン距離やハミング距離を使うケースをメインに考えました．</p>\n\n<p>その結果，実行時間のかなりの割合が <code>Entry</code> interface を介した関数呼び出しのオーバヘッドとか，inteface の allocation になってしまいました．<br/>\nデータ構造を <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> で提供する以上このオーバヘッドは避けられないです．( もちろん BK-tree そのものを，自分の利用形態に特化して作れば回避できますが&hellip; )<br/>\nちょっと Rust や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> で書きたくなりました．十分速いし書きやすいので良いんですが&hellip;</p>\n\n---\n\n---\n","slug":"BK-tree_を_golang_で実装した","title":"BK-tree を golang で実装した","timestamp":1494667990000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Rust でグラフ構造や木構造を作る\"\ndate: 2017-01-16T06:17:45.000Z\ntags: []\n---\n\n<p>プログラムを書いていると何かしら<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>っぽいものやグラフっぽいものを作りたい場面が多々あると思います．\nRust は所有権や <code>Size</code> の都合で，これらを作ろうと思うと地味にハマるのでまとめておきます．</p>\n\n<h3>Rust で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a></h3>\n\n<p>最も単純な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>は Rust だと</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">enum</span> <span class=\"synIdentifier\">Tree</span><span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;</span> {\n    <span class=\"synIdentifier\">Leaf</span>(T),\n    <span class=\"synIdentifier\">Node</span>(<span class=\"synType\">Box</span><span class=\"synStatement\">&lt;</span>Tree<span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;&gt;</span>, <span class=\"synType\">Box</span><span class=\"synStatement\">&lt;</span>Tree<span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;&gt;</span>),\n}\n</pre>\n\n<p>といった形で表せます．\nRust では明示的に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/boxing\">boxing</a> してあげないと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>的なデータ構造は作れないのでちょっと複雑に見えるかもしれませんが，まぁ単純です．</p>\n\n<p>この<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>を書き換えたい場合は，ownership をとって書き換えた値を返すこともできますし，<code>&amp;mut Tree&lt;T&gt;</code> をとって in-place に書き換えることもできます．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">inc</span>(<span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>) {\n    <span class=\"synStatement\">match</span> <span class=\"synType\">*</span><span class=\"synConstant\">self</span> {\n        <span class=\"synPreProc\">Tree</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">Leaf</span>(<span class=\"synType\">ref</span> <span class=\"synType\">mut</span> i) <span class=\"synStatement\">=&gt;</span> <span class=\"synType\">*</span>i <span class=\"synStatement\">=</span> <span class=\"synType\">*</span>i <span class=\"synStatement\">+</span> <span class=\"synConstant\">1</span>,\n        <span class=\"synPreProc\">Tree</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">Node</span>(<span class=\"synType\">ref</span> <span class=\"synType\">mut</span> left, <span class=\"synType\">ref</span> <span class=\"synType\">mut</span> right) <span class=\"synStatement\">=&gt;</span> {\n            left.<span class=\"synIdentifier\">inc</span>();\n            right.<span class=\"synIdentifier\">inc</span>();\n        }\n    }\n}\n\n<span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">inc2</span>(<span class=\"synConstant\">self</span>) <span class=\"synStatement\">-&gt;</span> Tree<span class=\"synStatement\">&lt;</span><span class=\"synType\">i32</span><span class=\"synStatement\">&gt;</span> {\n    <span class=\"synStatement\">match</span> <span class=\"synConstant\">self</span> {\n        <span class=\"synPreProc\">Tree</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">Leaf</span>(i) <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">Tree</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">Leaf</span>(i <span class=\"synStatement\">+</span> <span class=\"synConstant\">1</span>),\n        <span class=\"synPreProc\">Tree</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">Node</span>(left, right) <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">Tree</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">Node</span>(<span class=\"synType\">Box</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">new</span>(left.<span class=\"synIdentifier\">inc2</span>()), <span class=\"synType\">Box</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">new</span>(right.<span class=\"synIdentifier\">inc2</span>())),\n    }\n}\n</pre>\n\n<h3>Rust で有向非巡回グラフ</h3>\n\n<p>有向非巡回グラフ構造は，グラフのエッジに向きがあり，かつ循環がない構造で，これは割りと単純に表現できます．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">struct</span> <span class=\"synIdentifier\">Node</span><span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;</span>(T, <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>Rc<span class=\"synStatement\">&lt;</span>Node<span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;&gt;&gt;</span>);\n</pre>\n\n<p><code>Node</code> は自身の値 <code>T</code> と，つながっているノードの <code>Vec</code> を持ちます．(対象問題によっては <code>Vec</code> ではなくて <code>HashMap</code> とか <code>HashSet</code> とか)</p>\n\n<p><code>Rc</code> は参照カウント方式のスマートポインタです．\nグラフでは，<code>Node</code> は複数の <code>Node</code> から参照される可能性があるので， <code>Box</code> は使えません．</p>\n\n<p>これを変更可能にしたい場合はちょっと面倒ですが <code>RefCell</code> を使う必要があります．</p>\n\n<p>Rust では基本的に mutable borrow は常にひとつしか存在できず，mutable borrow が生きている間は immutable borrow もつくることができません．\n<code>Rc</code> から mutable な参照を取り出すこともできません．</p>\n\n<p>そこで <code>RefCell</code> を使うことで borrow check をランタイムに行うようにします．\n<code>RefCell</code> は immutable な参照から mutable な参照を取り出せるようにする働きをしますが，\nmutable な参照を取っている間に，さらに mutable な参照を作ろうとしたり immutable な参照を作ろうとすると，ランタイムに <code>panic</code> します．\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時検査ではなくランタイム検査になるので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DE\">プログラマ</a>の責任できちんと管理しないと死にます．</p>\n\n<p><code>RefCell</code> 版がこちら</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">struct</span> <span class=\"synIdentifier\">Node</span><span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;</span>(T, <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>Rc<span class=\"synStatement\">&lt;</span>RefCell<span class=\"synStatement\">&lt;</span>Node<span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;&gt;&gt;&gt;</span>);\n\n<span class=\"synStatement\">impl</span> Node<span class=\"synStatement\">&lt;</span><span class=\"synType\">i32</span><span class=\"synStatement\">&gt;</span> {\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">inc</span>(<span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>) {\n        <span class=\"synConstant\">self</span>.<span class=\"synConstant\">0</span> <span class=\"synStatement\">+=</span> <span class=\"synConstant\">1</span>;\n        <span class=\"synStatement\">for</span> n <span class=\"synStatement\">in</span> <span class=\"synType\">&amp;</span><span class=\"synConstant\">self</span>.<span class=\"synConstant\">1</span> {\n            n.<span class=\"synIdentifier\">borrow_mut</span>().<span class=\"synIdentifier\">inc</span>();\n        }\n    }\n}\n</pre>\n\n<h3>Rust で巡回有向グラフ</h3>\n\n<p>循環がある場合は厄介です．\nRust で参照を共有するための <code>Rc</code> は参照カウントなので，循環参照があるとリークします．\nしたがって循環のある構造を表すために <code>Rc</code> は使えません．</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>で親を参照するポインタを子に持たせておきたいといったケースでは，親は子を <code>Rc</code> で持ち，子は親を <code>Weak</code> で持つという形で対応できますが，\nグラフだとそういうわけにもいきません．</p>\n\n<p>そこで出て来るのが <code>Arena</code> という方法です．</p>\n\n<p>オブジェクトの実体は <code>Arena</code> の中に作り，グラフにはその ID を持たせて管理します．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">type</span> <span class=\"synIdentifier\">NodeId</span> <span class=\"synStatement\">=</span> <span class=\"synType\">usize</span>;\n\n<span class=\"synStatement\">struct</span> <span class=\"synIdentifier\">NodeArena</span><span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;</span> {\n    arena: <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>Node<span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;&gt;</span>,\n}\n\n<span class=\"synStatement\">impl&lt;</span>T<span class=\"synStatement\">&gt;</span> NodeArena {\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">alloc</span>(<span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>, value: T) <span class=\"synStatement\">-&gt;</span> NodeId {\n        <span class=\"synStatement\">let</span> id <span class=\"synStatement\">=</span> <span class=\"synConstant\">self</span>.arena.<span class=\"synIdentifier\">len</span>();\n        <span class=\"synStatement\">let</span> node <span class=\"synStatement\">=</span> <span class=\"synIdentifier\">Node</span>(id, value, <span class=\"synType\">Vec</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">new</span>());\n        <span class=\"synConstant\">self</span>.arena.<span class=\"synIdentifier\">push</span>(node);\n        id\n    }\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">get</span>(<span class=\"synType\">&amp;</span><span class=\"synConstant\">self</span>, id: NodeId) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">&amp;</span>Node<span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synType\">&amp;</span><span class=\"synConstant\">self</span>.arena[id]\n    }\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">get_mut</span>(<span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>, id: NodeId) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">&amp;mut</span> Node<span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>.arena[id]\n    }\n}\n\n<span class=\"synStatement\">struct</span> <span class=\"synIdentifier\">Node</span><span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;</span>(NodeId, T, <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>NodeId<span class=\"synStatement\">&gt;</span>);\n</pre>\n\n<p>こんな感じです．</p>\n\n<p>こうすることで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時の borrow check を諦めることなくグラフ構造を作ることができます．<br/>\n(<code>i</code> と <code>i+1</code> 番目のノードを同時に mutable に参照したいとかは苦しいですが)</p>\n\n<p>欠点としては単純に間接的な表現でめんどくさいというのもありますが，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GC\">GC</a> がないので参照されなくなったオブジェクトも <code>Arena</code> 上で生き続けてしまうことです．\nそのため，動的に要素が生きたり死んだりするケースには使いにくいです．</p>\n\n<p>ノードグラフの構築が終わったら <code>Arena</code> をリフレッシュするみたいなことをすると良いのかもしれません．\n(構築中は <code>Vec</code> で <code>Arena</code> を表現して，構造が固まったら <code>HashMap</code> を使った <code>Arena</code> に切り替えて参照されているidだけを残すみたいな)<br/>\nそれでも構築中はオブジェクトがあまりまくるので辛いですね...</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>プログラムを書いていると何かしら<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>っぽいものやグラフっぽいものを作りたい場面が多々あると思います．\nRust は所有権や <code>Size</code> の都合で，これらを作ろうと思うと地味にハマるのでまとめておきます．</p>\n\n<h3>Rust で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a></h3>\n\n<p>最も単純な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>は Rust だと</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">enum</span> <span class=\"synIdentifier\">Tree</span><span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;</span> {\n    <span class=\"synIdentifier\">Leaf</span>(T),\n    <span class=\"synIdentifier\">Node</span>(<span class=\"synType\">Box</span><span class=\"synStatement\">&lt;</span>Tree<span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;&gt;</span>, <span class=\"synType\">Box</span><span class=\"synStatement\">&lt;</span>Tree<span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;&gt;</span>),\n}\n</pre>\n\n<p>といった形で表せます．\nRust では明示的に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/boxing\">boxing</a> してあげないと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>的なデータ構造は作れないのでちょっと複雑に見えるかもしれませんが，まぁ単純です．</p>\n\n<p>この<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>を書き換えたい場合は，ownership をとって書き換えた値を返すこともできますし，<code>&amp;mut Tree&lt;T&gt;</code> をとって in-place に書き換えることもできます．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">inc</span>(<span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>) {\n    <span class=\"synStatement\">match</span> <span class=\"synType\">*</span><span class=\"synConstant\">self</span> {\n        <span class=\"synPreProc\">Tree</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">Leaf</span>(<span class=\"synType\">ref</span> <span class=\"synType\">mut</span> i) <span class=\"synStatement\">=&gt;</span> <span class=\"synType\">*</span>i <span class=\"synStatement\">=</span> <span class=\"synType\">*</span>i <span class=\"synStatement\">+</span> <span class=\"synConstant\">1</span>,\n        <span class=\"synPreProc\">Tree</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">Node</span>(<span class=\"synType\">ref</span> <span class=\"synType\">mut</span> left, <span class=\"synType\">ref</span> <span class=\"synType\">mut</span> right) <span class=\"synStatement\">=&gt;</span> {\n            left.<span class=\"synIdentifier\">inc</span>();\n            right.<span class=\"synIdentifier\">inc</span>();\n        }\n    }\n}\n\n<span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">inc2</span>(<span class=\"synConstant\">self</span>) <span class=\"synStatement\">-&gt;</span> Tree<span class=\"synStatement\">&lt;</span><span class=\"synType\">i32</span><span class=\"synStatement\">&gt;</span> {\n    <span class=\"synStatement\">match</span> <span class=\"synConstant\">self</span> {\n        <span class=\"synPreProc\">Tree</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">Leaf</span>(i) <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">Tree</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">Leaf</span>(i <span class=\"synStatement\">+</span> <span class=\"synConstant\">1</span>),\n        <span class=\"synPreProc\">Tree</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">Node</span>(left, right) <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">Tree</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">Node</span>(<span class=\"synType\">Box</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">new</span>(left.<span class=\"synIdentifier\">inc2</span>()), <span class=\"synType\">Box</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">new</span>(right.<span class=\"synIdentifier\">inc2</span>())),\n    }\n}\n</pre>\n\n<h3>Rust で有向非巡回グラフ</h3>\n\n<p>有向非巡回グラフ構造は，グラフのエッジに向きがあり，かつ循環がない構造で，これは割りと単純に表現できます．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">struct</span> <span class=\"synIdentifier\">Node</span><span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;</span>(T, <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>Rc<span class=\"synStatement\">&lt;</span>Node<span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;&gt;&gt;</span>);\n</pre>\n\n<p><code>Node</code> は自身の値 <code>T</code> と，つながっているノードの <code>Vec</code> を持ちます．(対象問題によっては <code>Vec</code> ではなくて <code>HashMap</code> とか <code>HashSet</code> とか)</p>\n\n<p><code>Rc</code> は参照カウント方式のスマートポインタです．\nグラフでは，<code>Node</code> は複数の <code>Node</code> から参照される可能性があるので， <code>Box</code> は使えません．</p>\n\n<p>これを変更可能にしたい場合はちょっと面倒ですが <code>RefCell</code> を使う必要があります．</p>\n\n<p>Rust では基本的に mutable borrow は常にひとつしか存在できず，mutable borrow が生きている間は immutable borrow もつくることができません．\n<code>Rc</code> から mutable な参照を取り出すこともできません．</p>\n\n<p>そこで <code>RefCell</code> を使うことで borrow check をランタイムに行うようにします．\n<code>RefCell</code> は immutable な参照から mutable な参照を取り出せるようにする働きをしますが，\nmutable な参照を取っている間に，さらに mutable な参照を作ろうとしたり immutable な参照を作ろうとすると，ランタイムに <code>panic</code> します．\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時検査ではなくランタイム検査になるので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DE\">プログラマ</a>の責任できちんと管理しないと死にます．</p>\n\n<p><code>RefCell</code> 版がこちら</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">struct</span> <span class=\"synIdentifier\">Node</span><span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;</span>(T, <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>Rc<span class=\"synStatement\">&lt;</span>RefCell<span class=\"synStatement\">&lt;</span>Node<span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;&gt;&gt;&gt;</span>);\n\n<span class=\"synStatement\">impl</span> Node<span class=\"synStatement\">&lt;</span><span class=\"synType\">i32</span><span class=\"synStatement\">&gt;</span> {\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">inc</span>(<span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>) {\n        <span class=\"synConstant\">self</span>.<span class=\"synConstant\">0</span> <span class=\"synStatement\">+=</span> <span class=\"synConstant\">1</span>;\n        <span class=\"synStatement\">for</span> n <span class=\"synStatement\">in</span> <span class=\"synType\">&amp;</span><span class=\"synConstant\">self</span>.<span class=\"synConstant\">1</span> {\n            n.<span class=\"synIdentifier\">borrow_mut</span>().<span class=\"synIdentifier\">inc</span>();\n        }\n    }\n}\n</pre>\n\n<h3>Rust で巡回有向グラフ</h3>\n\n<p>循環がある場合は厄介です．\nRust で参照を共有するための <code>Rc</code> は参照カウントなので，循環参照があるとリークします．\nしたがって循環のある構造を表すために <code>Rc</code> は使えません．</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>で親を参照するポインタを子に持たせておきたいといったケースでは，親は子を <code>Rc</code> で持ち，子は親を <code>Weak</code> で持つという形で対応できますが，\nグラフだとそういうわけにもいきません．</p>\n\n<p>そこで出て来るのが <code>Arena</code> という方法です．</p>\n\n<p>オブジェクトの実体は <code>Arena</code> の中に作り，グラフにはその ID を持たせて管理します．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">type</span> <span class=\"synIdentifier\">NodeId</span> <span class=\"synStatement\">=</span> <span class=\"synType\">usize</span>;\n\n<span class=\"synStatement\">struct</span> <span class=\"synIdentifier\">NodeArena</span><span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;</span> {\n    arena: <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>Node<span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;&gt;</span>,\n}\n\n<span class=\"synStatement\">impl&lt;</span>T<span class=\"synStatement\">&gt;</span> NodeArena {\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">alloc</span>(<span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>, value: T) <span class=\"synStatement\">-&gt;</span> NodeId {\n        <span class=\"synStatement\">let</span> id <span class=\"synStatement\">=</span> <span class=\"synConstant\">self</span>.arena.<span class=\"synIdentifier\">len</span>();\n        <span class=\"synStatement\">let</span> node <span class=\"synStatement\">=</span> <span class=\"synIdentifier\">Node</span>(id, value, <span class=\"synType\">Vec</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">new</span>());\n        <span class=\"synConstant\">self</span>.arena.<span class=\"synIdentifier\">push</span>(node);\n        id\n    }\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">get</span>(<span class=\"synType\">&amp;</span><span class=\"synConstant\">self</span>, id: NodeId) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">&amp;</span>Node<span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synType\">&amp;</span><span class=\"synConstant\">self</span>.arena[id]\n    }\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">get_mut</span>(<span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>, id: NodeId) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">&amp;mut</span> Node<span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>.arena[id]\n    }\n}\n\n<span class=\"synStatement\">struct</span> <span class=\"synIdentifier\">Node</span><span class=\"synStatement\">&lt;</span>T<span class=\"synStatement\">&gt;</span>(NodeId, T, <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>NodeId<span class=\"synStatement\">&gt;</span>);\n</pre>\n\n<p>こんな感じです．</p>\n\n<p>こうすることで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時の borrow check を諦めることなくグラフ構造を作ることができます．<br/>\n(<code>i</code> と <code>i+1</code> 番目のノードを同時に mutable に参照したいとかは苦しいですが)</p>\n\n<p>欠点としては単純に間接的な表現でめんどくさいというのもありますが，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GC\">GC</a> がないので参照されなくなったオブジェクトも <code>Arena</code> 上で生き続けてしまうことです．\nそのため，動的に要素が生きたり死んだりするケースには使いにくいです．</p>\n\n<p>ノードグラフの構築が終わったら <code>Arena</code> をリフレッシュするみたいなことをすると良いのかもしれません．\n(構築中は <code>Vec</code> で <code>Arena</code> を表現して，構造が固まったら <code>HashMap</code> を使った <code>Arena</code> に切り替えて参照されているidだけを残すみたいな)<br/>\nそれでも構築中はオブジェクトがあまりまくるので辛いですね...</p>\n\n---\n\n---\n","slug":"Rust_でグラフ構造や木構造を作る","title":"Rust でグラフ構造や木構造を作る","timestamp":1484547465000,"tags":[]},{"rawMarkdown":"---\ntitle: \"mio で echo サーバメモ\"\ndate: 2017-01-07T06:14:55.000Z\ntags: []\n---\n\n<p>Rust の非同期 IO ライブラリのなかでももっとも低レベルなレイヤーを担っている <a href=\"https://github.com/carllerche/mio\">mio</a> を使ってecho サーバを書いた。\necho サーバばっかり書いているような気がするけど，echo サーバやっておくと簡単な割にライブラリの使い方とかがちゃんと分かる気がするので好きです。</p>\n\n<h3>コード</h3>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">extern</span> <span class=\"synStatement\">crate</span> <span class=\"synIdentifier\">mio</span>;\n\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">std</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">io</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">prelude</span><span class=\"synSpecial\">::</span><span class=\"synType\">*</span>;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">std</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">collections</span><span class=\"synSpecial\">::</span>HashMap;\n\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">mio</span><span class=\"synSpecial\">::</span><span class=\"synType\">*</span>;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">mio</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">tcp</span><span class=\"synSpecial\">::</span>{TcpListener, TcpStream};\n\n<span class=\"synPreProc\">#[derive(</span><span class=\"synType\">Debug</span><span class=\"synPreProc\">)]</span>\n<span class=\"synStatement\">struct</span> <span class=\"synIdentifier\">ClientsHolder</span> {\n    table: HashMap<span class=\"synStatement\">&lt;</span>Token, TcpStream<span class=\"synStatement\">&gt;</span>,\n    free_token: <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>Token<span class=\"synStatement\">&gt;</span>,\n    next_max_token: Token,\n}\n\n<span class=\"synStatement\">impl</span> ClientsHolder {\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">new_from</span>(start_token: Token) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Self</span> {\n        ClientsHolder {\n            table: <span class=\"synPreProc\">HashMap</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">new</span>(),\n            free_token: <span class=\"synType\">Vec</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">new</span>(),\n            next_max_token: start_token,\n        }\n    }\n\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">next_token</span>(<span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>) <span class=\"synStatement\">-&gt;</span> Token {\n        <span class=\"synStatement\">if</span> <span class=\"synStatement\">let</span> <span class=\"synConstant\">Some</span>(tok) <span class=\"synStatement\">=</span> <span class=\"synConstant\">self</span>.free_token.<span class=\"synIdentifier\">pop</span>() {\n            <span class=\"synStatement\">return</span> tok;\n        }\n        <span class=\"synStatement\">let</span> tok <span class=\"synStatement\">=</span> <span class=\"synConstant\">self</span>.next_max_token;\n        <span class=\"synConstant\">self</span>.next_max_token <span class=\"synStatement\">=</span> <span class=\"synIdentifier\">Token</span>(tok.<span class=\"synConstant\">0</span> <span class=\"synStatement\">+</span> <span class=\"synConstant\">1</span>);\n        tok\n    }\n\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">register</span>(<span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>, tok: Token, client: TcpStream) {\n        <span class=\"synConstant\">self</span>.table.<span class=\"synIdentifier\">insert</span>(tok, client);\n    }\n\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">get_mut</span>(<span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>, tok: Token) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Option</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;mut</span> TcpStream<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synConstant\">self</span>.table.<span class=\"synIdentifier\">get_mut</span>(<span class=\"synType\">&amp;</span>tok)\n    }\n\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">remove</span>(<span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>, tok: Token) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Option</span><span class=\"synStatement\">&lt;</span>TcpStream<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synStatement\">let</span> result <span class=\"synStatement\">=</span> <span class=\"synConstant\">self</span>.table.<span class=\"synIdentifier\">remove</span>(<span class=\"synType\">&amp;</span>tok);\n        <span class=\"synStatement\">if</span> result.<span class=\"synIdentifier\">is_some</span>() {\n            <span class=\"synConstant\">self</span>.free_token.<span class=\"synIdentifier\">push</span>(tok);\n        }\n        result\n    }\n}\n\n<span class=\"synComment\">// Setup some tokens to allow us to identify which event is</span>\n<span class=\"synComment\">// for which socket.</span>\n<span class=\"synType\">const</span> SERVER: Token <span class=\"synStatement\">=</span> <span class=\"synIdentifier\">Token</span>(<span class=\"synConstant\">0</span>);\n\n<span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">main</span>() {\n\n    <span class=\"synStatement\">let</span> addr <span class=\"synStatement\">=</span> <span class=\"synConstant\">&quot;127.0.0.1:13265&quot;</span>.<span class=\"synIdentifier\">parse</span>().<span class=\"synIdentifier\">unwrap</span>();\n\n    <span class=\"synComment\">// Setup the server socket</span>\n    <span class=\"synStatement\">let</span> server <span class=\"synStatement\">=</span> <span class=\"synPreProc\">TcpListener</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">bind</span>(<span class=\"synType\">&amp;</span>addr).<span class=\"synIdentifier\">unwrap</span>();\n\n    <span class=\"synComment\">// Create an poll instance</span>\n    <span class=\"synStatement\">let</span> poll <span class=\"synStatement\">=</span> <span class=\"synPreProc\">Poll</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">new</span>().<span class=\"synIdentifier\">unwrap</span>();\n\n    <span class=\"synComment\">// Start listening for incoming connections</span>\n    poll.<span class=\"synIdentifier\">register</span>(<span class=\"synType\">&amp;</span>server, SERVER, <span class=\"synPreProc\">Ready</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">readable</span>(), <span class=\"synPreProc\">PollOpt</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">edge</span>())\n        .<span class=\"synIdentifier\">unwrap</span>();\n\n    <span class=\"synComment\">// Create storage for events</span>\n    <span class=\"synStatement\">let</span> <span class=\"synType\">mut</span> events <span class=\"synStatement\">=</span> <span class=\"synPreProc\">Events</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">with_capacity</span>(<span class=\"synConstant\">1024</span>);\n    <span class=\"synStatement\">let</span> <span class=\"synType\">mut</span> clients <span class=\"synStatement\">=</span> <span class=\"synPreProc\">ClientsHolder</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">new_from</span>(<span class=\"synIdentifier\">Token</span>(<span class=\"synConstant\">1</span>));\n\n    <span class=\"synStatement\">loop</span> {\n        poll.<span class=\"synIdentifier\">poll</span>(<span class=\"synType\">&amp;mut</span> events, <span class=\"synConstant\">None</span>).<span class=\"synIdentifier\">unwrap</span>();\n\n        <span class=\"synStatement\">for</span> event <span class=\"synStatement\">in</span> events.<span class=\"synIdentifier\">iter</span>() {\n            <span class=\"synStatement\">match</span> event.<span class=\"synIdentifier\">token</span>() {\n                SERVER <span class=\"synStatement\">=&gt;</span> {\n                    <span class=\"synComment\">// Accept and drop the socket immediately, this will close</span>\n                    <span class=\"synComment\">// the socket and notify the client of the EOF.</span>\n                    <span class=\"synStatement\">let</span> (stream, _) <span class=\"synStatement\">=</span> server.<span class=\"synIdentifier\">accept</span>().<span class=\"synIdentifier\">unwrap</span>();\n                    <span class=\"synStatement\">let</span> tok <span class=\"synStatement\">=</span> clients.<span class=\"synIdentifier\">next_token</span>();\n                    poll.<span class=\"synIdentifier\">register</span>(<span class=\"synType\">&amp;</span>stream, tok, <span class=\"synPreProc\">Ready</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">readable</span>(), <span class=\"synPreProc\">PollOpt</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">edge</span>()).<span class=\"synIdentifier\">unwrap</span>();\n                    clients.<span class=\"synIdentifier\">register</span>(tok, stream);\n                }\n                tok <span class=\"synStatement\">=&gt;</span> {\n                    <span class=\"synStatement\">let</span> <span class=\"synType\">mut</span> close <span class=\"synStatement\">=</span> <span class=\"synConstant\">false</span>;\n                    <span class=\"synStatement\">if</span> <span class=\"synStatement\">let</span> <span class=\"synConstant\">Some</span>(<span class=\"synType\">mut</span> stream) <span class=\"synStatement\">=</span> clients.<span class=\"synIdentifier\">get_mut</span>(tok) {\n                        <span class=\"synStatement\">let</span> <span class=\"synType\">mut</span> buf <span class=\"synStatement\">=</span> [<span class=\"synConstant\">0</span>; <span class=\"synConstant\">1024</span>];\n                        <span class=\"synStatement\">let</span> n <span class=\"synStatement\">=</span> stream.<span class=\"synIdentifier\">read</span>(<span class=\"synType\">&amp;mut</span> buf).<span class=\"synIdentifier\">unwrap</span>();\n                        <span class=\"synStatement\">if</span> n <span class=\"synStatement\">==</span> <span class=\"synConstant\">0</span> {\n                            poll.<span class=\"synIdentifier\">deregister</span>(stream).<span class=\"synIdentifier\">unwrap</span>();\n                            close <span class=\"synStatement\">=</span> <span class=\"synConstant\">true</span>;\n                        } <span class=\"synStatement\">else</span> {\n                            stream.<span class=\"synIdentifier\">write</span>(<span class=\"synType\">&amp;</span>buf[<span class=\"synConstant\">0</span>..n]).<span class=\"synIdentifier\">unwrap</span>();\n                        }\n                    }\n                    <span class=\"synStatement\">if</span> close {\n                        clients.<span class=\"synIdentifier\">remove</span>(tok);\n                    }\n                }\n            }\n        }\n    }\n}\n</pre>\n\n<p>面倒だったので <code>unwrap</code> まみれですが。</p>\n\n<h2>やったこと</h2>\n\n<p><code>mio</code> の全体の流れとしては，<code>Poll</code> 型の値がイベントを監視する役割を担います．\n<code>Poll</code> に監視対象を登録していき，<code>Poll::poll</code> でイベントの発火を待ちます．\n発火したイベント一覧が <code>Events</code> 型の <code>Events::iter</code> で取れるので，対応していけばよいです．</p>\n\n<p><code>mio</code> では <code>Token</code> という型の値を使って監視対象を識別しています．\n監視対象には <code>TcpListener</code> ，<code>TcpStream</code>，<code>Sender</code>，などなどいろんなものがあるので，統一的に扱うために <code>Poll</code> は <code>Token</code> だけを保持します．\n<code>Token</code> と監視対象の紐付けはユーザ側の責任でやってくれという感じみたいです．</p>\n\n<p>echo サーバではクライアントの数は不特定なので，「空いている <code>Token</code> を探す」と「<code>Token</code> に対応するクライアント (<code>TcpStream</code>) を探す」がうまくできる必要があります．\nそこで，<code>ClientsHolder</code> を定義しました．\nこいつが，空いている <code>Token</code> を返すのと <code>Token</code> をキーに <code>TcpStream</code> を返す仕事をします．\n<code>remove</code> されたらその <code>Token</code> は再利用します．</p>\n\n<h2>気になるところ</h2>\n\n<p><code>mio</code> はファイルに対する抽象化は提供しない方針のようです．\n<code>STDIN</code> / <code>STDOUT</code> も同様です．</p>\n\n<p>ファイル IO もノン<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D6%A5%ED%A5%C3%A5%AD%A5%F3%A5%B0\">ブロッキング</a>にしたい場合はどうしたらいいんでしょう？よくわかっていない．\n<code>mio::unix</code> 以下に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UNIX\">UNIX</a> 限定の拡張がおいてあって，<code>EventedFd</code> という file descriptor を扱う実装はあるので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UNIX\">UNIX</a> 限定なら力技でなんとかなるのかもしれない．</p>\n\n<p>あと <code>mio</code> は関係ないんですが，実装の部分で，</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">let</span> <span class=\"synType\">mut</span> close <span class=\"synStatement\">=</span> <span class=\"synConstant\">false</span>;\n<span class=\"synStatement\">if</span> <span class=\"synStatement\">let</span> <span class=\"synConstant\">Some</span>(<span class=\"synType\">mut</span> stream) <span class=\"synStatement\">=</span> clients.<span class=\"synIdentifier\">get_mut</span>(tok) {\n    <span class=\"synStatement\">let</span> <span class=\"synType\">mut</span> buf <span class=\"synStatement\">=</span> [<span class=\"synConstant\">0</span>; <span class=\"synConstant\">1024</span>];\n    <span class=\"synStatement\">let</span> n <span class=\"synStatement\">=</span> stream.<span class=\"synIdentifier\">read</span>(<span class=\"synType\">&amp;mut</span> buf).<span class=\"synIdentifier\">unwrap</span>();\n    <span class=\"synStatement\">if</span> n <span class=\"synStatement\">==</span> <span class=\"synConstant\">0</span> {\n        poll.<span class=\"synIdentifier\">deregister</span>(stream).<span class=\"synIdentifier\">unwrap</span>();\n        close <span class=\"synStatement\">=</span> <span class=\"synConstant\">true</span>;\n    } <span class=\"synStatement\">else</span> {\n        stream.<span class=\"synIdentifier\">write</span>(<span class=\"synType\">&amp;</span>buf[<span class=\"synConstant\">0</span>..n]).<span class=\"synIdentifier\">unwrap</span>();\n    }\n}\n<span class=\"synStatement\">if</span> close {\n    clients.<span class=\"synIdentifier\">remove</span>(tok);\n}\n</pre>\n\n<p>というのがあるんですが，これどうやったらスマートなんでしょう．\n<code>close = true</code> としている部分で <code>clients.remove(tok);</code> をやるのが普通だと思うんですが，<code>if let Some(mut stream) = clients.get_mut(tok) {</code> のところで <code>clients</code> は borrow されているから mutable borrow はこれ以上作れないのです．</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>Rust の非同期 IO ライブラリのなかでももっとも低レベルなレイヤーを担っている <a href=\"https://github.com/carllerche/mio\">mio</a> を使ってecho サーバを書いた。\necho サーバばっかり書いているような気がするけど，echo サーバやっておくと簡単な割にライブラリの使い方とかがちゃんと分かる気がするので好きです。</p>\n\n<h3>コード</h3>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">extern</span> <span class=\"synStatement\">crate</span> <span class=\"synIdentifier\">mio</span>;\n\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">std</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">io</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">prelude</span><span class=\"synSpecial\">::</span><span class=\"synType\">*</span>;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">std</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">collections</span><span class=\"synSpecial\">::</span>HashMap;\n\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">mio</span><span class=\"synSpecial\">::</span><span class=\"synType\">*</span>;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">mio</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">tcp</span><span class=\"synSpecial\">::</span>{TcpListener, TcpStream};\n\n<span class=\"synPreProc\">#[derive(</span><span class=\"synType\">Debug</span><span class=\"synPreProc\">)]</span>\n<span class=\"synStatement\">struct</span> <span class=\"synIdentifier\">ClientsHolder</span> {\n    table: HashMap<span class=\"synStatement\">&lt;</span>Token, TcpStream<span class=\"synStatement\">&gt;</span>,\n    free_token: <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>Token<span class=\"synStatement\">&gt;</span>,\n    next_max_token: Token,\n}\n\n<span class=\"synStatement\">impl</span> ClientsHolder {\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">new_from</span>(start_token: Token) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Self</span> {\n        ClientsHolder {\n            table: <span class=\"synPreProc\">HashMap</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">new</span>(),\n            free_token: <span class=\"synType\">Vec</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">new</span>(),\n            next_max_token: start_token,\n        }\n    }\n\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">next_token</span>(<span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>) <span class=\"synStatement\">-&gt;</span> Token {\n        <span class=\"synStatement\">if</span> <span class=\"synStatement\">let</span> <span class=\"synConstant\">Some</span>(tok) <span class=\"synStatement\">=</span> <span class=\"synConstant\">self</span>.free_token.<span class=\"synIdentifier\">pop</span>() {\n            <span class=\"synStatement\">return</span> tok;\n        }\n        <span class=\"synStatement\">let</span> tok <span class=\"synStatement\">=</span> <span class=\"synConstant\">self</span>.next_max_token;\n        <span class=\"synConstant\">self</span>.next_max_token <span class=\"synStatement\">=</span> <span class=\"synIdentifier\">Token</span>(tok.<span class=\"synConstant\">0</span> <span class=\"synStatement\">+</span> <span class=\"synConstant\">1</span>);\n        tok\n    }\n\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">register</span>(<span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>, tok: Token, client: TcpStream) {\n        <span class=\"synConstant\">self</span>.table.<span class=\"synIdentifier\">insert</span>(tok, client);\n    }\n\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">get_mut</span>(<span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>, tok: Token) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Option</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;mut</span> TcpStream<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synConstant\">self</span>.table.<span class=\"synIdentifier\">get_mut</span>(<span class=\"synType\">&amp;</span>tok)\n    }\n\n    <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">remove</span>(<span class=\"synType\">&amp;mut</span> <span class=\"synConstant\">self</span>, tok: Token) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Option</span><span class=\"synStatement\">&lt;</span>TcpStream<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synStatement\">let</span> result <span class=\"synStatement\">=</span> <span class=\"synConstant\">self</span>.table.<span class=\"synIdentifier\">remove</span>(<span class=\"synType\">&amp;</span>tok);\n        <span class=\"synStatement\">if</span> result.<span class=\"synIdentifier\">is_some</span>() {\n            <span class=\"synConstant\">self</span>.free_token.<span class=\"synIdentifier\">push</span>(tok);\n        }\n        result\n    }\n}\n\n<span class=\"synComment\">// Setup some tokens to allow us to identify which event is</span>\n<span class=\"synComment\">// for which socket.</span>\n<span class=\"synType\">const</span> SERVER: Token <span class=\"synStatement\">=</span> <span class=\"synIdentifier\">Token</span>(<span class=\"synConstant\">0</span>);\n\n<span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">main</span>() {\n\n    <span class=\"synStatement\">let</span> addr <span class=\"synStatement\">=</span> <span class=\"synConstant\">&quot;127.0.0.1:13265&quot;</span>.<span class=\"synIdentifier\">parse</span>().<span class=\"synIdentifier\">unwrap</span>();\n\n    <span class=\"synComment\">// Setup the server socket</span>\n    <span class=\"synStatement\">let</span> server <span class=\"synStatement\">=</span> <span class=\"synPreProc\">TcpListener</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">bind</span>(<span class=\"synType\">&amp;</span>addr).<span class=\"synIdentifier\">unwrap</span>();\n\n    <span class=\"synComment\">// Create an poll instance</span>\n    <span class=\"synStatement\">let</span> poll <span class=\"synStatement\">=</span> <span class=\"synPreProc\">Poll</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">new</span>().<span class=\"synIdentifier\">unwrap</span>();\n\n    <span class=\"synComment\">// Start listening for incoming connections</span>\n    poll.<span class=\"synIdentifier\">register</span>(<span class=\"synType\">&amp;</span>server, SERVER, <span class=\"synPreProc\">Ready</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">readable</span>(), <span class=\"synPreProc\">PollOpt</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">edge</span>())\n        .<span class=\"synIdentifier\">unwrap</span>();\n\n    <span class=\"synComment\">// Create storage for events</span>\n    <span class=\"synStatement\">let</span> <span class=\"synType\">mut</span> events <span class=\"synStatement\">=</span> <span class=\"synPreProc\">Events</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">with_capacity</span>(<span class=\"synConstant\">1024</span>);\n    <span class=\"synStatement\">let</span> <span class=\"synType\">mut</span> clients <span class=\"synStatement\">=</span> <span class=\"synPreProc\">ClientsHolder</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">new_from</span>(<span class=\"synIdentifier\">Token</span>(<span class=\"synConstant\">1</span>));\n\n    <span class=\"synStatement\">loop</span> {\n        poll.<span class=\"synIdentifier\">poll</span>(<span class=\"synType\">&amp;mut</span> events, <span class=\"synConstant\">None</span>).<span class=\"synIdentifier\">unwrap</span>();\n\n        <span class=\"synStatement\">for</span> event <span class=\"synStatement\">in</span> events.<span class=\"synIdentifier\">iter</span>() {\n            <span class=\"synStatement\">match</span> event.<span class=\"synIdentifier\">token</span>() {\n                SERVER <span class=\"synStatement\">=&gt;</span> {\n                    <span class=\"synComment\">// Accept and drop the socket immediately, this will close</span>\n                    <span class=\"synComment\">// the socket and notify the client of the EOF.</span>\n                    <span class=\"synStatement\">let</span> (stream, _) <span class=\"synStatement\">=</span> server.<span class=\"synIdentifier\">accept</span>().<span class=\"synIdentifier\">unwrap</span>();\n                    <span class=\"synStatement\">let</span> tok <span class=\"synStatement\">=</span> clients.<span class=\"synIdentifier\">next_token</span>();\n                    poll.<span class=\"synIdentifier\">register</span>(<span class=\"synType\">&amp;</span>stream, tok, <span class=\"synPreProc\">Ready</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">readable</span>(), <span class=\"synPreProc\">PollOpt</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">edge</span>()).<span class=\"synIdentifier\">unwrap</span>();\n                    clients.<span class=\"synIdentifier\">register</span>(tok, stream);\n                }\n                tok <span class=\"synStatement\">=&gt;</span> {\n                    <span class=\"synStatement\">let</span> <span class=\"synType\">mut</span> close <span class=\"synStatement\">=</span> <span class=\"synConstant\">false</span>;\n                    <span class=\"synStatement\">if</span> <span class=\"synStatement\">let</span> <span class=\"synConstant\">Some</span>(<span class=\"synType\">mut</span> stream) <span class=\"synStatement\">=</span> clients.<span class=\"synIdentifier\">get_mut</span>(tok) {\n                        <span class=\"synStatement\">let</span> <span class=\"synType\">mut</span> buf <span class=\"synStatement\">=</span> [<span class=\"synConstant\">0</span>; <span class=\"synConstant\">1024</span>];\n                        <span class=\"synStatement\">let</span> n <span class=\"synStatement\">=</span> stream.<span class=\"synIdentifier\">read</span>(<span class=\"synType\">&amp;mut</span> buf).<span class=\"synIdentifier\">unwrap</span>();\n                        <span class=\"synStatement\">if</span> n <span class=\"synStatement\">==</span> <span class=\"synConstant\">0</span> {\n                            poll.<span class=\"synIdentifier\">deregister</span>(stream).<span class=\"synIdentifier\">unwrap</span>();\n                            close <span class=\"synStatement\">=</span> <span class=\"synConstant\">true</span>;\n                        } <span class=\"synStatement\">else</span> {\n                            stream.<span class=\"synIdentifier\">write</span>(<span class=\"synType\">&amp;</span>buf[<span class=\"synConstant\">0</span>..n]).<span class=\"synIdentifier\">unwrap</span>();\n                        }\n                    }\n                    <span class=\"synStatement\">if</span> close {\n                        clients.<span class=\"synIdentifier\">remove</span>(tok);\n                    }\n                }\n            }\n        }\n    }\n}\n</pre>\n\n<p>面倒だったので <code>unwrap</code> まみれですが。</p>\n\n<h2>やったこと</h2>\n\n<p><code>mio</code> の全体の流れとしては，<code>Poll</code> 型の値がイベントを監視する役割を担います．\n<code>Poll</code> に監視対象を登録していき，<code>Poll::poll</code> でイベントの発火を待ちます．\n発火したイベント一覧が <code>Events</code> 型の <code>Events::iter</code> で取れるので，対応していけばよいです．</p>\n\n<p><code>mio</code> では <code>Token</code> という型の値を使って監視対象を識別しています．\n監視対象には <code>TcpListener</code> ，<code>TcpStream</code>，<code>Sender</code>，などなどいろんなものがあるので，統一的に扱うために <code>Poll</code> は <code>Token</code> だけを保持します．\n<code>Token</code> と監視対象の紐付けはユーザ側の責任でやってくれという感じみたいです．</p>\n\n<p>echo サーバではクライアントの数は不特定なので，「空いている <code>Token</code> を探す」と「<code>Token</code> に対応するクライアント (<code>TcpStream</code>) を探す」がうまくできる必要があります．\nそこで，<code>ClientsHolder</code> を定義しました．\nこいつが，空いている <code>Token</code> を返すのと <code>Token</code> をキーに <code>TcpStream</code> を返す仕事をします．\n<code>remove</code> されたらその <code>Token</code> は再利用します．</p>\n\n<h2>気になるところ</h2>\n\n<p><code>mio</code> はファイルに対する抽象化は提供しない方針のようです．\n<code>STDIN</code> / <code>STDOUT</code> も同様です．</p>\n\n<p>ファイル IO もノン<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D6%A5%ED%A5%C3%A5%AD%A5%F3%A5%B0\">ブロッキング</a>にしたい場合はどうしたらいいんでしょう？よくわかっていない．\n<code>mio::unix</code> 以下に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UNIX\">UNIX</a> 限定の拡張がおいてあって，<code>EventedFd</code> という file descriptor を扱う実装はあるので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UNIX\">UNIX</a> 限定なら力技でなんとかなるのかもしれない．</p>\n\n<p>あと <code>mio</code> は関係ないんですが，実装の部分で，</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">let</span> <span class=\"synType\">mut</span> close <span class=\"synStatement\">=</span> <span class=\"synConstant\">false</span>;\n<span class=\"synStatement\">if</span> <span class=\"synStatement\">let</span> <span class=\"synConstant\">Some</span>(<span class=\"synType\">mut</span> stream) <span class=\"synStatement\">=</span> clients.<span class=\"synIdentifier\">get_mut</span>(tok) {\n    <span class=\"synStatement\">let</span> <span class=\"synType\">mut</span> buf <span class=\"synStatement\">=</span> [<span class=\"synConstant\">0</span>; <span class=\"synConstant\">1024</span>];\n    <span class=\"synStatement\">let</span> n <span class=\"synStatement\">=</span> stream.<span class=\"synIdentifier\">read</span>(<span class=\"synType\">&amp;mut</span> buf).<span class=\"synIdentifier\">unwrap</span>();\n    <span class=\"synStatement\">if</span> n <span class=\"synStatement\">==</span> <span class=\"synConstant\">0</span> {\n        poll.<span class=\"synIdentifier\">deregister</span>(stream).<span class=\"synIdentifier\">unwrap</span>();\n        close <span class=\"synStatement\">=</span> <span class=\"synConstant\">true</span>;\n    } <span class=\"synStatement\">else</span> {\n        stream.<span class=\"synIdentifier\">write</span>(<span class=\"synType\">&amp;</span>buf[<span class=\"synConstant\">0</span>..n]).<span class=\"synIdentifier\">unwrap</span>();\n    }\n}\n<span class=\"synStatement\">if</span> close {\n    clients.<span class=\"synIdentifier\">remove</span>(tok);\n}\n</pre>\n\n<p>というのがあるんですが，これどうやったらスマートなんでしょう．\n<code>close = true</code> としている部分で <code>clients.remove(tok);</code> をやるのが普通だと思うんですが，<code>if let Some(mut stream) = clients.get_mut(tok) {</code> のところで <code>clients</code> は borrow されているから mutable borrow はこれ以上作れないのです．</p>\n\n---\n\n---\n","slug":"mio_で_echo_サーバメモ","title":"mio で echo サーバメモ","timestamp":1483769695000,"tags":[]},{"rawMarkdown":"---\ntitle: \"NCurses の Crystal binding を作った\"\ndate: 2016-12-08T13:33:17.000Z\ntags: []\n---\n\n<p>この記事は、 Crystal Advent Calendar 2016 の８日目の記事です。\n<iframe src=\"//hatenablog-parts.com/embed?url=http%3A%2F%2Fqiita.com%2Fadvent-calendar%2F2016%2Fcrystal\" title=\"Crystal Advent Calendar 2016 - Qiita\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://qiita.com/advent-calendar/2016/crystal\">qiita.com</a></cite></p>\n\n<p>ncurses という <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CUI\">CUI</a> を作るためにスクリーンやキー入力を扱う有名なライブラリの Crystal binding を作りました。</p>\n\n<p><iframe src=\"//hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fncurses.cr\" title=\"agatan/ncurses.cr\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://github.com/agatan/ncurses.cr\">github.com</a></cite></p>\n\n<p>ほとんど C の ncurses と同じ感じで使えるようになっていると思います．\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\">Ruby</a> や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a> の <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/curses\">curses</a> ライブラリを参考にしつつ，なるべく使用感がかわらないようにしています．</p>\n\n<h2>examples</h2>\n\n<pre class=\"code lang-crystal\" data-lang=\"crystal\" data-unlink><span class=\"synPreProc\">require</span> “ncurses”\n\n<span class=\"synType\">NCurses</span>.open <span class=\"synStatement\">do</span>\n  <span class=\"synType\">NCurses</span>.cbreak\n  <span class=\"synType\">NCurses</span>.noecho\n  <span class=\"synType\">NCurses</span>.move(<span class=\"synConstant\">x</span>: <span class=\"synConstant\">30</span>, <span class=\"synConstant\">y</span>: <span class=\"synConstant\">20</span>)\n  <span class=\"synType\">NCurses</span>.addstr(“<span class=\"synType\">Hello</span>, world!”)\n  <span class=\"synType\">NCurses</span>.refresh\n\n  <span class=\"synType\">NCurses</span>.notimeout(<span class=\"synConstant\">true</span>)\n  <span class=\"synType\">NCurses</span>.getch\n<span class=\"synStatement\">end</span>\n</pre>\n\n<p><code>NCurses.addstr</code> とか <code>NCurses.move</code> とかは ncurses で言う <code>addstr</code> や <code>move</code> に当たる関数で，<code>stdscr</code> に対して <code>waddstr</code> とか <code>wmove</code> するやつです．</p>\n\n<p><code>w = NCurses::Window.new(height: height, width: width)</code> とすることで subwindow が作れます．\n<code>w.addstr</code> や <code>w.move</code> という形で <code>w</code> prefix な関数たちが呼べるようになっています．</p>\n\n<p><code>pad</code> や <code>attron</code> / <code>attroff</code> などなども使えます．</p>\n\n<p>詳細な例は <code>example/</code> 以下のにおいてあります</p>\n\n<h2>なぜ作ったのか</h2>\n\n<p>実は ncurses bindings for Crystal はすでにあります．(<a href=\"https://github.com/jreinert/ncurses-crystal\">https://github.com/jreinert/ncurses-crystal</a>)<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/curses\">curses</a> が Crystal の標準ライブラリから外されることが決まったときの <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CHANGELOG\">CHANGELOG</a> を見ると，今後はそっちを使ってねと書いてあったりします．</p>\n\n<p>じゃあなんでわざわざ別で作ったのかという話ですが，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> が足りない &amp; 提供する <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> の形を変えたいと思ったからです．</p>\n\n<p>単純に bind されている <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> が少なくてやりたいことができなかったので，最初は追加して PR を出そうと思っていたのですが，すでに提供されている <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> が割と高級になっていて 1 : 1 で C <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> と対応していない感じでした．\n個人的には C library の wrapper にはなるべく薄くなっていてもらって基本的な <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> は覚え直さないでも使えるようになっていてほしいというふうに思ったので，C <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> と 1 : 1 で対応した形の <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> を提供する wrapper を作ってみようという経緯で新しく作ることにしました．</p>\n\n<h2>おまけ</h2>\n\n<p>C bindings を書くときに，wrapper <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> として <code>LibC::Int</code> が登場しちゃうのがなんとなく嫌で，<code>LibC::Int</code> を C が要求してくる関数を呼ぶ wrapper 関数には型指定をあえてしないという選択をしたんですがどうなんでしょう．</p>\n\n<pre class=\"code lang-crystal\" data-lang=\"crystal\" data-unlink><span class=\"synPreProc\">lib</span> <span class=\"synType\">LibNCurses</span>\n  <span class=\"synPreProc\">fun</span> <span class=\"synIdentifier\">wmove</span>(<span class=\"synIdentifier\">w</span> : <span class=\"synType\">Window</span>, y : <span class=\"synType\">LibC</span>::<span class=\"synType\">Int</span>, x : <span class=\"synType\">LibC</span>::<span class=\"synType\">Int</span>) : <span class=\"synType\">Result</span>\n<span class=\"synPreProc\">end</span>\n</pre>\n\n<pre class=\"code lang-crystal\" data-lang=\"crystal\" data-unlink><span class=\"synPreProc\">class</span> <span class=\"synType\">Window</span>\n  <span class=\"synPreProc\">def</span> <span class=\"synIdentifier\">move</span>(y, x)\n     <span class=\"synType\">LibNCurses</span>.wmove(<span class=\"synIdentifier\">@win</span>, y, x)\n  <span class=\"synPreProc\">end</span>\n<span class=\"synPreProc\">end</span>\n</pre>\n\n<p>みたいな感じです．（多少簡略化しています）</p>\n\n<p>これどうなんですかね．なるべく外に見せる <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> には型を明記するようにしたかったのですが，<code>LibC:Int</code> 系は環境によって異なるのでそういうわけにも行かず…</p>\n\n<p><code>y : LibC::Int, x : LibC::Int</code> とかは別に良いんですが，ncurses は文字と属性をくっつけた <code>chtype</code> なる型を持っていてこれが結構厄介というか混乱を招くのではと思っています．\n<code>chtype</code> は <code>char</code> ではなく <code>unsigned int</code> で，文字と属性を bitor でくっつけたものになっています．<code>addch</code> のように <code>char</code> をとることを連想させる関数の引数が実は <code>chtype = unsigned int</code> でしかも Crystal の文字型 <code>Char</code> は 32bit なのでものすごく混乱します…</p>\n\n<p>C は型変換を勝手にやってくれるので，<code>unsigned int</code> を返す関数から受け取った値を <code>short</code> を受け取る関数に渡すみたいなことをよくやっていて，Crystal のような型変換を暗黙にやらない言語から使おうとすると難しいんだなぁと思いました．\nなにか良い方法があればぜひ知りたいです．</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>この記事は、 Crystal Advent Calendar 2016 の８日目の記事です。\n<iframe src=\"//hatenablog-parts.com/embed?url=http%3A%2F%2Fqiita.com%2Fadvent-calendar%2F2016%2Fcrystal\" title=\"Crystal Advent Calendar 2016 - Qiita\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://qiita.com/advent-calendar/2016/crystal\">qiita.com</a></cite></p>\n\n<p>ncurses という <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CUI\">CUI</a> を作るためにスクリーンやキー入力を扱う有名なライブラリの Crystal binding を作りました。</p>\n\n<p><iframe src=\"//hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fncurses.cr\" title=\"agatan/ncurses.cr\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://github.com/agatan/ncurses.cr\">github.com</a></cite></p>\n\n<p>ほとんど C の ncurses と同じ感じで使えるようになっていると思います．\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\">Ruby</a> や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a> の <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/curses\">curses</a> ライブラリを参考にしつつ，なるべく使用感がかわらないようにしています．</p>\n\n<h2>examples</h2>\n\n<pre class=\"code lang-crystal\" data-lang=\"crystal\" data-unlink><span class=\"synPreProc\">require</span> “ncurses”\n\n<span class=\"synType\">NCurses</span>.open <span class=\"synStatement\">do</span>\n  <span class=\"synType\">NCurses</span>.cbreak\n  <span class=\"synType\">NCurses</span>.noecho\n  <span class=\"synType\">NCurses</span>.move(<span class=\"synConstant\">x</span>: <span class=\"synConstant\">30</span>, <span class=\"synConstant\">y</span>: <span class=\"synConstant\">20</span>)\n  <span class=\"synType\">NCurses</span>.addstr(“<span class=\"synType\">Hello</span>, world!”)\n  <span class=\"synType\">NCurses</span>.refresh\n\n  <span class=\"synType\">NCurses</span>.notimeout(<span class=\"synConstant\">true</span>)\n  <span class=\"synType\">NCurses</span>.getch\n<span class=\"synStatement\">end</span>\n</pre>\n\n<p><code>NCurses.addstr</code> とか <code>NCurses.move</code> とかは ncurses で言う <code>addstr</code> や <code>move</code> に当たる関数で，<code>stdscr</code> に対して <code>waddstr</code> とか <code>wmove</code> するやつです．</p>\n\n<p><code>w = NCurses::Window.new(height: height, width: width)</code> とすることで subwindow が作れます．\n<code>w.addstr</code> や <code>w.move</code> という形で <code>w</code> prefix な関数たちが呼べるようになっています．</p>\n\n<p><code>pad</code> や <code>attron</code> / <code>attroff</code> などなども使えます．</p>\n\n<p>詳細な例は <code>example/</code> 以下のにおいてあります</p>\n\n<h2>なぜ作ったのか</h2>\n\n<p>実は ncurses bindings for Crystal はすでにあります．(<a href=\"https://github.com/jreinert/ncurses-crystal\">https://github.com/jreinert/ncurses-crystal</a>)<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/curses\">curses</a> が Crystal の標準ライブラリから外されることが決まったときの <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CHANGELOG\">CHANGELOG</a> を見ると，今後はそっちを使ってねと書いてあったりします．</p>\n\n<p>じゃあなんでわざわざ別で作ったのかという話ですが，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> が足りない &amp; 提供する <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> の形を変えたいと思ったからです．</p>\n\n<p>単純に bind されている <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> が少なくてやりたいことができなかったので，最初は追加して PR を出そうと思っていたのですが，すでに提供されている <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> が割と高級になっていて 1 : 1 で C <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> と対応していない感じでした．\n個人的には C library の wrapper にはなるべく薄くなっていてもらって基本的な <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> は覚え直さないでも使えるようになっていてほしいというふうに思ったので，C <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> と 1 : 1 で対応した形の <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> を提供する wrapper を作ってみようという経緯で新しく作ることにしました．</p>\n\n<h2>おまけ</h2>\n\n<p>C bindings を書くときに，wrapper <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> として <code>LibC::Int</code> が登場しちゃうのがなんとなく嫌で，<code>LibC::Int</code> を C が要求してくる関数を呼ぶ wrapper 関数には型指定をあえてしないという選択をしたんですがどうなんでしょう．</p>\n\n<pre class=\"code lang-crystal\" data-lang=\"crystal\" data-unlink><span class=\"synPreProc\">lib</span> <span class=\"synType\">LibNCurses</span>\n  <span class=\"synPreProc\">fun</span> <span class=\"synIdentifier\">wmove</span>(<span class=\"synIdentifier\">w</span> : <span class=\"synType\">Window</span>, y : <span class=\"synType\">LibC</span>::<span class=\"synType\">Int</span>, x : <span class=\"synType\">LibC</span>::<span class=\"synType\">Int</span>) : <span class=\"synType\">Result</span>\n<span class=\"synPreProc\">end</span>\n</pre>\n\n<pre class=\"code lang-crystal\" data-lang=\"crystal\" data-unlink><span class=\"synPreProc\">class</span> <span class=\"synType\">Window</span>\n  <span class=\"synPreProc\">def</span> <span class=\"synIdentifier\">move</span>(y, x)\n     <span class=\"synType\">LibNCurses</span>.wmove(<span class=\"synIdentifier\">@win</span>, y, x)\n  <span class=\"synPreProc\">end</span>\n<span class=\"synPreProc\">end</span>\n</pre>\n\n<p>みたいな感じです．（多少簡略化しています）</p>\n\n<p>これどうなんですかね．なるべく外に見せる <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> には型を明記するようにしたかったのですが，<code>LibC:Int</code> 系は環境によって異なるのでそういうわけにも行かず…</p>\n\n<p><code>y : LibC::Int, x : LibC::Int</code> とかは別に良いんですが，ncurses は文字と属性をくっつけた <code>chtype</code> なる型を持っていてこれが結構厄介というか混乱を招くのではと思っています．\n<code>chtype</code> は <code>char</code> ではなく <code>unsigned int</code> で，文字と属性を bitor でくっつけたものになっています．<code>addch</code> のように <code>char</code> をとることを連想させる関数の引数が実は <code>chtype = unsigned int</code> でしかも Crystal の文字型 <code>Char</code> は 32bit なのでものすごく混乱します…</p>\n\n<p>C は型変換を勝手にやってくれるので，<code>unsigned int</code> を返す関数から受け取った値を <code>short</code> を受け取る関数に渡すみたいなことをよくやっていて，Crystal のような型変換を暗黙にやらない言語から使おうとすると難しいんだなぁと思いました．\nなにか良い方法があればぜひ知りたいです．</p>\n\n---\n\n---\n","slug":"NCurses_の_Crystal_binding_を作った","title":"NCurses の Crystal binding を作った","timestamp":1481203997000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Rust で Box に包まれた構造体の所有権分解\"\ndate: 2016-12-04T07:45:12.000Z\ntags: []\n---\n\n<p>ちょっとはまったのでメモ</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">struct</span> <span class=\"synIdentifier\">A</span> {\n    foo: <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">i32</span><span class=\"synStatement\">&gt;</span>,\n    bar: <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">bool</span><span class=\"synStatement\">&gt;</span>,\n}\n</pre>\n\n<p>こんな構造体があったとする。\n普通、<code>A</code> の所有権を分解して <code>foo</code> と <code>bar</code> にしたいときは</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">xxx</span>(x: A) <span class=\"synStatement\">-&gt;</span> (<span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">i32</span><span class=\"synStatement\">&gt;</span>, <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">bool</span><span class=\"synStatement\">&gt;</span>) {\n    <span class=\"synStatement\">let</span> A { foo, bar } <span class=\"synStatement\">=</span> x;\n    (foo, bar)\n}\n</pre>\n\n<p>とやれば良い（この例だともっと簡単に書ける気もするけど）</p>\n\n<p>一方、<code>Box&lt;A&gt;</code> から <code>foo</code> と <code>bar</code> に分解したい場合は話が変わってくる。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>fn error1(x: Box&lt;A&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;bool&gt;) {\n    (x.foo, x.bar)\n}\n\nfn error2(x: Box&lt;A&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;bool&gt;) {\n    let A { foo, bar } = *x;\n    (foo, bar)\n}</pre>\n\n<p>これらは両方共<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>できない。\n人間から見ると，<code>Box&lt;A&gt;</code> は <code>A</code> の所有権を持っているのだから、<code>A</code> -> <code>foo/bar</code> に分解できるなら <code>Box&lt;A&gt;</code> も同様にできる気がする。</p>\n\n<p>実際にはこのようにすると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>が通る。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>fn success(x: Box&lt;A&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;bool&gt;) {\n    let x = *x;\n    let A { foo, bar } = x;\n    (foo, bar)\n}</pre>\n\n<p>うーん、エラーになるケースだと <code>Deref</code> トレイトの機能を経由している感じになるのかな？\n<code>Deref</code> 経由で <code>foo</code> の所有権をとるとその時点で <code>Box&lt;A&gt;</code> の所有権は奪われちゃうから <code>bar</code> の所有権が取れないということなのだと想像した。\n<code>success</code> のようなコードが突然出てきたら混乱しそうだ。</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>ちょっとはまったのでメモ</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">struct</span> <span class=\"synIdentifier\">A</span> {\n    foo: <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">i32</span><span class=\"synStatement\">&gt;</span>,\n    bar: <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">bool</span><span class=\"synStatement\">&gt;</span>,\n}\n</pre>\n\n<p>こんな構造体があったとする。\n普通、<code>A</code> の所有権を分解して <code>foo</code> と <code>bar</code> にしたいときは</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">xxx</span>(x: A) <span class=\"synStatement\">-&gt;</span> (<span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">i32</span><span class=\"synStatement\">&gt;</span>, <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">bool</span><span class=\"synStatement\">&gt;</span>) {\n    <span class=\"synStatement\">let</span> A { foo, bar } <span class=\"synStatement\">=</span> x;\n    (foo, bar)\n}\n</pre>\n\n<p>とやれば良い（この例だともっと簡単に書ける気もするけど）</p>\n\n<p>一方、<code>Box&lt;A&gt;</code> から <code>foo</code> と <code>bar</code> に分解したい場合は話が変わってくる。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>fn error1(x: Box&lt;A&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;bool&gt;) {\n    (x.foo, x.bar)\n}\n\nfn error2(x: Box&lt;A&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;bool&gt;) {\n    let A { foo, bar } = *x;\n    (foo, bar)\n}</pre>\n\n<p>これらは両方共<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>できない。\n人間から見ると，<code>Box&lt;A&gt;</code> は <code>A</code> の所有権を持っているのだから、<code>A</code> -> <code>foo/bar</code> に分解できるなら <code>Box&lt;A&gt;</code> も同様にできる気がする。</p>\n\n<p>実際にはこのようにすると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>が通る。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>fn success(x: Box&lt;A&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;bool&gt;) {\n    let x = *x;\n    let A { foo, bar } = x;\n    (foo, bar)\n}</pre>\n\n<p>うーん、エラーになるケースだと <code>Deref</code> トレイトの機能を経由している感じになるのかな？\n<code>Deref</code> 経由で <code>foo</code> の所有権をとるとその時点で <code>Box&lt;A&gt;</code> の所有権は奪われちゃうから <code>bar</code> の所有権が取れないということなのだと想像した。\n<code>success</code> のようなコードが突然出てきたら混乱しそうだ。</p>\n\n---\n\n---\n","slug":"Rust_で_Box_に包まれた構造体の所有権分解","title":"Rust で Box に包まれた構造体の所有権分解","timestamp":1480837512000,"tags":[]},{"rawMarkdown":"---\ntitle: \"日本語の改行を適当にいい感じにするツールを作りました\"\ndate: 2016-10-29T04:24:49.000Z\ntags: []\n---\n\n<p>必要に迫られて、HTML ページ内の改行位置をいい感じにするツールを作ってみました。</p>\n\n<p><iframe src=\"//hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fjapawrap\" title=\"agatan/japawrap\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://github.com/agatan/japawrap\">github.com</a></cite></p>\n\n<p>HTMLに長文を書くと、親 DOM のサイズの制約上、適宜改行がぶちこまれます。\nしかし、改行位置は文節を考慮などせずにごりっと挿入されるので、多くの問題が生じることが報告されています。\n最も有名な問題として、今すぐダウンロー<br>\nド問題が挙げられます。</p>\n\n<p><code>japawrap</code> を使うと、それっぽく日本語を解釈して <code>&lt;span&gt;</code> でくくるみたいなことができます。<code>inline-block</code> を適用すれば改行がそれっぽく入るようにできます。</p>\n\n<h2>Install</h2>\n\n<p><code>go get github.com/agatan/japawrap/...</code></p>\n\n<p>で <code>japawrap</code> コマンドが使えるようになります。</p>\n\n<h2>Usage</h2>\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLI\">CLI</a></h3>\n\n<p>ファイル名を指定するか標準入力から流し込みます。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>$ echo &#34;今日も元気です&#34; | japawrap\n&lt;span class=&#34;wordwrap&#34;&gt;今日も&lt;/span&gt;&lt;span class=&#34;wordwrap&#34;&gt;元気です&lt;/span&gt;</pre>\n\n<p>このように適宜いい感じに wrap してくれます。</p>\n\n<p>オプションとして <code>-open string</code> と <code>-close string</code> をサポートしているので、</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>$ echo &#34;今日も元気です&#34; | japawrap -open &#39;&lt;span style=&#34;display: inline-block;&#34;&gt;&#39; -close &#34;&lt;/span&gt;&#34; \n&lt;span style=&#34;display: inline-block;&#34;&gt;今日も&lt;/span&gt;&lt;span style=&#34;display: inline-block;&#34;&gt;元気です&lt;/span&gt;</pre>\n\n<p>みたいなことができます。</p>\n\n<h3>Library</h3>\n\n<p>一応 <code>japawrap</code> はライブラリとしても使用できるようになっています。</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink>w := japawrap.New(open, <span class=\"synStatement\">close</span>)\ns := <span class=\"synConstant\">&quot;今日も元気です&quot;</span>\nfmt.Println(<span class=\"synConstant\">&quot;%s =&gt; %s&quot;</span>, s, w.Do(s))\n</pre>\n\n<p>これだけです。</p>\n\n<h2>Example</h2>\n\n<p>では実際に使った結果を下に記したいと思います。\n文章は、上の方に自分で書いた文章をそのまま使います。</p>\n\n<hr />\n\n<h4>before</h4>\n\n<p>HTMLに長文を書くと、親DOM のサイズの制約上、適宜改行がぶちこまれます。\nしかし、改行位置は文節を考慮などせずにごりっと挿入されるので、多くの問題が生じることが報告されています。\n最も有名な問題として、今すぐダウンロード問題が挙げられます。</p>\n\n<h4>after</h4>\n\n<p><span style=\"display: inline-block;\">HTMLに</span><span style=\"display: inline-block;\">長文を</span><span style=\"display: inline-block;\">書くと、</span><span style=\"display: inline-block;\">親 </span><span style=\"display: inline-block;\">DOM の</span><span style=\"display: inline-block;\">サイズの</span><span style=\"display: inline-block;\">制約上、</span><span style=\"display: inline-block;\">適宜改行が</span><span style=\"display: inline-block;\">ぶちこまれます。</span>\n<span style=\"display: inline-block;\">しかし、</span><span style=\"display: inline-block;\">改行位置は</span><span style=\"display: inline-block;\">文節を</span><span style=\"display: inline-block;\">考慮など</span><span style=\"display: inline-block;\">せず</span><span style=\"display: inline-block;\">にごりっと</span><span style=\"display: inline-block;\">挿入されるので、</span><span style=\"display: inline-block;\">多くの</span><span style=\"display: inline-block;\">問題が</span><span style=\"display: inline-block;\">生じる</span><span style=\"display: inline-block;\">ことが</span><span style=\"display: inline-block;\">報告されて</span><span style=\"display: inline-block;\">います。</span>\n<span style=\"display: inline-block;\">最も</span><span style=\"display: inline-block;\">有名な</span><span style=\"display: inline-block;\">問題として、<span style=\"display: inline-block;\">今すぐ</span><span style=\"display: inline-block;\">ダウンロード問題が</span><span style=\"display: inline-block;\">挙げられます。</span></p>\n\n<hr />\n\n<p>こんな感じになります。猛烈に効果がわかりにくくて驚いていますが、一応効果はちゃんと出ているのではないでしょうか？\nHTMLを直接見ていただければどうなっているかはわかると思います。</p>\n\n<p>次に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%C4%B6%F5%CA%B8%B8%CB\">青空文庫</a>から<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%C6%CC%DC%DE%FB%C0%D0\">夏目漱石</a>「こころ」の序文を抜粋してみたのが下の画像たちです。</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20161029/20161029131814.png\" alt=\"f:id:agtn:20161029131814p:plain\" title=\"f:id:agtn:20161029131814p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20161029/20161029131817.png\" alt=\"f:id:agtn:20161029131817p:plain\" title=\"f:id:agtn:20161029131817p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20161029/20161029131820.png\" alt=\"f:id:agtn:20161029131820p:plain\" title=\"f:id:agtn:20161029131820p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>レスポンシブ！それなりになっている気がします。</p>\n\n<h4>あとがき</h4>\n\n<p>この問題へのアプローチとして、<a href=\"https://github.com/google/budou\">https://github.com/google/budou</a> が有名だと思います。</p>\n\n<p><code>budou</code> は　<a href=\"https://cloud.google.com/natural-language/\">Cloud Natural Language API</a> を内部で使っていて、しっかり日本語の文章を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>しているようです。\nなので非常に精度は高いと思うのですが、今僕の <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GCP\">GCP</a> アカウントがごにょごにょしていてぱぱっと試せる状況ではなかったので自作しました。</p>\n\n<p><code>budou</code> と違ってしっかり<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>などはしていなくて、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%C1%C2%D6%C1%C7%B2%F2%C0%CF\">形態素解析</a>した後、それっぽく分割しているだけです。なので精度は落ちると思います。\n一方、<code>budou</code> は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GCP\">GCP</a> の credentails が必要だったりと準備が必要になるので、お手軽に試せるというのは悪くないかなと思っています。</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>必要に迫られて、HTML ページ内の改行位置をいい感じにするツールを作ってみました。</p>\n\n<p><iframe src=\"//hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fagatan%2Fjapawrap\" title=\"agatan/japawrap\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://github.com/agatan/japawrap\">github.com</a></cite></p>\n\n<p>HTMLに長文を書くと、親 DOM のサイズの制約上、適宜改行がぶちこまれます。\nしかし、改行位置は文節を考慮などせずにごりっと挿入されるので、多くの問題が生じることが報告されています。\n最も有名な問題として、今すぐダウンロー<br>\nド問題が挙げられます。</p>\n\n<p><code>japawrap</code> を使うと、それっぽく日本語を解釈して <code>&lt;span&gt;</code> でくくるみたいなことができます。<code>inline-block</code> を適用すれば改行がそれっぽく入るようにできます。</p>\n\n<h2>Install</h2>\n\n<p><code>go get github.com/agatan/japawrap/...</code></p>\n\n<p>で <code>japawrap</code> コマンドが使えるようになります。</p>\n\n<h2>Usage</h2>\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLI\">CLI</a></h3>\n\n<p>ファイル名を指定するか標準入力から流し込みます。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>$ echo &#34;今日も元気です&#34; | japawrap\n&lt;span class=&#34;wordwrap&#34;&gt;今日も&lt;/span&gt;&lt;span class=&#34;wordwrap&#34;&gt;元気です&lt;/span&gt;</pre>\n\n<p>このように適宜いい感じに wrap してくれます。</p>\n\n<p>オプションとして <code>-open string</code> と <code>-close string</code> をサポートしているので、</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>$ echo &#34;今日も元気です&#34; | japawrap -open &#39;&lt;span style=&#34;display: inline-block;&#34;&gt;&#39; -close &#34;&lt;/span&gt;&#34; \n&lt;span style=&#34;display: inline-block;&#34;&gt;今日も&lt;/span&gt;&lt;span style=&#34;display: inline-block;&#34;&gt;元気です&lt;/span&gt;</pre>\n\n<p>みたいなことができます。</p>\n\n<h3>Library</h3>\n\n<p>一応 <code>japawrap</code> はライブラリとしても使用できるようになっています。</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink>w := japawrap.New(open, <span class=\"synStatement\">close</span>)\ns := <span class=\"synConstant\">&quot;今日も元気です&quot;</span>\nfmt.Println(<span class=\"synConstant\">&quot;%s =&gt; %s&quot;</span>, s, w.Do(s))\n</pre>\n\n<p>これだけです。</p>\n\n<h2>Example</h2>\n\n<p>では実際に使った結果を下に記したいと思います。\n文章は、上の方に自分で書いた文章をそのまま使います。</p>\n\n<hr />\n\n<h4>before</h4>\n\n<p>HTMLに長文を書くと、親DOM のサイズの制約上、適宜改行がぶちこまれます。\nしかし、改行位置は文節を考慮などせずにごりっと挿入されるので、多くの問題が生じることが報告されています。\n最も有名な問題として、今すぐダウンロード問題が挙げられます。</p>\n\n<h4>after</h4>\n\n<p><span style=\"display: inline-block;\">HTMLに</span><span style=\"display: inline-block;\">長文を</span><span style=\"display: inline-block;\">書くと、</span><span style=\"display: inline-block;\">親 </span><span style=\"display: inline-block;\">DOM の</span><span style=\"display: inline-block;\">サイズの</span><span style=\"display: inline-block;\">制約上、</span><span style=\"display: inline-block;\">適宜改行が</span><span style=\"display: inline-block;\">ぶちこまれます。</span>\n<span style=\"display: inline-block;\">しかし、</span><span style=\"display: inline-block;\">改行位置は</span><span style=\"display: inline-block;\">文節を</span><span style=\"display: inline-block;\">考慮など</span><span style=\"display: inline-block;\">せず</span><span style=\"display: inline-block;\">にごりっと</span><span style=\"display: inline-block;\">挿入されるので、</span><span style=\"display: inline-block;\">多くの</span><span style=\"display: inline-block;\">問題が</span><span style=\"display: inline-block;\">生じる</span><span style=\"display: inline-block;\">ことが</span><span style=\"display: inline-block;\">報告されて</span><span style=\"display: inline-block;\">います。</span>\n<span style=\"display: inline-block;\">最も</span><span style=\"display: inline-block;\">有名な</span><span style=\"display: inline-block;\">問題として、<span style=\"display: inline-block;\">今すぐ</span><span style=\"display: inline-block;\">ダウンロード問題が</span><span style=\"display: inline-block;\">挙げられます。</span></p>\n\n<hr />\n\n<p>こんな感じになります。猛烈に効果がわかりにくくて驚いていますが、一応効果はちゃんと出ているのではないでしょうか？\nHTMLを直接見ていただければどうなっているかはわかると思います。</p>\n\n<p>次に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%C4%B6%F5%CA%B8%B8%CB\">青空文庫</a>から<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%C6%CC%DC%DE%FB%C0%D0\">夏目漱石</a>「こころ」の序文を抜粋してみたのが下の画像たちです。</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20161029/20161029131814.png\" alt=\"f:id:agtn:20161029131814p:plain\" title=\"f:id:agtn:20161029131814p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20161029/20161029131817.png\" alt=\"f:id:agtn:20161029131817p:plain\" title=\"f:id:agtn:20161029131817p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20161029/20161029131820.png\" alt=\"f:id:agtn:20161029131820p:plain\" title=\"f:id:agtn:20161029131820p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>レスポンシブ！それなりになっている気がします。</p>\n\n<h4>あとがき</h4>\n\n<p>この問題へのアプローチとして、<a href=\"https://github.com/google/budou\">https://github.com/google/budou</a> が有名だと思います。</p>\n\n<p><code>budou</code> は　<a href=\"https://cloud.google.com/natural-language/\">Cloud Natural Language API</a> を内部で使っていて、しっかり日本語の文章を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>しているようです。\nなので非常に精度は高いと思うのですが、今僕の <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GCP\">GCP</a> アカウントがごにょごにょしていてぱぱっと試せる状況ではなかったので自作しました。</p>\n\n<p><code>budou</code> と違ってしっかり<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>などはしていなくて、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%C1%C2%D6%C1%C7%B2%F2%C0%CF\">形態素解析</a>した後、それっぽく分割しているだけです。なので精度は落ちると思います。\n一方、<code>budou</code> は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GCP\">GCP</a> の credentails が必要だったりと準備が必要になるので、お手軽に試せるというのは悪くないかなと思っています。</p>\n\n---\n\n---\n","slug":"日本語の改行を適当にいい感じにするツールを作りました","title":"日本語の改行を適当にいい感じにするツールを作りました","timestamp":1477715089000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Rust の Result と Iterator\"\ndate: 2016-09-05T14:47:25.000Z\ntags: []\n---\n\n<p>Rust には失敗するかもしれない値を表す <code>Result&lt;T, E&gt;</code> という型があります。\n<a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\">std::result::Result</a></p>\n\n<p>そして iterate できることを表す <code>Iterator</code> という trait があります。\n<a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html\">std::iter::Iterator</a></p>\n\n<p>また、<code>Iterator</code> trait は要素型を表す関連型を持ちます。<del>例えば <code>String</code> は <code>Iterator&lt;Item=char&gt;</code> を <code>impl</code> しています。これは <code>char</code> 型を要素にもつ <code>Iterator</code> であることを意味します。</del>\nここ間違っていました。<code>String</code> が直接 <code>Iterator</code> を <code>impl</code> しているのではありませんでした。</p>\n\n<p>たまに <code>Iterator&lt;Item=Result&lt;T, E&gt;&gt;</code> のようになっている型を見かけます（T, E にはなにかしら具体的な型が入っていると思ってください）。\n例えば、<code>std::io::stdin().bytes()</code> の返り値である <a href=\"https://doc.rust-lang.org/stable/std/io/struct.Bytes.html\">std::io::Bytes</a> は <code>Iterator&lt;Item=Result&lt;u8&gt;&gt;</code> を <code>impl</code> しています。\n（ちょっとわかりにくいのですがここでの <code>Result</code> は <code>std::result::Result</code> ではなくて <code>std::io::Result</code> です。<code>std::io::Result</code> は <code>std::result::Result&lt;T, std::io::Error&gt;</code> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>です。）</p>\n\n<p>さて、このような <code>Iterator</code> からすべての要素が <code>Ok(_)</code> であれば <code>Ok&lt;Vec_&gt;&gt;</code> を、<code>Err(_)</code> があれば <code>Err&lt;_&gt;</code> を返すような処理を書きたいということは割りとよくあります。\nで、これを一生懸命実装しようとしていたのですが、標準ライブラリの範囲内ですでに実装されていました。べんり。</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">let</span> result <span class=\"synStatement\">=</span> <span class=\"synPreProc\">std</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">io</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">stdin</span>().<span class=\"synIdentifier\">bytes</span>().<span class=\"synIdentifier\">collect</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>_<span class=\"synStatement\">&gt;</span>, _<span class=\"synStatement\">&gt;&gt;</span>();\n</pre>\n\n<p>これだけです。これで要件を満たす <code>Result&lt;Vec&lt;_&gt;, _&gt;</code> が返って来ます。すばらしい。</p>\n\n<p>タネは簡単な話で <code>Result</code> が <code>FromIterator</code> trait を <code>impl</code> しているので <code>collect</code> で変換が可能であるというお話でした。\n<a href=\"https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html\">std::iter::FromIterator</a></p>\n\n---\n\n---\n","contentMarkdown":"\n<p>Rust には失敗するかもしれない値を表す <code>Result&lt;T, E&gt;</code> という型があります。\n<a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\">std::result::Result</a></p>\n\n<p>そして iterate できることを表す <code>Iterator</code> という trait があります。\n<a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html\">std::iter::Iterator</a></p>\n\n<p>また、<code>Iterator</code> trait は要素型を表す関連型を持ちます。<del>例えば <code>String</code> は <code>Iterator&lt;Item=char&gt;</code> を <code>impl</code> しています。これは <code>char</code> 型を要素にもつ <code>Iterator</code> であることを意味します。</del>\nここ間違っていました。<code>String</code> が直接 <code>Iterator</code> を <code>impl</code> しているのではありませんでした。</p>\n\n<p>たまに <code>Iterator&lt;Item=Result&lt;T, E&gt;&gt;</code> のようになっている型を見かけます（T, E にはなにかしら具体的な型が入っていると思ってください）。\n例えば、<code>std::io::stdin().bytes()</code> の返り値である <a href=\"https://doc.rust-lang.org/stable/std/io/struct.Bytes.html\">std::io::Bytes</a> は <code>Iterator&lt;Item=Result&lt;u8&gt;&gt;</code> を <code>impl</code> しています。\n（ちょっとわかりにくいのですがここでの <code>Result</code> は <code>std::result::Result</code> ではなくて <code>std::io::Result</code> です。<code>std::io::Result</code> は <code>std::result::Result&lt;T, std::io::Error&gt;</code> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>です。）</p>\n\n<p>さて、このような <code>Iterator</code> からすべての要素が <code>Ok(_)</code> であれば <code>Ok&lt;Vec_&gt;&gt;</code> を、<code>Err(_)</code> があれば <code>Err&lt;_&gt;</code> を返すような処理を書きたいということは割りとよくあります。\nで、これを一生懸命実装しようとしていたのですが、標準ライブラリの範囲内ですでに実装されていました。べんり。</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">let</span> result <span class=\"synStatement\">=</span> <span class=\"synPreProc\">std</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">io</span><span class=\"synSpecial\">::</span><span class=\"synIdentifier\">stdin</span>().<span class=\"synIdentifier\">bytes</span>().<span class=\"synIdentifier\">collect</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>_<span class=\"synStatement\">&gt;</span>, _<span class=\"synStatement\">&gt;&gt;</span>();\n</pre>\n\n<p>これだけです。これで要件を満たす <code>Result&lt;Vec&lt;_&gt;, _&gt;</code> が返って来ます。すばらしい。</p>\n\n<p>タネは簡単な話で <code>Result</code> が <code>FromIterator</code> trait を <code>impl</code> しているので <code>collect</code> で変換が可能であるというお話でした。\n<a href=\"https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html\">std::iter::FromIterator</a></p>\n\n---\n\n---\n","slug":"Rust_の_Result_と_Iterator","title":"Rust の Result と Iterator","timestamp":1473086845000,"tags":[]},{"rawMarkdown":"---\ntitle: \"値と参照について\"\ndate: 2016-08-14T04:56:32.000Z\ntags: []\n---\n\n<p>「値」と「参照」という言葉があります。\nこのへんの言葉について、今の理解をまとめておこうと思います。\n言葉の定義や理解が誤っている部分があればご指摘ください。</p>\n\n<p>まず、前提として以下では、「値」ベースの言語として C, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>, Rust などを、「参照」ベースの言語として <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a>, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%23\">C#</a>, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\">Ruby</a> などを想定しています。\n（もちろん言語によってはハイブリッドなものもあります: Crystal, Go, D, ...）</p>\n\n<h2>そもそも「値」「参照」とは</h2>\n\n<p>「値」は「実体」、「参照」は「実体へのポインタ」です。</p>\n\n<p><code>int</code> の配列みたいなものを考えてみます。\n<code>[1, 2, 3]</code> をメモリ上にどう表現できるでしょうか。</p>\n\n<p>配列ですから、単純にメモリ上のどこかに以下のような領域を作ればよさそうです。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>+---+\n| 1 |\n+---+\n| 2 |\n+---+\n| 3 |\n+---+</pre>\n\n<p>これが「値」であり配列の実体です。\nそして、実体の配置されたメモリ領域へのポインタが「参照」です。</p>\n\n<h2>スタック上の表現</h2>\n\n<p>さて、プログラム上ではこの配列のようなオブジェクトを、ローカル変数としてスタック上で表現したり、関数に引数として渡したりします。\nでは、スタック上での配列の表現はどうなっているのか考えてみます。</p>\n\n<p>ここで、「値」と「参照」という言葉が重要になります。</p>\n\n<p>「値」ベースな言語では、スタック上に</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>+---+\n| 1 |\n+---+\n| 2 |\n+---+\n| 3 |\n+---+</pre>\n\n<p>をそのままべたっと配置します。</p>\n\n<p>一方で、「参照」ベースな言語では、ヒープ上に</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>+---+\n| 1 |\n+---+\n| 2 |\n+---+\n| 3 |\n+---+</pre>\n\n<p>を配置し、スタック上では実体へのポインタという表現になります。\n（必ずしもヒープに置くとは限らない？処理系や最適化によってはスタックに置くこともありえる？とにかくローカル変数などの表現としては実体へのポインタという形をとるということ）</p>\n\n<h2>値渡し・参照渡し</h2>\n\n<p>値渡しとか参照渡しという言葉があります。</p>\n\n<p>以下に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%BC%BB%F7%A5%B3%A1%BC%A5%C9\">擬似コード</a>を一つ書いてみます。（C 風に書いていますが C ではないと思ってください）</p>\n\n<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synType\">void</span> inc_age(Person p) {\n  p.age++;\n}\n\nPerson john = Person { <span class=\"synConstant\">&quot;john&quot;</span>, <span class=\"synConstant\">20</span> };\ninc_age(john);\nprint(john.age); <span class=\"synComment\">// =&gt; ??</span>\n</pre>\n\n<p>このコード、処理系が「値」ベースか「参照」ベースかで結果が異なります。</p>\n\n<h4>「値」ベースの場合</h4>\n\n<p>値ベースの言語の場合、<code>inc_age</code> の引数に <code>john</code> を渡した時には、<code>inc_age</code> 内のローカル変数（引数） <code>p</code> のために、<code>john</code> のコピーが作られます。<br/>\n<code>inc_age</code> 内で <code>p.age++</code> としていますが、<code>p</code> は <code>john</code> のコピーであって <code>john</code> ではありませんから、<code>inc_age</code> から戻ってきて <code>john.age</code> を参照しても 20 のまま変化が無いはずです。</p>\n\n<p>したがって結果として <code>20</code> が出力されます。</p>\n\n<h4>「参照」ベースの場合</h4>\n\n<p>参照ベースの言語の場合、<code>john</code> 変数のメモリ上での表現は、ヒープに置かれた <code>Person { \"john\", 20 }</code> というオブジェクトへのポインタになります。<br/>\n<code>inc_age</code> にこれを引数として渡すと、ポインタの値がコピーされますから、<code>p</code> と <code>john</code> は同じオブジェクトを参照しているポインタになります。<br/>\n<code>p.age++</code> とすると <code>p</code> が参照するオブジェクトが変更されます。これは <code>john</code> が参照するオブジェクトと同一ですから、<code>john.age</code> も 21 に変化します。</p>\n\n<p>したがって結果として <code>21</code> が出力されます。</p>\n\n<h3>C の場合</h3>\n\n<p>C の場合、ポインタが直接表現できますから、参照渡しの挙動を模倣することができます。</p>\n\n<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synType\">void</span> inc_age(Person *p) {\n    p-&gt;age++;\n}\n\nPerson john = Person { <span class=\"synConstant\">&quot;john&quot;</span>, <span class=\"synConstant\">20</span> };\ninc_age(&amp;john);\nprint(john.age); <span class=\"synComment\">// =&gt; 21</span>\n</pre>\n\n<p><code>p</code> が <code>Person*</code> 型であること、そして <code>inc_age</code> に <code>john</code> のアドレスを渡していることに注目してください。\nこの場合、<code>p</code> は <code>john</code> を参照するポインタですから、結果は <code>21</code> になります。</p>\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の場合</h3>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の場合、言語機能として「参照渡し」という機能があります。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">void</span> inc_age(Person&amp; p) {\n    p.age++;\n}\n\nPerson john = Person { <span class=\"synConstant\">&quot;john&quot;</span>, <span class=\"synConstant\">20</span> };\ninc_age(john);\nprint(john.age); <span class=\"synComment\">// =&gt; 21</span>\n</pre>\n\n<p><code>p</code> が <code>Person&amp;</code> 型であること、<code>inc_age</code> には <code>john</code> をそのまま渡しているように見えることに注目してください。\nこれは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の提供する機能で、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>すると、<code>Person&amp;</code> は実質 <code>Person*</code> と同じ表現になります。\n<code>p-&gt;age</code> ではなく <code>p.age</code> と書けること、<code>&amp;john</code> ではなく <code>john</code> のままで参照渡しが実現できるようになっています。\n単純なポインタを使っても同じことが出来ますが、ポインタと違って <code>nullptr</code> になることがないという特徴があります。</p>\n\n<h2>参照のハマりやすい点</h2>\n\n<p>個人的に参照ベースの言語でハマりやすいなと感じるのは以下のようなコードです。</p>\n\n<pre class=\"code lang-java\" data-lang=\"java\" data-unlink><span class=\"synType\">void</span> some_function(Person p) {\n    p.age++;\n    p = <span class=\"synStatement\">new</span> Person(<span class=\"synConstant\">&quot;bob&quot;</span>, <span class=\"synConstant\">30</span>);\n}\n\nPerson p = <span class=\"synStatement\">new</span> Person(<span class=\"synConstant\">&quot;john&quot;</span>, <span class=\"synConstant\">20</span>);\nsome_function(p);\nprintln(p.name); <span class=\"synComment\">// =&gt; john</span>\nprintln(p.age); <span class=\"synComment\">// =&gt; 21</span>\n</pre>\n\n<p><code>p.age++</code> の部分は呼び出し元のオブジェクトに反映されるのに、<code>p = new Person(...)</code> の部分はなんで反映されないの！ってなります。（なりません？）\n本質的にポインタの値渡しにすぎないんだということを理解していればまぁ納得なのですが...</p>\n\n<p>（ちなみに <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> や D の参照渡しだと <code>p = new Person(...)</code> 的なコードも呼び出し元に反映されます。）</p>\n\n<h2>値のハマりやすい点</h2>\n\n<p>ハマりやすいというか、気がつかないままパフォーマンスが悪くなりやすいのが値ベースの言語の弱点でしょう。</p>\n\n<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synType\">void</span> print_object(HugeObject obj) {\n   printf(<span class=\"synConstant\">&quot;</span><span class=\"synSpecial\">%s\\n</span><span class=\"synConstant\">&quot;</span>, obj.name);\n}\nHugeObject obj = ...;\nprint_object(obj);\n</pre>\n\n<p>このようなコードを書くと、ただ名前を表示するだけの関数が激重になる可能性があります。\n値ベースの言語では、引数として値を渡すとまるっとそのコピーをつくりますから、不要にもかかわらず巨大な値のコピーを作ってしまいます。</p>\n\n<h2>まとめ</h2>\n\n<p>「ムーブセマンティクス」とか「immutable と参照」とかについてまとめようと思ったのですが、前提として「値」「参照」についてまとめていないと書きにくいなと思ったのでまとめておきました。</p>\n\n<p>内部表現を知ることでハマりやすい点の回避にもつながると思うので、この辺はきちんと理解しておきたいです。</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>「値」と「参照」という言葉があります。\nこのへんの言葉について、今の理解をまとめておこうと思います。\n言葉の定義や理解が誤っている部分があればご指摘ください。</p>\n\n<p>まず、前提として以下では、「値」ベースの言語として C, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>, Rust などを、「参照」ベースの言語として <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a>, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%23\">C#</a>, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\">Ruby</a> などを想定しています。\n（もちろん言語によってはハイブリッドなものもあります: Crystal, Go, D, ...）</p>\n\n<h2>そもそも「値」「参照」とは</h2>\n\n<p>「値」は「実体」、「参照」は「実体へのポインタ」です。</p>\n\n<p><code>int</code> の配列みたいなものを考えてみます。\n<code>[1, 2, 3]</code> をメモリ上にどう表現できるでしょうか。</p>\n\n<p>配列ですから、単純にメモリ上のどこかに以下のような領域を作ればよさそうです。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>+---+\n| 1 |\n+---+\n| 2 |\n+---+\n| 3 |\n+---+</pre>\n\n<p>これが「値」であり配列の実体です。\nそして、実体の配置されたメモリ領域へのポインタが「参照」です。</p>\n\n<h2>スタック上の表現</h2>\n\n<p>さて、プログラム上ではこの配列のようなオブジェクトを、ローカル変数としてスタック上で表現したり、関数に引数として渡したりします。\nでは、スタック上での配列の表現はどうなっているのか考えてみます。</p>\n\n<p>ここで、「値」と「参照」という言葉が重要になります。</p>\n\n<p>「値」ベースな言語では、スタック上に</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>+---+\n| 1 |\n+---+\n| 2 |\n+---+\n| 3 |\n+---+</pre>\n\n<p>をそのままべたっと配置します。</p>\n\n<p>一方で、「参照」ベースな言語では、ヒープ上に</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>+---+\n| 1 |\n+---+\n| 2 |\n+---+\n| 3 |\n+---+</pre>\n\n<p>を配置し、スタック上では実体へのポインタという表現になります。\n（必ずしもヒープに置くとは限らない？処理系や最適化によってはスタックに置くこともありえる？とにかくローカル変数などの表現としては実体へのポインタという形をとるということ）</p>\n\n<h2>値渡し・参照渡し</h2>\n\n<p>値渡しとか参照渡しという言葉があります。</p>\n\n<p>以下に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%BC%BB%F7%A5%B3%A1%BC%A5%C9\">擬似コード</a>を一つ書いてみます。（C 風に書いていますが C ではないと思ってください）</p>\n\n<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synType\">void</span> inc_age(Person p) {\n  p.age++;\n}\n\nPerson john = Person { <span class=\"synConstant\">&quot;john&quot;</span>, <span class=\"synConstant\">20</span> };\ninc_age(john);\nprint(john.age); <span class=\"synComment\">// =&gt; ??</span>\n</pre>\n\n<p>このコード、処理系が「値」ベースか「参照」ベースかで結果が異なります。</p>\n\n<h4>「値」ベースの場合</h4>\n\n<p>値ベースの言語の場合、<code>inc_age</code> の引数に <code>john</code> を渡した時には、<code>inc_age</code> 内のローカル変数（引数） <code>p</code> のために、<code>john</code> のコピーが作られます。<br/>\n<code>inc_age</code> 内で <code>p.age++</code> としていますが、<code>p</code> は <code>john</code> のコピーであって <code>john</code> ではありませんから、<code>inc_age</code> から戻ってきて <code>john.age</code> を参照しても 20 のまま変化が無いはずです。</p>\n\n<p>したがって結果として <code>20</code> が出力されます。</p>\n\n<h4>「参照」ベースの場合</h4>\n\n<p>参照ベースの言語の場合、<code>john</code> 変数のメモリ上での表現は、ヒープに置かれた <code>Person { \"john\", 20 }</code> というオブジェクトへのポインタになります。<br/>\n<code>inc_age</code> にこれを引数として渡すと、ポインタの値がコピーされますから、<code>p</code> と <code>john</code> は同じオブジェクトを参照しているポインタになります。<br/>\n<code>p.age++</code> とすると <code>p</code> が参照するオブジェクトが変更されます。これは <code>john</code> が参照するオブジェクトと同一ですから、<code>john.age</code> も 21 に変化します。</p>\n\n<p>したがって結果として <code>21</code> が出力されます。</p>\n\n<h3>C の場合</h3>\n\n<p>C の場合、ポインタが直接表現できますから、参照渡しの挙動を模倣することができます。</p>\n\n<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synType\">void</span> inc_age(Person *p) {\n    p-&gt;age++;\n}\n\nPerson john = Person { <span class=\"synConstant\">&quot;john&quot;</span>, <span class=\"synConstant\">20</span> };\ninc_age(&amp;john);\nprint(john.age); <span class=\"synComment\">// =&gt; 21</span>\n</pre>\n\n<p><code>p</code> が <code>Person*</code> 型であること、そして <code>inc_age</code> に <code>john</code> のアドレスを渡していることに注目してください。\nこの場合、<code>p</code> は <code>john</code> を参照するポインタですから、結果は <code>21</code> になります。</p>\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の場合</h3>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の場合、言語機能として「参照渡し」という機能があります。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">void</span> inc_age(Person&amp; p) {\n    p.age++;\n}\n\nPerson john = Person { <span class=\"synConstant\">&quot;john&quot;</span>, <span class=\"synConstant\">20</span> };\ninc_age(john);\nprint(john.age); <span class=\"synComment\">// =&gt; 21</span>\n</pre>\n\n<p><code>p</code> が <code>Person&amp;</code> 型であること、<code>inc_age</code> には <code>john</code> をそのまま渡しているように見えることに注目してください。\nこれは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の提供する機能で、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>すると、<code>Person&amp;</code> は実質 <code>Person*</code> と同じ表現になります。\n<code>p-&gt;age</code> ではなく <code>p.age</code> と書けること、<code>&amp;john</code> ではなく <code>john</code> のままで参照渡しが実現できるようになっています。\n単純なポインタを使っても同じことが出来ますが、ポインタと違って <code>nullptr</code> になることがないという特徴があります。</p>\n\n<h2>参照のハマりやすい点</h2>\n\n<p>個人的に参照ベースの言語でハマりやすいなと感じるのは以下のようなコードです。</p>\n\n<pre class=\"code lang-java\" data-lang=\"java\" data-unlink><span class=\"synType\">void</span> some_function(Person p) {\n    p.age++;\n    p = <span class=\"synStatement\">new</span> Person(<span class=\"synConstant\">&quot;bob&quot;</span>, <span class=\"synConstant\">30</span>);\n}\n\nPerson p = <span class=\"synStatement\">new</span> Person(<span class=\"synConstant\">&quot;john&quot;</span>, <span class=\"synConstant\">20</span>);\nsome_function(p);\nprintln(p.name); <span class=\"synComment\">// =&gt; john</span>\nprintln(p.age); <span class=\"synComment\">// =&gt; 21</span>\n</pre>\n\n<p><code>p.age++</code> の部分は呼び出し元のオブジェクトに反映されるのに、<code>p = new Person(...)</code> の部分はなんで反映されないの！ってなります。（なりません？）\n本質的にポインタの値渡しにすぎないんだということを理解していればまぁ納得なのですが...</p>\n\n<p>（ちなみに <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> や D の参照渡しだと <code>p = new Person(...)</code> 的なコードも呼び出し元に反映されます。）</p>\n\n<h2>値のハマりやすい点</h2>\n\n<p>ハマりやすいというか、気がつかないままパフォーマンスが悪くなりやすいのが値ベースの言語の弱点でしょう。</p>\n\n<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synType\">void</span> print_object(HugeObject obj) {\n   printf(<span class=\"synConstant\">&quot;</span><span class=\"synSpecial\">%s\\n</span><span class=\"synConstant\">&quot;</span>, obj.name);\n}\nHugeObject obj = ...;\nprint_object(obj);\n</pre>\n\n<p>このようなコードを書くと、ただ名前を表示するだけの関数が激重になる可能性があります。\n値ベースの言語では、引数として値を渡すとまるっとそのコピーをつくりますから、不要にもかかわらず巨大な値のコピーを作ってしまいます。</p>\n\n<h2>まとめ</h2>\n\n<p>「ムーブセマンティクス」とか「immutable と参照」とかについてまとめようと思ったのですが、前提として「値」「参照」についてまとめていないと書きにくいなと思ったのでまとめておきました。</p>\n\n<p>内部表現を知ることでハマりやすい点の回避にもつながると思うので、この辺はきちんと理解しておきたいです。</p>\n\n---\n\n---\n","slug":"値と参照について","title":"値と参照について","timestamp":1471150592000,"tags":[]},{"rawMarkdown":"---\ntitle: \"再帰的 grep ツール crepe を作っています\"\ndate: 2016-07-08T15:36:15.000Z\ntags: []\n---\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>的にパスをたどりながらパターンにマッチする行を検索する <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/grep\">grep</a> 系のツールを作っています。</p>\n\n<p><a href=\"https://github.com/agatan/crepe\">agatan/crepe</a></p>\n\n<p>有名どころとしては、<a href=\"http://beyondgrep.com/\">ack</a> とか <a href=\"https://github.com/ggreer/the_silver_searcher\">ggreer/the_silver_searcher</a>(ag) とか <a href=\"https://github.com/monochromegane/the_platinum_searcher\">monochromegane/the_platinum_searcher</a> とか <a href=\"https://github.com/tkengo/highway\">tkengo/highway</a> なんかがあります。群雄割拠ですね。</p>\n\n<p>これらの有名ツール達はそれぞれ特徴があって(速さとか出力形式とか<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%F3%A5%B3%A1%BC%A5%C9\">エンコード</a>対応とか)便利に使わせていただいております。<br/>\n今回 <code>crepe</code> を作ろうと思った理由は、なんとなく <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でちゃんとスレッド立てて並行処理みたいなコードを書いてみたくなったからです。</p>\n\n<p>速度等も測っていないのでどこまで意味があるのか怪しいのですが、とりあえず現状 3 つの仕事を並列に動かしています。</p>\n\n<p>一つ目は出力を担当するスレッドで、マッチ結果を受け取って出力するだけです。<br/>\n二つ目はマッチを担当するスレッドで、ファイル名と <code>FILE*</code> を受け取ってマッチ結果を生成し出力担当スレッドに渡します。<br/>\n三つ目はパスを walk するスレッドで、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リを掘りながらファイルを開いてマッチスレッドに送ります。</p>\n\n<p>現状はまだ部分一致の matcher しか実装していないので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%C9%BD%B8%BD\">正規表現</a>や fuzzy マッチは未実装です。<br/>\n標準入力かパスから部分一致する行を探してきて出力します。<br/>\n出力形式は <code>ag</code> に近い形式で、ファイルごとにグループ分けして行番号とともに出力します（オプションでこの辺の挙動はいじれるようにはなっています）</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\">バイ</a>ナリファイルっぽいファイルはスキップするようになっています。</p>\n\n<h2>やりたいこと</h2>\n\n<p>最終目標として <code>crepe</code> は <a href=\"https://github.com/peco/peco\">peco</a> のような interactive な検索を実装してみたいなと思っています。<br/>\n<code>ag</code> と <code>peco</code> の組み合わせで云々みたいな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\">ユースケース</a>が割りとあるなぁと思ったので。<br/>\nただこれメモリ使用量とか速度上の制約からまともに働くのかはよくわかっていません。<br/>\n単純に考えると、ユーザが一文字入力するたびにファイルの read からやり直す必要があるので...<br/>\n入力ファイルが多すぎた場合にどこまでキャッシュするのかとかその辺を相当うまくやらないと死ぬのでは？という気がします。</p>\n\n<p>短期的な目標としては</p>\n\n<ul>\n<li>.gitignore 対応 (意外とめっちゃ面倒で苦しんでいます)</li>\n<li>fuzzy マッチ</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%C9%BD%B8%BD\">正規表現</a>マッチ</li>\n</ul>\n\n<p>あたりから順にやっていきたいなと思っています。とりあえずこっちからやろうかなと思います。</p>\n\n<p>というわけで気合を入れる意味も込めて記事にしました。プルリクやフィードバック大歓迎なのでぜひよろしくお願いします。</p>\n\n---\n\nCOMMENT:\nAUTHOR: smaranrebub\nEMAIL: ruysqucp@gmail.com\nURL: http://cialisvipsale.com\nIP: 200.26.168.127\nDATE: 03/24/2018 15:30:29\n\nVery good info, Thanks!\nwalgreens price for cialis <a href=\"http://cialisvipsale.com\">buy brand cialis cheap</a>\nprices on cialis 10 mg <a href=\"http://cialisvipsale.com\">http://cialisvipsale.com</a>\nacheter du cialis a geneve <a href=\"http://cialisvipsale.com\">effetti del cialis</a>\nprices for cialis 50mg\n\n---\n\n---\n","contentMarkdown":"\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>的にパスをたどりながらパターンにマッチする行を検索する <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/grep\">grep</a> 系のツールを作っています。</p>\n\n<p><a href=\"https://github.com/agatan/crepe\">agatan/crepe</a></p>\n\n<p>有名どころとしては、<a href=\"http://beyondgrep.com/\">ack</a> とか <a href=\"https://github.com/ggreer/the_silver_searcher\">ggreer/the_silver_searcher</a>(ag) とか <a href=\"https://github.com/monochromegane/the_platinum_searcher\">monochromegane/the_platinum_searcher</a> とか <a href=\"https://github.com/tkengo/highway\">tkengo/highway</a> なんかがあります。群雄割拠ですね。</p>\n\n<p>これらの有名ツール達はそれぞれ特徴があって(速さとか出力形式とか<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%F3%A5%B3%A1%BC%A5%C9\">エンコード</a>対応とか)便利に使わせていただいております。<br/>\n今回 <code>crepe</code> を作ろうと思った理由は、なんとなく <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でちゃんとスレッド立てて並行処理みたいなコードを書いてみたくなったからです。</p>\n\n<p>速度等も測っていないのでどこまで意味があるのか怪しいのですが、とりあえず現状 3 つの仕事を並列に動かしています。</p>\n\n<p>一つ目は出力を担当するスレッドで、マッチ結果を受け取って出力するだけです。<br/>\n二つ目はマッチを担当するスレッドで、ファイル名と <code>FILE*</code> を受け取ってマッチ結果を生成し出力担当スレッドに渡します。<br/>\n三つ目はパスを walk するスレッドで、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リを掘りながらファイルを開いてマッチスレッドに送ります。</p>\n\n<p>現状はまだ部分一致の matcher しか実装していないので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%C9%BD%B8%BD\">正規表現</a>や fuzzy マッチは未実装です。<br/>\n標準入力かパスから部分一致する行を探してきて出力します。<br/>\n出力形式は <code>ag</code> に近い形式で、ファイルごとにグループ分けして行番号とともに出力します（オプションでこの辺の挙動はいじれるようにはなっています）</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\">バイ</a>ナリファイルっぽいファイルはスキップするようになっています。</p>\n\n<h2>やりたいこと</h2>\n\n<p>最終目標として <code>crepe</code> は <a href=\"https://github.com/peco/peco\">peco</a> のような interactive な検索を実装してみたいなと思っています。<br/>\n<code>ag</code> と <code>peco</code> の組み合わせで云々みたいな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\">ユースケース</a>が割りとあるなぁと思ったので。<br/>\nただこれメモリ使用量とか速度上の制約からまともに働くのかはよくわかっていません。<br/>\n単純に考えると、ユーザが一文字入力するたびにファイルの read からやり直す必要があるので...<br/>\n入力ファイルが多すぎた場合にどこまでキャッシュするのかとかその辺を相当うまくやらないと死ぬのでは？という気がします。</p>\n\n<p>短期的な目標としては</p>\n\n<ul>\n<li>.gitignore 対応 (意外とめっちゃ面倒で苦しんでいます)</li>\n<li>fuzzy マッチ</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%C9%BD%B8%BD\">正規表現</a>マッチ</li>\n</ul>\n\n<p>あたりから順にやっていきたいなと思っています。とりあえずこっちからやろうかなと思います。</p>\n\n<p>というわけで気合を入れる意味も込めて記事にしました。プルリクやフィードバック大歓迎なのでぜひよろしくお願いします。</p>\n\n---\n\nCOMMENT:\nAUTHOR: smaranrebub\nEMAIL: ruysqucp@gmail.com\nURL: http://cialisvipsale.com\nIP: 200.26.168.127\nDATE: 03/24/2018 15:30:29\n\nVery good info, Thanks!\nwalgreens price for cialis <a href=\"http://cialisvipsale.com\">buy brand cialis cheap</a>\nprices on cialis 10 mg <a href=\"http://cialisvipsale.com\">http://cialisvipsale.com</a>\nacheter du cialis a geneve <a href=\"http://cialisvipsale.com\">effetti del cialis</a>\nprices for cialis 50mg\n\n---\n\n---\n","slug":"再帰的_grep_ツール_crepe_を作っています","title":"再帰的 grep ツール crepe を作っています","timestamp":1467992175000,"tags":[]},{"rawMarkdown":"---\ntitle: \"C++ で result 型を作る\"\ndate: 2016-07-01T14:30:09.000Z\ntags: []\n---\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> や Rust など多くの強力な型システムを持つ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語</a>は、<code>Either</code> とか <code>Result</code> といった「失敗するかもしれない」計算の値を示す型を持っています。</p>\n\n<p>現在の <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の標準ライブラリにはこのような型はありませんので、それを自作してみようというわけです。</p>\n\n<p>ちなみに現在策定中の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>17には <code>std::optional</code> が入ることが決定しているようです。これは、<code>result</code> と同様に失敗するかもしれな値を示しますが、失敗した原因がなんなのかを通知する仕組みを持っていません。</p>\n\n<h2>そもそもどういう型か</h2>\n\n<p>Rust の <code>Result</code> 型を例にみてみます。</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">enum</span> <span class=\"synIdentifier\">Result</span><span class=\"synStatement\">&lt;</span>V, E<span class=\"synStatement\">&gt;</span> {\n  <span class=\"synConstant\">Ok</span>(V),\n  <span class=\"synConstant\">Err</span>(E),\n}\n</pre>\n\n<p>Rust における <code>Result</code> 型はだいたいこんな感じで定義されています。</p>\n\n<p><code>Result</code> は型引数を２つとります。<code>V</code> が成功時の値で、<code>E</code> が失敗時のエラー情報です。\n例えば、<code>fn parse_int(s: &amp;str) -&gt; Result&lt;isize, String&gt;;</code> は、文字列を受け取り、それが整数としてパース出来れば <code>isize</code> に変換し、<code>Ok(isize)</code> として返します。\nもし整数としてパース出来ないなどのエラーがあれば、それを <code>String</code> で表現し、<code>Err(String)</code> で返します。</p>\n\n<p>本質的にはこれが全てです。ここに、<code>Result</code> から中身を取り出す(<code>Err</code> なら <code>panic</code> する)関数などを定義してあげれば便利にエラー状態を表現できます。<br/>\n(Rust の <code>try</code> マクロはとても便利ですよね)</p>\n\n<h2>まずはベースとなる result を作る</h2>\n\n<p>まずはベースとなる <code>result</code> 型を作ってみます。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T, <span class=\"synType\">typename</span> E&gt;\n<span class=\"synType\">struct</span> result {\n\n  result(T <span class=\"synType\">const</span>&amp; ok) : t(tag::OK) {\n    ok_ = ok;\n  }\n\n  result(E <span class=\"synType\">const</span>&amp; e) : t(tag::OK) {\n    err_ = e;\n  }\n\n  ~result() {\n    <span class=\"synStatement\">switch</span> (t) {\n      <span class=\"synStatement\">case</span> tag::OK:\n        ok_.~T();\n        <span class=\"synStatement\">break</span>;\n      <span class=\"synStatement\">case</span> tag::ERROR:\n        err_.~E();\n        <span class=\"synStatement\">break</span>;\n    }\n  }\n\n  result(result <span class=\"synType\">const</span>&amp; r): t(r.t) {\n    <span class=\"synStatement\">switch</span> (t) {\n      <span class=\"synStatement\">case</span> tag::OK:\n        ok_ = r.ok_;\n        <span class=\"synStatement\">break</span>;\n      <span class=\"synStatement\">case</span> tag::ERROR:\n        err_ = r.err_;\n        <span class=\"synStatement\">break</span>;\n    }\n  }\n\n  T <span class=\"synType\">const</span>&amp; get() <span class=\"synType\">const</span> {\n    <span class=\"synStatement\">if</span> (t != tag::OK) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;invalid get operation&quot;</span>;\n    }\n    <span class=\"synStatement\">return</span> ok_;\n  }\n\n  E <span class=\"synType\">const</span>&amp; get_error() <span class=\"synType\">const</span> {\n    <span class=\"synStatement\">if</span> (t != tag::ERROR) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;invalid get operation&quot;</span>;\n    }\n    <span class=\"synStatement\">return</span> err_;\n  }\n\n<span class=\"synStatement\">private</span>:\n  <span class=\"synType\">enum</span> <span class=\"synType\">class</span> tag {\n    OK,\n    ERROR,\n  };\n  tag t;\n  <span class=\"synType\">union</span> {\n    T ok_;\n    E err_;\n  };\n\n};\n</pre>\n\n<p>かなり雑ですが、ざっくりこんな感じになるはずです。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>11 から拡張されて自由度がかなり高くなった <code>union</code> がとても便利です。</p>\n\n<p>これで <code>result&lt;int, std::string&gt;(1).get()</code> とやれば <code>1</code> が返るし <code>result&lt;int, std::string&gt;(std::string(\"test\")).get_error()</code> で <code>\"test\"</code> が返るはずです。</p>\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でやると何が難しいか</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> で難しいのは、Rustより弱い<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>が引き起こす問題です。<br/>\nRust では、<code>Ok(1isize)</code> とか <code>Err(\"error!\".to_owned())</code> とすれば、その値がどういう型であることが期待されているのかまで含めて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>や単一化が行われます。\nすなわち、<code>Ok(1isize)</code> だけを見てもエラーの型がわからないため、<code>Result&lt;isize, E&gt;</code> の <code>E</code> を決定することが出来ないが、Rust は強力な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>機構を持つため、これを決定することが出来ます。</p>\n\n<p>一方、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> では <code>result&lt;int, std::string&gt; f() { return 1; }</code> は <code>int</code> から <code>result&lt;int, std::string&gt;</code> の暗黙変換がきくので可能ですが、<code>result&lt;int, int&gt;</code> などとした瞬間、暗黙変換に頼ることはできなくなります。\nそこで、出来れば <code>ok(1)</code> とか <code>err(\"test\")</code> という感じにしたいのですが、これは一筋縄では行きません。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T, <span class=\"synType\">typename</span> E&gt; \nresult&lt;T, E&gt; ok(T);\n</pre>\n\n<p>これだと <code>T</code> は推論されても <code>E</code> が推論されないので、<code>ok&lt;int, std::string&gt;(1)</code> などとしなければなりません。これは使いづらすぎます。</p>\n\n<h2>じゃあどうするか</h2>\n\n<p>先ほどとは違う形ですが、やっぱり暗黙の型変換を応用します。</p>\n\n<p>要するに <code>ok</code> を表す型と <code>error</code> を表す型を区別しつつ、<code>result&lt;V, E&gt;</code> とはなるべくシームレスに変換をしたいというわけですから、それぞれ専用の型を作ってしまえば良いのです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">struct</span> ok_value {\n  <span class=\"synType\">explicit</span> ok_value(T t): t(t) {}\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> V, <span class=\"synType\">typename</span> E&gt;\n  <span class=\"synStatement\">operator</span> result&lt;V, E&gt; () <span class=\"synType\">const</span>;\n\n<span class=\"synStatement\">private</span>:\n  T t;\n};\n\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> V, <span class=\"synType\">typename</span> E&gt;\nok_value&lt;T&gt;::<span class=\"synStatement\">operator</span> result&lt;V, E&gt; () <span class=\"synType\">const</span> {\n  <span class=\"synStatement\">return</span> result&lt;V, E&gt;(t);\n}\n\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\nok_value&lt;T&gt; ok(T t) {\n  <span class=\"synStatement\">return</span> ok_value&lt;T&gt;(t);\n}\n</pre>\n\n<p><code>ok</code> 側だけ示しました。<br/>\n<code>ok</code> 関数はテンプレートになっており、<code>T</code> 型の値をとって <code>ok_value&lt;T&gt;</code> を返します。（本当は値渡し以外にも対応すべきですが、簡単のために値渡しだけ実装しています）</p>\n\n<p><code>ok_value&lt;T&gt;</code> は型変換<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\">演算子</a> <code>operator result&lt;V, E&gt;() const</code> を持ちます。これによって <code>ok_value</code> から <code>result</code> への暗黙変換が可能になります。</p>\n\n<p><code>ok_value&lt;T&gt;</code> は <code>result&lt;T, E&gt;</code> に変換出来れば良さそうに見えるのですが、それでは不十分です。<br/>\n<code>ok(\"test\")</code> は <code>ok_value&lt;const char*&gt;</code> を返します。<code>ok_value&lt;T&gt; -&gt; result&lt;T, E&gt;</code> の変換しか提供していない場合は、<code>result&lt;std::string, E&gt;</code> への変換ができなくなってしまいます。これは不便ですよね。<br/>\nそこで新たにテンプレート引数を導入することでこれを解決しています。もっときちんとやるなら <code>std::is_constructible</code> などを使ってチェックをするべきだとは思いますが。</p>\n\n<p><code>error</code> 側もほぼ同様のコードを書いてやれば、</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>result&lt;<span class=\"synType\">int</span>, std::string&gt; parse_digit(<span class=\"synType\">char</span> c) {\n  <span class=\"synStatement\">if</span> (c &lt; <span class=\"synConstant\">'0'</span> || <span class=\"synConstant\">'9'</span> &lt; c) {\n    <span class=\"synStatement\">return</span> error(<span class=\"synConstant\">&quot;invalid character&quot;</span>);\n  }\n  <span class=\"synStatement\">return</span> ok(c - <span class=\"synConstant\">'0'</span>);\n}\n</pre>\n\n<p>というように書けます。</p>\n\n<h2>まとめ</h2>\n\n<p><code>T</code> から <code>result&lt;T, E&gt;</code> への暗黙変換を許すという方針も全然ありだとは思いますが、個人的に Rust などで <code>ok</code> なら <code>ok</code> と明示するスタイルに慣れているので、こっちのほうが気に入っています。<br/>\n明らかに正常に値を返していそうな感じがコードにあらわれて好きです。</p>\n\n<p>暗黙の型変換って危険だしあまり良いイメージはないと思うのですが、やっぱりあれば便利ですね。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> を使っている時点で気を抜いたら死なので、「取り扱いを把握して全力で注意しながら使えば危険じゃない」という気持ちで便利に使いたいものです。</p>\n\n---\n\n---\n","contentMarkdown":"\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> や Rust など多くの強力な型システムを持つ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語</a>は、<code>Either</code> とか <code>Result</code> といった「失敗するかもしれない」計算の値を示す型を持っています。</p>\n\n<p>現在の <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の標準ライブラリにはこのような型はありませんので、それを自作してみようというわけです。</p>\n\n<p>ちなみに現在策定中の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>17には <code>std::optional</code> が入ることが決定しているようです。これは、<code>result</code> と同様に失敗するかもしれな値を示しますが、失敗した原因がなんなのかを通知する仕組みを持っていません。</p>\n\n<h2>そもそもどういう型か</h2>\n\n<p>Rust の <code>Result</code> 型を例にみてみます。</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">enum</span> <span class=\"synIdentifier\">Result</span><span class=\"synStatement\">&lt;</span>V, E<span class=\"synStatement\">&gt;</span> {\n  <span class=\"synConstant\">Ok</span>(V),\n  <span class=\"synConstant\">Err</span>(E),\n}\n</pre>\n\n<p>Rust における <code>Result</code> 型はだいたいこんな感じで定義されています。</p>\n\n<p><code>Result</code> は型引数を２つとります。<code>V</code> が成功時の値で、<code>E</code> が失敗時のエラー情報です。\n例えば、<code>fn parse_int(s: &amp;str) -&gt; Result&lt;isize, String&gt;;</code> は、文字列を受け取り、それが整数としてパース出来れば <code>isize</code> に変換し、<code>Ok(isize)</code> として返します。\nもし整数としてパース出来ないなどのエラーがあれば、それを <code>String</code> で表現し、<code>Err(String)</code> で返します。</p>\n\n<p>本質的にはこれが全てです。ここに、<code>Result</code> から中身を取り出す(<code>Err</code> なら <code>panic</code> する)関数などを定義してあげれば便利にエラー状態を表現できます。<br/>\n(Rust の <code>try</code> マクロはとても便利ですよね)</p>\n\n<h2>まずはベースとなる result を作る</h2>\n\n<p>まずはベースとなる <code>result</code> 型を作ってみます。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T, <span class=\"synType\">typename</span> E&gt;\n<span class=\"synType\">struct</span> result {\n\n  result(T <span class=\"synType\">const</span>&amp; ok) : t(tag::OK) {\n    ok_ = ok;\n  }\n\n  result(E <span class=\"synType\">const</span>&amp; e) : t(tag::OK) {\n    err_ = e;\n  }\n\n  ~result() {\n    <span class=\"synStatement\">switch</span> (t) {\n      <span class=\"synStatement\">case</span> tag::OK:\n        ok_.~T();\n        <span class=\"synStatement\">break</span>;\n      <span class=\"synStatement\">case</span> tag::ERROR:\n        err_.~E();\n        <span class=\"synStatement\">break</span>;\n    }\n  }\n\n  result(result <span class=\"synType\">const</span>&amp; r): t(r.t) {\n    <span class=\"synStatement\">switch</span> (t) {\n      <span class=\"synStatement\">case</span> tag::OK:\n        ok_ = r.ok_;\n        <span class=\"synStatement\">break</span>;\n      <span class=\"synStatement\">case</span> tag::ERROR:\n        err_ = r.err_;\n        <span class=\"synStatement\">break</span>;\n    }\n  }\n\n  T <span class=\"synType\">const</span>&amp; get() <span class=\"synType\">const</span> {\n    <span class=\"synStatement\">if</span> (t != tag::OK) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;invalid get operation&quot;</span>;\n    }\n    <span class=\"synStatement\">return</span> ok_;\n  }\n\n  E <span class=\"synType\">const</span>&amp; get_error() <span class=\"synType\">const</span> {\n    <span class=\"synStatement\">if</span> (t != tag::ERROR) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;invalid get operation&quot;</span>;\n    }\n    <span class=\"synStatement\">return</span> err_;\n  }\n\n<span class=\"synStatement\">private</span>:\n  <span class=\"synType\">enum</span> <span class=\"synType\">class</span> tag {\n    OK,\n    ERROR,\n  };\n  tag t;\n  <span class=\"synType\">union</span> {\n    T ok_;\n    E err_;\n  };\n\n};\n</pre>\n\n<p>かなり雑ですが、ざっくりこんな感じになるはずです。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>11 から拡張されて自由度がかなり高くなった <code>union</code> がとても便利です。</p>\n\n<p>これで <code>result&lt;int, std::string&gt;(1).get()</code> とやれば <code>1</code> が返るし <code>result&lt;int, std::string&gt;(std::string(\"test\")).get_error()</code> で <code>\"test\"</code> が返るはずです。</p>\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でやると何が難しいか</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> で難しいのは、Rustより弱い<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>が引き起こす問題です。<br/>\nRust では、<code>Ok(1isize)</code> とか <code>Err(\"error!\".to_owned())</code> とすれば、その値がどういう型であることが期待されているのかまで含めて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>や単一化が行われます。\nすなわち、<code>Ok(1isize)</code> だけを見てもエラーの型がわからないため、<code>Result&lt;isize, E&gt;</code> の <code>E</code> を決定することが出来ないが、Rust は強力な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>機構を持つため、これを決定することが出来ます。</p>\n\n<p>一方、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> では <code>result&lt;int, std::string&gt; f() { return 1; }</code> は <code>int</code> から <code>result&lt;int, std::string&gt;</code> の暗黙変換がきくので可能ですが、<code>result&lt;int, int&gt;</code> などとした瞬間、暗黙変換に頼ることはできなくなります。\nそこで、出来れば <code>ok(1)</code> とか <code>err(\"test\")</code> という感じにしたいのですが、これは一筋縄では行きません。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T, <span class=\"synType\">typename</span> E&gt; \nresult&lt;T, E&gt; ok(T);\n</pre>\n\n<p>これだと <code>T</code> は推論されても <code>E</code> が推論されないので、<code>ok&lt;int, std::string&gt;(1)</code> などとしなければなりません。これは使いづらすぎます。</p>\n\n<h2>じゃあどうするか</h2>\n\n<p>先ほどとは違う形ですが、やっぱり暗黙の型変換を応用します。</p>\n\n<p>要するに <code>ok</code> を表す型と <code>error</code> を表す型を区別しつつ、<code>result&lt;V, E&gt;</code> とはなるべくシームレスに変換をしたいというわけですから、それぞれ専用の型を作ってしまえば良いのです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">struct</span> ok_value {\n  <span class=\"synType\">explicit</span> ok_value(T t): t(t) {}\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> V, <span class=\"synType\">typename</span> E&gt;\n  <span class=\"synStatement\">operator</span> result&lt;V, E&gt; () <span class=\"synType\">const</span>;\n\n<span class=\"synStatement\">private</span>:\n  T t;\n};\n\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> V, <span class=\"synType\">typename</span> E&gt;\nok_value&lt;T&gt;::<span class=\"synStatement\">operator</span> result&lt;V, E&gt; () <span class=\"synType\">const</span> {\n  <span class=\"synStatement\">return</span> result&lt;V, E&gt;(t);\n}\n\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\nok_value&lt;T&gt; ok(T t) {\n  <span class=\"synStatement\">return</span> ok_value&lt;T&gt;(t);\n}\n</pre>\n\n<p><code>ok</code> 側だけ示しました。<br/>\n<code>ok</code> 関数はテンプレートになっており、<code>T</code> 型の値をとって <code>ok_value&lt;T&gt;</code> を返します。（本当は値渡し以外にも対応すべきですが、簡単のために値渡しだけ実装しています）</p>\n\n<p><code>ok_value&lt;T&gt;</code> は型変換<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\">演算子</a> <code>operator result&lt;V, E&gt;() const</code> を持ちます。これによって <code>ok_value</code> から <code>result</code> への暗黙変換が可能になります。</p>\n\n<p><code>ok_value&lt;T&gt;</code> は <code>result&lt;T, E&gt;</code> に変換出来れば良さそうに見えるのですが、それでは不十分です。<br/>\n<code>ok(\"test\")</code> は <code>ok_value&lt;const char*&gt;</code> を返します。<code>ok_value&lt;T&gt; -&gt; result&lt;T, E&gt;</code> の変換しか提供していない場合は、<code>result&lt;std::string, E&gt;</code> への変換ができなくなってしまいます。これは不便ですよね。<br/>\nそこで新たにテンプレート引数を導入することでこれを解決しています。もっときちんとやるなら <code>std::is_constructible</code> などを使ってチェックをするべきだとは思いますが。</p>\n\n<p><code>error</code> 側もほぼ同様のコードを書いてやれば、</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>result&lt;<span class=\"synType\">int</span>, std::string&gt; parse_digit(<span class=\"synType\">char</span> c) {\n  <span class=\"synStatement\">if</span> (c &lt; <span class=\"synConstant\">'0'</span> || <span class=\"synConstant\">'9'</span> &lt; c) {\n    <span class=\"synStatement\">return</span> error(<span class=\"synConstant\">&quot;invalid character&quot;</span>);\n  }\n  <span class=\"synStatement\">return</span> ok(c - <span class=\"synConstant\">'0'</span>);\n}\n</pre>\n\n<p>というように書けます。</p>\n\n<h2>まとめ</h2>\n\n<p><code>T</code> から <code>result&lt;T, E&gt;</code> への暗黙変換を許すという方針も全然ありだとは思いますが、個人的に Rust などで <code>ok</code> なら <code>ok</code> と明示するスタイルに慣れているので、こっちのほうが気に入っています。<br/>\n明らかに正常に値を返していそうな感じがコードにあらわれて好きです。</p>\n\n<p>暗黙の型変換って危険だしあまり良いイメージはないと思うのですが、やっぱりあれば便利ですね。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> を使っている時点で気を抜いたら死なので、「取り扱いを把握して全力で注意しながら使えば危険じゃない」という気持ちで便利に使いたいものです。</p>\n\n---\n\n---\n","slug":"C++_で_result_型を作る","title":"C++ で result 型を作る","timestamp":1467383409000,"tags":[]},{"rawMarkdown":"---\ntitle: \"C++テンプレートイディオム CRTP\"\ndate: 2016-06-16T10:27:08.000Z\ntags: []\n---\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>テンプレートの有名なイディオムとして、CRTPというものがあります。\n今回はそれについて。\n複雑な部分特殊化みたいな話もないですし、メリットもわかりやすい良いイディオムだと思うので、ちょっとまとめておきます。\n(Control キーのことをよく CTRL と書くので、CTRP とタイポしがち）</p>\n\n<p>詳細はこちらを参照してください。\n<a href=\"https://ja.wikibooks.org/wiki/More_C%2B%2B_Idioms/%E5%A5%87%E5%A6%99%E3%81%AB%E5%86%8D%E5%B8%B0%E3%81%97%E3%81%9F%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3(Curiously_Recurring_Template_Pattern\">More C++ Idioms/奇妙に再帰したテンプレートパターン(Curiously Recurring Template Pattern) - Wikibooks</a>)</p>\n\n<h2>CRTPの利点</h2>\n\n<p>細かい実装の話の前に、CRTPを使うと何がうれしいのかを簡単に。</p>\n\n<p><strong>静的 Template Method パターンの実現</strong>_ 。これがCRTPの利点です。</p>\n\n<p>Template Method パターンについてはここでは説明しませんが、大枠の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\">アルゴリズム</a>を共有しつつその内部で使用する実装の詳細をクラスごとに切り替えるといった目的に使われる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%B6%A5%A4%A5%F3%A5%D1%A5%BF%A1%BC%A5%F3\">デザインパターン</a>です。</p>\n\n<p>通常 Template Method パターンを <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> で実現しようと思うとどうしても仮想関数を使うことになると思います。これによって実行時のオーバヘッドがかかってしまいます。\nTemplate Method パターンは、いわゆるクラスベースの動的な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DD%A5%EA%A5%E2%A1%BC%A5%D5%A5%A3%A5%BA%A5%E0\">ポリモーフィズム</a>を必要としないクラスであっても、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\">アルゴリズム</a>の共有やボイラープレートコードの削減に非常に有用なパターンです。\nこれを静的に実現するのが CRTP の目的なのです。</p>\n\n<h2>実装</h2>\n\n<p>CRTP とは、その名の通り、奇妙に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>したテンプレートのパターンのことです。\n情報量０の文章ですね。実際のコードも見たほうがわかりやすいと思います。</p>\n\n<p>以下に、<code>compare</code> というメソッドから比較<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\">演算子</a>を <em>derive</em> (自動導出) する例をのせます。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">struct</span> comparable {\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> U&gt;\n  <span class=\"synStatement\">friend</span> <span class=\"synType\">bool</span> <span class=\"synStatement\">operator</span>==(comparable <span class=\"synType\">const</span>&amp; lhs, U <span class=\"synType\">const</span>&amp; rhs) {\n    <span class=\"synStatement\">return</span> <span class=\"synStatement\">static_cast</span>&lt;T <span class=\"synType\">const</span>&amp;&gt;(lhs).compare(rhs) == <span class=\"synConstant\">0</span>;\n  }\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> U&gt;\n  <span class=\"synStatement\">friend</span> <span class=\"synType\">bool</span> <span class=\"synStatement\">operator</span>&gt;(comparable <span class=\"synType\">const</span>&amp; lhs, U <span class=\"synType\">const</span>&amp; rhs) {\n    <span class=\"synStatement\">return</span> <span class=\"synStatement\">static_cast</span>&lt;T <span class=\"synType\">const</span>&amp;&gt;(lhs).compare(rhs) &gt; <span class=\"synConstant\">0</span>;\n  }\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> U&gt;\n  <span class=\"synStatement\">friend</span> <span class=\"synType\">bool</span> <span class=\"synStatement\">operator</span>&lt;(comparable <span class=\"synType\">const</span>&amp; lhs, U <span class=\"synType\">const</span>&amp; rhs) {\n    <span class=\"synStatement\">return</span> <span class=\"synStatement\">static_cast</span>&lt;T <span class=\"synType\">const</span>&amp;&gt;(lhs).compare(rhs) &lt; <span class=\"synConstant\">0</span>;\n  }\n};\n\n<span class=\"synType\">struct</span> person : comparable&lt;person&gt; {\n  <span class=\"synType\">int</span> age;\n\n  <span class=\"synType\">int</span> compare(person <span class=\"synType\">const</span>&amp; rhs) <span class=\"synType\">const</span> {\n    <span class=\"synStatement\">return</span> age - rhs.age;\n  }\n};\n\n<span class=\"synType\">int</span> main() {\n  person p1, p2;\n  p1.age = <span class=\"synConstant\">10</span>;\n  p2.age = <span class=\"synConstant\">100</span>;\n\n  std::cout &lt;&lt; std::boolalpha &lt;&lt; (p1 == p2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; std::boolalpha &lt;&lt; (p1 &lt; p2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; std::boolalpha &lt;&lt; (p1 &gt; p2) &lt;&lt; std::endl;\n}\n</pre>\n\n<p><code>person</code> クラスには <code>operator==</code> など定義していないにもかかわらず、<code>person</code> を比較することが出来ています。</p>\n\n<p>CRTPの中心となるのは <code>struct person : comparable&lt;person&gt;</code> という部分です。\nクラスを定義する際に、自分をテンプレート引数にとるクラスを継承するというコード、これこそが「奇妙な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>」なのです。\n実際、<code>struct person : comparable&lt;person&gt;</code> の部分ではまだ <code>person</code> がどんな実装になるかはわかっていません。奇妙ですね。</p>\n\n<p>さて、まずは <code>person</code> の中身を見てみます。\n<code>person</code> では、<code>person const&amp;</code> を引数にとり、それが自分より大きければ正の値を、小さければ負の値を、等しければ0を返すような、<code>compare</code> というメソッドを定義しています。\n<code>person</code> の仕事はこれだけです。</p>\n\n<p><code>comparable</code> は、テンプレート引数にひとつの型をとります。<br/>\n<code>comparable</code> はその型が <code>compare</code> というメソッドをもつことを期待しています。(暗黙のインターフェース)<br/>\n<code>comparable</code> の仕事は <code>compare</code> というひとつのメソッドから、<code>operator==</code>, <code>operator&lt;</code>, <code>operator&gt;</code> を自動的に導くことです。<br/>\nTemplate Methodパターンをご存じの方ならすんなり理解できるかと思います。</p>\n\n<p>CRTP のすごいところは、仮想関数をまったく使わないことです。つまり、実行時のテーブルルックアップは発生しません。すべてが静的に決定されるのです。</p>\n\n<h2>おまけ</h2>\n\n<p>先に挙げた <code>compare</code> から <code>operator==</code> を自動導出する例ですが、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> の <code>Ord</code> 型クラスを意識しています。</p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink><span class=\"synType\">class</span> Eq a <span class=\"synStatement\">=&gt;</span> Ord a <span class=\"synType\">where</span>\n  compare <span class=\"synStatement\">::</span> a <span class=\"synStatement\">-&gt;</span> a <span class=\"synStatement\">-&gt;</span> Ordering\n  (<span class=\"synStatement\">&lt;</span>), (<span class=\"synStatement\">&lt;=</span>), (<span class=\"synStatement\">&gt;</span>), (<span class=\"synStatement\">&lt;=</span>) <span class=\"synStatement\">::</span> a <span class=\"synStatement\">-&gt;</span> a <span class=\"synStatement\">-&gt;</span> Bool\n  max, min <span class=\"synStatement\">::</span> a <span class=\"synStatement\">-&gt;</span> a <span class=\"synStatement\">-&gt;</span> a\n</pre>\n\n<p><code>Ord</code> 型クラスの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>になるためには、最低でも <code>compare</code> を実装している必要があります。\n逆にいえば、<code>compare</code> だけ実装すれば、他の関数は自動的に実装されます。</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> では、<code>Ord</code> になるためには <code>Eq</code> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>である必要があります。\nこれを <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> で表現するためには、</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">struct</span> ord : eq&lt;T&gt; {\n  ...\n};\n</pre>\n\n<p>こんな感じでしょうか。もちろん型クラスの代替にはなりえないんですけどね。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> の型クラスの利点のひとつである、最小限のインターフェース実装による関数の自動導出っぽいこともできるよというお話でした。</p>\n\n<p>実際にテンプレートライブラリを書いてみて改めて有用性がわかったテクニックでした。\n拙作の coco にも導入したい... すべてのパーサにユーティリティ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>を追加するみたいなことが出来るはず... いつかやります。</p>\n\n---\n\n---\n","contentMarkdown":"\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>テンプレートの有名なイディオムとして、CRTPというものがあります。\n今回はそれについて。\n複雑な部分特殊化みたいな話もないですし、メリットもわかりやすい良いイディオムだと思うので、ちょっとまとめておきます。\n(Control キーのことをよく CTRL と書くので、CTRP とタイポしがち）</p>\n\n<p>詳細はこちらを参照してください。\n<a href=\"https://ja.wikibooks.org/wiki/More_C%2B%2B_Idioms/%E5%A5%87%E5%A6%99%E3%81%AB%E5%86%8D%E5%B8%B0%E3%81%97%E3%81%9F%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3(Curiously_Recurring_Template_Pattern\">More C++ Idioms/奇妙に再帰したテンプレートパターン(Curiously Recurring Template Pattern) - Wikibooks</a>)</p>\n\n<h2>CRTPの利点</h2>\n\n<p>細かい実装の話の前に、CRTPを使うと何がうれしいのかを簡単に。</p>\n\n<p><strong>静的 Template Method パターンの実現</strong>_ 。これがCRTPの利点です。</p>\n\n<p>Template Method パターンについてはここでは説明しませんが、大枠の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\">アルゴリズム</a>を共有しつつその内部で使用する実装の詳細をクラスごとに切り替えるといった目的に使われる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%B6%A5%A4%A5%F3%A5%D1%A5%BF%A1%BC%A5%F3\">デザインパターン</a>です。</p>\n\n<p>通常 Template Method パターンを <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> で実現しようと思うとどうしても仮想関数を使うことになると思います。これによって実行時のオーバヘッドがかかってしまいます。\nTemplate Method パターンは、いわゆるクラスベースの動的な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DD%A5%EA%A5%E2%A1%BC%A5%D5%A5%A3%A5%BA%A5%E0\">ポリモーフィズム</a>を必要としないクラスであっても、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\">アルゴリズム</a>の共有やボイラープレートコードの削減に非常に有用なパターンです。\nこれを静的に実現するのが CRTP の目的なのです。</p>\n\n<h2>実装</h2>\n\n<p>CRTP とは、その名の通り、奇妙に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>したテンプレートのパターンのことです。\n情報量０の文章ですね。実際のコードも見たほうがわかりやすいと思います。</p>\n\n<p>以下に、<code>compare</code> というメソッドから比較<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\">演算子</a>を <em>derive</em> (自動導出) する例をのせます。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">struct</span> comparable {\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> U&gt;\n  <span class=\"synStatement\">friend</span> <span class=\"synType\">bool</span> <span class=\"synStatement\">operator</span>==(comparable <span class=\"synType\">const</span>&amp; lhs, U <span class=\"synType\">const</span>&amp; rhs) {\n    <span class=\"synStatement\">return</span> <span class=\"synStatement\">static_cast</span>&lt;T <span class=\"synType\">const</span>&amp;&gt;(lhs).compare(rhs) == <span class=\"synConstant\">0</span>;\n  }\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> U&gt;\n  <span class=\"synStatement\">friend</span> <span class=\"synType\">bool</span> <span class=\"synStatement\">operator</span>&gt;(comparable <span class=\"synType\">const</span>&amp; lhs, U <span class=\"synType\">const</span>&amp; rhs) {\n    <span class=\"synStatement\">return</span> <span class=\"synStatement\">static_cast</span>&lt;T <span class=\"synType\">const</span>&amp;&gt;(lhs).compare(rhs) &gt; <span class=\"synConstant\">0</span>;\n  }\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> U&gt;\n  <span class=\"synStatement\">friend</span> <span class=\"synType\">bool</span> <span class=\"synStatement\">operator</span>&lt;(comparable <span class=\"synType\">const</span>&amp; lhs, U <span class=\"synType\">const</span>&amp; rhs) {\n    <span class=\"synStatement\">return</span> <span class=\"synStatement\">static_cast</span>&lt;T <span class=\"synType\">const</span>&amp;&gt;(lhs).compare(rhs) &lt; <span class=\"synConstant\">0</span>;\n  }\n};\n\n<span class=\"synType\">struct</span> person : comparable&lt;person&gt; {\n  <span class=\"synType\">int</span> age;\n\n  <span class=\"synType\">int</span> compare(person <span class=\"synType\">const</span>&amp; rhs) <span class=\"synType\">const</span> {\n    <span class=\"synStatement\">return</span> age - rhs.age;\n  }\n};\n\n<span class=\"synType\">int</span> main() {\n  person p1, p2;\n  p1.age = <span class=\"synConstant\">10</span>;\n  p2.age = <span class=\"synConstant\">100</span>;\n\n  std::cout &lt;&lt; std::boolalpha &lt;&lt; (p1 == p2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; std::boolalpha &lt;&lt; (p1 &lt; p2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; std::boolalpha &lt;&lt; (p1 &gt; p2) &lt;&lt; std::endl;\n}\n</pre>\n\n<p><code>person</code> クラスには <code>operator==</code> など定義していないにもかかわらず、<code>person</code> を比較することが出来ています。</p>\n\n<p>CRTPの中心となるのは <code>struct person : comparable&lt;person&gt;</code> という部分です。\nクラスを定義する際に、自分をテンプレート引数にとるクラスを継承するというコード、これこそが「奇妙な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>」なのです。\n実際、<code>struct person : comparable&lt;person&gt;</code> の部分ではまだ <code>person</code> がどんな実装になるかはわかっていません。奇妙ですね。</p>\n\n<p>さて、まずは <code>person</code> の中身を見てみます。\n<code>person</code> では、<code>person const&amp;</code> を引数にとり、それが自分より大きければ正の値を、小さければ負の値を、等しければ0を返すような、<code>compare</code> というメソッドを定義しています。\n<code>person</code> の仕事はこれだけです。</p>\n\n<p><code>comparable</code> は、テンプレート引数にひとつの型をとります。<br/>\n<code>comparable</code> はその型が <code>compare</code> というメソッドをもつことを期待しています。(暗黙のインターフェース)<br/>\n<code>comparable</code> の仕事は <code>compare</code> というひとつのメソッドから、<code>operator==</code>, <code>operator&lt;</code>, <code>operator&gt;</code> を自動的に導くことです。<br/>\nTemplate Methodパターンをご存じの方ならすんなり理解できるかと思います。</p>\n\n<p>CRTP のすごいところは、仮想関数をまったく使わないことです。つまり、実行時のテーブルルックアップは発生しません。すべてが静的に決定されるのです。</p>\n\n<h2>おまけ</h2>\n\n<p>先に挙げた <code>compare</code> から <code>operator==</code> を自動導出する例ですが、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> の <code>Ord</code> 型クラスを意識しています。</p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink><span class=\"synType\">class</span> Eq a <span class=\"synStatement\">=&gt;</span> Ord a <span class=\"synType\">where</span>\n  compare <span class=\"synStatement\">::</span> a <span class=\"synStatement\">-&gt;</span> a <span class=\"synStatement\">-&gt;</span> Ordering\n  (<span class=\"synStatement\">&lt;</span>), (<span class=\"synStatement\">&lt;=</span>), (<span class=\"synStatement\">&gt;</span>), (<span class=\"synStatement\">&lt;=</span>) <span class=\"synStatement\">::</span> a <span class=\"synStatement\">-&gt;</span> a <span class=\"synStatement\">-&gt;</span> Bool\n  max, min <span class=\"synStatement\">::</span> a <span class=\"synStatement\">-&gt;</span> a <span class=\"synStatement\">-&gt;</span> a\n</pre>\n\n<p><code>Ord</code> 型クラスの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>になるためには、最低でも <code>compare</code> を実装している必要があります。\n逆にいえば、<code>compare</code> だけ実装すれば、他の関数は自動的に実装されます。</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> では、<code>Ord</code> になるためには <code>Eq</code> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>である必要があります。\nこれを <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> で表現するためには、</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">struct</span> ord : eq&lt;T&gt; {\n  ...\n};\n</pre>\n\n<p>こんな感じでしょうか。もちろん型クラスの代替にはなりえないんですけどね。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> の型クラスの利点のひとつである、最小限のインターフェース実装による関数の自動導出っぽいこともできるよというお話でした。</p>\n\n<p>実際にテンプレートライブラリを書いてみて改めて有用性がわかったテクニックでした。\n拙作の coco にも導入したい... すべてのパーサにユーティリティ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>を追加するみたいなことが出来るはず... いつかやります。</p>\n\n---\n\n---\n","slug":"C++テンプレートイディオム_CRTP","title":"C++テンプレートイディオム CRTP","timestamp":1466072828000,"tags":[]},{"rawMarkdown":"---\ntitle: \"C++ のテンプレートの実装\"\ndate: 2016-06-13T07:59:27.000Z\ntags: []\n---\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のテンプレートがなぜ必要で，どんな構文・種類のものがあるかについては前回までにまとめました。<br/>\nというわけで次は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> ではテンプレートという機能を使用するとどんな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\">バイ</a>ナリが生成されるのかについて見ていきます。<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のテンプレートの強力さとか勘所みたいなものを把握するために非常に重要な部分なので、覚えておくとよいと思います。</p>\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でテンプレートを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>してみる</h2>\n\n<p>早速ですが、実際に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でテンプレートを使っているコードを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>してみます。<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%BB%A5%F3%A5%D6%A5%EA\">アセンブリ</a>よりも <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR のほうがわかりやすいかな？と思うので、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR を clang++ で生成させてみます。\n（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR については <a href=\"http://postd.cc/llvm-for-grad-students/\">大学院生のためのLLVM | インフラ・ミドルウェア | POSTD</a> あたりを読んでおくとなんとなく概念がつかめると思います。公式は<a href=\"http://llvm.org/docs/LangRef.html\">LLVM Language Reference Manual — LLVM 3.9 documentation</a>）</p>\n\n<p>対象となるコードはこちら。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synComment\">// main.cpp</span>\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\nT identity(T x) {\n  <span class=\"synStatement\">return</span> x;\n}\n\n<span class=\"synType\">int</span> main() {\n  <span class=\"synType\">float</span> f = <span class=\"synConstant\">0.0f</span>;\n  identity(f);\n\n  <span class=\"synType\">int</span> d = <span class=\"synConstant\">0</span>;\n  identity(d);\n  <span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;\n}\n</pre>\n\n<p>clang++ で <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR を生成させるには，<code>-S -emit-llvm</code> をオプションに指定します。また、今回のコードは最適化されてしまうとほとんどコードが残らないので、最適化を抑制するよう、<code>-O0</code> を付けます。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>$ clang++ -O0 -S -emit-llvm main.cpp</pre>\n\n<p>すると <code>main.ll</code> というファイルが出来ています。これが <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR です。</p>\n\n<h2>IR を読む</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR は，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> という<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>基盤技術における中間表現 (Intermediate Representation) です。<br/>\nざっくり言うと、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3\">アーキテクチャ</a>に依存しない、読みやすい<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%BB%A5%F3%A5%D6%A5%EA\">アセンブリ</a>です。</p>\n\n<p><code>main.ll</code> はそこまで長くないですが、エッセンスだけ抜粋します。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>define i32 @main() #0 { ;; main 関数\n  %1 = alloca i32, align 4\n  %f = alloca float, align 4\n  %d = alloca i32, align 4\n  store i32 0, i32* %1\n  store float 0.000000e+00, float* %f, align 4\n  %2 = load float* %f, align 4\n  %3 = call float @_Z8identityIfET_S0_(float %2)\n  store i32 0, i32* %d, align 4\n  %4 = load i32* %d, align 4\n  %5 = call i32 @_Z8identityIiET_S0_(i32 %4)\n  ret i32 0\n}\n\ndefine linkonce_odr float @_Z8identityIfET_S0_(float %x) #1 { ;; identity&lt;float&gt; の実体\n  %1 = alloca float, align 4\n  store float %x, float* %1, align 4\n  %2 = load float* %1, align 4\n  ret float %2\n}\n\ndefine linkonce_odr i32 @_Z8identityIiET_S0_(i32 %x) #1 { ;; identity&lt;int&gt; の実体\n  %1 = alloca i32, align 4\n  store i32 %x, i32* %1, align 4\n  %2 = load i32* %1, align 4\n  ret i32 %2\n}</pre>\n\n<p>コメントでも書きましたが、3 つの関数が定義されていることがわかると思います。\nここで重要なのは、 <strong>identity&lt;int>とidentity&lt;float>がそれぞれ別の関数として定義されている</strong> ことです。</p>\n\n<p><code>identity&lt;int&gt;</code> と <code>identity&lt;float&gt;</code> は <code>main</code> の中で使われています。<br/>\nつまり、テンプレートは、「使った分だけ実体が作られる。かつその処理は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時に終わる。」ということがわかります。<br/>\nたとえば<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>中に <code>identity&lt;bool&gt;</code> の実体化を要求するコードがあれば、その時はじめて <code>identity&lt;bool&gt;</code> が作られます。\n独自定義でも構いません。<code>identity&lt;MyClass&gt;</code> の実体化を要求するコードがあれば、その時はじめて <code>identity&lt;MyClass&gt;</code> が作られます。</p>\n\n<p>もちろん、一度実体化されたテンプレートは再利用されます。つまり、<code>identity&lt;int&gt;</code> を要求するコードが、一つの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>に何度現れても、ただひとつの <code>identity&lt;int&gt;</code> が生成されます。</p>\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> との比較</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> にも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>という仕組みがあります。<br/>\n概念的にはテンプレートに似たものなので、比較してみます (テンプレートの方がより強力ですが、型を汎用化したいという目的であれば、両者とも同様に使用できます。)</p>\n\n<p>同じようなコードを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>して<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\">バイトコード</a>を見てみます。</p>\n\n<pre class=\"code lang-java\" data-lang=\"java\" data-unlink><span class=\"synType\">class</span> Main {\n  <span class=\"synType\">static</span> &lt;T&gt; T identity(T x) {\n    <span class=\"synStatement\">return</span> x;\n  }\n\n  <span class=\"synType\">public</span> <span class=\"synType\">static</span> <span class=\"synType\">void</span> main(String[] args) {\n    Integer d = <span class=\"synConstant\">1</span>;\n    Float f = <span class=\"synConstant\">0.0f</span>;\n    Main.identity(f);\n    Main.identity(d);\n  }\n}\n</pre>\n\n<p><code>javac Main.java</code> してから、<code>javap -v Main</code> します。これで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\">バイトコード</a>が出力されます。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>class Main\n/* 中略 */\n{\n  Main();\n    descriptor: ()V\n    flags:\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V\n         4: return\n      LineNumberTable:\n        line 1: 0\n\n  static &lt;T extends java.lang.Object&gt; T identity(T);\n    descriptor: (Ljava/lang/Object;)Ljava/lang/Object;\n    flags: ACC_STATIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: areturn\n      LineNumberTable:\n        line 3: 0\n    Signature: #14                          // &lt;T:Ljava/lang/Object;&gt;(TT;)TT;\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=1, locals=3, args_size=1\n         0: iconst_1\n         1: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n         4: astore_1\n         5: fconst_0\n         6: invokestatic  #3                  // Method java/lang/Float.valueOf:(F)Ljava/lang/Float;\n         9: astore_2\n        10: aload_2\n        11: invokestatic  #4                  // Method identity:(Ljava/lang/Object;)Ljava/lang/Object;\n        14: pop\n        15: aload_1\n        16: invokestatic  #4                  // Method identity:(Ljava/lang/Object;)Ljava/lang/Object;\n        19: pop\n        20: return\n      LineNumberTable:\n        line 7: 0\n        line 8: 5\n        line 9: 10\n        line 10: 15\n        line 11: 20\n}\nSourceFile: &#34;Main.java&#34;</pre>\n\n<p>注目すべきは <code>// Method identity:(Ljava/lang/Object;)Ljava/lang/Object;</code> というコメントのついた行です。<br/>\n2 行ありますが、それぞれ <code>identity(d)</code> と <code>identity(f)</code> に相当します。</p>\n\n<p><code>Integer.valueOf</code> や <code>Float.valueOf</code> を含むコメントを見ていただければわかると思いますが、このコメント部分には呼び出しているメソッドの型が記されています。<br/>\nつまり、<code>identity</code> は <code>Integer</code> で呼んでも <code>Float</code> で呼んでも <code>Object identity(Object)</code> を呼んでいるということです。</p>\n\n<p>これは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>の大きな特徴で型消去などと呼ばれる性質です。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>による型はすべて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時にのみ利用され、実行時にはすべて <code>Object</code> として表現しつつ適切にキャストを挟むような構造になっています。<br/>\nキャストはキャストでも、正しいことが<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>によって保証されたキャストになるので、<code>List</code> よりも <code>List&lt;String&gt;</code> のほうが安全というわけです。</p>\n\n<h2>それぞれの利点と欠点</h2>\n\n<p>テンプレートや<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>を実現する方法として、2つの例を上げました。<br/>\n一つは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の採用している方式で、テンプレート引数ごとに新しく実体を作ってしまう方式です。<br/>\nもう一つは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> の採用している方式で、<code>Object</code> のようにすべての型を受け取れる基底クラスのようなものを用いて、実行時には型情報を残さない方式です。</p>\n\n<p>今回はたまたま <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> と <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> を例にあげましたが、他の言語でもこのような方式を使っている言語は多いです。（みんなだいすき D 言語は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の方式を採用しています）</p>\n\n<p>さてそれぞれの利点と欠点についてです。</p>\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> 方式</h3>\n\n<ul>\n<li>利点\n\n<ul>\n<li>分割<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>が容易（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な関数を提供する側は <code>Object</code> を入れた<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\">バイ</a>ナリや<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\">バイトコード</a>と、型情報だけを生成すればよい。使用する側は、型情報から型検査を行った後、<code>Object</code> へのキャストなどを含めた<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\">バイ</a>ナリや<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\">バイトコード</a>をはけば良い）</li>\n</ul>\n</li>\n<li>欠点\n\n<ul>\n<li>実行時にやることが増えるのでオーバヘッドがある</li>\n</ul>\n</li>\n</ul>\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> 方式</h3>\n\n<ul>\n<li>利点\n\n<ul>\n<li>実行時オーバヘッドなし（全て<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時に解決される）</li>\n</ul>\n</li>\n<li>欠点\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\">バイ</a>ナリサイズの増加</li>\n<li>分割<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>が困難 (テンプレートを実体化しようと思うと、型情報だけでは足りない。使用者側が定義そのものをまるまる知っている必要がある。)</li>\n</ul>\n</li>\n</ul>\n\n<p>こんな感じでしょうか。<br/>\nこの比較はあくまで型を汎用化したいという目的に関しての比較です。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のテンプレートにできて <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>に出来ないことはたくさんあります。</p>\n\n<h2>まとめ</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>er はみんな実行時のオーバヘッドが嫌いです。テンプレートは、今までに紹介してきた使用法からは想像も出来ないほど豊富な計算を、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時にすべて行うことが出来ます。実行時のオーバヘッドなしで。<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時にテンプレートの解決が終わるということは、強力な最適化が望めるということでもあります。つまり、実行時のキャストといったわかりやすいオーバヘッド以上に、実行速度には差が生まれるでしょう。</p>\n\n<p>というわけで今回はテンプレートの実現方法について、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> と比較しながら説明してみました。</p>\n\n---\n\n---\n","contentMarkdown":"\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のテンプレートがなぜ必要で，どんな構文・種類のものがあるかについては前回までにまとめました。<br/>\nというわけで次は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> ではテンプレートという機能を使用するとどんな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\">バイ</a>ナリが生成されるのかについて見ていきます。<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のテンプレートの強力さとか勘所みたいなものを把握するために非常に重要な部分なので、覚えておくとよいと思います。</p>\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でテンプレートを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>してみる</h2>\n\n<p>早速ですが、実際に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でテンプレートを使っているコードを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>してみます。<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%BB%A5%F3%A5%D6%A5%EA\">アセンブリ</a>よりも <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR のほうがわかりやすいかな？と思うので、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR を clang++ で生成させてみます。\n（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR については <a href=\"http://postd.cc/llvm-for-grad-students/\">大学院生のためのLLVM | インフラ・ミドルウェア | POSTD</a> あたりを読んでおくとなんとなく概念がつかめると思います。公式は<a href=\"http://llvm.org/docs/LangRef.html\">LLVM Language Reference Manual — LLVM 3.9 documentation</a>）</p>\n\n<p>対象となるコードはこちら。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synComment\">// main.cpp</span>\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\nT identity(T x) {\n  <span class=\"synStatement\">return</span> x;\n}\n\n<span class=\"synType\">int</span> main() {\n  <span class=\"synType\">float</span> f = <span class=\"synConstant\">0.0f</span>;\n  identity(f);\n\n  <span class=\"synType\">int</span> d = <span class=\"synConstant\">0</span>;\n  identity(d);\n  <span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;\n}\n</pre>\n\n<p>clang++ で <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR を生成させるには，<code>-S -emit-llvm</code> をオプションに指定します。また、今回のコードは最適化されてしまうとほとんどコードが残らないので、最適化を抑制するよう、<code>-O0</code> を付けます。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>$ clang++ -O0 -S -emit-llvm main.cpp</pre>\n\n<p>すると <code>main.ll</code> というファイルが出来ています。これが <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR です。</p>\n\n<h2>IR を読む</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR は，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> という<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>基盤技術における中間表現 (Intermediate Representation) です。<br/>\nざっくり言うと、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3\">アーキテクチャ</a>に依存しない、読みやすい<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%BB%A5%F3%A5%D6%A5%EA\">アセンブリ</a>です。</p>\n\n<p><code>main.ll</code> はそこまで長くないですが、エッセンスだけ抜粋します。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>define i32 @main() #0 { ;; main 関数\n  %1 = alloca i32, align 4\n  %f = alloca float, align 4\n  %d = alloca i32, align 4\n  store i32 0, i32* %1\n  store float 0.000000e+00, float* %f, align 4\n  %2 = load float* %f, align 4\n  %3 = call float @_Z8identityIfET_S0_(float %2)\n  store i32 0, i32* %d, align 4\n  %4 = load i32* %d, align 4\n  %5 = call i32 @_Z8identityIiET_S0_(i32 %4)\n  ret i32 0\n}\n\ndefine linkonce_odr float @_Z8identityIfET_S0_(float %x) #1 { ;; identity&lt;float&gt; の実体\n  %1 = alloca float, align 4\n  store float %x, float* %1, align 4\n  %2 = load float* %1, align 4\n  ret float %2\n}\n\ndefine linkonce_odr i32 @_Z8identityIiET_S0_(i32 %x) #1 { ;; identity&lt;int&gt; の実体\n  %1 = alloca i32, align 4\n  store i32 %x, i32* %1, align 4\n  %2 = load i32* %1, align 4\n  ret i32 %2\n}</pre>\n\n<p>コメントでも書きましたが、3 つの関数が定義されていることがわかると思います。\nここで重要なのは、 <strong>identity&lt;int>とidentity&lt;float>がそれぞれ別の関数として定義されている</strong> ことです。</p>\n\n<p><code>identity&lt;int&gt;</code> と <code>identity&lt;float&gt;</code> は <code>main</code> の中で使われています。<br/>\nつまり、テンプレートは、「使った分だけ実体が作られる。かつその処理は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時に終わる。」ということがわかります。<br/>\nたとえば<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>中に <code>identity&lt;bool&gt;</code> の実体化を要求するコードがあれば、その時はじめて <code>identity&lt;bool&gt;</code> が作られます。\n独自定義でも構いません。<code>identity&lt;MyClass&gt;</code> の実体化を要求するコードがあれば、その時はじめて <code>identity&lt;MyClass&gt;</code> が作られます。</p>\n\n<p>もちろん、一度実体化されたテンプレートは再利用されます。つまり、<code>identity&lt;int&gt;</code> を要求するコードが、一つの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>に何度現れても、ただひとつの <code>identity&lt;int&gt;</code> が生成されます。</p>\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> との比較</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> にも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>という仕組みがあります。<br/>\n概念的にはテンプレートに似たものなので、比較してみます (テンプレートの方がより強力ですが、型を汎用化したいという目的であれば、両者とも同様に使用できます。)</p>\n\n<p>同じようなコードを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>して<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\">バイトコード</a>を見てみます。</p>\n\n<pre class=\"code lang-java\" data-lang=\"java\" data-unlink><span class=\"synType\">class</span> Main {\n  <span class=\"synType\">static</span> &lt;T&gt; T identity(T x) {\n    <span class=\"synStatement\">return</span> x;\n  }\n\n  <span class=\"synType\">public</span> <span class=\"synType\">static</span> <span class=\"synType\">void</span> main(String[] args) {\n    Integer d = <span class=\"synConstant\">1</span>;\n    Float f = <span class=\"synConstant\">0.0f</span>;\n    Main.identity(f);\n    Main.identity(d);\n  }\n}\n</pre>\n\n<p><code>javac Main.java</code> してから、<code>javap -v Main</code> します。これで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\">バイトコード</a>が出力されます。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>class Main\n/* 中略 */\n{\n  Main();\n    descriptor: ()V\n    flags:\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.&#34;&lt;init&gt;&#34;:()V\n         4: return\n      LineNumberTable:\n        line 1: 0\n\n  static &lt;T extends java.lang.Object&gt; T identity(T);\n    descriptor: (Ljava/lang/Object;)Ljava/lang/Object;\n    flags: ACC_STATIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: areturn\n      LineNumberTable:\n        line 3: 0\n    Signature: #14                          // &lt;T:Ljava/lang/Object;&gt;(TT;)TT;\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=1, locals=3, args_size=1\n         0: iconst_1\n         1: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n         4: astore_1\n         5: fconst_0\n         6: invokestatic  #3                  // Method java/lang/Float.valueOf:(F)Ljava/lang/Float;\n         9: astore_2\n        10: aload_2\n        11: invokestatic  #4                  // Method identity:(Ljava/lang/Object;)Ljava/lang/Object;\n        14: pop\n        15: aload_1\n        16: invokestatic  #4                  // Method identity:(Ljava/lang/Object;)Ljava/lang/Object;\n        19: pop\n        20: return\n      LineNumberTable:\n        line 7: 0\n        line 8: 5\n        line 9: 10\n        line 10: 15\n        line 11: 20\n}\nSourceFile: &#34;Main.java&#34;</pre>\n\n<p>注目すべきは <code>// Method identity:(Ljava/lang/Object;)Ljava/lang/Object;</code> というコメントのついた行です。<br/>\n2 行ありますが、それぞれ <code>identity(d)</code> と <code>identity(f)</code> に相当します。</p>\n\n<p><code>Integer.valueOf</code> や <code>Float.valueOf</code> を含むコメントを見ていただければわかると思いますが、このコメント部分には呼び出しているメソッドの型が記されています。<br/>\nつまり、<code>identity</code> は <code>Integer</code> で呼んでも <code>Float</code> で呼んでも <code>Object identity(Object)</code> を呼んでいるということです。</p>\n\n<p>これは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>の大きな特徴で型消去などと呼ばれる性質です。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>による型はすべて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時にのみ利用され、実行時にはすべて <code>Object</code> として表現しつつ適切にキャストを挟むような構造になっています。<br/>\nキャストはキャストでも、正しいことが<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>によって保証されたキャストになるので、<code>List</code> よりも <code>List&lt;String&gt;</code> のほうが安全というわけです。</p>\n\n<h2>それぞれの利点と欠点</h2>\n\n<p>テンプレートや<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>を実現する方法として、2つの例を上げました。<br/>\n一つは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の採用している方式で、テンプレート引数ごとに新しく実体を作ってしまう方式です。<br/>\nもう一つは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> の採用している方式で、<code>Object</code> のようにすべての型を受け取れる基底クラスのようなものを用いて、実行時には型情報を残さない方式です。</p>\n\n<p>今回はたまたま <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> と <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> を例にあげましたが、他の言語でもこのような方式を使っている言語は多いです。（みんなだいすき D 言語は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の方式を採用しています）</p>\n\n<p>さてそれぞれの利点と欠点についてです。</p>\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> 方式</h3>\n\n<ul>\n<li>利点\n\n<ul>\n<li>分割<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>が容易（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な関数を提供する側は <code>Object</code> を入れた<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\">バイ</a>ナリや<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\">バイトコード</a>と、型情報だけを生成すればよい。使用する側は、型情報から型検査を行った後、<code>Object</code> へのキャストなどを含めた<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\">バイ</a>ナリや<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%C8%A5%B3%A1%BC%A5%C9\">バイトコード</a>をはけば良い）</li>\n</ul>\n</li>\n<li>欠点\n\n<ul>\n<li>実行時にやることが増えるのでオーバヘッドがある</li>\n</ul>\n</li>\n</ul>\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> 方式</h3>\n\n<ul>\n<li>利点\n\n<ul>\n<li>実行時オーバヘッドなし（全て<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時に解決される）</li>\n</ul>\n</li>\n<li>欠点\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\">バイ</a>ナリサイズの増加</li>\n<li>分割<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>が困難 (テンプレートを実体化しようと思うと、型情報だけでは足りない。使用者側が定義そのものをまるまる知っている必要がある。)</li>\n</ul>\n</li>\n</ul>\n\n<p>こんな感じでしょうか。<br/>\nこの比較はあくまで型を汎用化したいという目的に関しての比較です。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のテンプレートにできて <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>に出来ないことはたくさんあります。</p>\n\n<h2>まとめ</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>er はみんな実行時のオーバヘッドが嫌いです。テンプレートは、今までに紹介してきた使用法からは想像も出来ないほど豊富な計算を、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時にすべて行うことが出来ます。実行時のオーバヘッドなしで。<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時にテンプレートの解決が終わるということは、強力な最適化が望めるということでもあります。つまり、実行時のキャストといったわかりやすいオーバヘッド以上に、実行速度には差が生まれるでしょう。</p>\n\n<p>というわけで今回はテンプレートの実現方法について、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> と比較しながら説明してみました。</p>\n\n---\n\n---\n","slug":"C++_のテンプレートの実装","title":"C++ のテンプレートの実装","timestamp":1465804767000,"tags":[]},{"rawMarkdown":"---\ntitle: \"C++ のテンプレートについてまとめるのまとめ\"\ndate: 2016-06-03T03:54:57.000Z\ntags: []\n---\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のテンプレートについてまとめているのでそれらをまとめておきます。<br/>\n今後の予定も合わせて目次にしておきます。</p>\n\n<ol>\n<li>なぜテンプレートが必要なのか\n <iframe src=\"http://agtn.hatenablog.com/embed/2016/05/30/234647\" title=\"C++ のテンプレートについてまとめる（１）なぜテンプレートが必要なのか - refer to 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://agtn.hatenablog.com/entry/2016/05/30/234647\">agtn.hatenablog.com</a></cite></li>\n<li>テンプレートの種類と構文\n<iframe src=\"http://agtn.hatenablog.com/embed/2016/05/31/175756\" title=\"C++ のテンプレートについてまとめる(２) テンプレートの種類と構文 - refer to 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://agtn.hatenablog.com/entry/2016/05/31/175756\">agtn.hatenablog.com</a></cite></li>\n<li>(おまけ) テンプレートの実行時表現と<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>方法</li>\n<li>特殊化と部分特殊化</li>\n<li>メタ関数</li>\n<li>SFINAE</li>\n</ol>\n\n<p>後々CRTPやtype erasureについてもまとめていけたらと思います</p>\n\n---\n\n---\n","contentMarkdown":"\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のテンプレートについてまとめているのでそれらをまとめておきます。<br/>\n今後の予定も合わせて目次にしておきます。</p>\n\n<ol>\n<li>なぜテンプレートが必要なのか\n <iframe src=\"http://agtn.hatenablog.com/embed/2016/05/30/234647\" title=\"C++ のテンプレートについてまとめる（１）なぜテンプレートが必要なのか - refer to 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://agtn.hatenablog.com/entry/2016/05/30/234647\">agtn.hatenablog.com</a></cite></li>\n<li>テンプレートの種類と構文\n<iframe src=\"http://agtn.hatenablog.com/embed/2016/05/31/175756\" title=\"C++ のテンプレートについてまとめる(２) テンプレートの種類と構文 - refer to 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://agtn.hatenablog.com/entry/2016/05/31/175756\">agtn.hatenablog.com</a></cite></li>\n<li>(おまけ) テンプレートの実行時表現と<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>方法</li>\n<li>特殊化と部分特殊化</li>\n<li>メタ関数</li>\n<li>SFINAE</li>\n</ol>\n\n<p>後々CRTPやtype erasureについてもまとめていけたらと思います</p>\n\n---\n\n---\n","slug":"C++_のテンプレートについてまとめるのまとめ","title":"C++ のテンプレートについてまとめるのまとめ","timestamp":1464926097000,"tags":[]},{"rawMarkdown":"---\ntitle: \"C++ テンプレートの種類と構文\"\ndate: 2016-05-31T08:57:56.000Z\ntags: []\n---\n\n<p>前回テンプレートがなぜ必要なのかについて簡単にまとめたので、今回はその構文や種類についてまとめたいと思います。</p>\n\n<p><iframe src=\"http://agtn.hatenablog.com/embed/2016/05/30/234647\" title=\"C++ のテンプレートについてまとめる（１）なぜテンプレートが必要なのか - refer to 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://agtn.hatenablog.com/entry/2016/05/30/234647\">agtn.hatenablog.com</a></cite></p>\n\n<h2>アウトライン</h2>\n\n<ul>\n<li>テンプレートの種類と構文\n\n<ul>\n<li>定義する</li>\n<li>使用する(<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>化)</li>\n</ul>\n</li>\n<li>クラステンプレート</li>\n<li>関数テンプレート</li>\n<li>メンバテンプレート</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>テンプレート(<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>11〜)</li>\n<li>変数テンプレート(<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>14〜)</li>\n<li>まとめと今後</li>\n</ul>\n\n<h2>テンプレートの種類と構文</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のテンプレートは，大きく 5 種類に分類することが出来ます。</p>\n\n<ol>\n<li>クラステンプレート</li>\n<li>関数テンプレート</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>テンプレート</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>テンプレート</li>\n<li>変数テンプレート</li>\n</ol>\n\n<p>これらについて、以降で詳しくまとめていきます。</p>\n\n<p>まずざっくり共通する<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%F3%A5%BF%A5%C3%A5%AF%A5%B9\">シンタックス</a>を示しておきます。</p>\n\n<h3>定義する</h3>\n\n<p>何かのテンプレートを定義したい場合は、通常の定義の前に <code>template</code> 宣言を記述します。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">class</span> stack {\n  ...\n};\n</pre>\n\n<p>複数のテンプレート引数を取りたい場合や、型以外のテンプレート引数を取りたい場合には、以下のようにします。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T, <span class=\"synType\">int</span> N&gt;\n<span class=\"synType\">class</span> my_array {\n  ...\n};\n</pre>\n\n<p>上の例はクラステンプレートでしたが、関数でも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>でも、<code>template</code> を宣言する部分は共通です。</p>\n\n<h3>使用する(<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>化)</h3>\n\n<p>次にテンプレートを使用する場合です。<br/>\nテンプレートはあくまでテンプレートなので、使用する際には、具体的なテンプレート引数を与えて実体化する必要があります。これを <strong><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>化</strong> といいます。</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>化の構文も、テンプレートの種類によらず基本的には共通しています。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>stack&lt;<span class=\"synType\">int</span>&gt; int_stack;\nmy_array&lt;std::string, <span class=\"synConstant\">5</span>&gt; five_strings;\n</pre>\n\n<p><code>テンプレート名 &lt; 引数 &gt;</code> という感じです。<br/>\n一応注意書きをしておきますと、<code>stack&lt;stack&lt;int&gt;&gt;</code> が<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%F3%A5%BF%A5%C3%A5%AF%A5%B9\">シンタックス</a>エラーになる場合があります。\n意味としては <code>stack&lt;int&gt;</code> のスタックです。<br/>\n<code>stack&lt;stack&lt;int&gt;&gt;</code> が<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーになる場合は、使っている<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>が古いかもしれません。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>03 では、<code>&gt;&gt;</code> の部分がシフト<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\">演算子</a>として解釈されてしまうためです。<br/>\n<code>g++ -std=c++11</code> とか <code>clang++ -std=c++11</code> とか <code>g++ -std=c++14</code> とか <code>clang++ -std=c++14</code> とか、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>が新しい規格を参照するようにオプションを渡してあげれば動きます。<br/>\n(もし動かない場合は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>が古すぎます。もう 2016 年ですから、最低でも <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>11 以降を使いましょう。別物です。)</p>\n\n<p>では、以降、それぞれのテンプレートについて詳しく見ていきます。</p>\n\n<h2>クラステンプレート</h2>\n\n<p>クラステンプレートは、クラスのテンプレートです。前回の <code>stack</code> がこれにあたります。<br/>\n一番わかり易い<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\">ユースケース</a>は、コンテナ型の定義でしょう。<br/>\nスタックや単方向リスト、ハッシュマップなど、内部に保持する型に依存しないデータ構造を定義するために使えます。</p>\n\n<p>前回の <code>stack</code> を再掲しておきます。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">class</span> stack {\n<span class=\"synStatement\">public</span>:\n  stack() : data(), n() {}\n\n  <span class=\"synType\">void</span> push(T x) {\n    <span class=\"synStatement\">if</span> (n &gt;= MAX_ELEM) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;stack is full!!&quot;</span>;\n    }\n    data[n++] = x;\n  }\n\n  T pop() {\n    <span class=\"synStatement\">if</span> (n &lt; <span class=\"synConstant\">0</span>) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;stack is empty!!&quot;</span>;\n    }\n    <span class=\"synStatement\">return</span> data[--n];\n  }\n<span class=\"synStatement\">private</span>:\n  T data[MAX_ELEM];\n  <span class=\"synType\">int</span> n;\n};\n</pre>\n\n<h2>関数テンプレート</h2>\n\n<p>関数テンプレートは以下の様なものです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\nT max(T left, T right) {\n  <span class=\"synStatement\">if</span> (left &gt; right) {\n    <span class=\"synStatement\">return</span> left;\n  } <span class=\"synStatement\">else</span> {\n    <span class=\"synStatement\">return</span> right;\n  }\n}\n\n<span class=\"synType\">int</span> x = max&lt;<span class=\"synType\">int</span>&gt;(<span class=\"synConstant\">1</span>, <span class=\"synConstant\">0</span>); <span class=\"synComment\">// =&gt; x == 1</span>\n<span class=\"synType\">double</span> y = max&lt;<span class=\"synType\">double</span>&gt;(<span class=\"synConstant\">0.5</span>, <span class=\"synConstant\">100.0</span>); <span class=\"synComment\">// =&gt; y == 100.0</span>\n</pre>\n\n<p><code>max</code> 関数は、「ある型 T について、２つの引数のうち、大きい方を返す」関数です。<br/>\n明示的に <code>max&lt;int&gt;</code> や <code>max&lt;double&gt;</code> とすることで、<code>int</code> や <code>double</code> についての「大きい方を返す」関数を得ています。</p>\n\n<h3>テンプレート引数の推論</h3>\n\n<p>実は、関数テンプレートの場合、明示的にテンプレートを引数を渡す必要がない場合があります。<br/>\n今回の <code>max</code> 関数はまさにそのケースです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">int</span> x = max(<span class=\"synConstant\">1</span>, <span class=\"synConstant\">0</span>);\n</pre>\n\n<p>これは、テンプレート引数の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>の結果です。<br/>\n<code>max</code> 関数の第一引数、第二引数はそれぞれ <code>T</code> です。そして、実際に渡されている <code>1</code> や <code>0</code> は <code>int</code> 型です。<br/>\nこれらの情報から、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>は <code>T == int</code> であることを推論します。<br/>\nしたがって暗黙に <code>max&lt;int&gt;</code> と指定されることになります。<br/>\nこの推論は色々複雑だったりしますが、はじめは引数から単純に推論できれば推論されると思っておけば良いんじゃないかなと思います。</p>\n\n<p>一方、クラステンプレートなど、関数テンプレート(と<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>テンプレート)以外のテンプレートの場合には、この推論は行われません。<br/>\n勘違いしやすいので気をつけましょう。特にクラステンプレートは間違いやすいです。</p>\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>テンプレート</h3>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">class</span> printer {\n<span class=\"synStatement\">public</span>:\n  <span class=\"synType\">explicit</span> printer(std::ostream&amp; os) : os(os) {}\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n  <span class=\"synType\">void</span> print(T <span class=\"synType\">const</span>&amp; v) {\n    os &lt;&lt; v;\n  }\n<span class=\"synStatement\">private</span>:\n  std::ostream&amp; os;\n};\n</pre>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>テンプレートは、関数テンプレートとほとんど同じです。違いは、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>として定義されていることだけです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>printer p(std::cout);\n</pre>\n\n<p>ここまではテンプレートでもなんでもないただのクラスです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>p.print(<span class=\"synConstant\">0</span>);\np.print(<span class=\"synConstant\">&quot;abc&quot;</span>);\np.print&lt;<span class=\"synType\">double</span>&gt;(<span class=\"synConstant\">0.1</span>);\n</pre>\n\n<p>こんな感じで使います。関数テンプレートとほぼ同じですね。</p>\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>テンプレート</h3>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>テンプレートは、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>11 から使用できるテンプレートです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T, <span class=\"synType\">typename</span> U&gt;\n<span class=\"synType\">struct</span> pair;\n\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synStatement\">using</span> with_int_t = pair&lt;T, <span class=\"synType\">int</span>&gt;;\n</pre>\n\n<p><code>using</code> で型名の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>を作ることが出来ますが、それをテンプレートにすることが出来ます。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>with_int_t&lt;<span class=\"synType\">bool</span>&gt; p(<span class=\"synConstant\">true</span>, <span class=\"synConstant\">0</span>);  <span class=\"synComment\">// pair&lt;bool, int&gt; p(true, 0);</span>\nwith_int_t&lt;std::string&gt; s(<span class=\"synConstant\">&quot;abc&quot;</span>, <span class=\"synConstant\">100</span>);  <span class=\"synComment\">// pair&lt;std::string, int&gt; s(&quot;abc&quot;, 100);</span>\n</pre>\n\n<p>ちなみに <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>11 より前は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>テンプレートの代替として、</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">struct</span> with_int {\n  <span class=\"synType\">typedef</span> pair&lt;T, <span class=\"synType\">int</span>&gt; type;\n}\n\nwith_int&lt;<span class=\"synType\">bool</span>&gt;::type p(<span class=\"synConstant\">true</span>, <span class=\"synConstant\">0</span>); <span class=\"synComment\">// pair&lt;bool, int&gt; p(true, 0);</span>\n</pre>\n\n<p>という記述をしていました。(今でもライブラリなどで現役の表現ですので覚えておきましょう)</p>\n\n<h3>変数テンプレート</h3>\n\n<p>最後の変数テンプレートは、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>14 から使用できるテンプレートです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\nconstexpr T pi = <span class=\"synStatement\">static_cast</span>&lt;T&gt;(<span class=\"synConstant\">3.1415926</span>);\n\n<span class=\"synType\">int</span> x = pi&lt;<span class=\"synType\">int</span>&gt;;\n<span class=\"synType\">double</span> y = pi&lt;<span class=\"synType\">double</span>&gt;;\n</pre>\n\n<p><code>constexpr</code> は定数式というやつです。</p>\n\n<p>ちなみに <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>14 より前は、代替として</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">struct</span> pi {\n  <span class=\"synType\">static</span> <span class=\"synType\">const</span> T value = <span class=\"synStatement\">static_cast</span>&lt;T&gt;(<span class=\"synConstant\">3.1415926</span>);\n};\n\n<span class=\"synType\">int</span> x = pi&lt;<span class=\"synType\">int</span>&gt;::value;\n<span class=\"synType\">double</span> y = pi&lt;<span class=\"synType\">double</span>&gt;::value;\n</pre>\n\n<p>という記述をしていました。(こちらも現役の表現です)</p>\n\n<h2>まとめと今後</h2>\n\n<p>というわけで今回はテンプレートの種類とそれぞれの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%F3%A5%BF%A5%C3%A5%AF%A5%B9\">シンタックス</a>についてまとめてみました。<br/>\n今後、特殊化や部分特殊化などのお話をするときに種類によって微妙に違いがあったりするので、しっかり区別しておいたほうが良さそうです。</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>前回テンプレートがなぜ必要なのかについて簡単にまとめたので、今回はその構文や種類についてまとめたいと思います。</p>\n\n<p><iframe src=\"http://agtn.hatenablog.com/embed/2016/05/30/234647\" title=\"C++ のテンプレートについてまとめる（１）なぜテンプレートが必要なのか - refer to 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://agtn.hatenablog.com/entry/2016/05/30/234647\">agtn.hatenablog.com</a></cite></p>\n\n<h2>アウトライン</h2>\n\n<ul>\n<li>テンプレートの種類と構文\n\n<ul>\n<li>定義する</li>\n<li>使用する(<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>化)</li>\n</ul>\n</li>\n<li>クラステンプレート</li>\n<li>関数テンプレート</li>\n<li>メンバテンプレート</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>テンプレート(<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>11〜)</li>\n<li>変数テンプレート(<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>14〜)</li>\n<li>まとめと今後</li>\n</ul>\n\n<h2>テンプレートの種類と構文</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のテンプレートは，大きく 5 種類に分類することが出来ます。</p>\n\n<ol>\n<li>クラステンプレート</li>\n<li>関数テンプレート</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>テンプレート</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>テンプレート</li>\n<li>変数テンプレート</li>\n</ol>\n\n<p>これらについて、以降で詳しくまとめていきます。</p>\n\n<p>まずざっくり共通する<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%F3%A5%BF%A5%C3%A5%AF%A5%B9\">シンタックス</a>を示しておきます。</p>\n\n<h3>定義する</h3>\n\n<p>何かのテンプレートを定義したい場合は、通常の定義の前に <code>template</code> 宣言を記述します。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">class</span> stack {\n  ...\n};\n</pre>\n\n<p>複数のテンプレート引数を取りたい場合や、型以外のテンプレート引数を取りたい場合には、以下のようにします。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T, <span class=\"synType\">int</span> N&gt;\n<span class=\"synType\">class</span> my_array {\n  ...\n};\n</pre>\n\n<p>上の例はクラステンプレートでしたが、関数でも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>でも、<code>template</code> を宣言する部分は共通です。</p>\n\n<h3>使用する(<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>化)</h3>\n\n<p>次にテンプレートを使用する場合です。<br/>\nテンプレートはあくまでテンプレートなので、使用する際には、具体的なテンプレート引数を与えて実体化する必要があります。これを <strong><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>化</strong> といいます。</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>化の構文も、テンプレートの種類によらず基本的には共通しています。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>stack&lt;<span class=\"synType\">int</span>&gt; int_stack;\nmy_array&lt;std::string, <span class=\"synConstant\">5</span>&gt; five_strings;\n</pre>\n\n<p><code>テンプレート名 &lt; 引数 &gt;</code> という感じです。<br/>\n一応注意書きをしておきますと、<code>stack&lt;stack&lt;int&gt;&gt;</code> が<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%F3%A5%BF%A5%C3%A5%AF%A5%B9\">シンタックス</a>エラーになる場合があります。\n意味としては <code>stack&lt;int&gt;</code> のスタックです。<br/>\n<code>stack&lt;stack&lt;int&gt;&gt;</code> が<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーになる場合は、使っている<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>が古いかもしれません。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>03 では、<code>&gt;&gt;</code> の部分がシフト<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\">演算子</a>として解釈されてしまうためです。<br/>\n<code>g++ -std=c++11</code> とか <code>clang++ -std=c++11</code> とか <code>g++ -std=c++14</code> とか <code>clang++ -std=c++14</code> とか、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>が新しい規格を参照するようにオプションを渡してあげれば動きます。<br/>\n(もし動かない場合は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>が古すぎます。もう 2016 年ですから、最低でも <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>11 以降を使いましょう。別物です。)</p>\n\n<p>では、以降、それぞれのテンプレートについて詳しく見ていきます。</p>\n\n<h2>クラステンプレート</h2>\n\n<p>クラステンプレートは、クラスのテンプレートです。前回の <code>stack</code> がこれにあたります。<br/>\n一番わかり易い<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\">ユースケース</a>は、コンテナ型の定義でしょう。<br/>\nスタックや単方向リスト、ハッシュマップなど、内部に保持する型に依存しないデータ構造を定義するために使えます。</p>\n\n<p>前回の <code>stack</code> を再掲しておきます。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">class</span> stack {\n<span class=\"synStatement\">public</span>:\n  stack() : data(), n() {}\n\n  <span class=\"synType\">void</span> push(T x) {\n    <span class=\"synStatement\">if</span> (n &gt;= MAX_ELEM) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;stack is full!!&quot;</span>;\n    }\n    data[n++] = x;\n  }\n\n  T pop() {\n    <span class=\"synStatement\">if</span> (n &lt; <span class=\"synConstant\">0</span>) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;stack is empty!!&quot;</span>;\n    }\n    <span class=\"synStatement\">return</span> data[--n];\n  }\n<span class=\"synStatement\">private</span>:\n  T data[MAX_ELEM];\n  <span class=\"synType\">int</span> n;\n};\n</pre>\n\n<h2>関数テンプレート</h2>\n\n<p>関数テンプレートは以下の様なものです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\nT max(T left, T right) {\n  <span class=\"synStatement\">if</span> (left &gt; right) {\n    <span class=\"synStatement\">return</span> left;\n  } <span class=\"synStatement\">else</span> {\n    <span class=\"synStatement\">return</span> right;\n  }\n}\n\n<span class=\"synType\">int</span> x = max&lt;<span class=\"synType\">int</span>&gt;(<span class=\"synConstant\">1</span>, <span class=\"synConstant\">0</span>); <span class=\"synComment\">// =&gt; x == 1</span>\n<span class=\"synType\">double</span> y = max&lt;<span class=\"synType\">double</span>&gt;(<span class=\"synConstant\">0.5</span>, <span class=\"synConstant\">100.0</span>); <span class=\"synComment\">// =&gt; y == 100.0</span>\n</pre>\n\n<p><code>max</code> 関数は、「ある型 T について、２つの引数のうち、大きい方を返す」関数です。<br/>\n明示的に <code>max&lt;int&gt;</code> や <code>max&lt;double&gt;</code> とすることで、<code>int</code> や <code>double</code> についての「大きい方を返す」関数を得ています。</p>\n\n<h3>テンプレート引数の推論</h3>\n\n<p>実は、関数テンプレートの場合、明示的にテンプレートを引数を渡す必要がない場合があります。<br/>\n今回の <code>max</code> 関数はまさにそのケースです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">int</span> x = max(<span class=\"synConstant\">1</span>, <span class=\"synConstant\">0</span>);\n</pre>\n\n<p>これは、テンプレート引数の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>の結果です。<br/>\n<code>max</code> 関数の第一引数、第二引数はそれぞれ <code>T</code> です。そして、実際に渡されている <code>1</code> や <code>0</code> は <code>int</code> 型です。<br/>\nこれらの情報から、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>は <code>T == int</code> であることを推論します。<br/>\nしたがって暗黙に <code>max&lt;int&gt;</code> と指定されることになります。<br/>\nこの推論は色々複雑だったりしますが、はじめは引数から単純に推論できれば推論されると思っておけば良いんじゃないかなと思います。</p>\n\n<p>一方、クラステンプレートなど、関数テンプレート(と<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>テンプレート)以外のテンプレートの場合には、この推論は行われません。<br/>\n勘違いしやすいので気をつけましょう。特にクラステンプレートは間違いやすいです。</p>\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>テンプレート</h3>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">class</span> printer {\n<span class=\"synStatement\">public</span>:\n  <span class=\"synType\">explicit</span> printer(std::ostream&amp; os) : os(os) {}\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n  <span class=\"synType\">void</span> print(T <span class=\"synType\">const</span>&amp; v) {\n    os &lt;&lt; v;\n  }\n<span class=\"synStatement\">private</span>:\n  std::ostream&amp; os;\n};\n</pre>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>テンプレートは、関数テンプレートとほとんど同じです。違いは、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>として定義されていることだけです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>printer p(std::cout);\n</pre>\n\n<p>ここまではテンプレートでもなんでもないただのクラスです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>p.print(<span class=\"synConstant\">0</span>);\np.print(<span class=\"synConstant\">&quot;abc&quot;</span>);\np.print&lt;<span class=\"synType\">double</span>&gt;(<span class=\"synConstant\">0.1</span>);\n</pre>\n\n<p>こんな感じで使います。関数テンプレートとほぼ同じですね。</p>\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>テンプレート</h3>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>テンプレートは、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>11 から使用できるテンプレートです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T, <span class=\"synType\">typename</span> U&gt;\n<span class=\"synType\">struct</span> pair;\n\n<span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synStatement\">using</span> with_int_t = pair&lt;T, <span class=\"synType\">int</span>&gt;;\n</pre>\n\n<p><code>using</code> で型名の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>を作ることが出来ますが、それをテンプレートにすることが出来ます。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>with_int_t&lt;<span class=\"synType\">bool</span>&gt; p(<span class=\"synConstant\">true</span>, <span class=\"synConstant\">0</span>);  <span class=\"synComment\">// pair&lt;bool, int&gt; p(true, 0);</span>\nwith_int_t&lt;std::string&gt; s(<span class=\"synConstant\">&quot;abc&quot;</span>, <span class=\"synConstant\">100</span>);  <span class=\"synComment\">// pair&lt;std::string, int&gt; s(&quot;abc&quot;, 100);</span>\n</pre>\n\n<p>ちなみに <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>11 より前は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>テンプレートの代替として、</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">struct</span> with_int {\n  <span class=\"synType\">typedef</span> pair&lt;T, <span class=\"synType\">int</span>&gt; type;\n}\n\nwith_int&lt;<span class=\"synType\">bool</span>&gt;::type p(<span class=\"synConstant\">true</span>, <span class=\"synConstant\">0</span>); <span class=\"synComment\">// pair&lt;bool, int&gt; p(true, 0);</span>\n</pre>\n\n<p>という記述をしていました。(今でもライブラリなどで現役の表現ですので覚えておきましょう)</p>\n\n<h3>変数テンプレート</h3>\n\n<p>最後の変数テンプレートは、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>14 から使用できるテンプレートです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\nconstexpr T pi = <span class=\"synStatement\">static_cast</span>&lt;T&gt;(<span class=\"synConstant\">3.1415926</span>);\n\n<span class=\"synType\">int</span> x = pi&lt;<span class=\"synType\">int</span>&gt;;\n<span class=\"synType\">double</span> y = pi&lt;<span class=\"synType\">double</span>&gt;;\n</pre>\n\n<p><code>constexpr</code> は定数式というやつです。</p>\n\n<p>ちなみに <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>14 より前は、代替として</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">struct</span> pi {\n  <span class=\"synType\">static</span> <span class=\"synType\">const</span> T value = <span class=\"synStatement\">static_cast</span>&lt;T&gt;(<span class=\"synConstant\">3.1415926</span>);\n};\n\n<span class=\"synType\">int</span> x = pi&lt;<span class=\"synType\">int</span>&gt;::value;\n<span class=\"synType\">double</span> y = pi&lt;<span class=\"synType\">double</span>&gt;::value;\n</pre>\n\n<p>という記述をしていました。(こちらも現役の表現です)</p>\n\n<h2>まとめと今後</h2>\n\n<p>というわけで今回はテンプレートの種類とそれぞれの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%F3%A5%BF%A5%C3%A5%AF%A5%B9\">シンタックス</a>についてまとめてみました。<br/>\n今後、特殊化や部分特殊化などのお話をするときに種類によって微妙に違いがあったりするので、しっかり区別しておいたほうが良さそうです。</p>\n\n---\n\n---\n","slug":"C++_テンプレートの種類と構文","title":"C++ テンプレートの種類と構文","timestamp":1464685076000,"tags":[]},{"rawMarkdown":"---\ntitle: \"C++ : なぜテンプレートが必要なのか\"\ndate: 2016-05-30T14:46:47.000Z\ntags: []\n---\n\n<p>こんにちは。<br/>\nちょっと <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> への熱を冷まさないために、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のテンプレートについてまとめてみたいと思います。</p>\n\n<h2>対象</h2>\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のテンプレートが怖い人</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーメッセージが怖い人</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の規格とブログポストを比較して誤りを探したい人(もし誤っていたら教えて下さい...)</li>\n</ul>\n\n<h2>テンプレートとは</h2>\n\n<blockquote><p>プログラミングにおけるテンプレートは、静的型付けの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>でデータ型にとらわれずにコードを書くことを可能にする機能であり、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>においては<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>プログラミングに用いられる。<br/>\n<a href=\"https://ja.wikipedia.org/wiki/%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0\">テンプレート (プログラミング) - Wikipedia</a>)より</p></blockquote>\n\n<p>他の静的型付きな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語</a>をすでに知っている場合は，すんなり入りやすいかもしれません。<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scala\">Scala</a>, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%23\">C#</a> でいうところの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>に近い存在です。<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> だと多相とか。</p>\n\n<p>雑に表現するならば、リストとか<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CF%A2%C1%DB%C7%DB%CE%F3\">連想配列</a>のように内部のデータ型に依らないデータ構造を、静的型のもとにどうやったらうまく表現できるかな、に対する解の一つです。</p>\n\n<h3>例</h3>\n\n<p>では一つの例として、スタックというデータ構造をプログラムに落としこむことを考えます。<br/>\nまずは <code>int</code> 型のスタックを定義してみます。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#define MAX_ELEM </span><span class=\"synConstant\">10</span>\n\n<span class=\"synType\">class</span> int_stack {\n<span class=\"synStatement\">public</span>:\n  int_stack() : data(), n() {}\n\n  <span class=\"synType\">void</span> push(<span class=\"synType\">int</span> x) {\n    <span class=\"synStatement\">if</span> (n &gt;= MAX_ELEM) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;stack is full!!&quot;</span>;\n    }\n    data[n++] = x;\n  }\n\n  <span class=\"synType\">int</span> pop() {\n    <span class=\"synStatement\">if</span> (n &lt; <span class=\"synConstant\">0</span>) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;stack is empty!!&quot;</span>;\n    }\n    <span class=\"synStatement\">return</span> data[--n];\n  }\n<span class=\"synStatement\">private</span>:\n  <span class=\"synType\">int</span> data[MAX_ELEM];\n  <span class=\"synType\">int</span> n;\n};\n</pre>\n\n<p>簡単のため、かなりお粗末なスタックですが、最低限のスタックとしての見た目はしていると思います。</p>\n\n<p>では次に、<code>std::string</code> 型のスタックや <code>double</code> 型のスタックを作りたいとなったらどうすればよいでしょうか。<br/>\nコピーして <code>int</code> を置換しますか？あまり褒められた方法ではなさそうです。</p>\n\n<h4>C でのアプローチの一つ</h4>\n\n<p>C 言語の場合、このような問題に対しては <code>void*</code> というアプローチがあります。<br/>\n<code>void*</code> は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/java\">java</a> でいう <code>Object</code> のように扱われます。</p>\n\n<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synPreProc\">#define MAX_ELEM </span><span class=\"synConstant\">10</span>\n\n<span class=\"synType\">struct</span> stack {\n  <span class=\"synType\">void</span> *data[MAX_ELEM];\n  <span class=\"synType\">int</span> n;\n};\n\n<span class=\"synType\">void</span> push(stack *s, <span class=\"synType\">void</span> *elem) {\n  ....\n}\n\n<span class=\"synType\">void</span> *pop(stack *s) {\n  ....\n}\n\n<span class=\"synComment\">/* Usage */</span>\nstack *s = new_stack();\n<span class=\"synType\">int</span> *x = (<span class=\"synType\">int</span>*)malloc(<span class=\"synStatement\">sizeof</span>(<span class=\"synType\">int</span>));\n*x = <span class=\"synConstant\">1</span>;\npush(s, (<span class=\"synType\">void</span>*)x);\n<span class=\"synType\">int</span> *y = (<span class=\"synType\">int</span>*)pop(s);\nprintf(<span class=\"synConstant\">&quot;</span><span class=\"synSpecial\">%d\\n</span><span class=\"synConstant\">&quot;</span> *y); <span class=\"synComment\">/* =&gt; 1 */</span>\n</pre>\n\n<p>こんな感じでしょうか。実装の細かい部分は省略しています。<br/>\n<code>push</code> の際にはあらゆるポインタを <code>void*</code> にキャストし、逆に <code>pop</code> する際には <code>void*</code> を求める型にキャストしています。<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>のなかった頃の <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/java\">java</a> は、これを <code>Object</code> へのキャスト・<code>Object</code> からのキャストとして表現していました。</p>\n\n<h5>void* のデメリット</h5>\n\n<p><code>void*</code> を使う場合のデメリットは、型システムを台無しにしている点です。(<code>malloc</code> や <code>free</code> が必要であることは C 言語特有の問題なのでスルー)<br/>\nつまり、<code>int</code> のスタックから <code>pop</code> してきたとき、<code>int*</code> に正しくキャストを行う責任は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DE\">プログラマ</a>にあり、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>は何も手助けをしてくれないということです。<br/>\nしたがって、 <code>int</code> スタックに <code>double</code> の値を <code>push</code> したり、 <code>double</code> スタックから <code>char*</code> を <code>pop</code> したりというミスが簡単に引き起こされてしまうということです。</p>\n\n<h4>そこでテンプレート</h4>\n\n<p>では <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> ではどのようなアプローチを取るかというと、テンプレートを使います。<br/>\n今回は型に関するテンプレートの話しかしないので、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/java\">java</a> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>も大体同じ話だと思って構わないと思います。(実行時の表現や<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>の動きなどの違いはあるが、対象としている問題は同じ)</p>\n\n<p>さきほどの <code>int_stack</code> の実装では、要素型が <code>int</code> に固定化されてしまっているのが問題でした。<br/>\nそこで、テンプレートでは、型を抽象化し、ある種の引数のように扱っています。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">class</span> stack {\n<span class=\"synStatement\">public</span>:\n  stack() : data(), n() {}\n\n  <span class=\"synType\">void</span> push(T x) {\n    <span class=\"synStatement\">if</span> (n &gt;= MAX_ELEM) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;stack is full!!&quot;</span>;\n    }\n    data[n++] = x;\n  }\n\n  T pop() {\n    <span class=\"synStatement\">if</span> (n &lt; <span class=\"synConstant\">0</span>) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;stack is empty!!&quot;</span>;\n    }\n    <span class=\"synStatement\">return</span> data[--n];\n  }\n<span class=\"synStatement\">private</span>:\n  T data[MAX_ELEM];\n  <span class=\"synType\">int</span> n;\n};\n</pre>\n\n<p>先頭の <code>template &lt;typename T&gt;</code> (<code>template &lt;class T&gt;</code> でも可)は、型引数の導入の役割を果たしています。<br/>\n<code>stack</code> クラスの定義内に登場する <code>T</code> は型引数として導入された型を表します。</p>\n\n<p>利用する際には、<code>stack&lt;int&gt;</code> とか <code>stack&lt;std::string&gt;</code> とか、型を <code>stack</code> に渡してあげればOKです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>stack&lt;<span class=\"synType\">int</span>&gt; int_stack;\nint_stack.push(<span class=\"synConstant\">1</span>);\nint_stack.push(<span class=\"synConstant\">2</span>);\n<span class=\"synType\">int</span> x = int_stack.pop();\nint_stack.push(<span class=\"synConstant\">&quot;abc&quot;</span>); <span class=\"synComment\">// =&gt; Compile error!</span>\n\nstack&lt;std::string&gt; str_stack;\nstr_stack.push(<span class=\"synConstant\">&quot;abc&quot;</span>);\nstr_stack.push(<span class=\"synConstant\">1</span>); <span class=\"synComment\">// =&gt; Compile error!</span>\n</pre>\n\n<p>このように、同じコードをコピペすることなく、複数の型に対応したスタックという汎用的なデータ構造を表現することが出来ています。<br/>\nさらに、この方法では、<code>void*</code> や <code>Object</code> と異なり、型的に誤った使用方法をしようとすると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーになるというメリットがあります。<br/>\nランタイムエラーより<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーのほうが<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%D0%A5%C3%A5%B0\">デバッグ</a>しやすいし発見しやすいですよね。</p>\n\n<h2>一旦まとめ</h2>\n\n<p>というわけで今回はテンプレートがなぜ便利かという話のほんのさわりの部分について書いてみました。<br/>\n次はテンプレートや<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>の実現方法、ランタイムにおける表現方法などについて書いてみます。<br/>\nそこからはテンプレート引数として値をとる話や、TMP についても触れていければと思っています。</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>こんにちは。<br/>\nちょっと <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> への熱を冷まさないために、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のテンプレートについてまとめてみたいと思います。</p>\n\n<h2>対象</h2>\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のテンプレートが怖い人</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーメッセージが怖い人</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の規格とブログポストを比較して誤りを探したい人(もし誤っていたら教えて下さい...)</li>\n</ul>\n\n<h2>テンプレートとは</h2>\n\n<blockquote><p>プログラミングにおけるテンプレートは、静的型付けの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>でデータ型にとらわれずにコードを書くことを可能にする機能であり、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>においては<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>プログラミングに用いられる。<br/>\n<a href=\"https://ja.wikipedia.org/wiki/%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0\">テンプレート (プログラミング) - Wikipedia</a>)より</p></blockquote>\n\n<p>他の静的型付きな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語</a>をすでに知っている場合は，すんなり入りやすいかもしれません。<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scala\">Scala</a>, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%23\">C#</a> でいうところの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>に近い存在です。<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> だと多相とか。</p>\n\n<p>雑に表現するならば、リストとか<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CF%A2%C1%DB%C7%DB%CE%F3\">連想配列</a>のように内部のデータ型に依らないデータ構造を、静的型のもとにどうやったらうまく表現できるかな、に対する解の一つです。</p>\n\n<h3>例</h3>\n\n<p>では一つの例として、スタックというデータ構造をプログラムに落としこむことを考えます。<br/>\nまずは <code>int</code> 型のスタックを定義してみます。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#define MAX_ELEM </span><span class=\"synConstant\">10</span>\n\n<span class=\"synType\">class</span> int_stack {\n<span class=\"synStatement\">public</span>:\n  int_stack() : data(), n() {}\n\n  <span class=\"synType\">void</span> push(<span class=\"synType\">int</span> x) {\n    <span class=\"synStatement\">if</span> (n &gt;= MAX_ELEM) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;stack is full!!&quot;</span>;\n    }\n    data[n++] = x;\n  }\n\n  <span class=\"synType\">int</span> pop() {\n    <span class=\"synStatement\">if</span> (n &lt; <span class=\"synConstant\">0</span>) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;stack is empty!!&quot;</span>;\n    }\n    <span class=\"synStatement\">return</span> data[--n];\n  }\n<span class=\"synStatement\">private</span>:\n  <span class=\"synType\">int</span> data[MAX_ELEM];\n  <span class=\"synType\">int</span> n;\n};\n</pre>\n\n<p>簡単のため、かなりお粗末なスタックですが、最低限のスタックとしての見た目はしていると思います。</p>\n\n<p>では次に、<code>std::string</code> 型のスタックや <code>double</code> 型のスタックを作りたいとなったらどうすればよいでしょうか。<br/>\nコピーして <code>int</code> を置換しますか？あまり褒められた方法ではなさそうです。</p>\n\n<h4>C でのアプローチの一つ</h4>\n\n<p>C 言語の場合、このような問題に対しては <code>void*</code> というアプローチがあります。<br/>\n<code>void*</code> は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/java\">java</a> でいう <code>Object</code> のように扱われます。</p>\n\n<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synPreProc\">#define MAX_ELEM </span><span class=\"synConstant\">10</span>\n\n<span class=\"synType\">struct</span> stack {\n  <span class=\"synType\">void</span> *data[MAX_ELEM];\n  <span class=\"synType\">int</span> n;\n};\n\n<span class=\"synType\">void</span> push(stack *s, <span class=\"synType\">void</span> *elem) {\n  ....\n}\n\n<span class=\"synType\">void</span> *pop(stack *s) {\n  ....\n}\n\n<span class=\"synComment\">/* Usage */</span>\nstack *s = new_stack();\n<span class=\"synType\">int</span> *x = (<span class=\"synType\">int</span>*)malloc(<span class=\"synStatement\">sizeof</span>(<span class=\"synType\">int</span>));\n*x = <span class=\"synConstant\">1</span>;\npush(s, (<span class=\"synType\">void</span>*)x);\n<span class=\"synType\">int</span> *y = (<span class=\"synType\">int</span>*)pop(s);\nprintf(<span class=\"synConstant\">&quot;</span><span class=\"synSpecial\">%d\\n</span><span class=\"synConstant\">&quot;</span> *y); <span class=\"synComment\">/* =&gt; 1 */</span>\n</pre>\n\n<p>こんな感じでしょうか。実装の細かい部分は省略しています。<br/>\n<code>push</code> の際にはあらゆるポインタを <code>void*</code> にキャストし、逆に <code>pop</code> する際には <code>void*</code> を求める型にキャストしています。<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>のなかった頃の <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/java\">java</a> は、これを <code>Object</code> へのキャスト・<code>Object</code> からのキャストとして表現していました。</p>\n\n<h5>void* のデメリット</h5>\n\n<p><code>void*</code> を使う場合のデメリットは、型システムを台無しにしている点です。(<code>malloc</code> や <code>free</code> が必要であることは C 言語特有の問題なのでスルー)<br/>\nつまり、<code>int</code> のスタックから <code>pop</code> してきたとき、<code>int*</code> に正しくキャストを行う責任は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DE\">プログラマ</a>にあり、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>は何も手助けをしてくれないということです。<br/>\nしたがって、 <code>int</code> スタックに <code>double</code> の値を <code>push</code> したり、 <code>double</code> スタックから <code>char*</code> を <code>pop</code> したりというミスが簡単に引き起こされてしまうということです。</p>\n\n<h4>そこでテンプレート</h4>\n\n<p>では <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> ではどのようなアプローチを取るかというと、テンプレートを使います。<br/>\n今回は型に関するテンプレートの話しかしないので、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/java\">java</a> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>も大体同じ話だと思って構わないと思います。(実行時の表現や<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>の動きなどの違いはあるが、対象としている問題は同じ)</p>\n\n<p>さきほどの <code>int_stack</code> の実装では、要素型が <code>int</code> に固定化されてしまっているのが問題でした。<br/>\nそこで、テンプレートでは、型を抽象化し、ある種の引数のように扱っています。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt;\n<span class=\"synType\">class</span> stack {\n<span class=\"synStatement\">public</span>:\n  stack() : data(), n() {}\n\n  <span class=\"synType\">void</span> push(T x) {\n    <span class=\"synStatement\">if</span> (n &gt;= MAX_ELEM) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;stack is full!!&quot;</span>;\n    }\n    data[n++] = x;\n  }\n\n  T pop() {\n    <span class=\"synStatement\">if</span> (n &lt; <span class=\"synConstant\">0</span>) {\n      <span class=\"synStatement\">throw</span> <span class=\"synConstant\">&quot;stack is empty!!&quot;</span>;\n    }\n    <span class=\"synStatement\">return</span> data[--n];\n  }\n<span class=\"synStatement\">private</span>:\n  T data[MAX_ELEM];\n  <span class=\"synType\">int</span> n;\n};\n</pre>\n\n<p>先頭の <code>template &lt;typename T&gt;</code> (<code>template &lt;class T&gt;</code> でも可)は、型引数の導入の役割を果たしています。<br/>\n<code>stack</code> クラスの定義内に登場する <code>T</code> は型引数として導入された型を表します。</p>\n\n<p>利用する際には、<code>stack&lt;int&gt;</code> とか <code>stack&lt;std::string&gt;</code> とか、型を <code>stack</code> に渡してあげればOKです。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>stack&lt;<span class=\"synType\">int</span>&gt; int_stack;\nint_stack.push(<span class=\"synConstant\">1</span>);\nint_stack.push(<span class=\"synConstant\">2</span>);\n<span class=\"synType\">int</span> x = int_stack.pop();\nint_stack.push(<span class=\"synConstant\">&quot;abc&quot;</span>); <span class=\"synComment\">// =&gt; Compile error!</span>\n\nstack&lt;std::string&gt; str_stack;\nstr_stack.push(<span class=\"synConstant\">&quot;abc&quot;</span>);\nstr_stack.push(<span class=\"synConstant\">1</span>); <span class=\"synComment\">// =&gt; Compile error!</span>\n</pre>\n\n<p>このように、同じコードをコピペすることなく、複数の型に対応したスタックという汎用的なデータ構造を表現することが出来ています。<br/>\nさらに、この方法では、<code>void*</code> や <code>Object</code> と異なり、型的に誤った使用方法をしようとすると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーになるというメリットがあります。<br/>\nランタイムエラーより<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーのほうが<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%D0%A5%C3%A5%B0\">デバッグ</a>しやすいし発見しやすいですよね。</p>\n\n<h2>一旦まとめ</h2>\n\n<p>というわけで今回はテンプレートがなぜ便利かという話のほんのさわりの部分について書いてみました。<br/>\n次はテンプレートや<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>の実現方法、ランタイムにおける表現方法などについて書いてみます。<br/>\nそこからはテンプレート引数として値をとる話や、TMP についても触れていければと思っています。</p>\n\n---\n\n---\n","slug":"C++_:_なぜテンプレートが必要なのか","title":"C++ : なぜテンプレートが必要なのか","timestamp":1464619607000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Rust のパーサコンビネータライブラリ combine を使う時の tips\"\ndate: 2016-05-14T16:03:19.000Z\ntags: []\n---\n\n<p>Rust のパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>ライブラリの一つである <a href=\"https://github.com/Marwes/combine\">Marwes/combine: A parser combinator library for Rust</a> を使ってみています．<br/>\n詳しい使い方はきちんとしたドキュメントがあるのでそちらを参照してください．<br/>\nざっくりいうと <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> の <a href=\"https://hackage.haskell.org/package/parsec\">parsec: Monadic parser combinators | Hackage</a> の Rust 版という感じです．</p>\n\n<p>(ちなみに私も combine を参考に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>を作ってみたりしました. )\n<iframe src=\"http://agtn.hatenablog.com/embed/2016/04/30/003009\" title=\"C++ でパーサコンビネータを書きました - 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://agtn.hatenablog.com/entry/2016/04/30/003009\">agtn.hatenablog.com</a></cite></p>\n\n<p>で、このライブラリ、とても<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なコードで書かれているので、かなり<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間が増加します&hellip; (Boost.Spirit 系に近いです． <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーなどは遥かに読みやすいのであまり困ることはないですが)  <br/>\nパーサを書いている時にはテストは頻繁に行いたいので，ちょっと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>がおそいのはつらい．</p>\n\n<p>なにか解決策はないかなぁと思っていたら本家に issue がたっていました．<br/>\n<a href=\"https://github.com/Marwes/combine/issues/21\">Extremely long compile times · Issue #21 · Marwes/combine</a></p>\n\n<p>今回この issue にかかれていた内容を検証してみたので，ここでまとめておこうと思います．</p>\n\n<h2>結論</h2>\n\n<p>パーサの定義を，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体のメソッドとして定義すると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間が大幅に短くなる</p>\n\n<h2>方法</h2>\n\n<p>まずはじめに言われているのは，入力ストリーム型を<code>I: Stream&lt;Item=char&gt;</code> から <code>&amp;str</code> にしてしまうという方法です．</p>\n\n<blockquote><p>(It might be possible to specialize the parsers directly as well, say\n<code>\nfn expr(input: State&lt;&amp;str&gt;) -&gt; ParseResult&lt;Expr, &amp;str&gt;\n</code>\ninstead of\n<code>\nfn expr&lt;I: Stream&gt;(input: State&lt;I&gt;) -&gt; ParseResult&lt;I, &amp;str&gt;\n</code>\n)</p></blockquote>\n\n<p>これは作ったパーサを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な入力に対して適用することができなくなりますが，ライブラリの利用者側としては，<code>char</code> のストリームといったらだいたい <code>&amp;str</code> だと思うので，ぶっちゃけ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>じゃなくてもいいじゃんという感じです．</p>\n\n<p>そしてもう一つが,  <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体を作って，パーサの定義をその中に閉じ込めるという方法です．<br/>\nちょっとこちらはコード例を実際に見たほうがわかりやすいと思うので後で説明します．</p>\n\n<h2>実験コード</h2>\n\n<p>というわけで，</p>\n\n<ol>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なパーサ</li>\n<li>&amp;str のみを受理するパーサ</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体の中に定義された<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>でないパーサ</li>\n</ol>\n\n<p>の三種類について，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間をはかってみます．</p>\n\n<p>パーサ界のハローワールド，計算機で実験してみます．\nまずは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なパーサです．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synType\">*</span>;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">primitives</span><span class=\"synSpecial\">::</span>Stream;\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">integer</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synIdentifier\">many1</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>_<span class=\"synStatement\">&gt;</span>, _<span class=\"synStatement\">&gt;</span>(<span class=\"synIdentifier\">digit</span>())\n        .<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>is<span class=\"synStatement\">|</span> is.<span class=\"synIdentifier\">into_iter</span>().<span class=\"synIdentifier\">fold</span>(<span class=\"synConstant\">0</span>, <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> lhs <span class=\"synStatement\">+</span> (rhs <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span> <span class=\"synStatement\">-</span> <span class=\"synConstant\">'0'</span> <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span>)))\n        .<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">factor</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synIdentifier\">between</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'('</span>), <span class=\"synType\">char</span>(<span class=\"synConstant\">')'</span>), <span class=\"synIdentifier\">parser</span>(expr)).<span class=\"synIdentifier\">or</span>(<span class=\"synIdentifier\">parser</span>(integer)).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">term</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'*'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'/'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n        <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n            <span class=\"synConstant\">'*'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">*</span> rhs,\n            <span class=\"synConstant\">'/'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">/</span> rhs,\n            _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n        }\n    });\n    <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(factor), op).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">expr</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'+'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'-'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n        <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n            <span class=\"synConstant\">'+'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">+</span> rhs,\n            <span class=\"synConstant\">'-'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">-</span> rhs,\n            _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n        }\n    });\n    <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(term), op).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">parse</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: I) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span>(<span class=\"synType\">i64</span>, I), ParseError<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synIdentifier\">parser</span>(expr).<span class=\"synIdentifier\">parse</span>(input)\n}\n</pre>\n\n<p>それぞれの関数が一つのパーサの役割を担います．それぞれのパーサが独立していて，それぞれ別々に型変数を導入しています．</p>\n\n<p>次に <code>&amp;str</code> だけを受け取るパーサです．これは上記の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なパーサの，型変数を <code>&amp;str</code> に置き換えるだけなのでとても簡単です．<br/>\n一部だけ掲載します．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">expr</span>(input: State<span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, <span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;</span> {\n     <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'+'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'-'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n        <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n            <span class=\"synConstant\">'+'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">+</span> rhs,\n            <span class=\"synConstant\">'-'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">-</span> rhs,\n            _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n        }\n    });\n    <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(term), op).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">parse</span>(input: <span class=\"synType\">&amp;str</span>) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span>(<span class=\"synType\">i64</span>, <span class=\"synType\">&amp;str</span>), ParseError<span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;&gt;</span> {\n    <span class=\"synIdentifier\">parser</span>(expr).<span class=\"synIdentifier\">parse</span>(input)\n}\n</pre>\n\n<p>最後が，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体のメソッド中に，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>でないパーサを定義して閉じ込める方法です．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synType\">*</span>;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">primitives</span><span class=\"synSpecial\">::</span>Stream;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">std</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">marker</span><span class=\"synSpecial\">::</span>PhantomData;\n\n truct P<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(PhantomData<span class=\"synStatement\">&lt;fn</span>(I) <span class=\"synStatement\">-&gt;</span> I<span class=\"synStatement\">&gt;</span>);\n\n<span class=\"synStatement\">impl&lt;</span>I<span class=\"synStatement\">&gt;</span> P<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span> <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span> {\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">integer</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synIdentifier\">many1</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>_<span class=\"synStatement\">&gt;</span>, _<span class=\"synStatement\">&gt;</span>(<span class=\"synIdentifier\">digit</span>())\n            .<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>is<span class=\"synStatement\">|</span> is.<span class=\"synIdentifier\">into_iter</span>().<span class=\"synIdentifier\">fold</span>(<span class=\"synConstant\">0</span>, <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> lhs <span class=\"synStatement\">+</span> (rhs <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span> <span class=\"synStatement\">-</span> <span class=\"synConstant\">'0'</span> <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span>)))\n            .<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">factor</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synIdentifier\">between</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'('</span>), <span class=\"synType\">char</span>(<span class=\"synConstant\">')'</span>), <span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>expr))\n            .<span class=\"synIdentifier\">or</span>(<span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>integer))\n            .<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">term</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'*'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'/'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n            <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n                <span class=\"synConstant\">'*'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">*</span> rhs,\n                <span class=\"synConstant\">'/'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">/</span> rhs,\n                _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n            }\n        });\n        <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>factor), op).<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">expr</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'+'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'-'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n            <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n                <span class=\"synConstant\">'+'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">+</span> rhs,\n                <span class=\"synConstant\">'-'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">-</span> rhs,\n                _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n            }\n        });\n        <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>term), op).<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">parse</span>(input: <span class=\"synType\">&amp;str</span>) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span>(<span class=\"synType\">i64</span>, <span class=\"synType\">&amp;str</span>), ParseError<span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;&gt;</span> {\n    <span class=\"synIdentifier\">parser</span>(<span class=\"synPreProc\">P</span><span class=\"synSpecial\">::</span>expr).<span class=\"synIdentifier\">parse</span>(input)\n}\n</pre>\n\n<p>言葉で説明すると難しいのですが，型変数を導入する部分を構造体の定義部分だけにしてあげることで，型変数をそれぞれのパーサが別々に導入する必要がなくなっています．<br/>\nコードも割りとすっきりしますね．</p>\n\n<h2>結果</h2>\n\n<p>上記をコードを <code>cfg</code> を使って<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時に切り替えながら<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>してみました．<br/>\n本当はきちんと繰り返し計測すべきですが，ちょっとサボっています．まぁ何度実行してもだいたい同じくらいになったので許してください．</p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left;\"> 実装方法 </th>\n<th style=\"text-align:right;\"> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left;\"> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a> </td>\n<td style=\"text-align:right;\"> 2.666s </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> <code>&amp;str</code> </td>\n<td style=\"text-align:right;\"> 1.70s </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> 構造体内で定義 </td>\n<td style=\"text-align:right;\"> 1.55s </td>\n</tr>\n</tbody>\n</table>\n\n<p>このような結果になりました．<br/>\nつまり，先ほどの issue で述べられている<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間の短縮方法はかなり効き目があるということですね．<br/>\n構造体の中に閉じ込める方法が，<code>&amp;str</code> しか受理しないようにする方法よりもはやく<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>できるのは意外でした&hellip; 参照を引数にとると暗黙に lifetime 変数が導入されたと記憶しているので，その関係なのかな？</p>\n\n<p>構造体内で定義する方法では，<code>&amp;str</code> 以外の入力ストリーム型を受けつけることを可能にしつつも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間を短縮できるということで，積極的にこの方式でパーサを定義するべきということがわかりました．</p>\n\n<p>注意点として，構造体内で別のパーサを呼ぶときには，必ず <code>P::term</code> という形ではなく，<code>P::&lt;I&gt;::term</code> という形で呼び出すようにする必要があるようです．<br/>\nきちんと明示的に指定しないと，結局<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>するはめになって意味がないということのようです．</p>\n\n---\n\nCOMMENT:\nAUTHOR: anevaden\nEMAIL: pgbsajrq@gmail.com\nURL: http://cialisvipsale.com\nIP: 60.173.69.118\nDATE: 03/24/2018 13:14:29\n\nRegards. Quite a lot of posts.\n\ntadalafil 20 mg <a href=\"http://cialisvipsale.com\">cialis tablets australia</a>\ninteractions for cialis <a href=\"http://cialisvipsale.com\">http://cialisvipsale.com</a>\ncialis 5mg prix <a href=\"http://cialisvipsale.com\">cialis generico</a>\ncialis dose 30mg\n\n---\n\n---\n","contentMarkdown":"\n<p>Rust のパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>ライブラリの一つである <a href=\"https://github.com/Marwes/combine\">Marwes/combine: A parser combinator library for Rust</a> を使ってみています．<br/>\n詳しい使い方はきちんとしたドキュメントがあるのでそちらを参照してください．<br/>\nざっくりいうと <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> の <a href=\"https://hackage.haskell.org/package/parsec\">parsec: Monadic parser combinators | Hackage</a> の Rust 版という感じです．</p>\n\n<p>(ちなみに私も combine を参考に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>を作ってみたりしました. )\n<iframe src=\"http://agtn.hatenablog.com/embed/2016/04/30/003009\" title=\"C++ でパーサコンビネータを書きました - 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://agtn.hatenablog.com/entry/2016/04/30/003009\">agtn.hatenablog.com</a></cite></p>\n\n<p>で、このライブラリ、とても<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なコードで書かれているので、かなり<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間が増加します&hellip; (Boost.Spirit 系に近いです． <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーなどは遥かに読みやすいのであまり困ることはないですが)  <br/>\nパーサを書いている時にはテストは頻繁に行いたいので，ちょっと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>がおそいのはつらい．</p>\n\n<p>なにか解決策はないかなぁと思っていたら本家に issue がたっていました．<br/>\n<a href=\"https://github.com/Marwes/combine/issues/21\">Extremely long compile times · Issue #21 · Marwes/combine</a></p>\n\n<p>今回この issue にかかれていた内容を検証してみたので，ここでまとめておこうと思います．</p>\n\n<h2>結論</h2>\n\n<p>パーサの定義を，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体のメソッドとして定義すると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間が大幅に短くなる</p>\n\n<h2>方法</h2>\n\n<p>まずはじめに言われているのは，入力ストリーム型を<code>I: Stream&lt;Item=char&gt;</code> から <code>&amp;str</code> にしてしまうという方法です．</p>\n\n<blockquote><p>(It might be possible to specialize the parsers directly as well, say\n<code>\nfn expr(input: State&lt;&amp;str&gt;) -&gt; ParseResult&lt;Expr, &amp;str&gt;\n</code>\ninstead of\n<code>\nfn expr&lt;I: Stream&gt;(input: State&lt;I&gt;) -&gt; ParseResult&lt;I, &amp;str&gt;\n</code>\n)</p></blockquote>\n\n<p>これは作ったパーサを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な入力に対して適用することができなくなりますが，ライブラリの利用者側としては，<code>char</code> のストリームといったらだいたい <code>&amp;str</code> だと思うので，ぶっちゃけ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>じゃなくてもいいじゃんという感じです．</p>\n\n<p>そしてもう一つが,  <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体を作って，パーサの定義をその中に閉じ込めるという方法です．<br/>\nちょっとこちらはコード例を実際に見たほうがわかりやすいと思うので後で説明します．</p>\n\n<h2>実験コード</h2>\n\n<p>というわけで，</p>\n\n<ol>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なパーサ</li>\n<li>&amp;str のみを受理するパーサ</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体の中に定義された<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>でないパーサ</li>\n</ol>\n\n<p>の三種類について，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間をはかってみます．</p>\n\n<p>パーサ界のハローワールド，計算機で実験してみます．\nまずは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なパーサです．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synType\">*</span>;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">primitives</span><span class=\"synSpecial\">::</span>Stream;\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">integer</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synIdentifier\">many1</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>_<span class=\"synStatement\">&gt;</span>, _<span class=\"synStatement\">&gt;</span>(<span class=\"synIdentifier\">digit</span>())\n        .<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>is<span class=\"synStatement\">|</span> is.<span class=\"synIdentifier\">into_iter</span>().<span class=\"synIdentifier\">fold</span>(<span class=\"synConstant\">0</span>, <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> lhs <span class=\"synStatement\">+</span> (rhs <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span> <span class=\"synStatement\">-</span> <span class=\"synConstant\">'0'</span> <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span>)))\n        .<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">factor</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synIdentifier\">between</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'('</span>), <span class=\"synType\">char</span>(<span class=\"synConstant\">')'</span>), <span class=\"synIdentifier\">parser</span>(expr)).<span class=\"synIdentifier\">or</span>(<span class=\"synIdentifier\">parser</span>(integer)).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">term</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'*'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'/'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n        <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n            <span class=\"synConstant\">'*'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">*</span> rhs,\n            <span class=\"synConstant\">'/'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">/</span> rhs,\n            _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n        }\n    });\n    <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(factor), op).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">expr</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'+'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'-'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n        <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n            <span class=\"synConstant\">'+'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">+</span> rhs,\n            <span class=\"synConstant\">'-'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">-</span> rhs,\n            _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n        }\n    });\n    <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(term), op).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">parse</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: I) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span>(<span class=\"synType\">i64</span>, I), ParseError<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synIdentifier\">parser</span>(expr).<span class=\"synIdentifier\">parse</span>(input)\n}\n</pre>\n\n<p>それぞれの関数が一つのパーサの役割を担います．それぞれのパーサが独立していて，それぞれ別々に型変数を導入しています．</p>\n\n<p>次に <code>&amp;str</code> だけを受け取るパーサです．これは上記の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なパーサの，型変数を <code>&amp;str</code> に置き換えるだけなのでとても簡単です．<br/>\n一部だけ掲載します．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">expr</span>(input: State<span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, <span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;</span> {\n     <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'+'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'-'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n        <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n            <span class=\"synConstant\">'+'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">+</span> rhs,\n            <span class=\"synConstant\">'-'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">-</span> rhs,\n            _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n        }\n    });\n    <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(term), op).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">parse</span>(input: <span class=\"synType\">&amp;str</span>) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span>(<span class=\"synType\">i64</span>, <span class=\"synType\">&amp;str</span>), ParseError<span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;&gt;</span> {\n    <span class=\"synIdentifier\">parser</span>(expr).<span class=\"synIdentifier\">parse</span>(input)\n}\n</pre>\n\n<p>最後が，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体のメソッド中に，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>でないパーサを定義して閉じ込める方法です．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synType\">*</span>;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">primitives</span><span class=\"synSpecial\">::</span>Stream;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">std</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">marker</span><span class=\"synSpecial\">::</span>PhantomData;\n\n truct P<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(PhantomData<span class=\"synStatement\">&lt;fn</span>(I) <span class=\"synStatement\">-&gt;</span> I<span class=\"synStatement\">&gt;</span>);\n\n<span class=\"synStatement\">impl&lt;</span>I<span class=\"synStatement\">&gt;</span> P<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span> <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span> {\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">integer</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synIdentifier\">many1</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>_<span class=\"synStatement\">&gt;</span>, _<span class=\"synStatement\">&gt;</span>(<span class=\"synIdentifier\">digit</span>())\n            .<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>is<span class=\"synStatement\">|</span> is.<span class=\"synIdentifier\">into_iter</span>().<span class=\"synIdentifier\">fold</span>(<span class=\"synConstant\">0</span>, <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> lhs <span class=\"synStatement\">+</span> (rhs <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span> <span class=\"synStatement\">-</span> <span class=\"synConstant\">'0'</span> <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span>)))\n            .<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">factor</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synIdentifier\">between</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'('</span>), <span class=\"synType\">char</span>(<span class=\"synConstant\">')'</span>), <span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>expr))\n            .<span class=\"synIdentifier\">or</span>(<span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>integer))\n            .<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">term</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'*'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'/'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n            <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n                <span class=\"synConstant\">'*'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">*</span> rhs,\n                <span class=\"synConstant\">'/'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">/</span> rhs,\n                _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n            }\n        });\n        <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>factor), op).<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">expr</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'+'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'-'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n            <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n                <span class=\"synConstant\">'+'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">+</span> rhs,\n                <span class=\"synConstant\">'-'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">-</span> rhs,\n                _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n            }\n        });\n        <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>term), op).<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">parse</span>(input: <span class=\"synType\">&amp;str</span>) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span>(<span class=\"synType\">i64</span>, <span class=\"synType\">&amp;str</span>), ParseError<span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;&gt;</span> {\n    <span class=\"synIdentifier\">parser</span>(<span class=\"synPreProc\">P</span><span class=\"synSpecial\">::</span>expr).<span class=\"synIdentifier\">parse</span>(input)\n}\n</pre>\n\n<p>言葉で説明すると難しいのですが，型変数を導入する部分を構造体の定義部分だけにしてあげることで，型変数をそれぞれのパーサが別々に導入する必要がなくなっています．<br/>\nコードも割りとすっきりしますね．</p>\n\n<h2>結果</h2>\n\n<p>上記をコードを <code>cfg</code> を使って<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時に切り替えながら<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>してみました．<br/>\n本当はきちんと繰り返し計測すべきですが，ちょっとサボっています．まぁ何度実行してもだいたい同じくらいになったので許してください．</p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left;\"> 実装方法 </th>\n<th style=\"text-align:right;\"> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left;\"> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a> </td>\n<td style=\"text-align:right;\"> 2.666s </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> <code>&amp;str</code> </td>\n<td style=\"text-align:right;\"> 1.70s </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> 構造体内で定義 </td>\n<td style=\"text-align:right;\"> 1.55s </td>\n</tr>\n</tbody>\n</table>\n\n<p>このような結果になりました．<br/>\nつまり，先ほどの issue で述べられている<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間の短縮方法はかなり効き目があるということですね．<br/>\n構造体の中に閉じ込める方法が，<code>&amp;str</code> しか受理しないようにする方法よりもはやく<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>できるのは意外でした&hellip; 参照を引数にとると暗黙に lifetime 変数が導入されたと記憶しているので，その関係なのかな？</p>\n\n<p>構造体内で定義する方法では，<code>&amp;str</code> 以外の入力ストリーム型を受けつけることを可能にしつつも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間を短縮できるということで，積極的にこの方式でパーサを定義するべきということがわかりました．</p>\n\n<p>注意点として，構造体内で別のパーサを呼ぶときには，必ず <code>P::term</code> という形ではなく，<code>P::&lt;I&gt;::term</code> という形で呼び出すようにする必要があるようです．<br/>\nきちんと明示的に指定しないと，結局<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>するはめになって意味がないということのようです．</p>\n\n---\n\nCOMMENT:\nAUTHOR: anevaden\nEMAIL: pgbsajrq@gmail.com\nURL: http://cialisvipsale.com\nIP: 60.173.69.118\nDATE: 03/24/2018 13:14:29\n\nRegards. Quite a lot of posts.\n\ntadalafil 20 mg <a href=\"http://cialisvipsale.com\">cialis tablets australia</a>\ninteractions for cialis <a href=\"http://cialisvipsale.com\">http://cialisvipsale.com</a>\ncialis 5mg prix <a href=\"http://cialisvipsale.com\">cialis generico</a>\ncialis dose 30mg\n\n---\n\n---\n","slug":"Rust_のパーサコンビネータライブラリ_combine_を使う時の_tips","title":"Rust のパーサコンビネータライブラリ combine を使う時の tips","timestamp":1463241799000,"tags":[]},{"rawMarkdown":"---\ntitle: \"C++ でパーサコンビネータを書きました\"\ndate: 2016-04-29T15:30:09.000Z\ntags: []\n---\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>といえば，Boost.Spirit や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/yacc\">yacc</a>系などが有名ですが，どうにも使うの辛かったので作りました．</p>\n\n<h3>2016/05/01 追記　</h3>\n\n<p>いろいろ更新しました．肯定先読み以外はプリミティブも実装し終わっているかと思います．<br/>\nドキュメントはまだ無いのですが，すべての機能についてテストは書いてあるので，それを見てもらえればなんとか使い方もわかるかと思います．</p>\n\n<p><a href=\"https://github.com/agatan/coco\">agatan/coco</a></p>\n\n<p><code>coco::combix</code> がパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>ライブラリの namespace です．</p>\n\n<p>Boost.Spirit は高機能かつ高性能なんですが，かなり変態的な構文で記述する必要があり(まぁ <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> なんですけど)，さらにその性能や便利さ，構文のために異常なまでにテンプレートを多用しています．私は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>後の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%CC%DA\">構文木</a>の構築に Boost.Variant を使ってみているのですが，Boost.Spirit と Boost.Variant の両面から，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>すぎるがゆえの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラー爆発攻撃を食らって本当に辛いです．</p>\n\n<p>そこで，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> の <a href=\"https://hackage.haskell.org/package/parsec\">parsec</a> や Rust の <a href=\"https://github.com/Marwes/combine\">combine</a> を参考にしつつ，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>を書いてみました．(実際これを使っても<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーは割りと発狂しますが)</p>\n\n<h2>例</h2>\n\n<p>例となるコードは <a href=\"https://github.com/agatan/coco-combix-demo\">agatan/coco-combix-demo</a> においてあります．<br/>\nドキュメントもないので，なんとなく雰囲気だけコードから読み取る必要があります．(例に出ていない機能もちょいちょい実装されてしまっています．)</p>\n\n<p>以下にちょっと簡略版のコードを載せてみます．ありがちな電卓です．AST を作らず直接計算しています．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;functional&gt;</span>\n\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;coco/combix.hpp&gt;</span>\n\n<span class=\"synType\">namespace</span> cbx = coco::combix;\n\n<span class=\"synStatement\">using</span> stream_type = cbx::iterator_stream&lt;std::string::const_iterator&gt;;\n\ncbx::parser&lt;<span class=\"synType\">int</span>, stream_type&gt; expression();\n\ncbx::parser&lt;<span class=\"synType\">int</span>, stream_type&gt; number() {\n  <span class=\"synStatement\">return</span> cbx::expected(cbx::map(cbx::many1(cbx::digit()),\n                                [](<span class=\"synType\">auto</span>&amp;&amp; is) <span class=\"synError\">{</span>\n                                  <span class=\"synType\">int</span> acc = <span class=\"synConstant\">0</span>;\n                                  <span class=\"synStatement\">for</span> (<span class=\"synType\">auto</span> i : is) <span class=\"synError\">{</span>\n                                    acc = acc * <span class=\"synConstant\">10</span> + i;\n                                  <span class=\"synError\">}</span>\n                                  <span class=\"synStatement\">return</span> acc;\n                                }<span class=\"synError\">)</span>,\n                       <span class=\"synConstant\">&quot;integer number&quot;</span><span class=\"synError\">)</span>;\n}\n\ncbx::parser&lt;<span class=\"synType\">int</span>, stream_type&gt; factor() {\n  <span class=\"synStatement\">return</span> cbx::choice(\n      number(),\n      cbx::between(cbx::skip(cbx::token(<span class=\"synConstant\">'('</span>), cbx::spaces()),\n                   cbx::skip(cbx::token(<span class=\"synConstant\">')'</span>), cbx::spaces()),\n                   cbx::skip(cbx::lazy_fun(expression), cbx::spaces())));\n}\n\ncbx::parser&lt;<span class=\"synType\">int</span>, stream_type&gt; term() {\n  <span class=\"synType\">auto</span> op = cbx::map(\n      cbx::skip(cbx::choice(cbx::token(<span class=\"synConstant\">'*'</span>), cbx::token(<span class=\"synConstant\">'/'</span>)), cbx::spaces()),\n      [](<span class=\"synType\">auto</span> c) -&gt; std::function&lt;<span class=\"synType\">int</span>(<span class=\"synType\">int</span>, <span class=\"synType\">int</span>)&gt; <span class=\"synError\">{</span>\n        <span class=\"synStatement\">if</span> (c == <span class=\"synConstant\">'*'</span>) <span class=\"synError\">{</span>\n          <span class=\"synStatement\">return</span> std::multiplies&lt;<span class=\"synType\">int</span>&gt;();\n        <span class=\"synError\">}</span> <span class=\"synStatement\">else</span> <span class=\"synError\">{</span>\n          <span class=\"synStatement\">return</span> std::divides&lt;<span class=\"synType\">int</span>&gt;();\n        <span class=\"synError\">}</span>\n      }<span class=\"synError\">)</span>;\n  <span class=\"synStatement\">return</span> cbx::chainl1(cbx::skip(factor(), cbx::spaces()), op);\n}\n\ncbx::parser&lt;<span class=\"synType\">int</span>, stream_type&gt; expression() {\n  <span class=\"synType\">auto</span> op = cbx::map(\n      cbx::skip(cbx::choice(cbx::token(<span class=\"synConstant\">'+'</span>), cbx::token(<span class=\"synConstant\">'-'</span>)), cbx::spaces()),\n      [](<span class=\"synType\">auto</span> c) -&gt; std::function&lt;<span class=\"synType\">int</span>(<span class=\"synType\">int</span>, <span class=\"synType\">int</span>)&gt; <span class=\"synError\">{</span>\n        <span class=\"synStatement\">if</span> (c == <span class=\"synConstant\">'+'</span>) <span class=\"synError\">{</span>\n          <span class=\"synStatement\">return</span> std::plus&lt;<span class=\"synType\">int</span>&gt;();\n        <span class=\"synError\">}</span> <span class=\"synStatement\">else</span> <span class=\"synError\">{</span>\n          <span class=\"synStatement\">return</span> std::minus&lt;<span class=\"synType\">int</span>&gt;();\n        <span class=\"synError\">}</span>\n      }<span class=\"synError\">)</span>;\n  <span class=\"synStatement\">return</span> cbx::chainl1(cbx::skip(term(), cbx::spaces()), op);\n}\n\n<span class=\"synType\">int</span> main() {\n  std::string src;\n  std::getline(std::cin, src);\n  <span class=\"synType\">auto</span> n = number();\n  <span class=\"synType\">auto</span> stream = cbx::range_stream(src);\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> parser = expression();\n  <span class=\"synStatement\">if</span> (<span class=\"synType\">auto</span> res = cbx::parse(parser, stream)) {\n    std::cout &lt;&lt; res.unwrap() &lt;&lt; std::endl;\n  } <span class=\"synStatement\">else</span> {\n    std::cout &lt;&lt; cbx::to_string(res.unwrap_error()) &lt;&lt; std::endl;\n  }\n}\n</pre>\n\n<h2>特徴</h2>\n\n<p>parsec を知っている方であれば読めるはずです...<br/>\n特徴としては，多くのパーサは入力ストリームの型に依存せずに作れるようになっていることです．例えば，あらゆる入力一つを受け付け消費する <code>any</code> というパーサは，入力が <code>char</code> のストリームであろうと <code>int</code> のストリームであろうとパースを実行できるようになっています．<br/>\n本来はエラーメッセージの爆発や読みづらさを防ぐために，すべてのパーサ自体にストリームの型をひも付けたかったのですが，そうすると，<code>any</code> を使うたびに，<code>any&lt;cbx::iterator_stream&lt;typename std::vector&lt;int&gt;::const_iterator&gt;&gt;()</code> とか <code>any&lt;cbx::iterator_stream&lt;std::string::const_iterator&gt;&gt;()</code> とかしなくてはなりません．これは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> や Rust と違って <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>が限定的であるためです．(<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> や Rust では後でその値がどう使われているかも推論の根拠として使われます．)<br/>\nそこで，パーサ自体には入力ストリームの型を指定させずに，実際にパースする部分で初めて入力ストリームの型を検査することにしました．</p>\n\n<p>で，<code>cbx::parser&lt;int, stream_type&gt;</code> はパーサを type erasure を使ってラップします．普通に使っていると簡単に <code>cbx::expected&lt;cbx::map_parser&lt;cbx::many1_parser&lt;cbx::digit_parser&gt;, (lambda at ...)&gt;&gt;</code> 型とかが出てきます(<code>cbx::expected(cbx::map(cbx::many1(cbx::digit()), [](auto&amp;&amp;) {...}), \"integer number\")</code> の型です)<br/>\nこれを関数定義のたびに書くとか発狂してしまうので，type erasure を使って型をラップし短絡します．<br/>\nただしパフォーマンスの観点から行くとおそらく型をラップするために仮想関数を使ってしまうので，インライン展開等がきかなくなると思われます．まぁ仕方ないです．<br/>\nただ，型を膨らませすぎずに適度にラップしてやると，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーの内容がかなり読みやすくなるはずです．なのでなんかわからんけどエラーになるっていうときは細かくパーサを分割してラップしてやると良いかもしれません．</p>\n\n<h2>まとめ</h2>\n\n<p>あまりにもドキュメントやコメント書かなすぎてひどいですが，ちょっと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>したいとかっていうときに便利だと思います．<br/>\nBoost.Spirit と違って普通に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のプログラムとして書けます．(Boost.Spirit も <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> プログラムとして書けてはいるんですが，なんかあれはあれで別の言語を覚えているような気分になってしまったので...)</p>\n\n<p>あと PEG のプリミティブをまだ完全に実装していないと思います．先読みや否定先読みが出来ません．(実装します…)</p>\n\n---\n\n---\n","contentMarkdown":"\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>といえば，Boost.Spirit や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/yacc\">yacc</a>系などが有名ですが，どうにも使うの辛かったので作りました．</p>\n\n<h3>2016/05/01 追記　</h3>\n\n<p>いろいろ更新しました．肯定先読み以外はプリミティブも実装し終わっているかと思います．<br/>\nドキュメントはまだ無いのですが，すべての機能についてテストは書いてあるので，それを見てもらえればなんとか使い方もわかるかと思います．</p>\n\n<p><a href=\"https://github.com/agatan/coco\">agatan/coco</a></p>\n\n<p><code>coco::combix</code> がパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>ライブラリの namespace です．</p>\n\n<p>Boost.Spirit は高機能かつ高性能なんですが，かなり変態的な構文で記述する必要があり(まぁ <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> なんですけど)，さらにその性能や便利さ，構文のために異常なまでにテンプレートを多用しています．私は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>後の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%CC%DA\">構文木</a>の構築に Boost.Variant を使ってみているのですが，Boost.Spirit と Boost.Variant の両面から，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>すぎるがゆえの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラー爆発攻撃を食らって本当に辛いです．</p>\n\n<p>そこで，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> の <a href=\"https://hackage.haskell.org/package/parsec\">parsec</a> や Rust の <a href=\"https://github.com/Marwes/combine\">combine</a> を参考にしつつ，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>を書いてみました．(実際これを使っても<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーは割りと発狂しますが)</p>\n\n<h2>例</h2>\n\n<p>例となるコードは <a href=\"https://github.com/agatan/coco-combix-demo\">agatan/coco-combix-demo</a> においてあります．<br/>\nドキュメントもないので，なんとなく雰囲気だけコードから読み取る必要があります．(例に出ていない機能もちょいちょい実装されてしまっています．)</p>\n\n<p>以下にちょっと簡略版のコードを載せてみます．ありがちな電卓です．AST を作らず直接計算しています．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;functional&gt;</span>\n\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;coco/combix.hpp&gt;</span>\n\n<span class=\"synType\">namespace</span> cbx = coco::combix;\n\n<span class=\"synStatement\">using</span> stream_type = cbx::iterator_stream&lt;std::string::const_iterator&gt;;\n\ncbx::parser&lt;<span class=\"synType\">int</span>, stream_type&gt; expression();\n\ncbx::parser&lt;<span class=\"synType\">int</span>, stream_type&gt; number() {\n  <span class=\"synStatement\">return</span> cbx::expected(cbx::map(cbx::many1(cbx::digit()),\n                                [](<span class=\"synType\">auto</span>&amp;&amp; is) <span class=\"synError\">{</span>\n                                  <span class=\"synType\">int</span> acc = <span class=\"synConstant\">0</span>;\n                                  <span class=\"synStatement\">for</span> (<span class=\"synType\">auto</span> i : is) <span class=\"synError\">{</span>\n                                    acc = acc * <span class=\"synConstant\">10</span> + i;\n                                  <span class=\"synError\">}</span>\n                                  <span class=\"synStatement\">return</span> acc;\n                                }<span class=\"synError\">)</span>,\n                       <span class=\"synConstant\">&quot;integer number&quot;</span><span class=\"synError\">)</span>;\n}\n\ncbx::parser&lt;<span class=\"synType\">int</span>, stream_type&gt; factor() {\n  <span class=\"synStatement\">return</span> cbx::choice(\n      number(),\n      cbx::between(cbx::skip(cbx::token(<span class=\"synConstant\">'('</span>), cbx::spaces()),\n                   cbx::skip(cbx::token(<span class=\"synConstant\">')'</span>), cbx::spaces()),\n                   cbx::skip(cbx::lazy_fun(expression), cbx::spaces())));\n}\n\ncbx::parser&lt;<span class=\"synType\">int</span>, stream_type&gt; term() {\n  <span class=\"synType\">auto</span> op = cbx::map(\n      cbx::skip(cbx::choice(cbx::token(<span class=\"synConstant\">'*'</span>), cbx::token(<span class=\"synConstant\">'/'</span>)), cbx::spaces()),\n      [](<span class=\"synType\">auto</span> c) -&gt; std::function&lt;<span class=\"synType\">int</span>(<span class=\"synType\">int</span>, <span class=\"synType\">int</span>)&gt; <span class=\"synError\">{</span>\n        <span class=\"synStatement\">if</span> (c == <span class=\"synConstant\">'*'</span>) <span class=\"synError\">{</span>\n          <span class=\"synStatement\">return</span> std::multiplies&lt;<span class=\"synType\">int</span>&gt;();\n        <span class=\"synError\">}</span> <span class=\"synStatement\">else</span> <span class=\"synError\">{</span>\n          <span class=\"synStatement\">return</span> std::divides&lt;<span class=\"synType\">int</span>&gt;();\n        <span class=\"synError\">}</span>\n      }<span class=\"synError\">)</span>;\n  <span class=\"synStatement\">return</span> cbx::chainl1(cbx::skip(factor(), cbx::spaces()), op);\n}\n\ncbx::parser&lt;<span class=\"synType\">int</span>, stream_type&gt; expression() {\n  <span class=\"synType\">auto</span> op = cbx::map(\n      cbx::skip(cbx::choice(cbx::token(<span class=\"synConstant\">'+'</span>), cbx::token(<span class=\"synConstant\">'-'</span>)), cbx::spaces()),\n      [](<span class=\"synType\">auto</span> c) -&gt; std::function&lt;<span class=\"synType\">int</span>(<span class=\"synType\">int</span>, <span class=\"synType\">int</span>)&gt; <span class=\"synError\">{</span>\n        <span class=\"synStatement\">if</span> (c == <span class=\"synConstant\">'+'</span>) <span class=\"synError\">{</span>\n          <span class=\"synStatement\">return</span> std::plus&lt;<span class=\"synType\">int</span>&gt;();\n        <span class=\"synError\">}</span> <span class=\"synStatement\">else</span> <span class=\"synError\">{</span>\n          <span class=\"synStatement\">return</span> std::minus&lt;<span class=\"synType\">int</span>&gt;();\n        <span class=\"synError\">}</span>\n      }<span class=\"synError\">)</span>;\n  <span class=\"synStatement\">return</span> cbx::chainl1(cbx::skip(term(), cbx::spaces()), op);\n}\n\n<span class=\"synType\">int</span> main() {\n  std::string src;\n  std::getline(std::cin, src);\n  <span class=\"synType\">auto</span> n = number();\n  <span class=\"synType\">auto</span> stream = cbx::range_stream(src);\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> parser = expression();\n  <span class=\"synStatement\">if</span> (<span class=\"synType\">auto</span> res = cbx::parse(parser, stream)) {\n    std::cout &lt;&lt; res.unwrap() &lt;&lt; std::endl;\n  } <span class=\"synStatement\">else</span> {\n    std::cout &lt;&lt; cbx::to_string(res.unwrap_error()) &lt;&lt; std::endl;\n  }\n}\n</pre>\n\n<h2>特徴</h2>\n\n<p>parsec を知っている方であれば読めるはずです...<br/>\n特徴としては，多くのパーサは入力ストリームの型に依存せずに作れるようになっていることです．例えば，あらゆる入力一つを受け付け消費する <code>any</code> というパーサは，入力が <code>char</code> のストリームであろうと <code>int</code> のストリームであろうとパースを実行できるようになっています．<br/>\n本来はエラーメッセージの爆発や読みづらさを防ぐために，すべてのパーサ自体にストリームの型をひも付けたかったのですが，そうすると，<code>any</code> を使うたびに，<code>any&lt;cbx::iterator_stream&lt;typename std::vector&lt;int&gt;::const_iterator&gt;&gt;()</code> とか <code>any&lt;cbx::iterator_stream&lt;std::string::const_iterator&gt;&gt;()</code> とかしなくてはなりません．これは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> や Rust と違って <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>が限定的であるためです．(<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> や Rust では後でその値がどう使われているかも推論の根拠として使われます．)<br/>\nそこで，パーサ自体には入力ストリームの型を指定させずに，実際にパースする部分で初めて入力ストリームの型を検査することにしました．</p>\n\n<p>で，<code>cbx::parser&lt;int, stream_type&gt;</code> はパーサを type erasure を使ってラップします．普通に使っていると簡単に <code>cbx::expected&lt;cbx::map_parser&lt;cbx::many1_parser&lt;cbx::digit_parser&gt;, (lambda at ...)&gt;&gt;</code> 型とかが出てきます(<code>cbx::expected(cbx::map(cbx::many1(cbx::digit()), [](auto&amp;&amp;) {...}), \"integer number\")</code> の型です)<br/>\nこれを関数定義のたびに書くとか発狂してしまうので，type erasure を使って型をラップし短絡します．<br/>\nただしパフォーマンスの観点から行くとおそらく型をラップするために仮想関数を使ってしまうので，インライン展開等がきかなくなると思われます．まぁ仕方ないです．<br/>\nただ，型を膨らませすぎずに適度にラップしてやると，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーの内容がかなり読みやすくなるはずです．なのでなんかわからんけどエラーになるっていうときは細かくパーサを分割してラップしてやると良いかもしれません．</p>\n\n<h2>まとめ</h2>\n\n<p>あまりにもドキュメントやコメント書かなすぎてひどいですが，ちょっと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>したいとかっていうときに便利だと思います．<br/>\nBoost.Spirit と違って普通に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のプログラムとして書けます．(Boost.Spirit も <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> プログラムとして書けてはいるんですが，なんかあれはあれで別の言語を覚えているような気分になってしまったので...)</p>\n\n<p>あと PEG のプリミティブをまだ完全に実装していないと思います．先読みや否定先読みが出来ません．(実装します…)</p>\n\n---\n\n---\n","slug":"C++_でパーサコンビネータを書きました","title":"C++ でパーサコンビネータを書きました","timestamp":1461943809000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Rust における return文の LLVM IR 表現について\"\ndate: 2016-04-13T09:34:03.000Z\ntags: []\n---\n\n<ul>\n<li><code>if</code> 文が値を返す</li>\n<li><code>return</code> 文を持つ</li>\n</ul>\n\n<p>以上のような特徴を持つ言語はどういう感じで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>されるのか知りたくて，Rust について調べてみました．</p>\n\n<p>Rust では以下の様なことが出来ます．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">f</span>() {\n  <span class=\"synStatement\">let</span> x = <span class=\"synStatement\">if</span> cond {\n    return None;\n  } <span class=\"synStatement\">else</span> {\n    <span class=\"synConstant\">1</span>\n  };\n  ...\n}\n</pre>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scala\">Scala</a> とかもできると思います．<code>cond</code> が真だった場合は，<code>x</code> の値を返すのではなく，関数から抜けてしまうという意味です．</p>\n\n<p>これを Rust ではどんな <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR に落とし込んでいるのか．</p>\n\n<h1><code>return</code> 文がない場合</h1>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">noreturn</span>(x: isize) -&gt; isize {\n  x\n}\n</pre>\n\n<p>最も単純な場合です．この場合，生成される <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR は，</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>define internal i64 @_ZN4hoge8noreturn17h811bf1a871f85432E(i64) unnamed_addr #0 {\nentry-block:\n  %x = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  ret i64 %1\n}</pre>\n\n<p>となります．\n名前がマングルされていますが，上記の <code>noreturn</code> 関数です．\nやっていることは単純で，第一引数を読み込んで返すだけです．</p>\n\n<h1><code>return</code> に相当する文が一つのみの場合</h1>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">onereturn</span>(x: isize) -&gt; isize {\n  <span class=\"synStatement\">let</span> y = <span class=\"synStatement\">if</span> x == <span class=\"synConstant\">0</span> {\n    <span class=\"synConstant\">1</span>\n  } <span class=\"synStatement\">else</span> {\n    x\n  };\n  return x;\n}\n</pre>\n\n<p>実際に値を返す部分が一箇所しかない場合です．途中に分岐があっても最終的に一箇所になっていれば多分同じ結果になります．</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>define internal i64 @_ZN4hoge9onereturn17h8b718f32daa6a379E(i64) unnamed_addr #0 {\nentry-block:\n  %x = alloca i64\n  %y = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  %2 = icmp eq i64 %1, 0\n  br i1 %2, label %then-block-18-, label %else-block\n\nthen-block-18-:                                   ; preds = %entry-block\n  store i64 1, i64* %y\n  br label %join\n\nelse-block:                                       ; preds = %entry-block\n  %3 = load i64, i64* %x\n  store i64 %3, i64* %y\n  br label %join\n\njoin:                                             ; preds = %else-block, %then-block-18-\n  %4 = load i64, i64* %x\n  br label %clean_ast_10_\n\nreturn:                                           ; preds = %clean_ast_10_\n  ret i64 %4\n\nclean_ast_10_:                                    ; preds = %join\n  br label %return\n}</pre>\n\n<p><code>return</code> という BasicBlock ができています．これは <code>return</code> 文が現れると作られるよう？です．\nで，その中では単純に <code>x</code> に該当する値を返しています．</p>\n\n<p>最後の <code>return x;</code> 文を 単純に <code>x</code> に置き換えてみると，</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>define internal i64 @_ZN4hoge9onereturn17h8b718f32daa6a379E(i64) unnamed_addr #0 {\nentry-block:\n  %x = alloca i64\n  %y = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  %2 = icmp eq i64 %1, 0\n  br i1 %2, label %then-block-18-, label %else-block\n\nthen-block-18-:                                   ; preds = %entry-block\n  store i64 1, i64* %y\n  br label %join\n\nelse-block:                                       ; preds = %entry-block\n  %3 = load i64, i64* %x\n  store i64 %3, i64* %y\n  br label %join\n\njoin:                                             ; preds = %else-block, %then-block-18-\n  %4 = load i64, i64* %x\n  ret i64 %4\n}</pre>\n\n<p>となります． <code>return</code> ブロックが消えていますね．なので <code>return</code> 文があると <code>return</code> ブロックが作られる、で良さそう？</p>\n\n<h1><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>のパスから値を返す</h1>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">multireturn</span>(x: isize) -&gt; isize {\n  <span class=\"synStatement\">let</span> y = <span class=\"synStatement\">if</span> x == <span class=\"synConstant\">0</span> {\n    return -<span class=\"synConstant\">1</span>;\n  } <span class=\"synStatement\">else</span> {\n    x\n  };\n  y\n}\n</pre>\n\n<p>さて，では最初に述べた，<code>if</code> の分岐内にある <code>return</code> についてです．\nこれは，</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>define internal i64 @_ZN4hoge11multireturn17had379e8ce5a18f08E(i64) unnamed_addr #0 {\nentry-block:\n  %sret_slot = alloca i64\n  %x = alloca i64\n  %y = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  %2 = icmp eq i64 %1, 0\n  br i1 %2, label %then-block-18-, label %else-block\n\nthen-block-18-:                                   ; preds = %entry-block\n  store i64 -1, i64* %sret_slot\n  br label %return\n\nelse-block:                                       ; preds = %entry-block\n  %3 = load i64, i64* %x\n  store i64 %3, i64* %y\n  br label %join\n\njoin:                                             ; preds = %else-block\n  %4 = load i64, i64* %y\n  store i64 %4, i64* %sret_slot\n  br label %return\n\nreturn:                                           ; preds = %join, %then-block-18-\n  %5 = load i64, i64* %sret_slot\n  ret i64 %5\n}</pre>\n\n<p>こうなりました．\nまず，<code>return</code> 文があるため？，<code>return</code> ブロックが作られています．\nしかし今回は，パスによって返すものが違います．(値が違うという意味ではなく，同じ変数ですらないという意味です...)</p>\n\n<p>よく IR を読むと，関数の頭で <code>%sret_slot</code> という名前でスタック領域を確保していることがわかります．\nそして，<code>return</code> ブロック内では，これを読んできて返しています．<br/>\nさらに，<code>if</code> 文の then 節にあたる，<code>then-block-18-</code> というブロックでは，<code>%sret_slot</code> に値を格納して <code>return</code> ブロックへジャンプしています．\nelse 節のあとの部分 (<code>join</code> ブロック) でも同様に, <code>%sret_slot</code> に値を格納して <code>return</code> ブロックへジャンプしています．</p>\n\n<h1>まとめ</h1>\n\n<p>というわけで，様々な Rust コードを <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR に変換して見てみた結果，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>のパスから値を返す場合は，「ローカル変数として返り値を定義し，そこに返したい値を格納してから <code>return</code> に goto」という形になっていることがわかりました．</p>\n\n<p>(ほとんど <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR を乗っけるだけになってしまった...)</p>\n\n<h2>ちなみに ...</h2>\n\n<h1><code>if</code> 文の返す値をそのまま返す</h1>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">ifreturn</span>(x: isize) -&gt; isize {\n  <span class=\"synStatement\">if</span> x == <span class=\"synConstant\">0</span> {\n    <span class=\"synConstant\">1</span>\n  } <span class=\"synStatement\">else</span> {\n    x\n  }\n}\n</pre>\n\n<p>Rust に慣れていないとちょっとわかりにくいですが，<code>x == 0</code> の場合は 1 を返し，そうでない場合は <code>x</code> を返す関数です．</p>\n\n<p>これは，</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>define internal i64 @_ZN4hoge8ifreturn17hcdaab6e376d6c95cE(i64) unnamed_addr #0 {\nentry-block:\n  %sret_slot = alloca i64\n  %x = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  %2 = icmp eq i64 %1, 0\n  br i1 %2, label %then-block-15-, label %else-block\n\nthen-block-15-:                                   ; preds = %entry-block\n  store i64 1, i64* %sret_slot\n  br label %join\n\nelse-block:                                       ; preds = %entry-block\n  %3 = load i64, i64* %x\n  store i64 %3, i64* %sret_slot\n  br label %join\n\njoin:                                             ; preds = %else-block, %then-block-15-\n  %4 = load i64, i64* %sret_slot\n  ret i64 %4\n}</pre>\n\n<p>こうなります．やっていることは上記の例たちとあまり変わりません．\nしかし，<code>return</code> 文がないので？，<code>return</code> ブロックが作られていません．が, <code>%sret_slot</code> は定義されていますね...<br/>\nこれはどういうことなんでしょう．<code>rustc</code> のコードを読むべきなのかもしれませんが，イマイチ内部処理が想像しにくいです...</p>\n\n<p>普通に翻訳していったら，</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>let x = if x == 0 { 1 } else { x };\nx</pre>\n\n<p>と同じ感じになる気がするので，<code>%sret_slot</code> という名前が出てくる余地は無い気がするのですが...(実質同じ処理ではあります)\n分岐が直接返戻値になる場合は特別扱いしているのかな？</p>\n\n---\n\n---\n","contentMarkdown":"\n<ul>\n<li><code>if</code> 文が値を返す</li>\n<li><code>return</code> 文を持つ</li>\n</ul>\n\n<p>以上のような特徴を持つ言語はどういう感じで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>されるのか知りたくて，Rust について調べてみました．</p>\n\n<p>Rust では以下の様なことが出来ます．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">f</span>() {\n  <span class=\"synStatement\">let</span> x = <span class=\"synStatement\">if</span> cond {\n    return None;\n  } <span class=\"synStatement\">else</span> {\n    <span class=\"synConstant\">1</span>\n  };\n  ...\n}\n</pre>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scala\">Scala</a> とかもできると思います．<code>cond</code> が真だった場合は，<code>x</code> の値を返すのではなく，関数から抜けてしまうという意味です．</p>\n\n<p>これを Rust ではどんな <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR に落とし込んでいるのか．</p>\n\n<h1><code>return</code> 文がない場合</h1>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">noreturn</span>(x: isize) -&gt; isize {\n  x\n}\n</pre>\n\n<p>最も単純な場合です．この場合，生成される <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR は，</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>define internal i64 @_ZN4hoge8noreturn17h811bf1a871f85432E(i64) unnamed_addr #0 {\nentry-block:\n  %x = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  ret i64 %1\n}</pre>\n\n<p>となります．\n名前がマングルされていますが，上記の <code>noreturn</code> 関数です．\nやっていることは単純で，第一引数を読み込んで返すだけです．</p>\n\n<h1><code>return</code> に相当する文が一つのみの場合</h1>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">onereturn</span>(x: isize) -&gt; isize {\n  <span class=\"synStatement\">let</span> y = <span class=\"synStatement\">if</span> x == <span class=\"synConstant\">0</span> {\n    <span class=\"synConstant\">1</span>\n  } <span class=\"synStatement\">else</span> {\n    x\n  };\n  return x;\n}\n</pre>\n\n<p>実際に値を返す部分が一箇所しかない場合です．途中に分岐があっても最終的に一箇所になっていれば多分同じ結果になります．</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>define internal i64 @_ZN4hoge9onereturn17h8b718f32daa6a379E(i64) unnamed_addr #0 {\nentry-block:\n  %x = alloca i64\n  %y = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  %2 = icmp eq i64 %1, 0\n  br i1 %2, label %then-block-18-, label %else-block\n\nthen-block-18-:                                   ; preds = %entry-block\n  store i64 1, i64* %y\n  br label %join\n\nelse-block:                                       ; preds = %entry-block\n  %3 = load i64, i64* %x\n  store i64 %3, i64* %y\n  br label %join\n\njoin:                                             ; preds = %else-block, %then-block-18-\n  %4 = load i64, i64* %x\n  br label %clean_ast_10_\n\nreturn:                                           ; preds = %clean_ast_10_\n  ret i64 %4\n\nclean_ast_10_:                                    ; preds = %join\n  br label %return\n}</pre>\n\n<p><code>return</code> という BasicBlock ができています．これは <code>return</code> 文が現れると作られるよう？です．\nで，その中では単純に <code>x</code> に該当する値を返しています．</p>\n\n<p>最後の <code>return x;</code> 文を 単純に <code>x</code> に置き換えてみると，</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>define internal i64 @_ZN4hoge9onereturn17h8b718f32daa6a379E(i64) unnamed_addr #0 {\nentry-block:\n  %x = alloca i64\n  %y = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  %2 = icmp eq i64 %1, 0\n  br i1 %2, label %then-block-18-, label %else-block\n\nthen-block-18-:                                   ; preds = %entry-block\n  store i64 1, i64* %y\n  br label %join\n\nelse-block:                                       ; preds = %entry-block\n  %3 = load i64, i64* %x\n  store i64 %3, i64* %y\n  br label %join\n\njoin:                                             ; preds = %else-block, %then-block-18-\n  %4 = load i64, i64* %x\n  ret i64 %4\n}</pre>\n\n<p>となります． <code>return</code> ブロックが消えていますね．なので <code>return</code> 文があると <code>return</code> ブロックが作られる、で良さそう？</p>\n\n<h1><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>のパスから値を返す</h1>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">multireturn</span>(x: isize) -&gt; isize {\n  <span class=\"synStatement\">let</span> y = <span class=\"synStatement\">if</span> x == <span class=\"synConstant\">0</span> {\n    return -<span class=\"synConstant\">1</span>;\n  } <span class=\"synStatement\">else</span> {\n    x\n  };\n  y\n}\n</pre>\n\n<p>さて，では最初に述べた，<code>if</code> の分岐内にある <code>return</code> についてです．\nこれは，</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>define internal i64 @_ZN4hoge11multireturn17had379e8ce5a18f08E(i64) unnamed_addr #0 {\nentry-block:\n  %sret_slot = alloca i64\n  %x = alloca i64\n  %y = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  %2 = icmp eq i64 %1, 0\n  br i1 %2, label %then-block-18-, label %else-block\n\nthen-block-18-:                                   ; preds = %entry-block\n  store i64 -1, i64* %sret_slot\n  br label %return\n\nelse-block:                                       ; preds = %entry-block\n  %3 = load i64, i64* %x\n  store i64 %3, i64* %y\n  br label %join\n\njoin:                                             ; preds = %else-block\n  %4 = load i64, i64* %y\n  store i64 %4, i64* %sret_slot\n  br label %return\n\nreturn:                                           ; preds = %join, %then-block-18-\n  %5 = load i64, i64* %sret_slot\n  ret i64 %5\n}</pre>\n\n<p>こうなりました．\nまず，<code>return</code> 文があるため？，<code>return</code> ブロックが作られています．\nしかし今回は，パスによって返すものが違います．(値が違うという意味ではなく，同じ変数ですらないという意味です...)</p>\n\n<p>よく IR を読むと，関数の頭で <code>%sret_slot</code> という名前でスタック領域を確保していることがわかります．\nそして，<code>return</code> ブロック内では，これを読んできて返しています．<br/>\nさらに，<code>if</code> 文の then 節にあたる，<code>then-block-18-</code> というブロックでは，<code>%sret_slot</code> に値を格納して <code>return</code> ブロックへジャンプしています．\nelse 節のあとの部分 (<code>join</code> ブロック) でも同様に, <code>%sret_slot</code> に値を格納して <code>return</code> ブロックへジャンプしています．</p>\n\n<h1>まとめ</h1>\n\n<p>というわけで，様々な Rust コードを <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR に変換して見てみた結果，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>のパスから値を返す場合は，「ローカル変数として返り値を定義し，そこに返したい値を格納してから <code>return</code> に goto」という形になっていることがわかりました．</p>\n\n<p>(ほとんど <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/LLVM\">LLVM</a> IR を乗っけるだけになってしまった...)</p>\n\n<h2>ちなみに ...</h2>\n\n<h1><code>if</code> 文の返す値をそのまま返す</h1>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">ifreturn</span>(x: isize) -&gt; isize {\n  <span class=\"synStatement\">if</span> x == <span class=\"synConstant\">0</span> {\n    <span class=\"synConstant\">1</span>\n  } <span class=\"synStatement\">else</span> {\n    x\n  }\n}\n</pre>\n\n<p>Rust に慣れていないとちょっとわかりにくいですが，<code>x == 0</code> の場合は 1 を返し，そうでない場合は <code>x</code> を返す関数です．</p>\n\n<p>これは，</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>define internal i64 @_ZN4hoge8ifreturn17hcdaab6e376d6c95cE(i64) unnamed_addr #0 {\nentry-block:\n  %sret_slot = alloca i64\n  %x = alloca i64\n  store i64 %0, i64* %x\n  %1 = load i64, i64* %x\n  %2 = icmp eq i64 %1, 0\n  br i1 %2, label %then-block-15-, label %else-block\n\nthen-block-15-:                                   ; preds = %entry-block\n  store i64 1, i64* %sret_slot\n  br label %join\n\nelse-block:                                       ; preds = %entry-block\n  %3 = load i64, i64* %x\n  store i64 %3, i64* %sret_slot\n  br label %join\n\njoin:                                             ; preds = %else-block, %then-block-15-\n  %4 = load i64, i64* %sret_slot\n  ret i64 %4\n}</pre>\n\n<p>こうなります．やっていることは上記の例たちとあまり変わりません．\nしかし，<code>return</code> 文がないので？，<code>return</code> ブロックが作られていません．が, <code>%sret_slot</code> は定義されていますね...<br/>\nこれはどういうことなんでしょう．<code>rustc</code> のコードを読むべきなのかもしれませんが，イマイチ内部処理が想像しにくいです...</p>\n\n<p>普通に翻訳していったら，</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>let x = if x == 0 { 1 } else { x };\nx</pre>\n\n<p>と同じ感じになる気がするので，<code>%sret_slot</code> という名前が出てくる余地は無い気がするのですが...(実質同じ処理ではあります)\n分岐が直接返戻値になる場合は特別扱いしているのかな？</p>\n\n---\n\n---\n","slug":"Rust_における_return文の_LLVM_IR_表現について","title":"Rust における return文の LLVM IR 表現について","timestamp":1460540043000,"tags":[]},{"rawMarkdown":"---\ntitle: \"C++ の複雑な型を整形するプログラムを作りました\"\ndate: 2016-03-08T11:55:10.000Z\ntags: []\n---\n\n<p>テンプレートをバリバリ使っている <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> プログラムの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーが，死ぬほど辛かったので作りました．\n型を綺麗に出力するだけです．\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>の型版 <code>jq</code> みたいなやつありそうだけど無いのかな？</p>\n\n<p><a href=\"https://github.com/agatan/tf\">agatan/tf</a></p>\n\n<p>たとえば，</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>boost::spirit::x3::raw_directive&lt;boost::spirit::x3::lexeme_directive&lt;boost::spirit::x3::sequence&lt;boost::spirit::x3::alternative&lt;boost::spirit::x3::char_class&lt;boost::spirit::char_encoding::standard, boost::spirit::x3::alpha_tag&gt;, boost::spirit::x3::literal_char&lt;boost::spirit::char_encoding::standard, boost::spirit::x3::unused_type&gt; &gt;, boost::spirit::x3::kleene&lt;boost::spirit::x3::alternative&lt;boost::spirit::x3::char_class&lt;boost::spirit::char_encoding::standard, boost::spirit::x3::alnum_tag&gt;, boost::spirit::x3::literal_char&lt;boost::spirit::char_encoding::standard, boost::spirit::x3::unused_type&gt; &gt; &gt; &gt; &gt; &gt;::parse&lt;__gnu_cxx::__normal_iterator&lt;<span class=\"synType\">const</span> <span class=\"synType\">char</span> *, std::__cxx11::basic_string&lt;<span class=\"synType\">char</span>&gt; &gt;, boost::spirit::x3::context&lt;boost::spirit::x3::error_handler_tag, <span class=\"synType\">const</span> std::reference_wrapper&lt;boost::spirit::x3::error_handler&lt;__gnu_cxx::__normal_iterator&lt;<span class=\"synType\">const</span> <span class=\"synType\">char</span> *, std::__cxx11::basic_string&lt;<span class=\"synType\">char</span>&gt; &gt; &gt; &gt;, boost::spirit::x3::context&lt;boost::spirit::x3::skipper_tag, <span class=\"synType\">const</span> boost::spirit::x3::char_class&lt;boost::spirit::char_encoding::ascii, boost::spirit::x3::space_tag&gt;, boost::spirit::x3::unused_type&gt; &gt;, std::__cxx11::basic_string&lt;<span class=\"synType\">char</span>&gt;, <span class=\"synType\">char</span>&gt;\n</pre>\n\n<p>こんなエラーがよく有りますよね．</p>\n\n<p>これを <code>tf</code> の標準入力に流しこむと，</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>boost::spirit::x3::raw_directive&lt;\n    boost::spirit::x3::lexeme_directive&lt;\n        boost::spirit::x3::sequence&lt;\n            boost::spirit::x3::alternative&lt;\n                boost::spirit::x3::char_class&lt;\n                    boost::spirit::char_encoding::standard,\n                    boost::spirit::x3::alpha_tag\n                &gt;,\n                boost::spirit::x3::literal_char&lt;\n                    boost::spirit::char_encoding::standard,\n                    boost::spirit::x3::unused_type\n                &gt;\n            &gt;,\n            boost::spirit::x3::kleene&lt;\n                boost::spirit::x3::alternative&lt;\n                    boost::spirit::x3::char_class&lt;\n                        boost::spirit::char_encoding::standard,\n                        boost::spirit::x3::alnum_tag\n                    &gt;,\n                    boost::spirit::x3::literal_char&lt;\n                        boost::spirit::char_encoding::standard,\n                        boost::spirit::x3::unused_type\n                    &gt;\n                &gt;\n            &gt;\n        &gt;\n    &gt;\n&gt;::parse&lt;\n    __gnu_cxx::__normal_iterator&lt;\n        constchar*,\n        std::__cxx11::basic_string&lt;\n            <span class=\"synType\">char</span>\n        &gt;\n    &gt;,\n    boost::spirit::x3::context&lt;\n        boost::spirit::x3::error_handler_tag,\n        conststd::reference_wrapper&lt;\n            boost::spirit::x3::error_handler&lt;\n                __gnu_cxx::__normal_iterator&lt;\n                    constchar*,\n                    std::__cxx11::basic_string&lt;\n                        <span class=\"synType\">char</span>\n                    &gt;\n                &gt;\n            &gt;\n        &gt;,\n        boost::spirit::x3::context&lt;\n            boost::spirit::x3::skipper_tag,\n            constboost::spirit::x3::char_class&lt;\n                boost::spirit::char_encoding::ascii,\n                boost::spirit::x3::space_tag\n            &gt;,\n            boost::spirit::x3::unused_type\n        &gt;\n    &gt;,\n    std::__cxx11::basic_string&lt;\n        <span class=\"synType\">char</span>\n    &gt;,\n    <span class=\"synType\">char</span>\n&gt;\n</pre>\n\n<p>こうなります．</p>\n\n<p>単純に <code>&lt;</code>, <code>&gt;</code>, <code>,</code> を見てインデントを調整しながら出力しているだけです．\n空白はスキップします．</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>とかは全くしていないので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーをそのまま流し込んでも悲惨な事になります．\n<del>あと今気がついたのですが，<code>const hoge</code> が <code>consthoge</code> になっていますね．</del>\n修正しました</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>boost::spirit::x3::raw_directive&lt;\n    boost::spirit::x3::lexeme_directive&lt;\n        boost::spirit::x3::sequence&lt;\n            boost::spirit::x3::alternative&lt;\n                boost::spirit::x3::char_class&lt;\n                    boost::spirit::char_encoding::standard,\n                    boost::spirit::x3::alpha_tag\n                &gt;,\n                boost::spirit::x3::literal_char&lt;\n                    boost::spirit::char_encoding::standard,\n                    boost::spirit::x3::unused_type\n                &gt;\n            &gt;,\n            boost::spirit::x3::kleene&lt;\n                boost::spirit::x3::alternative&lt;\n                    boost::spirit::x3::char_class&lt;\n                        boost::spirit::char_encoding::standard,\n                        boost::spirit::x3::alnum_tag\n                    &gt;,\n                    boost::spirit::x3::literal_char&lt;\n                        boost::spirit::char_encoding::standard,\n                        boost::spirit::x3::unused_type\n                    &gt;\n                &gt;\n            &gt;\n        &gt;\n    &gt;\n&gt;::parse&lt;\n    __gnu_cxx::__normal_iterator&lt;\n        <span class=\"synType\">const</span> <span class=\"synType\">char</span> *,\n        std::__cxx11::basic_string&lt;\n            <span class=\"synType\">char</span>\n        &gt;\n    &gt;,\n    boost::spirit::x3::context&lt;\n        boost::spirit::x3::error_handler_tag,\n        <span class=\"synType\">const</span> std::reference_wrapper&lt;\n            boost::spirit::x3::error_handler&lt;\n                __gnu_cxx::__normal_iterator&lt;\n                    <span class=\"synType\">const</span> <span class=\"synType\">char</span> *,\n                    std::__cxx11::basic_string&lt;\n                        <span class=\"synType\">char</span>\n                    &gt;\n                &gt;\n            &gt;\n        &gt;,\n        boost::spirit::x3::context&lt;\n            boost::spirit::x3::skipper_tag,\n            <span class=\"synType\">const</span> boost::spirit::x3::char_class&lt;\n                boost::spirit::char_encoding::ascii,\n                boost::spirit::x3::space_tag\n            &gt;,\n            boost::spirit::x3::unused_type\n        &gt;\n    &gt;,\n    std::__cxx11::basic_string&lt;\n        <span class=\"synType\">char</span>\n    &gt;,\n    <span class=\"synType\">char</span>\n&gt;\n</pre>\n\n---\n\n---\n","contentMarkdown":"\n<p>テンプレートをバリバリ使っている <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> プログラムの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーが，死ぬほど辛かったので作りました．\n型を綺麗に出力するだけです．\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>の型版 <code>jq</code> みたいなやつありそうだけど無いのかな？</p>\n\n<p><a href=\"https://github.com/agatan/tf\">agatan/tf</a></p>\n\n<p>たとえば，</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>boost::spirit::x3::raw_directive&lt;boost::spirit::x3::lexeme_directive&lt;boost::spirit::x3::sequence&lt;boost::spirit::x3::alternative&lt;boost::spirit::x3::char_class&lt;boost::spirit::char_encoding::standard, boost::spirit::x3::alpha_tag&gt;, boost::spirit::x3::literal_char&lt;boost::spirit::char_encoding::standard, boost::spirit::x3::unused_type&gt; &gt;, boost::spirit::x3::kleene&lt;boost::spirit::x3::alternative&lt;boost::spirit::x3::char_class&lt;boost::spirit::char_encoding::standard, boost::spirit::x3::alnum_tag&gt;, boost::spirit::x3::literal_char&lt;boost::spirit::char_encoding::standard, boost::spirit::x3::unused_type&gt; &gt; &gt; &gt; &gt; &gt;::parse&lt;__gnu_cxx::__normal_iterator&lt;<span class=\"synType\">const</span> <span class=\"synType\">char</span> *, std::__cxx11::basic_string&lt;<span class=\"synType\">char</span>&gt; &gt;, boost::spirit::x3::context&lt;boost::spirit::x3::error_handler_tag, <span class=\"synType\">const</span> std::reference_wrapper&lt;boost::spirit::x3::error_handler&lt;__gnu_cxx::__normal_iterator&lt;<span class=\"synType\">const</span> <span class=\"synType\">char</span> *, std::__cxx11::basic_string&lt;<span class=\"synType\">char</span>&gt; &gt; &gt; &gt;, boost::spirit::x3::context&lt;boost::spirit::x3::skipper_tag, <span class=\"synType\">const</span> boost::spirit::x3::char_class&lt;boost::spirit::char_encoding::ascii, boost::spirit::x3::space_tag&gt;, boost::spirit::x3::unused_type&gt; &gt;, std::__cxx11::basic_string&lt;<span class=\"synType\">char</span>&gt;, <span class=\"synType\">char</span>&gt;\n</pre>\n\n<p>こんなエラーがよく有りますよね．</p>\n\n<p>これを <code>tf</code> の標準入力に流しこむと，</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>boost::spirit::x3::raw_directive&lt;\n    boost::spirit::x3::lexeme_directive&lt;\n        boost::spirit::x3::sequence&lt;\n            boost::spirit::x3::alternative&lt;\n                boost::spirit::x3::char_class&lt;\n                    boost::spirit::char_encoding::standard,\n                    boost::spirit::x3::alpha_tag\n                &gt;,\n                boost::spirit::x3::literal_char&lt;\n                    boost::spirit::char_encoding::standard,\n                    boost::spirit::x3::unused_type\n                &gt;\n            &gt;,\n            boost::spirit::x3::kleene&lt;\n                boost::spirit::x3::alternative&lt;\n                    boost::spirit::x3::char_class&lt;\n                        boost::spirit::char_encoding::standard,\n                        boost::spirit::x3::alnum_tag\n                    &gt;,\n                    boost::spirit::x3::literal_char&lt;\n                        boost::spirit::char_encoding::standard,\n                        boost::spirit::x3::unused_type\n                    &gt;\n                &gt;\n            &gt;\n        &gt;\n    &gt;\n&gt;::parse&lt;\n    __gnu_cxx::__normal_iterator&lt;\n        constchar*,\n        std::__cxx11::basic_string&lt;\n            <span class=\"synType\">char</span>\n        &gt;\n    &gt;,\n    boost::spirit::x3::context&lt;\n        boost::spirit::x3::error_handler_tag,\n        conststd::reference_wrapper&lt;\n            boost::spirit::x3::error_handler&lt;\n                __gnu_cxx::__normal_iterator&lt;\n                    constchar*,\n                    std::__cxx11::basic_string&lt;\n                        <span class=\"synType\">char</span>\n                    &gt;\n                &gt;\n            &gt;\n        &gt;,\n        boost::spirit::x3::context&lt;\n            boost::spirit::x3::skipper_tag,\n            constboost::spirit::x3::char_class&lt;\n                boost::spirit::char_encoding::ascii,\n                boost::spirit::x3::space_tag\n            &gt;,\n            boost::spirit::x3::unused_type\n        &gt;\n    &gt;,\n    std::__cxx11::basic_string&lt;\n        <span class=\"synType\">char</span>\n    &gt;,\n    <span class=\"synType\">char</span>\n&gt;\n</pre>\n\n<p>こうなります．</p>\n\n<p>単純に <code>&lt;</code>, <code>&gt;</code>, <code>,</code> を見てインデントを調整しながら出力しているだけです．\n空白はスキップします．</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>とかは全くしていないので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーをそのまま流し込んでも悲惨な事になります．\n<del>あと今気がついたのですが，<code>const hoge</code> が <code>consthoge</code> になっていますね．</del>\n修正しました</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>boost::spirit::x3::raw_directive&lt;\n    boost::spirit::x3::lexeme_directive&lt;\n        boost::spirit::x3::sequence&lt;\n            boost::spirit::x3::alternative&lt;\n                boost::spirit::x3::char_class&lt;\n                    boost::spirit::char_encoding::standard,\n                    boost::spirit::x3::alpha_tag\n                &gt;,\n                boost::spirit::x3::literal_char&lt;\n                    boost::spirit::char_encoding::standard,\n                    boost::spirit::x3::unused_type\n                &gt;\n            &gt;,\n            boost::spirit::x3::kleene&lt;\n                boost::spirit::x3::alternative&lt;\n                    boost::spirit::x3::char_class&lt;\n                        boost::spirit::char_encoding::standard,\n                        boost::spirit::x3::alnum_tag\n                    &gt;,\n                    boost::spirit::x3::literal_char&lt;\n                        boost::spirit::char_encoding::standard,\n                        boost::spirit::x3::unused_type\n                    &gt;\n                &gt;\n            &gt;\n        &gt;\n    &gt;\n&gt;::parse&lt;\n    __gnu_cxx::__normal_iterator&lt;\n        <span class=\"synType\">const</span> <span class=\"synType\">char</span> *,\n        std::__cxx11::basic_string&lt;\n            <span class=\"synType\">char</span>\n        &gt;\n    &gt;,\n    boost::spirit::x3::context&lt;\n        boost::spirit::x3::error_handler_tag,\n        <span class=\"synType\">const</span> std::reference_wrapper&lt;\n            boost::spirit::x3::error_handler&lt;\n                __gnu_cxx::__normal_iterator&lt;\n                    <span class=\"synType\">const</span> <span class=\"synType\">char</span> *,\n                    std::__cxx11::basic_string&lt;\n                        <span class=\"synType\">char</span>\n                    &gt;\n                &gt;\n            &gt;\n        &gt;,\n        boost::spirit::x3::context&lt;\n            boost::spirit::x3::skipper_tag,\n            <span class=\"synType\">const</span> boost::spirit::x3::char_class&lt;\n                boost::spirit::char_encoding::ascii,\n                boost::spirit::x3::space_tag\n            &gt;,\n            boost::spirit::x3::unused_type\n        &gt;\n    &gt;,\n    std::__cxx11::basic_string&lt;\n        <span class=\"synType\">char</span>\n    &gt;,\n    <span class=\"synType\">char</span>\n&gt;\n</pre>\n\n---\n\n---\n","slug":"C++_の複雑な型を整形するプログラムを作りました","title":"C++ の複雑な型を整形するプログラムを作りました","timestamp":1457438110000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Type Erasure による Visitor パターンの実装\"\ndate: 2016-01-25T11:07:38.000Z\ntags: []\n---\n\n<p>プログラミングしていて，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>をうまく扱いたいという状況は結構良くあると思います．<br/>\n代数的データ型とパターンマッチを持つ言語であればとても美しく完結に表現できる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>ですが，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A5%D6%A5%B8%A5%A7%A5%AF%A5%C8%BB%D8%B8%FE%B8%C0%B8%EC\">オブジェクト指向言語</a>でやろうと思うと結構たいへんです．<br/>\n典型的には Visitor パターンというやつを用います．<a href=\"http://qiita.com/lyrical_logical/items/bc6126f34a571a2c4f97\">デザインパターン - Visitor パターン再考 - Qiita</a>が非常にわかりやすく，理解の助けになりました．ありがとうございます．</p>\n\n<p>一方，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の有名なライブラリ，Boost には Boost.Variant というモジュールがあり，これまたとても美しく Visitor っぽいことが出来ます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;boost/variant.hpp&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n\n<span class=\"synStatement\">using</span> sample = boost::variant&lt;<span class=\"synType\">int</span>, <span class=\"synType\">double</span>, std::string&gt;;\n\nsample s1 = <span class=\"synConstant\">1</span>;\nsample s2 = <span class=\"synConstant\">2.0</span>;\nsample s3 = <span class=\"synConstant\">&quot;sample3&quot;</span>;\n\nboost::apply_visitor([](<span class=\"synType\">auto</span> <span class=\"synType\">const</span>&amp; v) <span class=\"synError\">{</span> std::cout &lt;&lt; v &lt;&lt; std::endl; }, s1); <span class=\"synComment\">// =&gt; 1</span>\nboost::apply_visitor([](<span class=\"synType\">auto</span> <span class=\"synType\">const</span>&amp; v) <span class=\"synError\">{</span> std::cout &lt;&lt; v &lt;&lt; std::endl; }, s2); <span class=\"synComment\">// =&gt; 2.0</span>\nboost::apply_visitor([](<span class=\"synType\">auto</span> <span class=\"synType\">const</span>&amp; v) <span class=\"synError\">{</span> std::cout &lt;&lt; v &lt;&lt; std::endl; }, s3); <span class=\"synComment\">// =&gt; sample3</span>\n</pre>\n\n<p>しかし，Boost.Variant は非常に高機能ですが，テンプレートをガンガン使っていたりするので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>コストが大きいという問題があります．</p>\n\n<p>そこで，Type Erasure を使って visitor パターンをうまく表せれば，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>コストを下げられるのでは？というお話です．<br/>\nType Erasure は「型消去」とかで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%B0%A4%EB\">ググる</a>と色々解説してくださっている記事などが出てくると思います．（ありがとうございます）</p>\n\n<p>この話，私が考えたわけではなくて，どこかの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>で見たようなきがするんですが，当時は Type Erasure とか意味不明だったのでスルーしていました．<br/>\n今ならなんとなくやりたいことは出来るような気がするので（＆ちょうど必要になったので）記事にしてみていますが，もしオリジナルっぽいものや同じようなことを提案している<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>・記事を見かけた方は是非ご連絡いただけると嬉しいです．</p>\n\n<h2>1st step</h2>\n\n<h3>Visitor</h3>\n\n<p>今回表現したいデータ構造をまず定めます．簡単のために，足し算・掛け算・整数定数の 3 種類のノードを持つ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>を考えます．<br/>\n<code>(1 + 2) * 3</code> なら， <code>mul( add(1, 2), 3 )</code> みたいな感じです．</p>\n\n<p>この構造を visit する Visitor クラスから先に考えます．<br/>\nVisitor クラスは，<code>visit</code> という<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>をもつ型の値を，型を消去して保持させます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">class</span> visitor {\n<span class=\"synStatement\">private</span>:\n  <span class=\"synType\">class</span> visitor_base_holder {\n  <span class=\"synStatement\">public</span>:\n    <span class=\"synType\">virtual</span> <span class=\"synType\">void</span> visit(add &amp;) = <span class=\"synConstant\">0</span>;\n    <span class=\"synType\">virtual</span> <span class=\"synType\">void</span> visit(mul &amp;) = <span class=\"synConstant\">0</span>;\n    <span class=\"synType\">virtual</span> <span class=\"synType\">void</span> visit(constant &amp;) = <span class=\"synConstant\">0</span>;\n\n    <span class=\"synType\">virtual</span> ~visitor_base_holder() = <span class=\"synStatement\">default</span>;\n  };\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> V&gt; <span class=\"synType\">class</span> visitor_holder : <span class=\"synStatement\">public</span> visitor_base_holder {\n  <span class=\"synStatement\">private</span>:\n    V &amp;v;\n\n  <span class=\"synStatement\">public</span>:\n    visitor_holder(V &amp;v) : v(v) {}\n\n    <span class=\"synType\">void</span> visit(add &amp;a) override { v(a); }\n    <span class=\"synType\">void</span> visit(mul &amp;a) override { v(a); }\n    <span class=\"synType\">void</span> visit(constant &amp;a) override { v(a); }\n\n    <span class=\"synType\">virtual</span> ~visitor_holder() = <span class=\"synStatement\">default</span>;\n  };\n\n  std::unique_ptr&lt;visitor_base_holder&gt; holder;\n\n<span class=\"synStatement\">public</span>:\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> V&gt;\n  visitor(V &amp;v)\n      : holder(std::make_unique&lt;visitor_holder&lt;V&gt;&gt;(v)) {}\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> Visitable&gt; <span class=\"synType\">void</span> visit(Visitable &amp;v) { holder-&gt;visit(v); }\n};\n</pre>\n\n<p>今回は <code>const</code> 修飾についてすべて無視しています．( <code>const</code> を考慮するならば，各 <code>visit</code> について，visitor の <code>const</code> 性と node の <code>const</code> 性を考える必要があります．つまり 4 種類の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>を定義しなければなりません．）<br/>\nvisit した対象となるそれぞれのデータについて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A1%BC%A5%D0%A1%BC%A5%ED%A1%BC%A5%C9\">オーバーロード</a>する形で <code>visit</code> を定義しています．<br/>\n<code>visitor</code> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%B9%A5%C8%A5%E9%A5%AF%A5%BF\">コンストラクタ</a>に，<code>operator()(add&amp;)</code>, <code>operator()(mul&amp;)</code>, <code>operator()(constant&amp;)</code> を全て持つオブジェクト（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>14 の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>ラムダでもOK）を渡すことで，型消去された visitor が出来上がります．<br/>\n<code>visitor</code> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%B9%A5%C8%A5%E9%A5%AF%A5%BF\">コンストラクタ</a>にどんな型の値を渡しても，出来上がる <code>visitor</code> にはその型情報は含まれないので，様々な visitor を統一して扱う（ <code>vector</code> に突っ込むとか）事ができるようになります．</p>\n\n<h3>Node</h3>\n\n<p>次にノードの方について考えます． 通常，Visitor パターンでは， visit される側のクラスに <code>accept</code> を実装します．<br/>\nvisit される側のデータを統一的に扱う（ <code>vector</code> に突っ込むとか）ためには，継承やインターフェースを用いるのが普通です．<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> では，Visitor 側に使った Type Erasure のテクニックが使えます．<br/>\n<code>std::vector&lt;node&gt;</code> などのように，統一的にノードを扱いつつも，visit される際には，<code>visit(add&amp;)</code> や <code>visit(mul&amp;)</code> のような適切な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A1%BC%A5%D0%A1%BC%A5%ED%A1%BC%A5%C9\">オーバーロード</a>関数を呼び出すようにしてやればオッケーです．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">class</span> node {\n<span class=\"synStatement\">private</span>:\n  <span class=\"synType\">class</span> node_base_holder {\n  <span class=\"synStatement\">public</span>:\n    <span class=\"synType\">virtual</span> <span class=\"synType\">void</span> accept(visitor &amp;v) = <span class=\"synConstant\">0</span>;\n\n    <span class=\"synType\">virtual</span> ~node_base_holder() = <span class=\"synStatement\">default</span>;\n  };\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt; <span class=\"synType\">class</span> node_holder : <span class=\"synStatement\">public</span> node_base_holder {\n  <span class=\"synStatement\">public</span>:\n    node_holder(T <span class=\"synType\">const</span> &amp;n) : node(n) {}\n    node_holder(T &amp;&amp;n) : node(n) {}\n\n    <span class=\"synType\">void</span> accept(visitor &amp;v) override { v.visit(node); }\n\n    ~node_holder() = <span class=\"synStatement\">default</span>;\n\n  <span class=\"synStatement\">private</span>:\n    T node;\n  };\n\n  std::shared_ptr&lt;node_base_holder&gt; holder;\n\n<span class=\"synStatement\">public</span>:\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> Node&gt;\n  node(Node <span class=\"synType\">const</span> &amp;n)\n      : holder(std::make_shared&lt;node_holder&lt;Node&gt;&gt;(n)) {}\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> Node&gt;\n  node(Node &amp;&amp;n)\n      : holder(std::make_shared&lt;node_holder&lt;Node&gt;&gt;(n)) {}\n\n  <span class=\"synType\">void</span> accept(visitor &amp;v) { holder-&gt;accept(v); }\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> Visitor&gt; <span class=\"synType\">void</span> accept(Visitor &amp;v) {\n    visitor visit(v);\n    holder-&gt;accept(visit);\n  }\n};\n</pre>\n\n<p>これ結構わかりにくと思うのですが，自分でも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>に怒られながら書いたのでいまいちよく分かってません．<br/>\n先ほどの <code>visitor</code> の場合と異なり，<code>node</code> には特別満たすべきインターフェースは有りません．<br/>\nType Erasure を使う理由は，適切な <code>visit</code> 関数へのディスパッチのためです．</p>\n\n<h3>使う</h3>\n\n<p><code>visitor</code> と <code>node</code> が出来たので，使ってみます．<br/>\nその前にデータ構造を定義しておきます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">struct</span> constant {\n  <span class=\"synType\">int</span> value;\n};\n\n<span class=\"synType\">struct</span> add {\n  node lhs;\n  node rhs;\n};\n\n<span class=\"synType\">struct</span> mul {\n  node lhs;\n  node rhs;\n};\n</pre>\n\n<p><code>add</code> や <code>mul</code> のフィールドに，<code>node</code> が使用されている点が大事です．<br/>\n<code>add.lhs</code> や <code>mul.rhs</code> には，<code>constant</code> が来るか <code>add</code> が来るか <code>mul</code> が来るか分かりません．<br/>\nそこで，visit 可能な型なら何でもOKという意味で，<code>node</code> 型の値をフィールドとします．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>node n = mul{add{constant{<span class=\"synConstant\">1</span>}, constant{<span class=\"synConstant\">2</span>}}, constant{<span class=\"synConstant\">3</span>}};\n</pre>\n\n<p>これで，<code>(1 + 2) * 3</code> が表現できています．\n<code>add</code> や <code>constant</code> から <code>node</code> へと暗黙変換が行われていることに注意してください．</p>\n\n<p>次に visitor を定義します．これは，<code>operator()</code> を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A1%BC%A5%D0%A1%BC%A5%ED%A1%BC%A5%C9\">オーバーロード</a>した関数オブジェクトです．<br/>\n式を出力する <code>printer</code> と 式を計算する <code>calculator</code> を定義します．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">struct</span> printer {\n  <span class=\"synType\">void</span> <span class=\"synStatement\">operator</span>()(add &amp;a) {\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;(&quot;</span>;\n    a.lhs.accept(*<span class=\"synStatement\">this</span>);\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;)&quot;</span>;\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;+&quot;</span>;\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;(&quot;</span>;\n    a.rhs.accept(*<span class=\"synStatement\">this</span>);\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;)&quot;</span>;\n  }\n\n  <span class=\"synType\">void</span> <span class=\"synStatement\">operator</span>()(mul &amp;a) {\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;(&quot;</span>;\n    a.lhs.accept(*<span class=\"synStatement\">this</span>);\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;)&quot;</span>;\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;*&quot;</span>;\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;(&quot;</span>;\n    a.rhs.accept(*<span class=\"synStatement\">this</span>);\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;)&quot;</span>;\n  }\n\n  <span class=\"synType\">void</span> <span class=\"synStatement\">operator</span>()(constant &amp;c) { std::cout &lt;&lt; c.value; }\n};\n\n<span class=\"synType\">struct</span> calculator {\n  <span class=\"synType\">int</span> result;\n  <span class=\"synType\">void</span> <span class=\"synStatement\">operator</span>()(add &amp;a) {\n    calculator l, r;\n    a.lhs.accept(l);\n    a.rhs.accept(r);\n    result = l.result + r.result;\n  }\n\n  <span class=\"synType\">void</span> <span class=\"synStatement\">operator</span>()(mul &amp;m) {\n    calculator l, r;\n    m.lhs.accept(l);\n    m.rhs.accept(r);\n    result = l.result * r.result;\n  }\n\n  <span class=\"synType\">void</span> <span class=\"synStatement\">operator</span>()(constant &amp;c) { result = c.value; }\n};\n</pre>\n\n<p>こんな感じです．<br/>\n<code>visit</code> や <code>accept</code> を <code>void</code> を返す関数として定義したので，<code>calculator</code> は自前のフィールドに結果を保持する必要があります．\n(あとで改善します)</p>\n\n<p>使い方は</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>  node n = mul{add{constant{<span class=\"synConstant\">1</span>}, constant{<span class=\"synConstant\">2</span>}}, constant{<span class=\"synConstant\">3</span>}};\n  printer p;\n  n.accept(p);\n  calculator calc;\n  n.accept(calc);\n  std::cout &lt;&lt; std::endl;\n  std::cout &lt;&lt; calc.result &lt;&lt; std::endl;\n  <span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;\n</pre>\n\n<p>です．</p>\n\n<h1>まとめ</h1>\n\n<p>この方法の利点としては，データの定義そのものに Visitor パターンのためのノイズが入らないことが挙げられます．<br/>\n普通の Visitor パターンでは継承必須ですし．</p>\n\n<p><code>const</code> つけてないせいで一時オブジェクトが使えないので <code>printer p;</code> という行が必要になってしまっています．これは<code>const</code>をがんばってつけるだけなのでまぁ問題有りません．<br/>\n一方，<code>calculator</code> の方はダサいですね．値を返す visitor も定義できるようにしたい．<br/>\n<code>visitor</code> の定義もツライです．<code>const</code> を考慮した場合，同じような内容の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>を 4 回ずつ書く必要がある．</p>\n\n<p>このへんの問題点は解決可能な気がするので出来たら後で記事にするつもりです．</p>\n\n<p>難しすぎて普通の visitor パターンで良くね？感出てきた</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>プログラミングしていて，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>をうまく扱いたいという状況は結構良くあると思います．<br/>\n代数的データ型とパターンマッチを持つ言語であればとても美しく完結に表現できる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>ですが，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A5%D6%A5%B8%A5%A7%A5%AF%A5%C8%BB%D8%B8%FE%B8%C0%B8%EC\">オブジェクト指向言語</a>でやろうと思うと結構たいへんです．<br/>\n典型的には Visitor パターンというやつを用います．<a href=\"http://qiita.com/lyrical_logical/items/bc6126f34a571a2c4f97\">デザインパターン - Visitor パターン再考 - Qiita</a>が非常にわかりやすく，理解の助けになりました．ありがとうございます．</p>\n\n<p>一方，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の有名なライブラリ，Boost には Boost.Variant というモジュールがあり，これまたとても美しく Visitor っぽいことが出来ます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;boost/variant.hpp&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n\n<span class=\"synStatement\">using</span> sample = boost::variant&lt;<span class=\"synType\">int</span>, <span class=\"synType\">double</span>, std::string&gt;;\n\nsample s1 = <span class=\"synConstant\">1</span>;\nsample s2 = <span class=\"synConstant\">2.0</span>;\nsample s3 = <span class=\"synConstant\">&quot;sample3&quot;</span>;\n\nboost::apply_visitor([](<span class=\"synType\">auto</span> <span class=\"synType\">const</span>&amp; v) <span class=\"synError\">{</span> std::cout &lt;&lt; v &lt;&lt; std::endl; }, s1); <span class=\"synComment\">// =&gt; 1</span>\nboost::apply_visitor([](<span class=\"synType\">auto</span> <span class=\"synType\">const</span>&amp; v) <span class=\"synError\">{</span> std::cout &lt;&lt; v &lt;&lt; std::endl; }, s2); <span class=\"synComment\">// =&gt; 2.0</span>\nboost::apply_visitor([](<span class=\"synType\">auto</span> <span class=\"synType\">const</span>&amp; v) <span class=\"synError\">{</span> std::cout &lt;&lt; v &lt;&lt; std::endl; }, s3); <span class=\"synComment\">// =&gt; sample3</span>\n</pre>\n\n<p>しかし，Boost.Variant は非常に高機能ですが，テンプレートをガンガン使っていたりするので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>コストが大きいという問題があります．</p>\n\n<p>そこで，Type Erasure を使って visitor パターンをうまく表せれば，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>コストを下げられるのでは？というお話です．<br/>\nType Erasure は「型消去」とかで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%B0%A4%EB\">ググる</a>と色々解説してくださっている記事などが出てくると思います．（ありがとうございます）</p>\n\n<p>この話，私が考えたわけではなくて，どこかの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>で見たようなきがするんですが，当時は Type Erasure とか意味不明だったのでスルーしていました．<br/>\n今ならなんとなくやりたいことは出来るような気がするので（＆ちょうど必要になったので）記事にしてみていますが，もしオリジナルっぽいものや同じようなことを提案している<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>・記事を見かけた方は是非ご連絡いただけると嬉しいです．</p>\n\n<h2>1st step</h2>\n\n<h3>Visitor</h3>\n\n<p>今回表現したいデータ構造をまず定めます．簡単のために，足し算・掛け算・整数定数の 3 種類のノードを持つ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>を考えます．<br/>\n<code>(1 + 2) * 3</code> なら， <code>mul( add(1, 2), 3 )</code> みたいな感じです．</p>\n\n<p>この構造を visit する Visitor クラスから先に考えます．<br/>\nVisitor クラスは，<code>visit</code> という<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>をもつ型の値を，型を消去して保持させます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">class</span> visitor {\n<span class=\"synStatement\">private</span>:\n  <span class=\"synType\">class</span> visitor_base_holder {\n  <span class=\"synStatement\">public</span>:\n    <span class=\"synType\">virtual</span> <span class=\"synType\">void</span> visit(add &amp;) = <span class=\"synConstant\">0</span>;\n    <span class=\"synType\">virtual</span> <span class=\"synType\">void</span> visit(mul &amp;) = <span class=\"synConstant\">0</span>;\n    <span class=\"synType\">virtual</span> <span class=\"synType\">void</span> visit(constant &amp;) = <span class=\"synConstant\">0</span>;\n\n    <span class=\"synType\">virtual</span> ~visitor_base_holder() = <span class=\"synStatement\">default</span>;\n  };\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> V&gt; <span class=\"synType\">class</span> visitor_holder : <span class=\"synStatement\">public</span> visitor_base_holder {\n  <span class=\"synStatement\">private</span>:\n    V &amp;v;\n\n  <span class=\"synStatement\">public</span>:\n    visitor_holder(V &amp;v) : v(v) {}\n\n    <span class=\"synType\">void</span> visit(add &amp;a) override { v(a); }\n    <span class=\"synType\">void</span> visit(mul &amp;a) override { v(a); }\n    <span class=\"synType\">void</span> visit(constant &amp;a) override { v(a); }\n\n    <span class=\"synType\">virtual</span> ~visitor_holder() = <span class=\"synStatement\">default</span>;\n  };\n\n  std::unique_ptr&lt;visitor_base_holder&gt; holder;\n\n<span class=\"synStatement\">public</span>:\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> V&gt;\n  visitor(V &amp;v)\n      : holder(std::make_unique&lt;visitor_holder&lt;V&gt;&gt;(v)) {}\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> Visitable&gt; <span class=\"synType\">void</span> visit(Visitable &amp;v) { holder-&gt;visit(v); }\n};\n</pre>\n\n<p>今回は <code>const</code> 修飾についてすべて無視しています．( <code>const</code> を考慮するならば，各 <code>visit</code> について，visitor の <code>const</code> 性と node の <code>const</code> 性を考える必要があります．つまり 4 種類の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>を定義しなければなりません．）<br/>\nvisit した対象となるそれぞれのデータについて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A1%BC%A5%D0%A1%BC%A5%ED%A1%BC%A5%C9\">オーバーロード</a>する形で <code>visit</code> を定義しています．<br/>\n<code>visitor</code> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%B9%A5%C8%A5%E9%A5%AF%A5%BF\">コンストラクタ</a>に，<code>operator()(add&amp;)</code>, <code>operator()(mul&amp;)</code>, <code>operator()(constant&amp;)</code> を全て持つオブジェクト（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>14 の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>ラムダでもOK）を渡すことで，型消去された visitor が出来上がります．<br/>\n<code>visitor</code> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%B9%A5%C8%A5%E9%A5%AF%A5%BF\">コンストラクタ</a>にどんな型の値を渡しても，出来上がる <code>visitor</code> にはその型情報は含まれないので，様々な visitor を統一して扱う（ <code>vector</code> に突っ込むとか）事ができるようになります．</p>\n\n<h3>Node</h3>\n\n<p>次にノードの方について考えます． 通常，Visitor パターンでは， visit される側のクラスに <code>accept</code> を実装します．<br/>\nvisit される側のデータを統一的に扱う（ <code>vector</code> に突っ込むとか）ためには，継承やインターフェースを用いるのが普通です．<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> では，Visitor 側に使った Type Erasure のテクニックが使えます．<br/>\n<code>std::vector&lt;node&gt;</code> などのように，統一的にノードを扱いつつも，visit される際には，<code>visit(add&amp;)</code> や <code>visit(mul&amp;)</code> のような適切な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A1%BC%A5%D0%A1%BC%A5%ED%A1%BC%A5%C9\">オーバーロード</a>関数を呼び出すようにしてやればオッケーです．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">class</span> node {\n<span class=\"synStatement\">private</span>:\n  <span class=\"synType\">class</span> node_base_holder {\n  <span class=\"synStatement\">public</span>:\n    <span class=\"synType\">virtual</span> <span class=\"synType\">void</span> accept(visitor &amp;v) = <span class=\"synConstant\">0</span>;\n\n    <span class=\"synType\">virtual</span> ~node_base_holder() = <span class=\"synStatement\">default</span>;\n  };\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> T&gt; <span class=\"synType\">class</span> node_holder : <span class=\"synStatement\">public</span> node_base_holder {\n  <span class=\"synStatement\">public</span>:\n    node_holder(T <span class=\"synType\">const</span> &amp;n) : node(n) {}\n    node_holder(T &amp;&amp;n) : node(n) {}\n\n    <span class=\"synType\">void</span> accept(visitor &amp;v) override { v.visit(node); }\n\n    ~node_holder() = <span class=\"synStatement\">default</span>;\n\n  <span class=\"synStatement\">private</span>:\n    T node;\n  };\n\n  std::shared_ptr&lt;node_base_holder&gt; holder;\n\n<span class=\"synStatement\">public</span>:\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> Node&gt;\n  node(Node <span class=\"synType\">const</span> &amp;n)\n      : holder(std::make_shared&lt;node_holder&lt;Node&gt;&gt;(n)) {}\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> Node&gt;\n  node(Node &amp;&amp;n)\n      : holder(std::make_shared&lt;node_holder&lt;Node&gt;&gt;(n)) {}\n\n  <span class=\"synType\">void</span> accept(visitor &amp;v) { holder-&gt;accept(v); }\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> Visitor&gt; <span class=\"synType\">void</span> accept(Visitor &amp;v) {\n    visitor visit(v);\n    holder-&gt;accept(visit);\n  }\n};\n</pre>\n\n<p>これ結構わかりにくと思うのですが，自分でも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>に怒られながら書いたのでいまいちよく分かってません．<br/>\n先ほどの <code>visitor</code> の場合と異なり，<code>node</code> には特別満たすべきインターフェースは有りません．<br/>\nType Erasure を使う理由は，適切な <code>visit</code> 関数へのディスパッチのためです．</p>\n\n<h3>使う</h3>\n\n<p><code>visitor</code> と <code>node</code> が出来たので，使ってみます．<br/>\nその前にデータ構造を定義しておきます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">struct</span> constant {\n  <span class=\"synType\">int</span> value;\n};\n\n<span class=\"synType\">struct</span> add {\n  node lhs;\n  node rhs;\n};\n\n<span class=\"synType\">struct</span> mul {\n  node lhs;\n  node rhs;\n};\n</pre>\n\n<p><code>add</code> や <code>mul</code> のフィールドに，<code>node</code> が使用されている点が大事です．<br/>\n<code>add.lhs</code> や <code>mul.rhs</code> には，<code>constant</code> が来るか <code>add</code> が来るか <code>mul</code> が来るか分かりません．<br/>\nそこで，visit 可能な型なら何でもOKという意味で，<code>node</code> 型の値をフィールドとします．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>node n = mul{add{constant{<span class=\"synConstant\">1</span>}, constant{<span class=\"synConstant\">2</span>}}, constant{<span class=\"synConstant\">3</span>}};\n</pre>\n\n<p>これで，<code>(1 + 2) * 3</code> が表現できています．\n<code>add</code> や <code>constant</code> から <code>node</code> へと暗黙変換が行われていることに注意してください．</p>\n\n<p>次に visitor を定義します．これは，<code>operator()</code> を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A1%BC%A5%D0%A1%BC%A5%ED%A1%BC%A5%C9\">オーバーロード</a>した関数オブジェクトです．<br/>\n式を出力する <code>printer</code> と 式を計算する <code>calculator</code> を定義します．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">struct</span> printer {\n  <span class=\"synType\">void</span> <span class=\"synStatement\">operator</span>()(add &amp;a) {\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;(&quot;</span>;\n    a.lhs.accept(*<span class=\"synStatement\">this</span>);\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;)&quot;</span>;\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;+&quot;</span>;\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;(&quot;</span>;\n    a.rhs.accept(*<span class=\"synStatement\">this</span>);\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;)&quot;</span>;\n  }\n\n  <span class=\"synType\">void</span> <span class=\"synStatement\">operator</span>()(mul &amp;a) {\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;(&quot;</span>;\n    a.lhs.accept(*<span class=\"synStatement\">this</span>);\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;)&quot;</span>;\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;*&quot;</span>;\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;(&quot;</span>;\n    a.rhs.accept(*<span class=\"synStatement\">this</span>);\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;)&quot;</span>;\n  }\n\n  <span class=\"synType\">void</span> <span class=\"synStatement\">operator</span>()(constant &amp;c) { std::cout &lt;&lt; c.value; }\n};\n\n<span class=\"synType\">struct</span> calculator {\n  <span class=\"synType\">int</span> result;\n  <span class=\"synType\">void</span> <span class=\"synStatement\">operator</span>()(add &amp;a) {\n    calculator l, r;\n    a.lhs.accept(l);\n    a.rhs.accept(r);\n    result = l.result + r.result;\n  }\n\n  <span class=\"synType\">void</span> <span class=\"synStatement\">operator</span>()(mul &amp;m) {\n    calculator l, r;\n    m.lhs.accept(l);\n    m.rhs.accept(r);\n    result = l.result * r.result;\n  }\n\n  <span class=\"synType\">void</span> <span class=\"synStatement\">operator</span>()(constant &amp;c) { result = c.value; }\n};\n</pre>\n\n<p>こんな感じです．<br/>\n<code>visit</code> や <code>accept</code> を <code>void</code> を返す関数として定義したので，<code>calculator</code> は自前のフィールドに結果を保持する必要があります．\n(あとで改善します)</p>\n\n<p>使い方は</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>  node n = mul{add{constant{<span class=\"synConstant\">1</span>}, constant{<span class=\"synConstant\">2</span>}}, constant{<span class=\"synConstant\">3</span>}};\n  printer p;\n  n.accept(p);\n  calculator calc;\n  n.accept(calc);\n  std::cout &lt;&lt; std::endl;\n  std::cout &lt;&lt; calc.result &lt;&lt; std::endl;\n  <span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;\n</pre>\n\n<p>です．</p>\n\n<h1>まとめ</h1>\n\n<p>この方法の利点としては，データの定義そのものに Visitor パターンのためのノイズが入らないことが挙げられます．<br/>\n普通の Visitor パターンでは継承必須ですし．</p>\n\n<p><code>const</code> つけてないせいで一時オブジェクトが使えないので <code>printer p;</code> という行が必要になってしまっています．これは<code>const</code>をがんばってつけるだけなのでまぁ問題有りません．<br/>\n一方，<code>calculator</code> の方はダサいですね．値を返す visitor も定義できるようにしたい．<br/>\n<code>visitor</code> の定義もツライです．<code>const</code> を考慮した場合，同じような内容の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%F3%A5%D0%B4%D8%BF%F4\">メンバ関数</a>を 4 回ずつ書く必要がある．</p>\n\n<p>このへんの問題点は解決可能な気がするので出来たら後で記事にするつもりです．</p>\n\n<p>難しすぎて普通の visitor パターンで良くね？感出てきた</p>\n\n---\n\n---\n","slug":"Type_Erasure_による_Visitor_パターンの実装","title":"Type Erasure による Visitor パターンの実装","timestamp":1453720058000,"tags":[]},{"rawMarkdown":"---\ntitle: \"#include をソートするVimプラグインを作りました\"\ndate: 2016-01-24T10:11:25.000Z\ntags: []\n---\n\n<p><a href=\"http://itchyny.hatenablog.com/entry/2016/01/23/190000\">Haskellでimport文をソートするプラグイン vim-haskell-sort-import を作りました - プログラムモグモグ</a>という記事を拝見して，コードを見たらすごくわかりやすくて，これの <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C/C%2B%2B\">C/C++</a> 版がほしいと思い，書いてみました．</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vim\">vim</a> script はほとんど書いたことがないんですが，やっぱりエディタ拡張用の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\">スクリプト</a>なので，普通の言語と違う部分は多いですね…\nでもその分エディタという UI が既に用意されている状態なので，なんというか書いていて楽しかったです．さくっと書けますし．（先ほどのコードを参考にしているというのもありますが）</p>\n\n<h2>使い方</h2>\n\n<p><code>NeoBundle</code> や <code>vim-plug</code> のような<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%E9%A5%B0%A5%A4%A5%F3\">プラグイン</a>マネージャを使うなどして runtime path に突っ込んでください．\n提供する機能は <code>SortInclude</code> コマンドのみです．</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20160124/20160124191335.gif\" alt=\"f:id:agtn:20160124191335g:plain\" title=\"f:id:agtn:20160124191335g:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>こんな感じの動作をします．</p>\n\n<p><code>#include</code> は <code>\"\"</code> を使う場合と <code>&lt;&gt;</code> を使う場合があり，それぞれファイルパスの探索場所が異なるので，それぞれ別のグループとしてソートするようにしました．</p>\n\n<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&quot;a.h&quot;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&quot;z.h&quot;</span>\n</pre>\n\n<p>が</p>\n\n<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&quot;a.h&quot;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&quot;z.h&quot;</span>\n</pre>\n\n<p>にソートされたら気持ち悪いと思うので．</p>\n\n<p>あとは参考にさせていただいた<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%E9%A5%B0%A5%A4%A5%F3\">プラグイン</a>と同様，空行を挟むなどブロック化されている場合は，ブロック内でソートします．</p>\n\n<p><code>#include</code> をソートするとか既にありふれてそうですが，はじめての <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vim\">vim</a> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%E9%A5%B0%A5%A4%A5%F3\">プラグイン</a>ということで．\nせっかくなのでドキュメントなども <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vim\">vim</a> の help フォーマットにしたがって書いてみました．</p>\n\n---\n\n---\n","contentMarkdown":"\n<p><a href=\"http://itchyny.hatenablog.com/entry/2016/01/23/190000\">Haskellでimport文をソートするプラグイン vim-haskell-sort-import を作りました - プログラムモグモグ</a>という記事を拝見して，コードを見たらすごくわかりやすくて，これの <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C/C%2B%2B\">C/C++</a> 版がほしいと思い，書いてみました．</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vim\">vim</a> script はほとんど書いたことがないんですが，やっぱりエディタ拡張用の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\">スクリプト</a>なので，普通の言語と違う部分は多いですね…\nでもその分エディタという UI が既に用意されている状態なので，なんというか書いていて楽しかったです．さくっと書けますし．（先ほどのコードを参考にしているというのもありますが）</p>\n\n<h2>使い方</h2>\n\n<p><code>NeoBundle</code> や <code>vim-plug</code> のような<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%E9%A5%B0%A5%A4%A5%F3\">プラグイン</a>マネージャを使うなどして runtime path に突っ込んでください．\n提供する機能は <code>SortInclude</code> コマンドのみです．</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20160124/20160124191335.gif\" alt=\"f:id:agtn:20160124191335g:plain\" title=\"f:id:agtn:20160124191335g:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>こんな感じの動作をします．</p>\n\n<p><code>#include</code> は <code>\"\"</code> を使う場合と <code>&lt;&gt;</code> を使う場合があり，それぞれファイルパスの探索場所が異なるので，それぞれ別のグループとしてソートするようにしました．</p>\n\n<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&quot;a.h&quot;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&quot;z.h&quot;</span>\n</pre>\n\n<p>が</p>\n\n<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&quot;a.h&quot;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&quot;z.h&quot;</span>\n</pre>\n\n<p>にソートされたら気持ち悪いと思うので．</p>\n\n<p>あとは参考にさせていただいた<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%E9%A5%B0%A5%A4%A5%F3\">プラグイン</a>と同様，空行を挟むなどブロック化されている場合は，ブロック内でソートします．</p>\n\n<p><code>#include</code> をソートするとか既にありふれてそうですが，はじめての <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vim\">vim</a> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%E9%A5%B0%A5%A4%A5%F3\">プラグイン</a>ということで．\nせっかくなのでドキュメントなども <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vim\">vim</a> の help フォーマットにしたがって書いてみました．</p>\n\n---\n\n---\n","slug":"include-cpp-vim-plugin","title":"#include をソートするVimプラグインを作りました","timestamp":1453630285000,"tags":[]},{"rawMarkdown":"---\ntitle: \"コンパイラ内部の AST 表現について\"\ndate: 2015-12-29T14:25:44.000Z\ntags: []\n---\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>は大体，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>し，AST を作り，意味解析，コード生成という流れで実装されると思います．</p>\n\n<p>さて，AST は単純に書くと</p>\n\n<pre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink><span class=\"synStatement\">type</span> expr <span class=\"synStatement\">=</span>\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Int</span> <span class=\"synStatement\">of</span> <span class=\"synType\">int</span>\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Add</span> <span class=\"synStatement\">of</span> expr <span class=\"synStatement\">*</span> expr\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Apply</span> <span class=\"synStatement\">of</span> expr <span class=\"synStatement\">*</span> expr <span class=\"synType\">list</span>\n  <span class=\"synStatement\">|</span> ...\n</pre>\n\n<p>みたいな感じに書けると思います．</p>\n\n<p>これで確かに<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>の syntax 上の余計な飾りをとっぱらった<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>になっているので抽象<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%CC%DA\">構文木</a>としては十分機能します．\n一方，既存の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>を見ると，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>の後，型検査などの意味解析時にプログラムの不正を見つけた場合，きちんとソース上の位置を合わせて通知してくれます．\nこのためには，AST に位置情報を含める必要があります．</p>\n\n<p>また，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>の前後で，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>としては同じ構造だけれども，型情報の持ち方に違いがあるという状況もあります．</p>\n\n<pre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink><span class=\"synComment\">(* 型推論前 *)</span>\n<span class=\"synStatement\">type</span> expr <span class=\"synStatement\">=</span>\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Int</span> <span class=\"synStatement\">of</span> <span class=\"synType\">int</span>\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Add</span> <span class=\"synStatement\">of</span> expr <span class=\"synStatement\">*</span> expr\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Apply</span> <span class=\"synStatement\">of</span> expr <span class=\"synStatement\">*</span> expr <span class=\"synType\">list</span>\n\n<span class=\"synComment\">(* 型推論後 *)</span>\n<span class=\"synStatement\">type</span> texpr <span class=\"synStatement\">=</span>\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Typed_int</span> <span class=\"synStatement\">of</span> <span class=\"synType\">int</span>\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Typed_add</span> <span class=\"synStatement\">of</span> texpr <span class=\"synStatement\">*</span> texpr\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Typed_apply</span> <span class=\"synStatement\">of</span> texpr <span class=\"synStatement\">*</span> texpr <span class=\"synType\">list</span>\n</pre>\n\n<p>このように AST の表現は，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>としては同じだが付随する情報だけが異なるという場合があります．</p>\n\n<p>いろいろな言語の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>の AST 表現を調査してみたところ，Elm <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>の方式が良かったのでまとめておきたいと思います．</p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink><span class=\"synType\">type</span> Expr annotation definition variable tipe <span class=\"synStatement\">=</span>\n    A.Annotated annotation (Expr' annotation definition variable tipe)\n\n\n<span class=\"synType\">data</span> Expr' ann def var typ\n    <span class=\"synStatement\">=</span> Literal Literal.Literal\n    <span class=\"synStatement\">|</span> Var var\n    <span class=\"synStatement\">|</span> Range (Expr ann def var typ) (Expr ann def var typ)\n    <span class=\"synStatement\">|</span> ExplicitList [Expr ann def var typ]\n    <span class=\"synStatement\">|</span> Binop var (Expr ann def var typ) (Expr ann def var typ)\n    <span class=\"synStatement\">|</span> Lambda (Pattern.Pattern ann var) (Expr ann def var typ)\n    <span class=\"synStatement\">|</span> App (Expr ann def var typ) (Expr ann def var typ)\n    <span class=\"synStatement\">|</span> If [(Expr ann def var typ, Expr ann def var typ)] (Expr ann def var typ)\n    <span class=\"synStatement\">|</span> Let [def] (Expr ann def var typ)\n    <span class=\"synStatement\">|</span> Case (Expr ann def var typ) [(Pattern.Pattern ann var, Expr ann def var typ)]\n    <span class=\"synStatement\">|</span> Data String [Expr ann def var typ]\n    <span class=\"synStatement\">|</span> Access (Expr ann def var typ) String\n    <span class=\"synStatement\">|</span> Update (Expr ann def var typ) [(String, Expr ann def var typ)]\n    <span class=\"synStatement\">|</span> Record [(String, Expr ann def var typ)]\n    <span class=\"synComment\">-- for type checking and code gen only</span>\n    <span class=\"synStatement\">|</span> Port (PortImpl (Expr ann def var typ) typ)\n    <span class=\"synStatement\">|</span> GLShader String String Literal.GLShaderTipe\n</pre>\n\n<p>Elm <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> で実装されています．\n<code>Expr</code> が型引数として，<code>annotation</code> などを持っています．(<code>definition</code>, <code>tipe</code> についてはいまいちなんのための抽象化か理解していません...)\n<code>annotation</code> は，AST に付随する情報です．<code>A.Annotated</code> という型が，核となる情報に，情報を annotate する役割を担います．</p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink><span class=\"synType\">data</span> Annotated annotation a\n    <span class=\"synStatement\">=</span> A annotation a\n</pre>\n\n<p>そして，AST の核となる構造自体は <code>Expr'</code> が持ちます．</p>\n\n<p>こうすることで，<code>annotation</code> の内容を変えるだけで，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>を何度も書き直す必要なく，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>の各ステップに適した AST 表現を作る事ができます．\nちなみに <code>variable</code> はどうやら変数などの名前を表現する型を表しているようです．(始めは単なる <code>String</code>)</p>\n\n---\n\n---\n","contentMarkdown":"\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>は大体，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>し，AST を作り，意味解析，コード生成という流れで実装されると思います．</p>\n\n<p>さて，AST は単純に書くと</p>\n\n<pre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink><span class=\"synStatement\">type</span> expr <span class=\"synStatement\">=</span>\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Int</span> <span class=\"synStatement\">of</span> <span class=\"synType\">int</span>\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Add</span> <span class=\"synStatement\">of</span> expr <span class=\"synStatement\">*</span> expr\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Apply</span> <span class=\"synStatement\">of</span> expr <span class=\"synStatement\">*</span> expr <span class=\"synType\">list</span>\n  <span class=\"synStatement\">|</span> ...\n</pre>\n\n<p>みたいな感じに書けると思います．</p>\n\n<p>これで確かに<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>の syntax 上の余計な飾りをとっぱらった<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>になっているので抽象<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%CC%DA\">構文木</a>としては十分機能します．\n一方，既存の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>を見ると，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>の後，型検査などの意味解析時にプログラムの不正を見つけた場合，きちんとソース上の位置を合わせて通知してくれます．\nこのためには，AST に位置情報を含める必要があります．</p>\n\n<p>また，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>の前後で，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>としては同じ構造だけれども，型情報の持ち方に違いがあるという状況もあります．</p>\n\n<pre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink><span class=\"synComment\">(* 型推論前 *)</span>\n<span class=\"synStatement\">type</span> expr <span class=\"synStatement\">=</span>\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Int</span> <span class=\"synStatement\">of</span> <span class=\"synType\">int</span>\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Add</span> <span class=\"synStatement\">of</span> expr <span class=\"synStatement\">*</span> expr\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Apply</span> <span class=\"synStatement\">of</span> expr <span class=\"synStatement\">*</span> expr <span class=\"synType\">list</span>\n\n<span class=\"synComment\">(* 型推論後 *)</span>\n<span class=\"synStatement\">type</span> texpr <span class=\"synStatement\">=</span>\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Typed_int</span> <span class=\"synStatement\">of</span> <span class=\"synType\">int</span>\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Typed_add</span> <span class=\"synStatement\">of</span> texpr <span class=\"synStatement\">*</span> texpr\n  <span class=\"synStatement\">|</span> <span class=\"synConstant\">Typed_apply</span> <span class=\"synStatement\">of</span> texpr <span class=\"synStatement\">*</span> texpr <span class=\"synType\">list</span>\n</pre>\n\n<p>このように AST の表現は，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>としては同じだが付随する情報だけが異なるという場合があります．</p>\n\n<p>いろいろな言語の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>の AST 表現を調査してみたところ，Elm <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>の方式が良かったのでまとめておきたいと思います．</p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink><span class=\"synType\">type</span> Expr annotation definition variable tipe <span class=\"synStatement\">=</span>\n    A.Annotated annotation (Expr' annotation definition variable tipe)\n\n\n<span class=\"synType\">data</span> Expr' ann def var typ\n    <span class=\"synStatement\">=</span> Literal Literal.Literal\n    <span class=\"synStatement\">|</span> Var var\n    <span class=\"synStatement\">|</span> Range (Expr ann def var typ) (Expr ann def var typ)\n    <span class=\"synStatement\">|</span> ExplicitList [Expr ann def var typ]\n    <span class=\"synStatement\">|</span> Binop var (Expr ann def var typ) (Expr ann def var typ)\n    <span class=\"synStatement\">|</span> Lambda (Pattern.Pattern ann var) (Expr ann def var typ)\n    <span class=\"synStatement\">|</span> App (Expr ann def var typ) (Expr ann def var typ)\n    <span class=\"synStatement\">|</span> If [(Expr ann def var typ, Expr ann def var typ)] (Expr ann def var typ)\n    <span class=\"synStatement\">|</span> Let [def] (Expr ann def var typ)\n    <span class=\"synStatement\">|</span> Case (Expr ann def var typ) [(Pattern.Pattern ann var, Expr ann def var typ)]\n    <span class=\"synStatement\">|</span> Data String [Expr ann def var typ]\n    <span class=\"synStatement\">|</span> Access (Expr ann def var typ) String\n    <span class=\"synStatement\">|</span> Update (Expr ann def var typ) [(String, Expr ann def var typ)]\n    <span class=\"synStatement\">|</span> Record [(String, Expr ann def var typ)]\n    <span class=\"synComment\">-- for type checking and code gen only</span>\n    <span class=\"synStatement\">|</span> Port (PortImpl (Expr ann def var typ) typ)\n    <span class=\"synStatement\">|</span> GLShader String String Literal.GLShaderTipe\n</pre>\n\n<p>Elm <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> で実装されています．\n<code>Expr</code> が型引数として，<code>annotation</code> などを持っています．(<code>definition</code>, <code>tipe</code> についてはいまいちなんのための抽象化か理解していません...)\n<code>annotation</code> は，AST に付随する情報です．<code>A.Annotated</code> という型が，核となる情報に，情報を annotate する役割を担います．</p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink><span class=\"synType\">data</span> Annotated annotation a\n    <span class=\"synStatement\">=</span> A annotation a\n</pre>\n\n<p>そして，AST の核となる構造自体は <code>Expr'</code> が持ちます．</p>\n\n<p>こうすることで，<code>annotation</code> の内容を変えるだけで，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%DA%B9%BD%C2%A4\">木構造</a>を何度も書き直す必要なく，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>の各ステップに適した AST 表現を作る事ができます．\nちなみに <code>variable</code> はどうやら変数などの名前を表現する型を表しているようです．(始めは単なる <code>String</code>)</p>\n\n---\n\n---\n","slug":"コンパイラ内部の_AST_表現について","title":"コンパイラ内部の AST 表現について","timestamp":1451399144000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Boost.Spirit.X3 で簡易電卓を実装 1\"\ndate: 2015-12-18T14:27:05.000Z\ntags: []\n---\n\n<p><iframe src=\"http://agtn.hatenablog.com/embed/2015/12/17/190505\" title=\"Boost.Spirit.X3 の練習1 - プログラミングのメモ帳➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://agtn.hatenablog.com/entry/2015/12/17/190505\">agtn.hatenablog.com</a></cite>\n<iframe src=\"http://agtn.hatenablog.com/embed/2015/12/17/232003\" title=\"Boost.Spirit.X3 の練習 2 - プログラミングのメモ帳➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://agtn.hatenablog.com/entry/2015/12/17/232003\">agtn.hatenablog.com</a></cite></p>\n\n<p>引き続き，<code>Boost.Spirit.X3</code> です．<br/>\n今回は，前回までの知識をつかって，簡易電卓を実装してみます．</p>\n\n<h2>仕様</h2>\n\n<p>今回定義する電卓は，</p>\n\n<ul>\n<li><code>+</code></li>\n<li><code>-</code></li>\n<li><code>*</code></li>\n<li><code>/</code></li>\n</ul>\n\n<p>の 4 つの演算と単項の <code>-</code> をサポートします．<br/>\nまた，整数型のみを扱うものとします．<br/>\n<code>(</code>, <code>)</code> でくくることで，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\">演算子</a>の結合優先順位を書き換えられ，<code>*</code> と <code>/</code> は <code>+</code> と <code>-</code> より優先されるとします．</p>\n\n<p>要するに整数の四則演算のみをサポートする電卓です．</p>\n\n<p>このような電卓を実装するサンプルは <code>Boost.Spirit.X3</code> 以外のライブラリ/<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C4%A1%BC%A5%EB\">ツール</a>でも大量に出てくると思います．<br/>\n今回は，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>そのものというよりは <code>Boost.Spirit.X3</code> の使い方についてメモしたいので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>そのものの話はぐぐってみてください．</p>\n\n<h2>パーサの骨格</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\">演算子</a>の結合規則をサポートするために，<code>primary</code>(定数と <code>()</code> で囲まれた式), <code>neg_expr</code>(単項 <code>-</code>), <code>mul_expr</code>(<code>*</code>, <code>/</code>), <code>add_expr</code>(<code>+</code>, <code>-</code>), <code>expression</code> というパーサをそれぞれ定義します．<br/>\n先頭から順に結合強度が強くなっています．(<code>expression</code> が最弱, <code>primary</code> が最強)</p>\n\n<p><code>primary</code> は <code>()</code> で囲まれた式，つまり <code>\"(\" &gt; expression &gt; \")\"</code> を受け付ける必要があり，また，<code>primary</code> 自体も <code>expression</code> の一部です．<br/>\nしたがって，この規則を定義するためには，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>的なパーサを記述する必要があります．</p>\n\n<p><code>X3</code> で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>的なパーサを記述する方法は<a href=\"http://agtn.hatenablog.com/entry/2015/12/17/232003\">前回の記事</a>にまとめました．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>  <span class=\"synType\">struct</span> primary;\n  <span class=\"synType\">struct</span> neg_expr;\n  <span class=\"synType\">struct</span> mul_expr;\n  <span class=\"synType\">struct</span> add_expr;\n  <span class=\"synType\">struct</span> expression;\n\n  x3::rule&lt;primary, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> primary;\n  x3::rule&lt;neg_expr, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> neg_expr;\n  x3::rule&lt;mul_expr, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> mul_expr;\n  x3::rule&lt;add_expr, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> add_expr;\n  x3::rule&lt;expression, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> expression;\n</pre>\n\n<p>それぞれのパーサは attribute として整数型を持ちます．ここに演算結果が格納されることになります．<br/>\n<code>struct primary</code> などは，今は前方宣言のみで十分です．<code>on_error</code> などを実装したくなった時に定義します．</p>\n\n<h2>primary</h2>\n\n<p>まずは <code>primary</code> を定義します.<br/>\n<code>primary</code> は整数定数か， <code>()</code> で囲まれた <code>expression</code> を受理します．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">auto</span> <span class=\"synType\">const</span> primary_def =\n    x3::int_\n  | <span class=\"synConstant\">&quot;(&quot;</span> &gt; expression &gt; <span class=\"synConstant\">&quot;)&quot;</span>\n  ;\n</pre>\n\n<p>attribute を考慮しなければこんな感じでしょうか．<code>expression</code> は既に宣言されているので使用可能です．(<code>expression</code> の実装がこの時点で見えていなくても使用できます.)</p>\n\n<p>単純に attribute を結果として返すセマンティックアクションはこの後もよく出てくるので，ヘルパとして定義しておきます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">namespace</span> detail {\n\n  decltype(<span class=\"synType\">auto</span>) assign()\n  {\n    <span class=\"synStatement\">using</span> x3::_attr;\n    <span class=\"synStatement\">using</span> x3::_val;\n    <span class=\"synStatement\">return</span> [](<span class=\"synType\">auto</span>&amp;&amp; ctx) { _val(ctx) = _attr(ctx); };\n  }\n\n} <span class=\"synComment\">// namespace detail</span>\n</pre>\n\n<p><code>assign</code> は attribute を結果に代入する関数オブジェクトを返します．<br/>\n関数にする必要が特にありませんが，この後出てくるヘルパと見た目を合わせたいので関数にしました．</p>\n\n<p>これを使うと，</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">auto</span> primary_def =\n    x3::int_[detail::assign()]\n  | (<span class=\"synConstant\">&quot;(&quot;</span> &gt; expression &gt; <span class=\"synConstant\">&quot;)&quot;</span>)[detail::assign()]\n  ;\n</pre>\n\n<p>こんな感じで <code>primary</code> が定義できます．</p>\n\n<h2>単項マイナス</h2>\n\n<p>次に <code>neg_expr</code> を定義します．\nセマンティックアクションを考えなければ，</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">auto</span> <span class=\"synType\">const</span> neg_expr_def =\n    primary\n  | <span class=\"synConstant\">&quot;-&quot;</span> &gt; primary\n  ;\n</pre>\n\n<p>となります．<br/>\n<code>\"-\" &gt; primary</code> のセマンティックアクションとしては，attribute を符号反転して結果に格納するというアクションが求められます．<br/>\nここはちょっと汎用的に，attribute に関数オブジェクトを適用して結果に格納するアクションを返すような関数を定義して解決してみます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">namespace</span> detail {\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> F&gt;\n  decltype(<span class=\"synType\">auto</span>) assign_f(F&amp;&amp; func)\n  {\n    <span class=\"synStatement\">return</span> [func](<span class=\"synType\">auto</span>&amp;&amp; ctx) { _val(ctx) = func(_attr(ctx)); };\n  }\n} <span class=\"synComment\">// namespace detail</span>\n</pre>\n\n<p><code>assign_f</code> は <code>assign</code> と異なり，関数オブジェクトを１つ引数に取ります．<br/>\nそして，その関数オブジェクトを <code>_attr(ctx)</code> に適用し結果に格納します．</p>\n\n<p>これを使って，<code>neg_expr</code> は</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">auto</span> <span class=\"synType\">const</span> neg_expr_def =\n    primary[detail::assign()]\n  | (<span class=\"synConstant\">&quot;-&quot;</span> &gt; primary)[detail::assign(std::negate&lt;<span class=\"synType\">int</span>&gt;<span class=\"synError\">{</span>})]\n  ;\n</pre>\n\n<p>となります．<code>std::negate</code> は <code>&lt;functional&gt;</code> で定義された型で，ここでは <code>int</code> 型の値を符号反転する関数オブジェクトとして使用しています．</p>\n\n<h2>乗除</h2>\n\n<p>次に結合強度が強いのは <code>*</code> と <code>/</code> です．<br/>\nちょっとわかりにくいですが，セマンティックアクションを無視すれば，<code>mul_expr</code> は</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">auto</span> <span class=\"synType\">const</span> mul_expr_def =\n    neg_expr\n    &gt;&gt; *(\n        (<span class=\"synConstant\">&quot;*&quot;</span> &gt;&gt; neg_expr)\n      | (<span class=\"synConstant\">&quot;/&quot;</span> &gt;&gt; neg_expr)\n    )\n  ;\n</pre>\n\n<p>と定義できます．<code>mul_expr</code> は <code>1</code> や <code>(1 + 2)</code>, <code>-1</code> の後に，<code>* 1</code> とか <code>/ -3</code> とか <code>* (1 - 2)</code> とかが 0 回以上現れるような式です．<br/>\n<code>1 * -2</code> はちょっと気持ち悪い気もしますが… 今気がついたので許してください．</p>\n\n<p>セマンティックアクションとしては，<code>(\"*\" &gt;&gt; neg_expr)</code> が現れる度に，<code>_val(ctx)</code> を <code>_val(ctx) * _attr(ctx)</code> に更新すれば良いです．<br/>\n始めの <code>neg_expr</code> の結果を <code>_val(ctx)</code> に格納すれば，<code>_val(ctx)</code> は常に現在の計算結果を表すことになります．<code>(\"*\" &gt;&gt; neg_expr)</code> は現在の計算結果に，今処理した式(<code>*</code> の後に続く式のこと) を処理した結果をかければ良いということです．</p>\n\n<p>というわけで分かりにくいとは思いますが，ほしいアクションは，</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>[](<span class=\"synType\">auto</span>&amp;&amp; ctx) { _val(ctx) = _val(ctx) * _attr(ctx); }\n</pre>\n\n<p>です．</p>\n\n<p>さて，では <code>/</code> の場合を考えます．<br/>\n<code>/</code> の場合であってもほとんどは <code>*</code> と同じであることがわかります．<br/>\nほしいアクションは</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>[](<span class=\"synType\">auto</span>&amp;&amp; ctx) { _val(ctx) = _val(ctx) / _attr(ctx); }\n</pre>\n\n<p>であり，<code>*</code> と <code>/</code> の違いしか有りません．</p>\n\n<p>そこでこれも関数にまとめてしまいます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">namespace</span> detail {\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> Op&gt;\n  decltype(<span class=\"synType\">auto</span>) calc_op(Op&amp;&amp; op)\n  {\n    <span class=\"synStatement\">return</span> [op](<span class=\"synType\">auto</span>&amp;&amp; ctx) { _val(ctx) = op(_val(ctx), _attr(ctx)); };\n  }\n\n} <span class=\"synComment\">// namespace detail</span>\n</pre>\n\n<p>こんな関数を定義して，</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">auto</span> <span class=\"synType\">const</span> mul_expr_def =\n    neg_expr[detail::assign()]\n    &gt;&gt; *(\n        (<span class=\"synConstant\">&quot;*&quot;</span> &gt;&gt; neg_expr)[detail::calc_op(std::multiplies&lt;<span class=\"synType\">int</span>&gt;<span class=\"synError\">{</span>})]\n      | (<span class=\"synConstant\">&quot;/&quot;</span> &gt;&gt; neg_expr)[detail::calc_op(std::divides&lt;<span class=\"synType\">int</span>&gt;<span class=\"synError\">{</span>})]\n    )\n  ;\n</pre>\n\n<p>と使います．<br/>\n<code>calc_op</code> は関数オブジェクトを引数に取り，<code>_val(ctx)</code> と <code>_attr(ctx)</code> に適用した結果を格納するアクションを返します．</p>\n\n<p><code>add_expr</code> は <code>mul_expr</code> とほぼおなじなので詳細はスキップします．</p>\n\n<h2>expression</h2>\n\n<p>最後に <code>expression</code> です．これは単純に <code>add_expr</code> と一致します．<br/>\n命名のわかりやすさと，今後拡張していく際に便利そうということで分けてあるだけです．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">auto</span> <span class=\"synType\">const</span> expression_def =\n    add_expr[detail::assign()]\n  ;\n</pre>\n\n<h2>確認</h2>\n\n<p>コード全体を掲載します．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;boost/spirit/home/x3.hpp&gt;</span>\n\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;functional&gt;</span>\n\n<span class=\"synType\">namespace</span> x3 = boost::spirit::x3;\n\n<span class=\"synType\">namespace</span> grammar {\n\n  <span class=\"synType\">namespace</span> detail {\n\n    decltype(<span class=\"synType\">auto</span>) assign()\n    {\n      <span class=\"synStatement\">using</span> x3::_attr;\n      <span class=\"synStatement\">using</span> x3::_val;\n      <span class=\"synStatement\">return</span> [](<span class=\"synType\">auto</span>&amp;&amp; ctx) { _val(ctx) = _attr(ctx); };\n    }\n\n    <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> F&gt;\n    decltype(<span class=\"synType\">auto</span>) assign_f(F&amp;&amp; func)\n    {\n      <span class=\"synStatement\">return</span> [func](<span class=\"synType\">auto</span>&amp;&amp; ctx) { _val(ctx) = func(_attr(ctx)); };\n    }\n\n    <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> Op&gt;\n    decltype(<span class=\"synType\">auto</span>) calc_op(Op&amp;&amp; op)\n    {\n      <span class=\"synStatement\">return</span> [op](<span class=\"synType\">auto</span>&amp;&amp; ctx) { x3::_val(ctx) = op(x3::_val(ctx), x3::_attr(ctx)); };\n    }\n\n  } <span class=\"synComment\">// namespace detail</span>\n\n  <span class=\"synType\">struct</span> primary;\n  <span class=\"synType\">struct</span> neg_expr;\n  <span class=\"synType\">struct</span> mul_expr;\n  <span class=\"synType\">struct</span> add_expr;\n  <span class=\"synType\">struct</span> expression;\n\n  x3::rule&lt;primary, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> primary;\n  x3::rule&lt;neg_expr, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> neg_expr;\n  x3::rule&lt;mul_expr, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> mul_expr;\n  x3::rule&lt;add_expr, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> add_expr;\n  x3::rule&lt;expression, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> expression;\n\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> primary_def =\n      x3::int_[detail::assign()]\n    | (<span class=\"synConstant\">&quot;(&quot;</span> &gt; expression &gt; <span class=\"synConstant\">&quot;)&quot;</span>)[detail::assign()]\n    ;\n\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> neg_expr_def =\n      primary[detail::assign()]\n    | (<span class=\"synConstant\">&quot;-&quot;</span> &gt; primary)[detail::assign_f(std::negate&lt;<span class=\"synType\">int</span>&gt;<span class=\"synError\">{</span>})]\n    ;\n\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> mul_expr_def =\n      neg_expr[detail::assign()]\n      &gt;&gt; *(\n          (<span class=\"synConstant\">&quot;*&quot;</span> &gt;&gt; neg_expr)[detail::calc_op(std::multiplies&lt;<span class=\"synType\">int</span>&gt;<span class=\"synError\">{</span>})]\n        | (<span class=\"synConstant\">&quot;/&quot;</span> &gt;&gt; neg_expr)[detail::calc_op(std::divides&lt;<span class=\"synType\">int</span>&gt;<span class=\"synError\">{</span>})]\n      )\n    ;\n\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> add_expr_def =\n      mul_expr[detail::assign()]\n      &gt;&gt; *(\n          (<span class=\"synConstant\">&quot;+&quot;</span> &gt; mul_expr)[detail::calc_op(std::plus&lt;<span class=\"synType\">int</span>&gt;<span class=\"synError\">{</span>})]\n        | (<span class=\"synConstant\">&quot;-&quot;</span> &gt; mul_expr)[detail::calc_op(std::minus&lt;<span class=\"synType\">int</span>&gt;<span class=\"synError\">{</span>})]\n      )\n    ;\n\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> expression_def =\n      add_expr[detail::assign()]\n    ;\n\n  BOOST_SPIRIT_DEFINE(\n      primary,\n      neg_expr,\n      mul_expr,\n      add_expr,\n      expression\n      );\n\n} <span class=\"synComment\">// namespace grammar</span>\n<span class=\"synStatement\">using</span> grammar::expression;\n\n<span class=\"synType\">int</span> main()\n{\n  std::string str;\n  std::getline(std::cin, str);\n\n  <span class=\"synType\">auto</span> first(std::cbegin(str));\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> last(std::cend(str));\n\n  <span class=\"synType\">int</span> result;\n  <span class=\"synType\">bool</span> success = x3::phrase_parse(first, last, expression, x3::ascii::space, result);\n\n  <span class=\"synStatement\">if</span> (!success || first != last) {\n    std::cerr &lt;&lt; <span class=\"synConstant\">&quot;Parse failed.&quot;</span> &lt;&lt; std::endl;\n    <span class=\"synStatement\">return</span> <span class=\"synConstant\">1</span>;\n  }\n\n  std::cout &lt;&lt; <span class=\"synConstant\">&quot;Parsed: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;\n  <span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;\n}\n</pre>\n\n<p>実行してみます．</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>$ clang++ -std=c++14 main.cpp\n$ ./a.out\n1 + 2 * 3\nParsed: 7\n$ ./a.out\n(1 + 2) * 3\nParsed: 9</pre>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\">演算子</a>の優先順位が正しく解決できていることが確認出来ます．</p>\n\n<h2>まとめ</h2>\n\n<p>今回は，セマンティックアクションで計算自体を行ってしまいましたが，普通は抽象<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%CC%DA\">構文木</a>(AST) に変換するためにセマンティックアクションを使うのが正道だと思います．<br/>\n<code>X3</code> は AST のための色々を提供してくれていますが，自前で作った AST でもちょっと苦労はするかもしれませんが変換できるはずなので，時間があれば，自前 AST に変換してから実行する電卓も作ってみたいと思います．</p>\n\n<p>また，AST に変換して計算する場合，AST に位置情報を付与することで，エラーレポートが便利になったりするはずです( 0 除算のエラーを通知する際，どの部分でのエラーなのかを吐いてくれればうれしいですよね).<br/>\nパース失敗時にもどこで失敗したのかをレポートしてくれたほうが便利です．<br/>\n<code>X3</code> で <code>on_error</code>, <code>on_success</code> を使ってこれらを実装してみようと考えています．</p>\n\n<p>今回のコードでは <code>decltype(auto)</code> など，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>14 の機能を使っています．<code>X3</code> は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>14 前提のライブラリなので，迷いなくこういった機能を使用できて幸せデスね．</p>\n\n---\n\n---\n","contentMarkdown":"\n<p><iframe src=\"http://agtn.hatenablog.com/embed/2015/12/17/190505\" title=\"Boost.Spirit.X3 の練習1 - プログラミングのメモ帳➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://agtn.hatenablog.com/entry/2015/12/17/190505\">agtn.hatenablog.com</a></cite>\n<iframe src=\"http://agtn.hatenablog.com/embed/2015/12/17/232003\" title=\"Boost.Spirit.X3 の練習 2 - プログラミングのメモ帳➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://agtn.hatenablog.com/entry/2015/12/17/232003\">agtn.hatenablog.com</a></cite></p>\n\n<p>引き続き，<code>Boost.Spirit.X3</code> です．<br/>\n今回は，前回までの知識をつかって，簡易電卓を実装してみます．</p>\n\n<h2>仕様</h2>\n\n<p>今回定義する電卓は，</p>\n\n<ul>\n<li><code>+</code></li>\n<li><code>-</code></li>\n<li><code>*</code></li>\n<li><code>/</code></li>\n</ul>\n\n<p>の 4 つの演算と単項の <code>-</code> をサポートします．<br/>\nまた，整数型のみを扱うものとします．<br/>\n<code>(</code>, <code>)</code> でくくることで，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\">演算子</a>の結合優先順位を書き換えられ，<code>*</code> と <code>/</code> は <code>+</code> と <code>-</code> より優先されるとします．</p>\n\n<p>要するに整数の四則演算のみをサポートする電卓です．</p>\n\n<p>このような電卓を実装するサンプルは <code>Boost.Spirit.X3</code> 以外のライブラリ/<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C4%A1%BC%A5%EB\">ツール</a>でも大量に出てくると思います．<br/>\n今回は，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>そのものというよりは <code>Boost.Spirit.X3</code> の使い方についてメモしたいので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>そのものの話はぐぐってみてください．</p>\n\n<h2>パーサの骨格</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\">演算子</a>の結合規則をサポートするために，<code>primary</code>(定数と <code>()</code> で囲まれた式), <code>neg_expr</code>(単項 <code>-</code>), <code>mul_expr</code>(<code>*</code>, <code>/</code>), <code>add_expr</code>(<code>+</code>, <code>-</code>), <code>expression</code> というパーサをそれぞれ定義します．<br/>\n先頭から順に結合強度が強くなっています．(<code>expression</code> が最弱, <code>primary</code> が最強)</p>\n\n<p><code>primary</code> は <code>()</code> で囲まれた式，つまり <code>\"(\" &gt; expression &gt; \")\"</code> を受け付ける必要があり，また，<code>primary</code> 自体も <code>expression</code> の一部です．<br/>\nしたがって，この規則を定義するためには，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>的なパーサを記述する必要があります．</p>\n\n<p><code>X3</code> で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>的なパーサを記述する方法は<a href=\"http://agtn.hatenablog.com/entry/2015/12/17/232003\">前回の記事</a>にまとめました．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>  <span class=\"synType\">struct</span> primary;\n  <span class=\"synType\">struct</span> neg_expr;\n  <span class=\"synType\">struct</span> mul_expr;\n  <span class=\"synType\">struct</span> add_expr;\n  <span class=\"synType\">struct</span> expression;\n\n  x3::rule&lt;primary, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> primary;\n  x3::rule&lt;neg_expr, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> neg_expr;\n  x3::rule&lt;mul_expr, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> mul_expr;\n  x3::rule&lt;add_expr, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> add_expr;\n  x3::rule&lt;expression, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> expression;\n</pre>\n\n<p>それぞれのパーサは attribute として整数型を持ちます．ここに演算結果が格納されることになります．<br/>\n<code>struct primary</code> などは，今は前方宣言のみで十分です．<code>on_error</code> などを実装したくなった時に定義します．</p>\n\n<h2>primary</h2>\n\n<p>まずは <code>primary</code> を定義します.<br/>\n<code>primary</code> は整数定数か， <code>()</code> で囲まれた <code>expression</code> を受理します．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">auto</span> <span class=\"synType\">const</span> primary_def =\n    x3::int_\n  | <span class=\"synConstant\">&quot;(&quot;</span> &gt; expression &gt; <span class=\"synConstant\">&quot;)&quot;</span>\n  ;\n</pre>\n\n<p>attribute を考慮しなければこんな感じでしょうか．<code>expression</code> は既に宣言されているので使用可能です．(<code>expression</code> の実装がこの時点で見えていなくても使用できます.)</p>\n\n<p>単純に attribute を結果として返すセマンティックアクションはこの後もよく出てくるので，ヘルパとして定義しておきます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">namespace</span> detail {\n\n  decltype(<span class=\"synType\">auto</span>) assign()\n  {\n    <span class=\"synStatement\">using</span> x3::_attr;\n    <span class=\"synStatement\">using</span> x3::_val;\n    <span class=\"synStatement\">return</span> [](<span class=\"synType\">auto</span>&amp;&amp; ctx) { _val(ctx) = _attr(ctx); };\n  }\n\n} <span class=\"synComment\">// namespace detail</span>\n</pre>\n\n<p><code>assign</code> は attribute を結果に代入する関数オブジェクトを返します．<br/>\n関数にする必要が特にありませんが，この後出てくるヘルパと見た目を合わせたいので関数にしました．</p>\n\n<p>これを使うと，</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">auto</span> primary_def =\n    x3::int_[detail::assign()]\n  | (<span class=\"synConstant\">&quot;(&quot;</span> &gt; expression &gt; <span class=\"synConstant\">&quot;)&quot;</span>)[detail::assign()]\n  ;\n</pre>\n\n<p>こんな感じで <code>primary</code> が定義できます．</p>\n\n<h2>単項マイナス</h2>\n\n<p>次に <code>neg_expr</code> を定義します．\nセマンティックアクションを考えなければ，</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">auto</span> <span class=\"synType\">const</span> neg_expr_def =\n    primary\n  | <span class=\"synConstant\">&quot;-&quot;</span> &gt; primary\n  ;\n</pre>\n\n<p>となります．<br/>\n<code>\"-\" &gt; primary</code> のセマンティックアクションとしては，attribute を符号反転して結果に格納するというアクションが求められます．<br/>\nここはちょっと汎用的に，attribute に関数オブジェクトを適用して結果に格納するアクションを返すような関数を定義して解決してみます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">namespace</span> detail {\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> F&gt;\n  decltype(<span class=\"synType\">auto</span>) assign_f(F&amp;&amp; func)\n  {\n    <span class=\"synStatement\">return</span> [func](<span class=\"synType\">auto</span>&amp;&amp; ctx) { _val(ctx) = func(_attr(ctx)); };\n  }\n} <span class=\"synComment\">// namespace detail</span>\n</pre>\n\n<p><code>assign_f</code> は <code>assign</code> と異なり，関数オブジェクトを１つ引数に取ります．<br/>\nそして，その関数オブジェクトを <code>_attr(ctx)</code> に適用し結果に格納します．</p>\n\n<p>これを使って，<code>neg_expr</code> は</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">auto</span> <span class=\"synType\">const</span> neg_expr_def =\n    primary[detail::assign()]\n  | (<span class=\"synConstant\">&quot;-&quot;</span> &gt; primary)[detail::assign(std::negate&lt;<span class=\"synType\">int</span>&gt;<span class=\"synError\">{</span>})]\n  ;\n</pre>\n\n<p>となります．<code>std::negate</code> は <code>&lt;functional&gt;</code> で定義された型で，ここでは <code>int</code> 型の値を符号反転する関数オブジェクトとして使用しています．</p>\n\n<h2>乗除</h2>\n\n<p>次に結合強度が強いのは <code>*</code> と <code>/</code> です．<br/>\nちょっとわかりにくいですが，セマンティックアクションを無視すれば，<code>mul_expr</code> は</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">auto</span> <span class=\"synType\">const</span> mul_expr_def =\n    neg_expr\n    &gt;&gt; *(\n        (<span class=\"synConstant\">&quot;*&quot;</span> &gt;&gt; neg_expr)\n      | (<span class=\"synConstant\">&quot;/&quot;</span> &gt;&gt; neg_expr)\n    )\n  ;\n</pre>\n\n<p>と定義できます．<code>mul_expr</code> は <code>1</code> や <code>(1 + 2)</code>, <code>-1</code> の後に，<code>* 1</code> とか <code>/ -3</code> とか <code>* (1 - 2)</code> とかが 0 回以上現れるような式です．<br/>\n<code>1 * -2</code> はちょっと気持ち悪い気もしますが… 今気がついたので許してください．</p>\n\n<p>セマンティックアクションとしては，<code>(\"*\" &gt;&gt; neg_expr)</code> が現れる度に，<code>_val(ctx)</code> を <code>_val(ctx) * _attr(ctx)</code> に更新すれば良いです．<br/>\n始めの <code>neg_expr</code> の結果を <code>_val(ctx)</code> に格納すれば，<code>_val(ctx)</code> は常に現在の計算結果を表すことになります．<code>(\"*\" &gt;&gt; neg_expr)</code> は現在の計算結果に，今処理した式(<code>*</code> の後に続く式のこと) を処理した結果をかければ良いということです．</p>\n\n<p>というわけで分かりにくいとは思いますが，ほしいアクションは，</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>[](<span class=\"synType\">auto</span>&amp;&amp; ctx) { _val(ctx) = _val(ctx) * _attr(ctx); }\n</pre>\n\n<p>です．</p>\n\n<p>さて，では <code>/</code> の場合を考えます．<br/>\n<code>/</code> の場合であってもほとんどは <code>*</code> と同じであることがわかります．<br/>\nほしいアクションは</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink>[](<span class=\"synType\">auto</span>&amp;&amp; ctx) { _val(ctx) = _val(ctx) / _attr(ctx); }\n</pre>\n\n<p>であり，<code>*</code> と <code>/</code> の違いしか有りません．</p>\n\n<p>そこでこれも関数にまとめてしまいます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">namespace</span> detail {\n\n  <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> Op&gt;\n  decltype(<span class=\"synType\">auto</span>) calc_op(Op&amp;&amp; op)\n  {\n    <span class=\"synStatement\">return</span> [op](<span class=\"synType\">auto</span>&amp;&amp; ctx) { _val(ctx) = op(_val(ctx), _attr(ctx)); };\n  }\n\n} <span class=\"synComment\">// namespace detail</span>\n</pre>\n\n<p>こんな関数を定義して，</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">auto</span> <span class=\"synType\">const</span> mul_expr_def =\n    neg_expr[detail::assign()]\n    &gt;&gt; *(\n        (<span class=\"synConstant\">&quot;*&quot;</span> &gt;&gt; neg_expr)[detail::calc_op(std::multiplies&lt;<span class=\"synType\">int</span>&gt;<span class=\"synError\">{</span>})]\n      | (<span class=\"synConstant\">&quot;/&quot;</span> &gt;&gt; neg_expr)[detail::calc_op(std::divides&lt;<span class=\"synType\">int</span>&gt;<span class=\"synError\">{</span>})]\n    )\n  ;\n</pre>\n\n<p>と使います．<br/>\n<code>calc_op</code> は関数オブジェクトを引数に取り，<code>_val(ctx)</code> と <code>_attr(ctx)</code> に適用した結果を格納するアクションを返します．</p>\n\n<p><code>add_expr</code> は <code>mul_expr</code> とほぼおなじなので詳細はスキップします．</p>\n\n<h2>expression</h2>\n\n<p>最後に <code>expression</code> です．これは単純に <code>add_expr</code> と一致します．<br/>\n命名のわかりやすさと，今後拡張していく際に便利そうということで分けてあるだけです．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">auto</span> <span class=\"synType\">const</span> expression_def =\n    add_expr[detail::assign()]\n  ;\n</pre>\n\n<h2>確認</h2>\n\n<p>コード全体を掲載します．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;boost/spirit/home/x3.hpp&gt;</span>\n\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;functional&gt;</span>\n\n<span class=\"synType\">namespace</span> x3 = boost::spirit::x3;\n\n<span class=\"synType\">namespace</span> grammar {\n\n  <span class=\"synType\">namespace</span> detail {\n\n    decltype(<span class=\"synType\">auto</span>) assign()\n    {\n      <span class=\"synStatement\">using</span> x3::_attr;\n      <span class=\"synStatement\">using</span> x3::_val;\n      <span class=\"synStatement\">return</span> [](<span class=\"synType\">auto</span>&amp;&amp; ctx) { _val(ctx) = _attr(ctx); };\n    }\n\n    <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> F&gt;\n    decltype(<span class=\"synType\">auto</span>) assign_f(F&amp;&amp; func)\n    {\n      <span class=\"synStatement\">return</span> [func](<span class=\"synType\">auto</span>&amp;&amp; ctx) { _val(ctx) = func(_attr(ctx)); };\n    }\n\n    <span class=\"synType\">template</span> &lt;<span class=\"synType\">typename</span> Op&gt;\n    decltype(<span class=\"synType\">auto</span>) calc_op(Op&amp;&amp; op)\n    {\n      <span class=\"synStatement\">return</span> [op](<span class=\"synType\">auto</span>&amp;&amp; ctx) { x3::_val(ctx) = op(x3::_val(ctx), x3::_attr(ctx)); };\n    }\n\n  } <span class=\"synComment\">// namespace detail</span>\n\n  <span class=\"synType\">struct</span> primary;\n  <span class=\"synType\">struct</span> neg_expr;\n  <span class=\"synType\">struct</span> mul_expr;\n  <span class=\"synType\">struct</span> add_expr;\n  <span class=\"synType\">struct</span> expression;\n\n  x3::rule&lt;primary, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> primary;\n  x3::rule&lt;neg_expr, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> neg_expr;\n  x3::rule&lt;mul_expr, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> mul_expr;\n  x3::rule&lt;add_expr, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> add_expr;\n  x3::rule&lt;expression, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> expression;\n\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> primary_def =\n      x3::int_[detail::assign()]\n    | (<span class=\"synConstant\">&quot;(&quot;</span> &gt; expression &gt; <span class=\"synConstant\">&quot;)&quot;</span>)[detail::assign()]\n    ;\n\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> neg_expr_def =\n      primary[detail::assign()]\n    | (<span class=\"synConstant\">&quot;-&quot;</span> &gt; primary)[detail::assign_f(std::negate&lt;<span class=\"synType\">int</span>&gt;<span class=\"synError\">{</span>})]\n    ;\n\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> mul_expr_def =\n      neg_expr[detail::assign()]\n      &gt;&gt; *(\n          (<span class=\"synConstant\">&quot;*&quot;</span> &gt;&gt; neg_expr)[detail::calc_op(std::multiplies&lt;<span class=\"synType\">int</span>&gt;<span class=\"synError\">{</span>})]\n        | (<span class=\"synConstant\">&quot;/&quot;</span> &gt;&gt; neg_expr)[detail::calc_op(std::divides&lt;<span class=\"synType\">int</span>&gt;<span class=\"synError\">{</span>})]\n      )\n    ;\n\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> add_expr_def =\n      mul_expr[detail::assign()]\n      &gt;&gt; *(\n          (<span class=\"synConstant\">&quot;+&quot;</span> &gt; mul_expr)[detail::calc_op(std::plus&lt;<span class=\"synType\">int</span>&gt;<span class=\"synError\">{</span>})]\n        | (<span class=\"synConstant\">&quot;-&quot;</span> &gt; mul_expr)[detail::calc_op(std::minus&lt;<span class=\"synType\">int</span>&gt;<span class=\"synError\">{</span>})]\n      )\n    ;\n\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> expression_def =\n      add_expr[detail::assign()]\n    ;\n\n  BOOST_SPIRIT_DEFINE(\n      primary,\n      neg_expr,\n      mul_expr,\n      add_expr,\n      expression\n      );\n\n} <span class=\"synComment\">// namespace grammar</span>\n<span class=\"synStatement\">using</span> grammar::expression;\n\n<span class=\"synType\">int</span> main()\n{\n  std::string str;\n  std::getline(std::cin, str);\n\n  <span class=\"synType\">auto</span> first(std::cbegin(str));\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> last(std::cend(str));\n\n  <span class=\"synType\">int</span> result;\n  <span class=\"synType\">bool</span> success = x3::phrase_parse(first, last, expression, x3::ascii::space, result);\n\n  <span class=\"synStatement\">if</span> (!success || first != last) {\n    std::cerr &lt;&lt; <span class=\"synConstant\">&quot;Parse failed.&quot;</span> &lt;&lt; std::endl;\n    <span class=\"synStatement\">return</span> <span class=\"synConstant\">1</span>;\n  }\n\n  std::cout &lt;&lt; <span class=\"synConstant\">&quot;Parsed: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;\n  <span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;\n}\n</pre>\n\n<p>実行してみます．</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>$ clang++ -std=c++14 main.cpp\n$ ./a.out\n1 + 2 * 3\nParsed: 7\n$ ./a.out\n(1 + 2) * 3\nParsed: 9</pre>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%E9%BB%BB%BB%D2\">演算子</a>の優先順位が正しく解決できていることが確認出来ます．</p>\n\n<h2>まとめ</h2>\n\n<p>今回は，セマンティックアクションで計算自体を行ってしまいましたが，普通は抽象<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%CC%DA\">構文木</a>(AST) に変換するためにセマンティックアクションを使うのが正道だと思います．<br/>\n<code>X3</code> は AST のための色々を提供してくれていますが，自前で作った AST でもちょっと苦労はするかもしれませんが変換できるはずなので，時間があれば，自前 AST に変換してから実行する電卓も作ってみたいと思います．</p>\n\n<p>また，AST に変換して計算する場合，AST に位置情報を付与することで，エラーレポートが便利になったりするはずです( 0 除算のエラーを通知する際，どの部分でのエラーなのかを吐いてくれればうれしいですよね).<br/>\nパース失敗時にもどこで失敗したのかをレポートしてくれたほうが便利です．<br/>\n<code>X3</code> で <code>on_error</code>, <code>on_success</code> を使ってこれらを実装してみようと考えています．</p>\n\n<p>今回のコードでは <code>decltype(auto)</code> など，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>14 の機能を使っています．<code>X3</code> は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>14 前提のライブラリなので，迷いなくこういった機能を使用できて幸せデスね．</p>\n\n---\n\n---\n","slug":"Boost.Spirit.X3_で簡易電卓を実装_1","title":"Boost.Spirit.X3 で簡易電卓を実装 1","timestamp":1450448825000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Boost.Spirit.X3 の練習 2\"\ndate: 2015-12-17T14:20:03.000Z\ntags: []\n---\n\n<p><a href=\"http://agtn.hatenablog.com/entry/2015/12/17/190505\">Boost.Spirit.X3 の練習1 - プログラミングのメモ帳➚</a>に引き続き，<code>Boost.Spirit.X3</code> のお勉強メモです．</p>\n\n<h2>セマンティックアクション</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>にはセマンティックアクションというのがつきものです．<br/>\n<code>yacc</code> や <code>parsec</code> など有名な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>のための<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C4%A1%BC%A5%EB\">ツール</a>/ライブラリにもありますね．</p>\n\n<p>セマンティックアクションとは，定義したパーサのルールにマッチした時に実行するプログラムのことです．<br/>\nといってもわかりにくいと思うので，コードを出してしまいます．</p>\n\n<p>以下のコードは，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>にマッチしてその値を標準出力に出力するパーサの定義です．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;boost/spirit/home/x3.hpp&gt;</span>\n\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n\n\n<span class=\"synType\">namespace</span> x3 = boost::spirit::x3;\n\n<span class=\"synType\">auto</span> <span class=\"synType\">const</span> print_action =\n  [](<span class=\"synType\">auto</span>&amp; ctx) { std::cout &lt;&lt; _attr(ctx) &lt;&lt; std::endl; };\n\n<span class=\"synType\">int</span> main()\n{\n\n  std::string src{ <span class=\"synConstant\">&quot;( 123.4 )&quot;</span> };\n\n  <span class=\"synType\">auto</span> first = std::cbegin(src);\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> last = std::cend(src);\n\n  <span class=\"synType\">auto</span> parser = (<span class=\"synConstant\">&quot;(&quot;</span> &gt;&gt; x3::double_ &gt;&gt; <span class=\"synConstant\">&quot;)&quot;</span>)[print_action];\n\n  <span class=\"synType\">bool</span> success = x3::phrase_parse(first, last, parser, x3::ascii::space);\n\n  <span class=\"synStatement\">if</span> (!success || first != last) {\n    <span class=\"synComment\">// parse failed</span>\n    std::cerr &lt;&lt; <span class=\"synConstant\">&quot;Parse failed.&quot;</span> &lt;&lt; std::endl;\n  }\n}\n</pre>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>$ clang++ -std=c++14 main.cpp\n$ ./a.out\n123.4</pre>\n\n<p>パーサの結果を受け取らないようにしています．<code>parser</code> は <code>double</code> を返しますが，その結果は無視しています．<br/>\nそして，セマンティックアクション部分で，出力を行っています．</p>\n\n<p><code>auto const print_action</code> の定義が，セマンティックアクションです．<br/>\n<code>C++14</code> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>ラムダの機能をつかっています．<br/>\nセマンティックアクションは，<code>X3</code> パーサのコンテキストを第一引数に取ります．<br/>\nその具体的な型を気にしてはいけません．<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>ラムダで受け取ります．<br/>\n<code>_attr(ctx)</code> で，現在マッチしているパーサの attribute にアクセス出来ます．\n<code>\"(\" &gt;&gt; x3::double_ &gt;&gt; \")\"</code> の attribute は <code>double</code> 型なので，<code>_attr(ctx)</code> はマッチした<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>になります．</p>\n\n<p><code>Qi</code> のセマンティックアクションは，関数オブジェクトなどを単純に使用することが出来ませんでした(?) が，<code>X3</code> ではセマンティックアクションはただの関数オブジェクトです．<br/>\nパーサのコンテキストを引数に受け，結果や attribute への参照をそのまま関数内で扱えるようになったため，セマンティックアクションの記述がより <em>普通</em> の関数っぽくかけるようになったと感じました．</p>\n\n<h2>名前付きパーサの定義</h2>\n\n<p>今までのサンプルでは，シンプルなパーサを１つ定義しているだけでした．<br/>\n一方現実には，パーサが<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>的になることは珍しくありません．</p>\n\n<p>そこで，パーサの名前を前方宣言し，あとから定義を記述するようなパーサの書き方を使用します．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;boost/spirit/home/x3.hpp&gt;</span>\n\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n\n\n<span class=\"synType\">namespace</span> x3 = boost::spirit::x3;\n\n<span class=\"synType\">namespace</span> detail {\n\n  x3::rule&lt;<span class=\"synType\">class</span> constant, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> constant;\n\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> constant_def = x3::int_;\n\n  BOOST_SPIRIT_DEFINE(constant);\n\n} <span class=\"synComment\">// namespace detail</span>\n\n<span class=\"synStatement\">using</span> detail::constant;\n\n<span class=\"synType\">int</span> main()\n{\n\n  std::string src{ <span class=\"synConstant\">&quot;123&quot;</span> };\n\n  <span class=\"synType\">auto</span> first = std::cbegin(src);\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> last = std::cend(src);\n\n\n  <span class=\"synType\">int</span> result;\n  <span class=\"synType\">bool</span> success = x3::phrase_parse(first, last, constant, x3::ascii::space, result);\n\n  <span class=\"synStatement\">if</span> (!success || first != last) {\n    <span class=\"synComment\">// parse failed</span>\n    std::cerr &lt;&lt; <span class=\"synConstant\">&quot;Parse failed.&quot;</span> &lt;&lt; std::endl;\n  } <span class=\"synStatement\">else</span> {\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;Parse: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;\n  }\n}\n</pre>\n\n<p><code>namespace detail</code> の中身がパーサの定義になっています．\n(<code>namespace</code> を分けたのは，<code>constant</code> そのものの名前以外を隠すためです．)\n<code>X3</code> では，<code>x3::rule&lt;class, result type&gt;</code> というテンプレートクラスがパーサルールになります．<code>class</code> 部分は今は前方宣言だけで構わないようです．(後で <code>on_error</code> とかの属性を付与する際に必要になる？)<br/>\n<code>result type</code> はそのパーサが返すべき値になります．</p>\n\n<p>つまり，<code>x3::rule&lt;class constant, int&gt; const constant;</code> は，<code>int</code> 型の値を返す，特別な属性を持たない <code>constant</code> という名前のパーサを宣言したことになります．</p>\n\n<p>そして，その実装は <code>constant_def</code> という名前で与えられます．<br/>\n<code>hogehoge_def</code> という名前にする規約のようです．(<code>BOOST_SPIRIT_DEFINE</code> 部分を書き換えれば違う名前にしても大丈夫のようだが，素直に従っておけば良さそう)<br/>\n今回はシンプルに <code>x3::int_</code> そのものとしています．</p>\n\n<p>最後に <code>BOOST_SPIRIT_DEFINE</code> することで，<code>constant</code> というパーサの宣言と，<code>constant_def</code> という実装をひも付けます．</p>\n\n<p>使い方は今までと全く同じです．</p>\n\n<h2>使ってみる</h2>\n\n<p>セマンティックアクションと名前付きパーサの両方を使って，整数を受け取って2倍にした値を返すパーサを書いてみます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;boost/spirit/home/x3.hpp&gt;</span>\n\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n\n\n<span class=\"synType\">namespace</span> x3 = boost::spirit::x3;\n\n<span class=\"synType\">namespace</span> detail {\n\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> twice = [](<span class=\"synType\">auto</span>&amp; ctx) { _val(ctx) = _attr(ctx) * <span class=\"synConstant\">2</span>; };\n\n  x3::rule&lt;<span class=\"synType\">class</span> constant, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> constant;\n\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> constant_def = x3::int_[twice];\n\n  BOOST_SPIRIT_DEFINE(constant);\n\n} <span class=\"synComment\">// namespace detail</span>\n\n<span class=\"synStatement\">using</span> detail::constant;\n\n<span class=\"synType\">int</span> main()\n{\n\n  std::string src{ <span class=\"synConstant\">&quot;123&quot;</span> };\n\n  <span class=\"synType\">auto</span> first = std::cbegin(src);\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> last = std::cend(src);\n\n\n  <span class=\"synType\">int</span> result;\n  <span class=\"synType\">bool</span> success = x3::phrase_parse(first, last, constant, x3::ascii::space, result);\n\n  <span class=\"synStatement\">if</span> (!success || first != last) {\n    <span class=\"synComment\">// parse failed</span>\n    std::cerr &lt;&lt; <span class=\"synConstant\">&quot;Parse failed.&quot;</span> &lt;&lt; std::endl;\n  } <span class=\"synStatement\">else</span> {\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;Parse: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;\n  }\n}\n</pre>\n\n<p>セマンティックアクション内では，パーサの <code>result type</code> に <code>_val(ctx)</code> でアクセス出来ます．\n<code>_val(ctx)</code> は参照を返すので，ここに適当な値を代入してやれば，パーサの返り値にすることが出来ます．<br/>\n<code>_attr(ctx)</code> は先程と同じです．<code>x3::int_</code> の attribute は <code>int</code> です．</p>\n\n<p>実行してみると，<code>Parse: 246</code> が返るはずです．</p>\n\n<h2>一旦まとめ</h2>\n\n<p>セマンティックアクションと名前付きパーサの宣言と定義をまとめました．<br/>\n<code>Qi</code> のころより，セマンティックアクションはかなり書きやすくなっている気がします．<br/>\n今回の例では，<code>_attr(ctx)</code> が単純な値だったのでわかりやすいですが，<code>x3::int_ &gt;&gt; x3::double_</code> の <code>_attr(ctx)</code> は <code>Boost.Fusion</code> が登場したりしてちょっとややこしそうです．</p>\n\n<p>また，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>的パーサを定義できるようにパーサの宣言をまとめたのに，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>的パーサを書いていませんが，これは別記事に電卓でも作ってまとめたいと思います．</p>\n\n---\n\n---\n","contentMarkdown":"\n<p><a href=\"http://agtn.hatenablog.com/entry/2015/12/17/190505\">Boost.Spirit.X3 の練習1 - プログラミングのメモ帳➚</a>に引き続き，<code>Boost.Spirit.X3</code> のお勉強メモです．</p>\n\n<h2>セマンティックアクション</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>にはセマンティックアクションというのがつきものです．<br/>\n<code>yacc</code> や <code>parsec</code> など有名な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%BD%CA%B8%B2%F2%C0%CF\">構文解析</a>のための<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C4%A1%BC%A5%EB\">ツール</a>/ライブラリにもありますね．</p>\n\n<p>セマンティックアクションとは，定義したパーサのルールにマッチした時に実行するプログラムのことです．<br/>\nといってもわかりにくいと思うので，コードを出してしまいます．</p>\n\n<p>以下のコードは，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>にマッチしてその値を標準出力に出力するパーサの定義です．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;boost/spirit/home/x3.hpp&gt;</span>\n\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n\n\n<span class=\"synType\">namespace</span> x3 = boost::spirit::x3;\n\n<span class=\"synType\">auto</span> <span class=\"synType\">const</span> print_action =\n  [](<span class=\"synType\">auto</span>&amp; ctx) { std::cout &lt;&lt; _attr(ctx) &lt;&lt; std::endl; };\n\n<span class=\"synType\">int</span> main()\n{\n\n  std::string src{ <span class=\"synConstant\">&quot;( 123.4 )&quot;</span> };\n\n  <span class=\"synType\">auto</span> first = std::cbegin(src);\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> last = std::cend(src);\n\n  <span class=\"synType\">auto</span> parser = (<span class=\"synConstant\">&quot;(&quot;</span> &gt;&gt; x3::double_ &gt;&gt; <span class=\"synConstant\">&quot;)&quot;</span>)[print_action];\n\n  <span class=\"synType\">bool</span> success = x3::phrase_parse(first, last, parser, x3::ascii::space);\n\n  <span class=\"synStatement\">if</span> (!success || first != last) {\n    <span class=\"synComment\">// parse failed</span>\n    std::cerr &lt;&lt; <span class=\"synConstant\">&quot;Parse failed.&quot;</span> &lt;&lt; std::endl;\n  }\n}\n</pre>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>$ clang++ -std=c++14 main.cpp\n$ ./a.out\n123.4</pre>\n\n<p>パーサの結果を受け取らないようにしています．<code>parser</code> は <code>double</code> を返しますが，その結果は無視しています．<br/>\nそして，セマンティックアクション部分で，出力を行っています．</p>\n\n<p><code>auto const print_action</code> の定義が，セマンティックアクションです．<br/>\n<code>C++14</code> の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>ラムダの機能をつかっています．<br/>\nセマンティックアクションは，<code>X3</code> パーサのコンテキストを第一引数に取ります．<br/>\nその具体的な型を気にしてはいけません．<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>ラムダで受け取ります．<br/>\n<code>_attr(ctx)</code> で，現在マッチしているパーサの attribute にアクセス出来ます．\n<code>\"(\" &gt;&gt; x3::double_ &gt;&gt; \")\"</code> の attribute は <code>double</code> 型なので，<code>_attr(ctx)</code> はマッチした<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>になります．</p>\n\n<p><code>Qi</code> のセマンティックアクションは，関数オブジェクトなどを単純に使用することが出来ませんでした(?) が，<code>X3</code> ではセマンティックアクションはただの関数オブジェクトです．<br/>\nパーサのコンテキストを引数に受け，結果や attribute への参照をそのまま関数内で扱えるようになったため，セマンティックアクションの記述がより <em>普通</em> の関数っぽくかけるようになったと感じました．</p>\n\n<h2>名前付きパーサの定義</h2>\n\n<p>今までのサンプルでは，シンプルなパーサを１つ定義しているだけでした．<br/>\n一方現実には，パーサが<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>的になることは珍しくありません．</p>\n\n<p>そこで，パーサの名前を前方宣言し，あとから定義を記述するようなパーサの書き方を使用します．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;boost/spirit/home/x3.hpp&gt;</span>\n\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n\n\n<span class=\"synType\">namespace</span> x3 = boost::spirit::x3;\n\n<span class=\"synType\">namespace</span> detail {\n\n  x3::rule&lt;<span class=\"synType\">class</span> constant, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> constant;\n\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> constant_def = x3::int_;\n\n  BOOST_SPIRIT_DEFINE(constant);\n\n} <span class=\"synComment\">// namespace detail</span>\n\n<span class=\"synStatement\">using</span> detail::constant;\n\n<span class=\"synType\">int</span> main()\n{\n\n  std::string src{ <span class=\"synConstant\">&quot;123&quot;</span> };\n\n  <span class=\"synType\">auto</span> first = std::cbegin(src);\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> last = std::cend(src);\n\n\n  <span class=\"synType\">int</span> result;\n  <span class=\"synType\">bool</span> success = x3::phrase_parse(first, last, constant, x3::ascii::space, result);\n\n  <span class=\"synStatement\">if</span> (!success || first != last) {\n    <span class=\"synComment\">// parse failed</span>\n    std::cerr &lt;&lt; <span class=\"synConstant\">&quot;Parse failed.&quot;</span> &lt;&lt; std::endl;\n  } <span class=\"synStatement\">else</span> {\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;Parse: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;\n  }\n}\n</pre>\n\n<p><code>namespace detail</code> の中身がパーサの定義になっています．\n(<code>namespace</code> を分けたのは，<code>constant</code> そのものの名前以外を隠すためです．)\n<code>X3</code> では，<code>x3::rule&lt;class, result type&gt;</code> というテンプレートクラスがパーサルールになります．<code>class</code> 部分は今は前方宣言だけで構わないようです．(後で <code>on_error</code> とかの属性を付与する際に必要になる？)<br/>\n<code>result type</code> はそのパーサが返すべき値になります．</p>\n\n<p>つまり，<code>x3::rule&lt;class constant, int&gt; const constant;</code> は，<code>int</code> 型の値を返す，特別な属性を持たない <code>constant</code> という名前のパーサを宣言したことになります．</p>\n\n<p>そして，その実装は <code>constant_def</code> という名前で与えられます．<br/>\n<code>hogehoge_def</code> という名前にする規約のようです．(<code>BOOST_SPIRIT_DEFINE</code> 部分を書き換えれば違う名前にしても大丈夫のようだが，素直に従っておけば良さそう)<br/>\n今回はシンプルに <code>x3::int_</code> そのものとしています．</p>\n\n<p>最後に <code>BOOST_SPIRIT_DEFINE</code> することで，<code>constant</code> というパーサの宣言と，<code>constant_def</code> という実装をひも付けます．</p>\n\n<p>使い方は今までと全く同じです．</p>\n\n<h2>使ってみる</h2>\n\n<p>セマンティックアクションと名前付きパーサの両方を使って，整数を受け取って2倍にした値を返すパーサを書いてみます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;boost/spirit/home/x3.hpp&gt;</span>\n\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n\n\n<span class=\"synType\">namespace</span> x3 = boost::spirit::x3;\n\n<span class=\"synType\">namespace</span> detail {\n\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> twice = [](<span class=\"synType\">auto</span>&amp; ctx) { _val(ctx) = _attr(ctx) * <span class=\"synConstant\">2</span>; };\n\n  x3::rule&lt;<span class=\"synType\">class</span> constant, <span class=\"synType\">int</span>&gt; <span class=\"synType\">const</span> constant;\n\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> constant_def = x3::int_[twice];\n\n  BOOST_SPIRIT_DEFINE(constant);\n\n} <span class=\"synComment\">// namespace detail</span>\n\n<span class=\"synStatement\">using</span> detail::constant;\n\n<span class=\"synType\">int</span> main()\n{\n\n  std::string src{ <span class=\"synConstant\">&quot;123&quot;</span> };\n\n  <span class=\"synType\">auto</span> first = std::cbegin(src);\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> last = std::cend(src);\n\n\n  <span class=\"synType\">int</span> result;\n  <span class=\"synType\">bool</span> success = x3::phrase_parse(first, last, constant, x3::ascii::space, result);\n\n  <span class=\"synStatement\">if</span> (!success || first != last) {\n    <span class=\"synComment\">// parse failed</span>\n    std::cerr &lt;&lt; <span class=\"synConstant\">&quot;Parse failed.&quot;</span> &lt;&lt; std::endl;\n  } <span class=\"synStatement\">else</span> {\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;Parse: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;\n  }\n}\n</pre>\n\n<p>セマンティックアクション内では，パーサの <code>result type</code> に <code>_val(ctx)</code> でアクセス出来ます．\n<code>_val(ctx)</code> は参照を返すので，ここに適当な値を代入してやれば，パーサの返り値にすることが出来ます．<br/>\n<code>_attr(ctx)</code> は先程と同じです．<code>x3::int_</code> の attribute は <code>int</code> です．</p>\n\n<p>実行してみると，<code>Parse: 246</code> が返るはずです．</p>\n\n<h2>一旦まとめ</h2>\n\n<p>セマンティックアクションと名前付きパーサの宣言と定義をまとめました．<br/>\n<code>Qi</code> のころより，セマンティックアクションはかなり書きやすくなっている気がします．<br/>\n今回の例では，<code>_attr(ctx)</code> が単純な値だったのでわかりやすいですが，<code>x3::int_ &gt;&gt; x3::double_</code> の <code>_attr(ctx)</code> は <code>Boost.Fusion</code> が登場したりしてちょっとややこしそうです．</p>\n\n<p>また，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>的パーサを定義できるようにパーサの宣言をまとめたのに，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>的パーサを書いていませんが，これは別記事に電卓でも作ってまとめたいと思います．</p>\n\n---\n\n---\n","slug":"Boost.Spirit.X3_の練習_2","title":"Boost.Spirit.X3 の練習 2","timestamp":1450362003000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Boost.Spirit.X3 の練習1\"\ndate: 2015-12-17T10:05:05.000Z\ntags: []\n---\n\n<h1>Boost.Spirit.X3 の練習1</h1>\n\n<p><a href=\"http://ciere.com/cppnow15/x3_docs/\">Boost.Spirit.X3</a> という <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のための パーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>ライブラリを使ってみています．<br/>\n<code>Boost.Spirit</code> というと， <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の黒魔術の塊みたいなイメージがあります． ちなみに <code>Boost.Spirit.Qi</code> が安定版のパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>ライブラリで， <code>X3</code> はまだ開発中のようなので注意してください．</p>\n\n<p><code>X3</code> は <code>Qi</code> と異なり，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>14 以降の規格を前提にしています．そのため，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>ラムダなどを用いてよりわかりやすいプログラムが書けるようになっているようです．<br/>\n<code>Qi</code> は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間が爆発していたのですが， <code>X3</code> だと多少マシのようです．</p>\n\n<h2>第一歩</h2>\n\n<p>まずは猛烈にシンプルなパーサを使ってみましょう．\n<code>X3</code> も <code>Qi</code> 同様に定義済みのパーサがあるので，それを単純に使用するだけのサンプルです．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;boost/spirit/home/x3.hpp&gt;</span>\n\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n\n\n<span class=\"synType\">int</span> main()\n{\n  <span class=\"synType\">namespace</span> x3 = boost::spirit::x3;\n\n  <span class=\"synType\">int</span> result;\n  std::string src{ <span class=\"synConstant\">&quot;123&quot;</span> };\n\n  <span class=\"synType\">auto</span> first = std::cbegin(src);\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> last = std::cend(src);\n  <span class=\"synType\">bool</span> success = x3::parse(first, last, x3::int_, result);\n\n  <span class=\"synStatement\">if</span> (!success || first != last) {\n    <span class=\"synComment\">// parse failed</span>\n    std::cerr &lt;&lt; <span class=\"synConstant\">&quot;Parse failed.&quot;</span> &lt;&lt; std::endl;\n  } <span class=\"synStatement\">else</span> {\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;Parse: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;\n  }\n}\n</pre>\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a> &amp; 実行</h3>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>$ clang++ -std=c++14 int_parser.cpp\n$ ./a.out\nParse: 123</pre>\n\n<p><code>Boost.Spirit.X3</code> を使用する場合は, <code>#include &lt;boost/spirit/home/x3.hpp&gt;</code> とすればオッケーです．(これは使用していない機能のヘッダも読み込んでしまっているので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>は重くなります… が，これ以降使う機能を増やす度にヘッダを書き換えるのは面倒ですし，<code>X3</code> の機能の多くを使用するプログラムの場合は，大差ないと思います．)</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%BE%C1%B0%B6%F5%B4%D6\">名前空間</a>は <code>boost::spirit::x3</code> です．頻繁に出てくるので <code>namespace x3</code> で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>しました．</p>\n\n<p>実際にパースしている部分は,</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">bool</span> success = x3::parse(first, last, x3::int_, result);\n</pre>\n\n<p>の部分です．<br/>\n<code>x3::parse</code> は，第一引数にソース文字列の先頭<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%C6%A5%EC%A1%BC%A5%BF\">イテレータ</a>，第二引数にソース文字列の終端<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%C6%A5%EC%A1%BC%A5%BF\">イテレータ</a>をとります．<br/>\n第三引数が，パーサの定義です．ここでは， <code>x3::int_</code> という定義済みパーサを使用しました． これは, 整数を表す文字列を受けて，それを整数に変換するパーサです． たとえば <code>\"1\"</code> を <code>1</code> に変換します．整数以外にあたった場合はマッチせず，パースに失敗します．(<code>x3::parse</code> の返り値が <code>false</code> になる)\n第四引数は，指定したパーサの返す値です．ここちょっと説明が難しいですね．<br/>\n<code>x3::int_</code> は <code>int</code> 型の値を返すパーサです(これを <code>x3::int_</code> の attribute が <code>int</code> 型であると表現している？).<br/>\nそこで，<code>x3::int_</code> の返す値を格納する変数として，<code>int result</code> の参照を渡しているという感じです．<br/>\nパースが成功していれば，<code>result</code> の中身は <code>x3::int_</code> の返り値になっているはずです．</p>\n\n<p>パースの成否判定は <code>success</code> と <code>first == last</code> で行います．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synStatement\">if</span> (!success || first != last) {\n</pre>\n\n<p><code>success</code> はそもそもパーサにソースがマッチしなかった場合, <code>false</code> になります．<br/>\nまた，<code>\"123abc\"</code> に <code>x3::int_</code> をマッチさせると，<code>\"123\"</code> だけが消費され，<code>\"abc\"</code> が残ります．この時，<code>first</code> は <code>\"a\"</code> の位置まで進んでいます．\nもしソースが先頭から終端まで，パーサにマッチしていたならば，<code>first == last</code> となるはずです．</p>\n\n<p>というわけでこのプログラムは，<code>x3::int_</code> に <code>\"123\"</code> をパースさせるプログラムでした．結果，きちんと整数の <code>123</code> が取得できていることがわかります．</p>\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a></h2>\n\n<p><code>Boost.Spirit.X3</code> はパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>ライブラリです．個々のパーサを組み合わせてみましょう．</p>\n\n<p><code>\" ( 1234.5)\"</code> とか <code>\"(67.8 )  \"</code> にマッチして，<code>double</code> を返すようなパーサを定義してみます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">auto</span> parser = x3::lit(<span class=\"synConstant\">&quot;(&quot;</span>) &gt;&gt; x3::double_ &gt;&gt; x3::lit(<span class=\"synConstant\">&quot;)&quot;</span>);\n<span class=\"synType\">bool</span> success = x3::phrase_parse(first, last, parser, x3::ascii::space, result);\n</pre>\n\n<p>まずは <code>parser</code> の定義です．\n<code>x3::lit</code> は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%C6%A5%E9%A5%EB\">リテラル</a>を表します．引数にとった文字列にマッチし，何も返さないパーサです．<code>x3::lit(\"(\")</code> は <code>(</code> にマッチし，何も返さないパーサということになります．<br/>\n<code>x3::double_</code> は <code>x3::int_</code> と同じく，定義済みパーサで，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>にマッチしその値を返します．</p>\n\n<p>そして重要なのが，<code>&gt;&gt;</code> です．<br/>\nこれは，「左辺にマッチした後，右辺にマッチするパーサ」を作り出す<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>です．<br/>\nここでは，<code>x3::lit(\"(\") &gt;&gt; x3::double_</code> ですから，<code>(</code> にマッチした後，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>にマッチするパーサ，ということになります.</p>\n\n<p>通常，<code>&gt;&gt;</code> は左辺の返す値と右辺の返す値のタプルを返します．(<code>x3::int_ &gt;&gt; x3::double_</code> ならば，<code>int</code> と <code>double</code> のタプル)<br/>\nしかし，左辺右辺どちらか一方が値を返さない(正確には <code>x3::unused_type</code> を返す) 場合には，もう一方の値だけを返します．<br/>\nつまり，<code>x3::lit(\"(\") &gt;&gt; x3::double_</code> は <code>double</code> だけを返し，<code>&gt;&gt; x3::lit(\")\")</code> と続けても <code>double</code> だけが返ります．</p>\n\n<p>次に，空白の読み飛ばしについてです．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">bool</span> success = x3::phrase_parse(first, last, parser, x3::ascii::space, result);\n</pre>\n\n<p>ひとつ目の例と異なり，<code>x3::parse</code> ではなく <code>x3::phrase_parse</code> を使っています．<br/>\nこちらは，<code>attribute</code> を示す最後の引数の前に，スキップパーサを取ります．\nスキップパーサとは，文字通り，スキップしてほしい文字列にマッチするパーサです．<br/>\n<code>x3::ascii::space</code> は定義済みのパーサで，スペース，改行文字，タブにマッチします．したがって，これらの文字はスキップされます．\nスキップ判定のタイミングは <code>&gt;&gt;</code> の部分です．つまり，\"12    3\" は <code>x3::int_</code> でパースすると, <code>12</code> までしかマッチしません．<code>x3::int_ &gt;&gt; x3::int_</code> とすることで，スペースがスキップされます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;boost/spirit/home/x3.hpp&gt;</span>\n\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n\n\n<span class=\"synType\">int</span> main()\n{\n  <span class=\"synType\">namespace</span> x3 = boost::spirit::x3;\n\n  std::string src{ <span class=\"synConstant\">&quot;( 123.4 )&quot;</span> };\n\n  <span class=\"synType\">auto</span> first = std::cbegin(src);\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> last = std::cend(src);\n  <span class=\"synType\">double</span> result;\n  <span class=\"synType\">auto</span> parser = x3::lit(<span class=\"synConstant\">&quot;(&quot;</span>) &gt;&gt; x3::double_ &gt;&gt; x3::lit(<span class=\"synConstant\">&quot;)&quot;</span>);\n  <span class=\"synType\">bool</span> success = x3::phrase_parse(first, last, parser, x3::ascii::space, result);\n\n  <span class=\"synStatement\">if</span> (!success || first != last) {\n    <span class=\"synComment\">// parse failed</span>\n    std::cerr &lt;&lt; <span class=\"synConstant\">&quot;Parse failed.&quot;</span> &lt;&lt; std::endl;\n  } <span class=\"synStatement\">else</span> {\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;Parse: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;\n  }\n}\n</pre>\n\n<p>ちなみに，<code>x3::lit(\"(\") &gt;&gt; x3::double_ &gt;&gt; x3::lit(\")\")</code> の部分ですが，<code>operator&lt;&lt;</code> の引数の内，片方がパーサであれば，<code>char const*</code> から暗黙変換が働くので， <code>\"(\" &gt;&gt; x3::double_ &gt;&gt; \")\"</code> と書くことが出来ます．</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>は他にもあります．</p>\n\n<ul>\n<li><code>|</code>\n\n<ul>\n<li><code>a | b</code> で，<code>a</code> にマッチするか <code>b</code> にマッチするか</li>\n<li><code>a</code> を先に試すので，両方にマッチする場合でも <code>a</code> にマッチしたことになる (PEG の特徴ですね)</li>\n<li>返り値は <code>boost::variant&lt;a, b&gt;</code> です．<code>a</code> と <code>b</code> が同じ型を返す場合はその型を返します</li>\n</ul>\n</li>\n<li><code>&gt;</code>\n\n<ul>\n<li><code>&gt;&gt;</code> とほぼ同じです．</li>\n<li><code>a &gt;&gt; b</code> は <code>a</code> にマッチして <code>b</code> にマッチしなかった場合，<code>a</code> の前にバックトラックします.</li>\n<li><code>a &gt; b</code> はその場合，即座にパース失敗を通知します．</li>\n</ul>\n</li>\n<li><code>*</code>\n\n<ul>\n<li><code>*a</code> という形で使う</li>\n<li><code>a</code> の 0 回以上の繰り返し</li>\n<li>返り値は <code>std::vector&lt;a&gt;</code></li>\n</ul>\n</li>\n<li><code>+</code>\n\n<ul>\n<li><code>+a</code> という形で使う</li>\n<li><code>*</code> の一回以上繰り返し版</li>\n</ul>\n</li>\n<li><code>-</code>\n\n<ul>\n<li><code>-a</code> という形で使う</li>\n<li><code>a</code> が来ても来なくても良いというパーサ</li>\n<li>返り値は <code>boost::optional&lt;a&gt;</code></li>\n</ul>\n</li>\n</ul>\n\n<p>...</p>\n\n<p><code>&gt;</code> と <code>&gt;&gt;</code> の違いはわかりにくいですね．<br/>\n<code>(x3::lit(\"(\") &gt;&gt; \")\") | (\"(\" &gt;&gt; x3::int_ &gt;&gt; \")\")</code> に <code>\"(123)\"</code> を食わせると，<code>|</code> の後半部分にマッチしてくれます．\n一方, <code>&gt;&gt;</code> を <code>&gt;</code> に置換えた場合，ソース先頭の<code>\"(\"</code> が<code>x3::lit(\"(\")</code> にマッチするにもかかわらず，その直後に<code>\")\"</code> が来ていないため，その時点でエラーを通知してしまいます．</p>\n\n<h2>一旦むすび</h2>\n\n<p>とりあえず最も基本的な部分をまとめてみました．<br/>\nここまでは <code>Qi</code> と同じなんですよね．</p>\n\n<p>セマンティックアクションや <code>on_error</code> などの扱いががっつり変わっているようなので，一旦ここで切って，それぞれ調べてからまとめたいと思います．\n何か間違い等あればぜひご指摘お願いします．</p>\n\n---\n\n---\n","contentMarkdown":"\n<h1>Boost.Spirit.X3 の練習1</h1>\n\n<p><a href=\"http://ciere.com/cppnow15/x3_docs/\">Boost.Spirit.X3</a> という <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> のための パーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>ライブラリを使ってみています．<br/>\n<code>Boost.Spirit</code> というと， <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> の黒魔術の塊みたいなイメージがあります． ちなみに <code>Boost.Spirit.Qi</code> が安定版のパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>ライブラリで， <code>X3</code> はまだ開発中のようなので注意してください．</p>\n\n<p><code>X3</code> は <code>Qi</code> と異なり，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>14 以降の規格を前提にしています．そのため，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>ラムダなどを用いてよりわかりやすいプログラムが書けるようになっているようです．<br/>\n<code>Qi</code> は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間が爆発していたのですが， <code>X3</code> だと多少マシのようです．</p>\n\n<h2>第一歩</h2>\n\n<p>まずは猛烈にシンプルなパーサを使ってみましょう．\n<code>X3</code> も <code>Qi</code> 同様に定義済みのパーサがあるので，それを単純に使用するだけのサンプルです．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;boost/spirit/home/x3.hpp&gt;</span>\n\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n\n\n<span class=\"synType\">int</span> main()\n{\n  <span class=\"synType\">namespace</span> x3 = boost::spirit::x3;\n\n  <span class=\"synType\">int</span> result;\n  std::string src{ <span class=\"synConstant\">&quot;123&quot;</span> };\n\n  <span class=\"synType\">auto</span> first = std::cbegin(src);\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> last = std::cend(src);\n  <span class=\"synType\">bool</span> success = x3::parse(first, last, x3::int_, result);\n\n  <span class=\"synStatement\">if</span> (!success || first != last) {\n    <span class=\"synComment\">// parse failed</span>\n    std::cerr &lt;&lt; <span class=\"synConstant\">&quot;Parse failed.&quot;</span> &lt;&lt; std::endl;\n  } <span class=\"synStatement\">else</span> {\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;Parse: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;\n  }\n}\n</pre>\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a> &amp; 実行</h3>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>$ clang++ -std=c++14 int_parser.cpp\n$ ./a.out\nParse: 123</pre>\n\n<p><code>Boost.Spirit.X3</code> を使用する場合は, <code>#include &lt;boost/spirit/home/x3.hpp&gt;</code> とすればオッケーです．(これは使用していない機能のヘッダも読み込んでしまっているので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>は重くなります… が，これ以降使う機能を増やす度にヘッダを書き換えるのは面倒ですし，<code>X3</code> の機能の多くを使用するプログラムの場合は，大差ないと思います．)</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%BE%C1%B0%B6%F5%B4%D6\">名前空間</a>は <code>boost::spirit::x3</code> です．頻繁に出てくるので <code>namespace x3</code> で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a>しました．</p>\n\n<p>実際にパースしている部分は,</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">bool</span> success = x3::parse(first, last, x3::int_, result);\n</pre>\n\n<p>の部分です．<br/>\n<code>x3::parse</code> は，第一引数にソース文字列の先頭<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%C6%A5%EC%A1%BC%A5%BF\">イテレータ</a>，第二引数にソース文字列の終端<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%C6%A5%EC%A1%BC%A5%BF\">イテレータ</a>をとります．<br/>\n第三引数が，パーサの定義です．ここでは， <code>x3::int_</code> という定義済みパーサを使用しました． これは, 整数を表す文字列を受けて，それを整数に変換するパーサです． たとえば <code>\"1\"</code> を <code>1</code> に変換します．整数以外にあたった場合はマッチせず，パースに失敗します．(<code>x3::parse</code> の返り値が <code>false</code> になる)\n第四引数は，指定したパーサの返す値です．ここちょっと説明が難しいですね．<br/>\n<code>x3::int_</code> は <code>int</code> 型の値を返すパーサです(これを <code>x3::int_</code> の attribute が <code>int</code> 型であると表現している？).<br/>\nそこで，<code>x3::int_</code> の返す値を格納する変数として，<code>int result</code> の参照を渡しているという感じです．<br/>\nパースが成功していれば，<code>result</code> の中身は <code>x3::int_</code> の返り値になっているはずです．</p>\n\n<p>パースの成否判定は <code>success</code> と <code>first == last</code> で行います．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synStatement\">if</span> (!success || first != last) {\n</pre>\n\n<p><code>success</code> はそもそもパーサにソースがマッチしなかった場合, <code>false</code> になります．<br/>\nまた，<code>\"123abc\"</code> に <code>x3::int_</code> をマッチさせると，<code>\"123\"</code> だけが消費され，<code>\"abc\"</code> が残ります．この時，<code>first</code> は <code>\"a\"</code> の位置まで進んでいます．\nもしソースが先頭から終端まで，パーサにマッチしていたならば，<code>first == last</code> となるはずです．</p>\n\n<p>というわけでこのプログラムは，<code>x3::int_</code> に <code>\"123\"</code> をパースさせるプログラムでした．結果，きちんと整数の <code>123</code> が取得できていることがわかります．</p>\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a></h2>\n\n<p><code>Boost.Spirit.X3</code> はパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>ライブラリです．個々のパーサを組み合わせてみましょう．</p>\n\n<p><code>\" ( 1234.5)\"</code> とか <code>\"(67.8 )  \"</code> にマッチして，<code>double</code> を返すようなパーサを定義してみます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">auto</span> parser = x3::lit(<span class=\"synConstant\">&quot;(&quot;</span>) &gt;&gt; x3::double_ &gt;&gt; x3::lit(<span class=\"synConstant\">&quot;)&quot;</span>);\n<span class=\"synType\">bool</span> success = x3::phrase_parse(first, last, parser, x3::ascii::space, result);\n</pre>\n\n<p>まずは <code>parser</code> の定義です．\n<code>x3::lit</code> は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%C6%A5%E9%A5%EB\">リテラル</a>を表します．引数にとった文字列にマッチし，何も返さないパーサです．<code>x3::lit(\"(\")</code> は <code>(</code> にマッチし，何も返さないパーサということになります．<br/>\n<code>x3::double_</code> は <code>x3::int_</code> と同じく，定義済みパーサで，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>にマッチしその値を返します．</p>\n\n<p>そして重要なのが，<code>&gt;&gt;</code> です．<br/>\nこれは，「左辺にマッチした後，右辺にマッチするパーサ」を作り出す<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>です．<br/>\nここでは，<code>x3::lit(\"(\") &gt;&gt; x3::double_</code> ですから，<code>(</code> にマッチした後，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>にマッチするパーサ，ということになります.</p>\n\n<p>通常，<code>&gt;&gt;</code> は左辺の返す値と右辺の返す値のタプルを返します．(<code>x3::int_ &gt;&gt; x3::double_</code> ならば，<code>int</code> と <code>double</code> のタプル)<br/>\nしかし，左辺右辺どちらか一方が値を返さない(正確には <code>x3::unused_type</code> を返す) 場合には，もう一方の値だけを返します．<br/>\nつまり，<code>x3::lit(\"(\") &gt;&gt; x3::double_</code> は <code>double</code> だけを返し，<code>&gt;&gt; x3::lit(\")\")</code> と続けても <code>double</code> だけが返ります．</p>\n\n<p>次に，空白の読み飛ばしについてです．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synType\">bool</span> success = x3::phrase_parse(first, last, parser, x3::ascii::space, result);\n</pre>\n\n<p>ひとつ目の例と異なり，<code>x3::parse</code> ではなく <code>x3::phrase_parse</code> を使っています．<br/>\nこちらは，<code>attribute</code> を示す最後の引数の前に，スキップパーサを取ります．\nスキップパーサとは，文字通り，スキップしてほしい文字列にマッチするパーサです．<br/>\n<code>x3::ascii::space</code> は定義済みのパーサで，スペース，改行文字，タブにマッチします．したがって，これらの文字はスキップされます．\nスキップ判定のタイミングは <code>&gt;&gt;</code> の部分です．つまり，\"12    3\" は <code>x3::int_</code> でパースすると, <code>12</code> までしかマッチしません．<code>x3::int_ &gt;&gt; x3::int_</code> とすることで，スペースがスキップされます．</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;boost/spirit/home/x3.hpp&gt;</span>\n\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n\n\n<span class=\"synType\">int</span> main()\n{\n  <span class=\"synType\">namespace</span> x3 = boost::spirit::x3;\n\n  std::string src{ <span class=\"synConstant\">&quot;( 123.4 )&quot;</span> };\n\n  <span class=\"synType\">auto</span> first = std::cbegin(src);\n  <span class=\"synType\">auto</span> <span class=\"synType\">const</span> last = std::cend(src);\n  <span class=\"synType\">double</span> result;\n  <span class=\"synType\">auto</span> parser = x3::lit(<span class=\"synConstant\">&quot;(&quot;</span>) &gt;&gt; x3::double_ &gt;&gt; x3::lit(<span class=\"synConstant\">&quot;)&quot;</span>);\n  <span class=\"synType\">bool</span> success = x3::phrase_parse(first, last, parser, x3::ascii::space, result);\n\n  <span class=\"synStatement\">if</span> (!success || first != last) {\n    <span class=\"synComment\">// parse failed</span>\n    std::cerr &lt;&lt; <span class=\"synConstant\">&quot;Parse failed.&quot;</span> &lt;&lt; std::endl;\n  } <span class=\"synStatement\">else</span> {\n    std::cout &lt;&lt; <span class=\"synConstant\">&quot;Parse: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;\n  }\n}\n</pre>\n\n<p>ちなみに，<code>x3::lit(\"(\") &gt;&gt; x3::double_ &gt;&gt; x3::lit(\")\")</code> の部分ですが，<code>operator&lt;&lt;</code> の引数の内，片方がパーサであれば，<code>char const*</code> から暗黙変換が働くので， <code>\"(\" &gt;&gt; x3::double_ &gt;&gt; \")\"</code> と書くことが出来ます．</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>は他にもあります．</p>\n\n<ul>\n<li><code>|</code>\n\n<ul>\n<li><code>a | b</code> で，<code>a</code> にマッチするか <code>b</code> にマッチするか</li>\n<li><code>a</code> を先に試すので，両方にマッチする場合でも <code>a</code> にマッチしたことになる (PEG の特徴ですね)</li>\n<li>返り値は <code>boost::variant&lt;a, b&gt;</code> です．<code>a</code> と <code>b</code> が同じ型を返す場合はその型を返します</li>\n</ul>\n</li>\n<li><code>&gt;</code>\n\n<ul>\n<li><code>&gt;&gt;</code> とほぼ同じです．</li>\n<li><code>a &gt;&gt; b</code> は <code>a</code> にマッチして <code>b</code> にマッチしなかった場合，<code>a</code> の前にバックトラックします.</li>\n<li><code>a &gt; b</code> はその場合，即座にパース失敗を通知します．</li>\n</ul>\n</li>\n<li><code>*</code>\n\n<ul>\n<li><code>*a</code> という形で使う</li>\n<li><code>a</code> の 0 回以上の繰り返し</li>\n<li>返り値は <code>std::vector&lt;a&gt;</code></li>\n</ul>\n</li>\n<li><code>+</code>\n\n<ul>\n<li><code>+a</code> という形で使う</li>\n<li><code>*</code> の一回以上繰り返し版</li>\n</ul>\n</li>\n<li><code>-</code>\n\n<ul>\n<li><code>-a</code> という形で使う</li>\n<li><code>a</code> が来ても来なくても良いというパーサ</li>\n<li>返り値は <code>boost::optional&lt;a&gt;</code></li>\n</ul>\n</li>\n</ul>\n\n<p>...</p>\n\n<p><code>&gt;</code> と <code>&gt;&gt;</code> の違いはわかりにくいですね．<br/>\n<code>(x3::lit(\"(\") &gt;&gt; \")\") | (\"(\" &gt;&gt; x3::int_ &gt;&gt; \")\")</code> に <code>\"(123)\"</code> を食わせると，<code>|</code> の後半部分にマッチしてくれます．\n一方, <code>&gt;&gt;</code> を <code>&gt;</code> に置換えた場合，ソース先頭の<code>\"(\"</code> が<code>x3::lit(\"(\")</code> にマッチするにもかかわらず，その直後に<code>\")\"</code> が来ていないため，その時点でエラーを通知してしまいます．</p>\n\n<h2>一旦むすび</h2>\n\n<p>とりあえず最も基本的な部分をまとめてみました．<br/>\nここまでは <code>Qi</code> と同じなんですよね．</p>\n\n<p>セマンティックアクションや <code>on_error</code> などの扱いががっつり変わっているようなので，一旦ここで切って，それぞれ調べてからまとめたいと思います．\n何か間違い等あればぜひご指摘お願いします．</p>\n\n---\n\n---\n","slug":"Boost.Spirit.X3_の練習1","title":"Boost.Spirit.X3 の練習1","timestamp":1450346705000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Sokoban.nim を書いてみた\"\ndate: 2015-10-29T13:10:42.000Z\ntags: []\n---\n\n<h1>Sokoban.nim を書いてみた</h1>\n\n<p><a href=\"http://www.nim-lang.org\">Nim</a> という言語を使って<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C1%D2%B8%CB%C8%D6\">倉庫番</a>を書いてみました.</p>\n\n<p><a href=\"https://github.com/agatan/sokoban-nim\">sokoban-nim</a></p>\n\n<p><a href=\"https://github.com/swatteau/sokoban-rs\">sokoban-rs</a> に影響されました．</p>\n\n<p>といっても <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDL\">SDL</a> ド素人なので見た目は恐ろしく質素です． Nim の練習のつもりで書いてみました．</p>\n\n<h2>動作</h2>\n\n<p>動作としては，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%DE%A5%F3%A5%C9%A5%E9%A5%A4%A5%F3\">コマンドライン</a>引数にステージ情報を記述したファイル名を指定します．</p>\n\n<pre><code>##########\n#   .    #\n#  $   . ####\n# @ $       #\n#           #\n#############\n</code></pre>\n\n<p>このようなファイルを指定します． クリアするとなにも言わずに終了するようになっています．(また, ESC でも終了します)</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20151029/20151029220921.png\" alt=\"f:id:agtn:20151029220921p:plain\" title=\"f:id:agtn:20151029220921p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>緑がプレイヤー, 青がゴール, 赤が箱です. 箱を押して青を塞げばクリアです.</p>\n\n<h2>感想</h2>\n\n<p>Nim で遊びたくて作ってみましたが，思っていた以上に Nim が楽しいですね． ライブラリも整っていますし，特に難しいことはなくサクサク書けました．</p>\n\n<p>Nim で <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Lisp\">Lisp</a> 処理系を書いたりしていて，息抜きに<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GUI\">GUI</a>っぽいものをと思って書きました． Cライブラリとの連携も非常にスムーズでしたし，Nim 流行んないかなぁと思っています．</p>\n\n---\n\n---\n","contentMarkdown":"\n<h1>Sokoban.nim を書いてみた</h1>\n\n<p><a href=\"http://www.nim-lang.org\">Nim</a> という言語を使って<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C1%D2%B8%CB%C8%D6\">倉庫番</a>を書いてみました.</p>\n\n<p><a href=\"https://github.com/agatan/sokoban-nim\">sokoban-nim</a></p>\n\n<p><a href=\"https://github.com/swatteau/sokoban-rs\">sokoban-rs</a> に影響されました．</p>\n\n<p>といっても <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDL\">SDL</a> ド素人なので見た目は恐ろしく質素です． Nim の練習のつもりで書いてみました．</p>\n\n<h2>動作</h2>\n\n<p>動作としては，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%DE%A5%F3%A5%C9%A5%E9%A5%A4%A5%F3\">コマンドライン</a>引数にステージ情報を記述したファイル名を指定します．</p>\n\n<pre><code>##########\n#   .    #\n#  $   . ####\n# @ $       #\n#           #\n#############\n</code></pre>\n\n<p>このようなファイルを指定します． クリアするとなにも言わずに終了するようになっています．(また, ESC でも終了します)</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/agtn/20151029/20151029220921.png\" alt=\"f:id:agtn:20151029220921p:plain\" title=\"f:id:agtn:20151029220921p:plain\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>緑がプレイヤー, 青がゴール, 赤が箱です. 箱を押して青を塞げばクリアです.</p>\n\n<h2>感想</h2>\n\n<p>Nim で遊びたくて作ってみましたが，思っていた以上に Nim が楽しいですね． ライブラリも整っていますし，特に難しいことはなくサクサク書けました．</p>\n\n<p>Nim で <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Lisp\">Lisp</a> 処理系を書いたりしていて，息抜きに<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GUI\">GUI</a>っぽいものをと思って書きました． Cライブラリとの連携も非常にスムーズでしたし，Nim 流行んないかなぁと思っています．</p>\n\n---\n\n---\n","slug":"Sokoban.nim_を書いてみた","title":"Sokoban.nim を書いてみた","timestamp":1446124242000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Golang での文字列連結に関するベンチマーク\"\ndate: 2015-09-08T08:09:45.000Z\ntags: []\n---\n\n<h1>まず結論</h1>\n\n<p><code>append</code> しよう. <code>bytes.Buffer</code> はそんなに速くない.</p>\n\n<h1>きっかけ</h1>\n\n<p>こんな記事を見かけました.<br/>\n<a href=\"http://qiita.com/ruiu/items/2bb83b29baeae2433a79\">Goでは文字列連結はコストの高い操作 - Qiita</a></p>\n\n<p><code>buf += \"abc\"</code> はコストが高いよーっていうお話ですね. これは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> にかぎらず, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a>とかでもよく話題になる一般的な問題だと思います.<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> だと <code>StringBuilder</code> を使うのが良いとされていたと思いますが, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> だと解法がいくつかあるようです.</p>\n\n<p>そこで, 解法をそれぞれ紹介した後, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\">ベンチマーク</a>結果を載せてみたいと思います.</p>\n\n<h2>1. 普通に <code>+=</code></h2>\n\n<p>まずは普通に <code>+=</code> で連結していく方法です.</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">func</span> AddString(n <span class=\"synType\">int</span>) <span class=\"synType\">string</span> {\n    base := <span class=\"synConstant\">&quot;abc&quot;</span>\n    buf := <span class=\"synConstant\">&quot;&quot;</span>\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; n; i++ {\n        buf += base\n    }\n    <span class=\"synStatement\">return</span> buf\n}\n</pre>\n\n<p>こんな感じですね.<br/>\nこれだと, 確実に n 回メモリ割り当てが発生するので遅いというのが問題となります.</p>\n\n<h2>2. <code>append</code> する</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> の <code>string</code> は, メモリ上では <code>[]byte</code> と同等の表現を持ちます.<br/>\nそこで, <code>string</code> を <code>[]byte</code> として扱い, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> のスライスを伸長する <code>append</code> 関数を用いるという方法があります.</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">func</span> AppendString(n <span class=\"synType\">int</span>) <span class=\"synType\">string</span> {\n    base := <span class=\"synConstant\">&quot;abc&quot;</span>\n    buf := <span class=\"synStatement\">make</span>([]<span class=\"synType\">byte</span>, <span class=\"synConstant\">0</span>)\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; n; i++ {\n        buf = append(buf, base...)\n    }\n    <span class=\"synStatement\">return</span> <span class=\"synType\">string</span>(buf)\n}\n</pre>\n\n<p><code>make([]byte, 0)</code> によって, 長さ0のスライスを作って, それを伸長していく方法となっています.<br/>\nこのあたりは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> のスライスの表現について知っていないとわかりづらいと思うのですが, わかりやすい説明がいろいろなところで読めるので, ここでは説明しません.\n<code>append</code> 関数は, スライスの len を必要な分だけ大きくします. また, その結果 len が スライスの cap を超える長さになる場合は, スライスの cap を必要以上に大きくすします.<br/>\nこれは, <code>append</code> を繰り返し適用するような場合(今回のように)に, メモリ割り当ての回数を最小にするためです. 一度の <code>append</code> で大きめにメモリを確保しておくことで, 次の <code>append</code> ではメモリ割り当てをしなくても済む可能性が生まれます.<br/>\nイメージとしては,</p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center;\"> append の回数 </th>\n<th style=\"text-align:center;\"> 0 </th>\n<th style=\"text-align:center;\"> 1 </th>\n<th style=\"text-align:center;\"> 2 </th>\n<th style=\"text-align:center;\"> 3 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center;\"> len </td>\n<td style=\"text-align:center;\"> 0 </td>\n<td style=\"text-align:center;\"> 3 </td>\n<td style=\"text-align:center;\"> 6 </td>\n<td style=\"text-align:center;\"> 9 </td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"> cap </td>\n<td style=\"text-align:center;\"> 0 </td>\n<td style=\"text-align:center;\"> 8 </td>\n<td style=\"text-align:center;\"> 8 </td>\n<td style=\"text-align:center;\"> 16 </td>\n</tr>\n</tbody>\n</table>\n\n<p>こんな感じでしょうか(あくまでイメージですが)<br/>\n<code>append</code> は3回呼ばれていますが, メモリ割り当ては2回に抑えられています.<br/>\nその分, <code>+=</code> よりも速いだろうということですね.</p>\n\n<h3>2'. <code>cap</code> を十分量確保しておく</h3>\n\n<p><code>make</code> によるスライスの作成の際には, 長さだけでなくキャパシティを指定することが出来ます.<br/>\nしたがって, はじめから <code>append</code> していった後の最終的なスライスの長さがわかっているのであれば, それをキャパシティに指定することで, メモリ割り当てを最小限に抑えることが可能になります.</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">func</span> AppendStringWithCap(n <span class=\"synType\">int</span>) <span class=\"synType\">string</span> {\n    base := <span class=\"synConstant\">&quot;abc&quot;</span>\n    buf := <span class=\"synStatement\">make</span>([]<span class=\"synType\">byte</span>, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">3</span>*n)\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; n; i++ {\n        buf = append(buf, base...)\n    }\n    <span class=\"synStatement\">return</span> <span class=\"synType\">string</span>(buf)\n}\n</pre>\n\n<h2>3. <code>bytes.Buffer</code> を使う</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> の <code>StringBuilder</code> に近い解法ですね.<br/>\n<code>bytes.Buffer</code> は文字通りバイト列のバッファリングを行ってくれます.<br/>\n<code>bytes.Buffer</code> に文字列やバイト列を書き込んでいくと, 自動的にメモリ割り当てを減らすように計らってくれます.</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">func</span> BufferString(n <span class=\"synType\">int</span>) <span class=\"synType\">string</span> {\n    base := <span class=\"synConstant\">&quot;abc&quot;</span>\n    <span class=\"synStatement\">var</span> buf <span class=\"synType\">bytes.Buffer</span>\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; n; i++ {\n        buf.WriteString(base)\n    }\n    <span class=\"synStatement\">return</span> buf.String()\n}\n</pre>\n\n<p>こんな感じです.</p>\n\n<h1><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\">ベンチマーク</a>結果</h1>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> には<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\">ベンチマーク</a>をとる機能も標準で付いているので, それを利用しました.</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">package</span> main\n\n<span class=\"synStatement\">import</span> <span class=\"synConstant\">&quot;testing&quot;</span>\n\n<span class=\"synStatement\">const</span> N = <span class=\"synConstant\">1000</span>\n\n<span class=\"synStatement\">func</span> BenchmarkAddString(b *testing.B) {\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; b.N; i++ {\n        AddString(N)\n    }\n}\n\n<span class=\"synStatement\">func</span> BenchmarkAppendString(b *testing.B) {\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; b.N; i++ {\n        AppendString(N)\n    }\n}\n\n<span class=\"synStatement\">func</span> BenchmarkAppendStringWithCap(b *testing.B) {\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; b.N; i++ {\n        AppendStringWithCap(N)\n    }\n}\n\n<span class=\"synStatement\">func</span> BenchmarkBufferString(b *testing.B) {\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; b.N; i++ {\n        BufferString(N)\n    }\n}\n\n<span class=\"synStatement\">func</span> TestEquality(t *testing.T) {\n    base := AddString(N)\n    tests := []<span class=\"synType\">string</span>{\n        AppendString(N),\n        AppendStringWithCap(N),\n        BufferString(N),\n    }\n    <span class=\"synStatement\">for</span> _, test := <span class=\"synStatement\">range</span> tests {\n        <span class=\"synStatement\">if</span> base != test {\n            t.Fatal(<span class=\"synConstant\">&quot;not fair&quot;</span>)\n        }\n    }\n}\n</pre>\n\n<p><code>TestEquality</code> は, すべての方法で正しく文字列を生成できていることを確認するためのテストです. <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\">ベンチマーク</a>には関係ありません.</p>\n\n<h2>結果</h2>\n\n<p>上記のファイルを用意した後, <code>go test -bench . -benchmem</code> とした結果を以下に示します.</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>PASS\nBenchmarkAddString-8                5000        348347 ns/op     1592481 B/op        999 allocs/op\nBenchmarkAppendString-8           200000          7346 ns/op       13056 B/op         12 allocs/op\nBenchmarkAppendStringWithCap-8    300000          5461 ns/op        6144 B/op          2 allocs/op\nBenchmarkBufferString-8           100000         16847 ns/op       12256 B/op          8 allocs/op\nok      github.com/agatan/bench 6.881s</pre>\n\n<p>というわけで, <code>make</code> の時点で十分なメモリを確保しておく 2' の方法が最も速く最もメモリを消費しないことがわかりました.<br/>\nまぁ当たり前ですねｗｗ</p>\n\n<p>より注目すべきは, 2 と 4 の結果です. 今回の結果だと, 最終的な文字列の長さがわからない場合, <code>bytes.Buffer</code> よりも <code>append</code> を使ったほうが速いという結果になっています (メモリ使用量は若干 <code>bytes.Buffer</code> のほうが小さい)</p>\n\n<p>メモリ割り当ての回数も <code>bytes.Buffer</code> のほうが少なく済んでいるため, <code>[]byte</code> と <code>string</code> の変換など, 文字列連結以外の部分でのオーバーヘッドが大きいため, このような結果になった可能性があります. そこで, <code>N</code> の値を変えて実行してみました.</p>\n\n<h2>N = 10 の場合</h2>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>PASS\nBenchmarkAddString-8             2000000           613 ns/op         224 B/op          9 allocs/op\nBenchmarkAppendString-8          5000000           270 ns/op          96 B/op          4 allocs/op\nBenchmarkAppendStringWithCap-8  10000000           142 ns/op          64 B/op          2 allocs/op\nBenchmarkBufferString-8          5000000           251 ns/op         144 B/op          2 allocs/op\nok      github.com/agatan/bench 6.581s</pre>\n\n<h2>N = 10000 の場合</h2>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>PASS\nBenchmarkAddString-8                  50      28544042 ns/op    160274378 B/op     10039 allocs/op\nBenchmarkAppendString-8            20000         71285 ns/op      160768 B/op         20 allocs/op\nBenchmarkAppendStringWithCap-8     30000         55262 ns/op       65536 B/op          2 allocs/op\nBenchmarkBufferString-8            10000        151665 ns/op      109280 B/op         11 allocs/op\nok      github.com/agatan/bench 7.393s</pre>\n\n<h1>結論</h1>\n\n<p>連結する文字列の長さや連結の回数にもよるが, おおよそ <code>append</code> のほうが速い！！<br/>\n<code>bytes.Buffer</code> はいつ使えばいいの...</p>\n\n---\n\n---\n","contentMarkdown":"\n<h1>まず結論</h1>\n\n<p><code>append</code> しよう. <code>bytes.Buffer</code> はそんなに速くない.</p>\n\n<h1>きっかけ</h1>\n\n<p>こんな記事を見かけました.<br/>\n<a href=\"http://qiita.com/ruiu/items/2bb83b29baeae2433a79\">Goでは文字列連結はコストの高い操作 - Qiita</a></p>\n\n<p><code>buf += \"abc\"</code> はコストが高いよーっていうお話ですね. これは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> にかぎらず, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a>とかでもよく話題になる一般的な問題だと思います.<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> だと <code>StringBuilder</code> を使うのが良いとされていたと思いますが, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> だと解法がいくつかあるようです.</p>\n\n<p>そこで, 解法をそれぞれ紹介した後, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\">ベンチマーク</a>結果を載せてみたいと思います.</p>\n\n<h2>1. 普通に <code>+=</code></h2>\n\n<p>まずは普通に <code>+=</code> で連結していく方法です.</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">func</span> AddString(n <span class=\"synType\">int</span>) <span class=\"synType\">string</span> {\n    base := <span class=\"synConstant\">&quot;abc&quot;</span>\n    buf := <span class=\"synConstant\">&quot;&quot;</span>\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; n; i++ {\n        buf += base\n    }\n    <span class=\"synStatement\">return</span> buf\n}\n</pre>\n\n<p>こんな感じですね.<br/>\nこれだと, 確実に n 回メモリ割り当てが発生するので遅いというのが問題となります.</p>\n\n<h2>2. <code>append</code> する</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> の <code>string</code> は, メモリ上では <code>[]byte</code> と同等の表現を持ちます.<br/>\nそこで, <code>string</code> を <code>[]byte</code> として扱い, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> のスライスを伸長する <code>append</code> 関数を用いるという方法があります.</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">func</span> AppendString(n <span class=\"synType\">int</span>) <span class=\"synType\">string</span> {\n    base := <span class=\"synConstant\">&quot;abc&quot;</span>\n    buf := <span class=\"synStatement\">make</span>([]<span class=\"synType\">byte</span>, <span class=\"synConstant\">0</span>)\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; n; i++ {\n        buf = append(buf, base...)\n    }\n    <span class=\"synStatement\">return</span> <span class=\"synType\">string</span>(buf)\n}\n</pre>\n\n<p><code>make([]byte, 0)</code> によって, 長さ0のスライスを作って, それを伸長していく方法となっています.<br/>\nこのあたりは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> のスライスの表現について知っていないとわかりづらいと思うのですが, わかりやすい説明がいろいろなところで読めるので, ここでは説明しません.\n<code>append</code> 関数は, スライスの len を必要な分だけ大きくします. また, その結果 len が スライスの cap を超える長さになる場合は, スライスの cap を必要以上に大きくすします.<br/>\nこれは, <code>append</code> を繰り返し適用するような場合(今回のように)に, メモリ割り当ての回数を最小にするためです. 一度の <code>append</code> で大きめにメモリを確保しておくことで, 次の <code>append</code> ではメモリ割り当てをしなくても済む可能性が生まれます.<br/>\nイメージとしては,</p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center;\"> append の回数 </th>\n<th style=\"text-align:center;\"> 0 </th>\n<th style=\"text-align:center;\"> 1 </th>\n<th style=\"text-align:center;\"> 2 </th>\n<th style=\"text-align:center;\"> 3 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center;\"> len </td>\n<td style=\"text-align:center;\"> 0 </td>\n<td style=\"text-align:center;\"> 3 </td>\n<td style=\"text-align:center;\"> 6 </td>\n<td style=\"text-align:center;\"> 9 </td>\n</tr>\n<tr>\n<td style=\"text-align:center;\"> cap </td>\n<td style=\"text-align:center;\"> 0 </td>\n<td style=\"text-align:center;\"> 8 </td>\n<td style=\"text-align:center;\"> 8 </td>\n<td style=\"text-align:center;\"> 16 </td>\n</tr>\n</tbody>\n</table>\n\n<p>こんな感じでしょうか(あくまでイメージですが)<br/>\n<code>append</code> は3回呼ばれていますが, メモリ割り当ては2回に抑えられています.<br/>\nその分, <code>+=</code> よりも速いだろうということですね.</p>\n\n<h3>2'. <code>cap</code> を十分量確保しておく</h3>\n\n<p><code>make</code> によるスライスの作成の際には, 長さだけでなくキャパシティを指定することが出来ます.<br/>\nしたがって, はじめから <code>append</code> していった後の最終的なスライスの長さがわかっているのであれば, それをキャパシティに指定することで, メモリ割り当てを最小限に抑えることが可能になります.</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">func</span> AppendStringWithCap(n <span class=\"synType\">int</span>) <span class=\"synType\">string</span> {\n    base := <span class=\"synConstant\">&quot;abc&quot;</span>\n    buf := <span class=\"synStatement\">make</span>([]<span class=\"synType\">byte</span>, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">3</span>*n)\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; n; i++ {\n        buf = append(buf, base...)\n    }\n    <span class=\"synStatement\">return</span> <span class=\"synType\">string</span>(buf)\n}\n</pre>\n\n<h2>3. <code>bytes.Buffer</code> を使う</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a> の <code>StringBuilder</code> に近い解法ですね.<br/>\n<code>bytes.Buffer</code> は文字通りバイト列のバッファリングを行ってくれます.<br/>\n<code>bytes.Buffer</code> に文字列やバイト列を書き込んでいくと, 自動的にメモリ割り当てを減らすように計らってくれます.</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">func</span> BufferString(n <span class=\"synType\">int</span>) <span class=\"synType\">string</span> {\n    base := <span class=\"synConstant\">&quot;abc&quot;</span>\n    <span class=\"synStatement\">var</span> buf <span class=\"synType\">bytes.Buffer</span>\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; n; i++ {\n        buf.WriteString(base)\n    }\n    <span class=\"synStatement\">return</span> buf.String()\n}\n</pre>\n\n<p>こんな感じです.</p>\n\n<h1><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\">ベンチマーク</a>結果</h1>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> には<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\">ベンチマーク</a>をとる機能も標準で付いているので, それを利用しました.</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">package</span> main\n\n<span class=\"synStatement\">import</span> <span class=\"synConstant\">&quot;testing&quot;</span>\n\n<span class=\"synStatement\">const</span> N = <span class=\"synConstant\">1000</span>\n\n<span class=\"synStatement\">func</span> BenchmarkAddString(b *testing.B) {\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; b.N; i++ {\n        AddString(N)\n    }\n}\n\n<span class=\"synStatement\">func</span> BenchmarkAppendString(b *testing.B) {\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; b.N; i++ {\n        AppendString(N)\n    }\n}\n\n<span class=\"synStatement\">func</span> BenchmarkAppendStringWithCap(b *testing.B) {\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; b.N; i++ {\n        AppendStringWithCap(N)\n    }\n}\n\n<span class=\"synStatement\">func</span> BenchmarkBufferString(b *testing.B) {\n    <span class=\"synStatement\">for</span> i := <span class=\"synConstant\">0</span>; i &lt; b.N; i++ {\n        BufferString(N)\n    }\n}\n\n<span class=\"synStatement\">func</span> TestEquality(t *testing.T) {\n    base := AddString(N)\n    tests := []<span class=\"synType\">string</span>{\n        AppendString(N),\n        AppendStringWithCap(N),\n        BufferString(N),\n    }\n    <span class=\"synStatement\">for</span> _, test := <span class=\"synStatement\">range</span> tests {\n        <span class=\"synStatement\">if</span> base != test {\n            t.Fatal(<span class=\"synConstant\">&quot;not fair&quot;</span>)\n        }\n    }\n}\n</pre>\n\n<p><code>TestEquality</code> は, すべての方法で正しく文字列を生成できていることを確認するためのテストです. <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D9%A5%F3%A5%C1%A5%DE%A1%BC%A5%AF\">ベンチマーク</a>には関係ありません.</p>\n\n<h2>結果</h2>\n\n<p>上記のファイルを用意した後, <code>go test -bench . -benchmem</code> とした結果を以下に示します.</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>PASS\nBenchmarkAddString-8                5000        348347 ns/op     1592481 B/op        999 allocs/op\nBenchmarkAppendString-8           200000          7346 ns/op       13056 B/op         12 allocs/op\nBenchmarkAppendStringWithCap-8    300000          5461 ns/op        6144 B/op          2 allocs/op\nBenchmarkBufferString-8           100000         16847 ns/op       12256 B/op          8 allocs/op\nok      github.com/agatan/bench 6.881s</pre>\n\n<p>というわけで, <code>make</code> の時点で十分なメモリを確保しておく 2' の方法が最も速く最もメモリを消費しないことがわかりました.<br/>\nまぁ当たり前ですねｗｗ</p>\n\n<p>より注目すべきは, 2 と 4 の結果です. 今回の結果だと, 最終的な文字列の長さがわからない場合, <code>bytes.Buffer</code> よりも <code>append</code> を使ったほうが速いという結果になっています (メモリ使用量は若干 <code>bytes.Buffer</code> のほうが小さい)</p>\n\n<p>メモリ割り当ての回数も <code>bytes.Buffer</code> のほうが少なく済んでいるため, <code>[]byte</code> と <code>string</code> の変換など, 文字列連結以外の部分でのオーバーヘッドが大きいため, このような結果になった可能性があります. そこで, <code>N</code> の値を変えて実行してみました.</p>\n\n<h2>N = 10 の場合</h2>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>PASS\nBenchmarkAddString-8             2000000           613 ns/op         224 B/op          9 allocs/op\nBenchmarkAppendString-8          5000000           270 ns/op          96 B/op          4 allocs/op\nBenchmarkAppendStringWithCap-8  10000000           142 ns/op          64 B/op          2 allocs/op\nBenchmarkBufferString-8          5000000           251 ns/op         144 B/op          2 allocs/op\nok      github.com/agatan/bench 6.581s</pre>\n\n<h2>N = 10000 の場合</h2>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>PASS\nBenchmarkAddString-8                  50      28544042 ns/op    160274378 B/op     10039 allocs/op\nBenchmarkAppendString-8            20000         71285 ns/op      160768 B/op         20 allocs/op\nBenchmarkAppendStringWithCap-8     30000         55262 ns/op       65536 B/op          2 allocs/op\nBenchmarkBufferString-8            10000        151665 ns/op      109280 B/op         11 allocs/op\nok      github.com/agatan/bench 7.393s</pre>\n\n<h1>結論</h1>\n\n<p>連結する文字列の長さや連結の回数にもよるが, おおよそ <code>append</code> のほうが速い！！<br/>\n<code>bytes.Buffer</code> はいつ使えばいいの...</p>\n\n---\n\n---\n","slug":"Golang_での文字列連結に関するベンチマーク","title":"Golang での文字列連結に関するベンチマーク","timestamp":1441699785000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Golangでechoサーバ\"\ndate: 2015-09-08T07:14:10.000Z\ntags: []\n---\n\n<p>最近 <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> が気になります<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> の特徴はもはやわざわざここに書くまでも無いことだと思うので書きませんが, 気になっている理由を書いてみます.</p>\n\n<ul>\n<li>バイナリ(しかもポータビリティが非常に高いバイナリ)に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>されること</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C/C%2B%2B\">C/C++</a> には及ばずとも実行が非常に速いこと</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C/C%2B%2B\">C/C++</a> ほど低レイヤーいじり放題なわけではないが, ある程度低レイヤーまで降りていけること</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%DE%A5%F3%A5%C9%A5%E9%A5%A4%A5%F3\">コマンドライン</a><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C4%A1%BC%A5%EB\">ツール</a>からWeb アプリケーションのような高レイヤーまで十分得意であること</li>\n<li><code>interface</code> による抽象化が, 過度でなく調度良く感じられること</li>\n</ul>\n\n<p>こんな感じでしょうか.<br/>\nCompiled <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a> っていう感じが非常に良さそうだなーと思っています.</p>\n\n<p>というわけで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>に引き続き <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> でも echo サーバを書いてみました</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">package</span> main\n\n<span class=\"synStatement\">import</span> (\n    <span class=\"synConstant\">&quot;fmt&quot;</span>\n    <span class=\"synConstant\">&quot;io&quot;</span>\n    <span class=\"synConstant\">&quot;net&quot;</span>\n)\n\n<span class=\"synStatement\">func</span> main() {\n    listener, err := net.Listen(<span class=\"synConstant\">&quot;tcp&quot;</span>, <span class=\"synConstant\">&quot;:8080&quot;</span>)\n    <span class=\"synStatement\">if</span> err != <span class=\"synStatement\">nil</span> {\n        <span class=\"synStatement\">panic</span>(err)\n    }\n    <span class=\"synStatement\">for</span> {\n        conn, err := listener.Accept()\n        <span class=\"synStatement\">if</span> err != <span class=\"synStatement\">nil</span> {\n            <span class=\"synStatement\">panic</span>(err)\n        }\n        <span class=\"synStatement\">go</span> <span class=\"synType\">func</span>(conn net.Conn) {\n            <span class=\"synStatement\">defer</span> conn.Close()\n            echo(conn)\n        }(conn)\n    }\n}\n\n<span class=\"synStatement\">func</span> echo(conn net.Conn) {\n    buf := <span class=\"synStatement\">make</span>([]<span class=\"synType\">byte</span>, <span class=\"synConstant\">256</span>)\n    <span class=\"synStatement\">for</span> {\n        n, err := conn.Read(buf)\n        <span class=\"synStatement\">if</span> err != <span class=\"synStatement\">nil</span> {\n            <span class=\"synStatement\">if</span> err == io.EOF {\n                <span class=\"synStatement\">break</span>\n            }\n            <span class=\"synStatement\">panic</span>(err)\n        }\n        <span class=\"synStatement\">if</span> n == <span class=\"synConstant\">0</span> {\n            <span class=\"synStatement\">break</span>\n        }\n        wn, err := conn.Write(buf[<span class=\"synConstant\">0</span>:n])\n        <span class=\"synStatement\">if</span> err != <span class=\"synStatement\">nil</span> {\n            <span class=\"synStatement\">panic</span>(err)\n        }\n        <span class=\"synStatement\">if</span> wn != n {\n            <span class=\"synStatement\">panic</span>(fmt.Errorf(<span class=\"synConstant\">&quot;could not send all data&quot;</span>))\n        }\n    }\n}\n</pre>\n\n<p>さすがは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> というかなんというか. ものすごく普通な空気を感じますね.<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a>はこういう普通さが売りの１つだと思っています.</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>最近 <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> が気になります<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> の特徴はもはやわざわざここに書くまでも無いことだと思うので書きませんが, 気になっている理由を書いてみます.</p>\n\n<ul>\n<li>バイナリ(しかもポータビリティが非常に高いバイナリ)に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>されること</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C/C%2B%2B\">C/C++</a> には及ばずとも実行が非常に速いこと</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C/C%2B%2B\">C/C++</a> ほど低レイヤーいじり放題なわけではないが, ある程度低レイヤーまで降りていけること</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%DE%A5%F3%A5%C9%A5%E9%A5%A4%A5%F3\">コマンドライン</a><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C4%A1%BC%A5%EB\">ツール</a>からWeb アプリケーションのような高レイヤーまで十分得意であること</li>\n<li><code>interface</code> による抽象化が, 過度でなく調度良く感じられること</li>\n</ul>\n\n<p>こんな感じでしょうか.<br/>\nCompiled <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a> っていう感じが非常に良さそうだなーと思っています.</p>\n\n<p>というわけで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>に引き続き <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> でも echo サーバを書いてみました</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">package</span> main\n\n<span class=\"synStatement\">import</span> (\n    <span class=\"synConstant\">&quot;fmt&quot;</span>\n    <span class=\"synConstant\">&quot;io&quot;</span>\n    <span class=\"synConstant\">&quot;net&quot;</span>\n)\n\n<span class=\"synStatement\">func</span> main() {\n    listener, err := net.Listen(<span class=\"synConstant\">&quot;tcp&quot;</span>, <span class=\"synConstant\">&quot;:8080&quot;</span>)\n    <span class=\"synStatement\">if</span> err != <span class=\"synStatement\">nil</span> {\n        <span class=\"synStatement\">panic</span>(err)\n    }\n    <span class=\"synStatement\">for</span> {\n        conn, err := listener.Accept()\n        <span class=\"synStatement\">if</span> err != <span class=\"synStatement\">nil</span> {\n            <span class=\"synStatement\">panic</span>(err)\n        }\n        <span class=\"synStatement\">go</span> <span class=\"synType\">func</span>(conn net.Conn) {\n            <span class=\"synStatement\">defer</span> conn.Close()\n            echo(conn)\n        }(conn)\n    }\n}\n\n<span class=\"synStatement\">func</span> echo(conn net.Conn) {\n    buf := <span class=\"synStatement\">make</span>([]<span class=\"synType\">byte</span>, <span class=\"synConstant\">256</span>)\n    <span class=\"synStatement\">for</span> {\n        n, err := conn.Read(buf)\n        <span class=\"synStatement\">if</span> err != <span class=\"synStatement\">nil</span> {\n            <span class=\"synStatement\">if</span> err == io.EOF {\n                <span class=\"synStatement\">break</span>\n            }\n            <span class=\"synStatement\">panic</span>(err)\n        }\n        <span class=\"synStatement\">if</span> n == <span class=\"synConstant\">0</span> {\n            <span class=\"synStatement\">break</span>\n        }\n        wn, err := conn.Write(buf[<span class=\"synConstant\">0</span>:n])\n        <span class=\"synStatement\">if</span> err != <span class=\"synStatement\">nil</span> {\n            <span class=\"synStatement\">panic</span>(err)\n        }\n        <span class=\"synStatement\">if</span> wn != n {\n            <span class=\"synStatement\">panic</span>(fmt.Errorf(<span class=\"synConstant\">&quot;could not send all data&quot;</span>))\n        }\n    }\n}\n</pre>\n\n<p>さすがは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a> というかなんというか. ものすごく普通な空気を感じますね.<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a>はこういう普通さが売りの１つだと思っています.</p>\n\n---\n\n---\n","slug":"Golangでechoサーバ","title":"Golangでechoサーバ","timestamp":1441696450000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Haskellでechoサーバ\"\ndate: 2015-07-23T12:43:44.000Z\ntags: []\n---\n\n<p>はいどうもー<br/>\n引き続き<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>の話題です. ちょっと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\">TCP</a>ソケットを使ってみたくなったので, まず簡単なものから実装してみます.</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\">TCP</a>ソケットの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C1%A5%E5%A1%BC%A5%C8%A5%EA%A5%A2%A5%EB\">チュートリアル</a>といえばechoサーバですね！クライアントからの入力をそのまま返すサーバです.<br/>\nせっかくなのできちんと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>クライアントとの同時通信を可能にしましょう.</p>\n\n<h1>Network.Socket</h1>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\">TCP</a>ソケットを使うには, <code>Network.Socket</code>を使うようです. <a href=\"http://hackage.haskell.org/package/network-2.6.2.1/docs/Network-Socket.html\">Network.Socket</a></p>\n\n<p>ドキュメントには, 低レベル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が<code>Network.Socket</code>で, 高レベル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が<code>Network</code>と書いてあるのですが, <code>Network</code>モジュールのドキュメントには, 互換性のために残してあるけどこれから使う人は<code>Network.Socket</code>を使ってくれみたいなことが書いてあります.<br/>\n適当に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%B0%A4%EB\">ググる</a>と<code>Network</code>モジュールを使ったサンプルが散見されますが, ここはドキュメントにしたがって, <code>Network.Socket</code>を使用することにします.</p>\n\n<h1>ソケットの用意</h1>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\">TCP</a>のサーバ側は, ソケットの作成 -> ソケットをポート番号指定でbind -> 接続受付を開始(listen) -> 接続を受け付ける(accept) というステップを踏む必要があります.<br/>\nというわけでまずは指定したポート番号にbindされたソケットを用意するアクションを定義します.</p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink><span class=\"synPreProc\">import</span> Network.Socket\n\nserveSocket <span class=\"synStatement\">::</span> PortNumber <span class=\"synStatement\">-&gt;</span> Socket\nserveSocket port <span class=\"synStatement\">=</span> <span class=\"synStatement\">do</span>\n    soc <span class=\"synStatement\">&lt;-</span> socket AF_INET Stream defaultProtocol\n    addr <span class=\"synStatement\">&lt;-</span> inet_addr <span class=\"synConstant\">&quot;0.0.0.0&quot;</span>\n    bind soc (SockAddrInet port addr)\n    return soc\n</pre>\n\n<p>これで引数に渡したポート番号にbindされたソケットが作成されます.</p>\n\n<h2>accept</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>クライアントとの同時通信を実現するためには, <code>Control.Concurrent</code>のちからを借ります.<br/>\n今回は <code>forkIO</code> を使って, 各コネクションごとにスレッドを起動していくことにします. (非同期版も作れるのかな？つくれたらつくります)</p>\n\n<p>というわけで次は <code>accept</code>して<code>forkIO</code>するという処理を繰り返し行うアクションを定義します.<br/>\n<code>forkIO</code> した後に実行するアクション(<code>echoLoop</code>)についてはとりあえず<code>undefined</code>とします. <br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>の<code>undefined</code>, とても便利ですね. 型で考えるっていうスタイルが実行しやすくなっているのは, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>上にトッ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%EC%A5%D9\">プレベ</a>ル関数の型指定を書きやすい<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>の文法と<code>undefined</code>のおかげって感じがします.</p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink>echoLoop <span class=\"synStatement\">::</span> Socket <span class=\"synStatement\">-&gt;</span> IO ()\nechoLoop <span class=\"synStatement\">=</span> undefined\n\n<span class=\"synComment\">-- import Control.Concurrent</span>\n<span class=\"synComment\">-- import Control.Monad</span>\n<span class=\"synComment\">-- が必要</span>\nacceptLoop <span class=\"synStatement\">::</span> Socket <span class=\"synStatement\">-&gt;</span> IO ()\nacceptLoop soc <span class=\"synStatement\">=</span> forever <span class=\"synStatement\">$</span> <span class=\"synStatement\">do</span>\n    (conn, _addr) <span class=\"synStatement\">&lt;-</span> accept soc\n    forkIO <span class=\"synStatement\">$</span> echoLoop conn\n</pre>\n\n<p><code>forever :: Monad m =&gt; m a -&gt; m b</code>は引数にIOアクションを受け取り, それを無限に繰り返し実行し続けます. (無限にくりかえすので返り値の型変数<code>b</code>は不定)<br/>\n<code>forever</code>の引数には, <code>accept</code>して<code>forkIO</code>するアクションを渡しています.</p>\n\n<h1>echo</h1>\n\n<p>最後にソケットから読み込み, そのまま書き出す<code>echoLoop</code>部分を作ります.</p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink><span class=\"synComment\">-- import Control.Exception が必要</span>\nechoLoop <span class=\"synStatement\">::</span> Socket <span class=\"synStatement\">-&gt;</span> IO ()\nechoLoop conn <span class=\"synStatement\">=</span> <span class=\"synStatement\">do</span>\n    sequence_ <span class=\"synStatement\">$</span> repeat <span class=\"synStatement\">$</span> <span class=\"synStatement\">do</span>\n        (str, _, _) <span class=\"synStatement\">&lt;-</span> recvFrom soc <span class=\"synConstant\">64</span>\n        send soc str\n</pre>\n\n<p><code>recvFrom :: Socket -&gt; Int -&gt; IO (String, Int, SockAddr)</code>は, <code>recvFrom conn n</code> で, <code>conn</code>から最大で<code>n</code>文字まで読み込みます.\n返り値は, <code>(読み込んだ文字列, 読み込んだ文字数, 読み込み元のアドレス??)</code> を返します.<br/>\nそして, <code>send :: Socket -&gt; String -&gt; IO ()</code> でソケットに読み込んだ文字列をそのまま書き込みます.<br/>\nこのように, 読み込んでそのままｍ書き込むというアクションを <code>repeat</code>でつなげています. <code>repeat :: a -&gt; [a]</code>は無限リストを作る関数です. <code>repeat 0</code>で<code>[0, 0, 0, 0, ...</code>というリストが作成されます. <br/>\nこのままでは <code>[IO ()]</code>型なので, これを<code>sequence_ :: Monad m =&gt; [m a] -&gt; m ()</code>を使って１つのIOアクションにまとめ上げます.<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>が遅延評価だから出来る芸当ですね. 無限に繰り返す感あふれるコードになっている気がします. (<code>forever</code>使ったほうがいいと思います)</p>\n\n<h1>例外処理</h1>\n\n<p><code>recvFrom</code>は相手側がコネクションを切断すると<code>End of file</code>の例外を投げます. <code>forkIO</code>しているので, １つのスレッドが例外で落ちてもサーバ全体は動き続けますが, ソケットのクローズも出来ませんし, 標準エラーになんかでてきてよろしくないので修正します.</p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink><span class=\"synComment\">-- import Control.Exceptionが必要</span>\nechoLoop <span class=\"synStatement\">::</span> Socket <span class=\"synStatement\">-&gt;</span> IO ()\nechoLoop conn <span class=\"synStatement\">=</span> <span class=\"synStatement\">do</span>\n   sequence_ <span class=\"synStatement\">$</span> repeat <span class=\"synStatement\">$</span> <span class=\"synStatement\">do</span>\n       (str, _, _) <span class=\"synStatement\">&lt;-</span> recvFrom conn <span class=\"synConstant\">64</span>\n       send conn str\n   <span class=\"synStatement\">`catch`</span> (<span class=\"synStatement\">\\</span>(SomeException e) <span class=\"synStatement\">-&gt;</span> return ())\n   <span class=\"synStatement\">`finally`</span> close conn\n</pre>\n\n<p><code>catch</code>と<code>finally</code>を追加しています.<br/>\nどちらも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a>とかのそれと同じように動きます.<br/>\n<code>SomeException</code>はすべての例外を補足することが出来ますが, ほんとはあんまり良くないですね. ここではEOFに達した(コネクションが切断された)という場合だけを補足したいので. (どの関数がどういう場合にどんな例外を投げるのかっていうドキュメントがわからなかったのでこのままにしておきました)<br/>\nそして, 例外が発生してもしなくても, 最後にかならずソケットのクローズをするよう<code>finally</code>を使います.</p>\n\n<p><code>SomeException</code>ですべての例外が捕捉出来るのって不思議じゃないですか？<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>には<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A5%D6%A5%B8%A5%A7%A5%AF%A5%C8%BB%D8%B8%FE\">オブジェクト指向</a>っぽい型の階層関係なんてないのに.\n<a href=\"http://d.hatena.ne.jp/kazu-yamamoto/20081024/1224819961\">Haskellの多相性 - あどけない話</a>このへんが関係しているっぽいなという感じがしますが詳しいことはよくわかりませんでした...</p>\n\n<h1>全体</h1>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink><span class=\"synType\">module</span> Main <span class=\"synType\">where</span>\n\n<span class=\"synPreProc\">import</span> Network.Socket\n<span class=\"synPreProc\">import</span> Control.Monad\n<span class=\"synPreProc\">import</span> Control.Concurrent\n<span class=\"synPreProc\">import</span> Control.Exception\n\nmain <span class=\"synStatement\">::</span> IO ()\nmain <span class=\"synStatement\">=</span> <span class=\"synStatement\">do</span>\n    soc <span class=\"synStatement\">&lt;-</span> serveSocket <span class=\"synConstant\">8080</span>\n    listen soc <span class=\"synConstant\">5</span>\n    acceptLoop soc <span class=\"synStatement\">`finally`</span> close soc\n\nserveSocket <span class=\"synStatement\">::</span> PortNumber <span class=\"synStatement\">-&gt;</span> IO Socket\nserveSocket port <span class=\"synStatement\">=</span> <span class=\"synStatement\">do</span>\n    soc <span class=\"synStatement\">&lt;-</span> socket AF_INET Stream defaultProtocol\n    addr <span class=\"synStatement\">&lt;-</span> inet_addr <span class=\"synConstant\">&quot;0.0.0.0&quot;</span>\n    bind soc (SockAddrInet port addr)\n    return soc\n\nacceptLoop <span class=\"synStatement\">::</span> Socket <span class=\"synStatement\">-&gt;</span> IO ()\nacceptLoop soc <span class=\"synStatement\">=</span> forever <span class=\"synStatement\">$</span> <span class=\"synStatement\">do</span>\n    (conn, addr) <span class=\"synStatement\">&lt;-</span> accept soc\n    forkIO <span class=\"synStatement\">$</span> echoLoop conn\n\nechoLoop <span class=\"synStatement\">::</span> Socket <span class=\"synStatement\">-&gt;</span> IO ()\nechoLoop conn <span class=\"synStatement\">=</span> <span class=\"synStatement\">do</span>\n    sequence_ <span class=\"synStatement\">$</span> repeat <span class=\"synStatement\">$</span> <span class=\"synStatement\">do</span>\n      (str, _, _) <span class=\"synStatement\">&lt;-</span> recvFrom conn <span class=\"synConstant\">64</span>\n      send conn str\n    <span class=\"synStatement\">`catch`</span> (<span class=\"synStatement\">\\</span>(SomeException e) <span class=\"synStatement\">-&gt;</span> return ())\n    <span class=\"synStatement\">`finally`</span> close conn\n</pre>\n\n<p><code>main</code>内で <code>listen</code>するのを忘れずに！また, <code>acceptLoop</code>中に例外が発生してもソケットをクローズするように<code>finally</code>を使っています. (まぁプログラム終了するのでいらない気もします)</p>\n\n<h1>動作確認</h1>\n\n<p><code>telnet</code>コマンドでテストします.</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>% telnet localhost 8080\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is &#39;^]&#39;.\ntest\ntest\naaa\naaa\nhooooogle\nhooooogle</pre>\n\n<p>ちょっとわかりづらいですが, 入力した文字列が即座にそのまま帰ってきていることがわかります. バッファリングの関係で, 一行ずつになっていますが.</p>\n\n<h1>まとめ</h1>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>でechoサーバ, 意外とすんなりかけましたね. 例外関係があまりよく理解できていない感じがしますが...<br/>\n非同期版が気になります. 調べてみます.</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>はいどうもー<br/>\n引き続き<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>の話題です. ちょっと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\">TCP</a>ソケットを使ってみたくなったので, まず簡単なものから実装してみます.</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\">TCP</a>ソケットの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C1%A5%E5%A1%BC%A5%C8%A5%EA%A5%A2%A5%EB\">チュートリアル</a>といえばechoサーバですね！クライアントからの入力をそのまま返すサーバです.<br/>\nせっかくなのできちんと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>クライアントとの同時通信を可能にしましょう.</p>\n\n<h1>Network.Socket</h1>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\">TCP</a>ソケットを使うには, <code>Network.Socket</code>を使うようです. <a href=\"http://hackage.haskell.org/package/network-2.6.2.1/docs/Network-Socket.html\">Network.Socket</a></p>\n\n<p>ドキュメントには, 低レベル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が<code>Network.Socket</code>で, 高レベル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が<code>Network</code>と書いてあるのですが, <code>Network</code>モジュールのドキュメントには, 互換性のために残してあるけどこれから使う人は<code>Network.Socket</code>を使ってくれみたいなことが書いてあります.<br/>\n適当に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B0%A5%B0%A4%EB\">ググる</a>と<code>Network</code>モジュールを使ったサンプルが散見されますが, ここはドキュメントにしたがって, <code>Network.Socket</code>を使用することにします.</p>\n\n<h1>ソケットの用意</h1>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\">TCP</a>のサーバ側は, ソケットの作成 -> ソケットをポート番号指定でbind -> 接続受付を開始(listen) -> 接続を受け付ける(accept) というステップを踏む必要があります.<br/>\nというわけでまずは指定したポート番号にbindされたソケットを用意するアクションを定義します.</p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink><span class=\"synPreProc\">import</span> Network.Socket\n\nserveSocket <span class=\"synStatement\">::</span> PortNumber <span class=\"synStatement\">-&gt;</span> Socket\nserveSocket port <span class=\"synStatement\">=</span> <span class=\"synStatement\">do</span>\n    soc <span class=\"synStatement\">&lt;-</span> socket AF_INET Stream defaultProtocol\n    addr <span class=\"synStatement\">&lt;-</span> inet_addr <span class=\"synConstant\">&quot;0.0.0.0&quot;</span>\n    bind soc (SockAddrInet port addr)\n    return soc\n</pre>\n\n<p>これで引数に渡したポート番号にbindされたソケットが作成されます.</p>\n\n<h2>accept</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>クライアントとの同時通信を実現するためには, <code>Control.Concurrent</code>のちからを借ります.<br/>\n今回は <code>forkIO</code> を使って, 各コネクションごとにスレッドを起動していくことにします. (非同期版も作れるのかな？つくれたらつくります)</p>\n\n<p>というわけで次は <code>accept</code>して<code>forkIO</code>するという処理を繰り返し行うアクションを定義します.<br/>\n<code>forkIO</code> した後に実行するアクション(<code>echoLoop</code>)についてはとりあえず<code>undefined</code>とします. <br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>の<code>undefined</code>, とても便利ですね. 型で考えるっていうスタイルが実行しやすくなっているのは, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>上にトッ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%EC%A5%D9\">プレベ</a>ル関数の型指定を書きやすい<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>の文法と<code>undefined</code>のおかげって感じがします.</p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink>echoLoop <span class=\"synStatement\">::</span> Socket <span class=\"synStatement\">-&gt;</span> IO ()\nechoLoop <span class=\"synStatement\">=</span> undefined\n\n<span class=\"synComment\">-- import Control.Concurrent</span>\n<span class=\"synComment\">-- import Control.Monad</span>\n<span class=\"synComment\">-- が必要</span>\nacceptLoop <span class=\"synStatement\">::</span> Socket <span class=\"synStatement\">-&gt;</span> IO ()\nacceptLoop soc <span class=\"synStatement\">=</span> forever <span class=\"synStatement\">$</span> <span class=\"synStatement\">do</span>\n    (conn, _addr) <span class=\"synStatement\">&lt;-</span> accept soc\n    forkIO <span class=\"synStatement\">$</span> echoLoop conn\n</pre>\n\n<p><code>forever :: Monad m =&gt; m a -&gt; m b</code>は引数にIOアクションを受け取り, それを無限に繰り返し実行し続けます. (無限にくりかえすので返り値の型変数<code>b</code>は不定)<br/>\n<code>forever</code>の引数には, <code>accept</code>して<code>forkIO</code>するアクションを渡しています.</p>\n\n<h1>echo</h1>\n\n<p>最後にソケットから読み込み, そのまま書き出す<code>echoLoop</code>部分を作ります.</p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink><span class=\"synComment\">-- import Control.Exception が必要</span>\nechoLoop <span class=\"synStatement\">::</span> Socket <span class=\"synStatement\">-&gt;</span> IO ()\nechoLoop conn <span class=\"synStatement\">=</span> <span class=\"synStatement\">do</span>\n    sequence_ <span class=\"synStatement\">$</span> repeat <span class=\"synStatement\">$</span> <span class=\"synStatement\">do</span>\n        (str, _, _) <span class=\"synStatement\">&lt;-</span> recvFrom soc <span class=\"synConstant\">64</span>\n        send soc str\n</pre>\n\n<p><code>recvFrom :: Socket -&gt; Int -&gt; IO (String, Int, SockAddr)</code>は, <code>recvFrom conn n</code> で, <code>conn</code>から最大で<code>n</code>文字まで読み込みます.\n返り値は, <code>(読み込んだ文字列, 読み込んだ文字数, 読み込み元のアドレス??)</code> を返します.<br/>\nそして, <code>send :: Socket -&gt; String -&gt; IO ()</code> でソケットに読み込んだ文字列をそのまま書き込みます.<br/>\nこのように, 読み込んでそのままｍ書き込むというアクションを <code>repeat</code>でつなげています. <code>repeat :: a -&gt; [a]</code>は無限リストを作る関数です. <code>repeat 0</code>で<code>[0, 0, 0, 0, ...</code>というリストが作成されます. <br/>\nこのままでは <code>[IO ()]</code>型なので, これを<code>sequence_ :: Monad m =&gt; [m a] -&gt; m ()</code>を使って１つのIOアクションにまとめ上げます.<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>が遅延評価だから出来る芸当ですね. 無限に繰り返す感あふれるコードになっている気がします. (<code>forever</code>使ったほうがいいと思います)</p>\n\n<h1>例外処理</h1>\n\n<p><code>recvFrom</code>は相手側がコネクションを切断すると<code>End of file</code>の例外を投げます. <code>forkIO</code>しているので, １つのスレッドが例外で落ちてもサーバ全体は動き続けますが, ソケットのクローズも出来ませんし, 標準エラーになんかでてきてよろしくないので修正します.</p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink><span class=\"synComment\">-- import Control.Exceptionが必要</span>\nechoLoop <span class=\"synStatement\">::</span> Socket <span class=\"synStatement\">-&gt;</span> IO ()\nechoLoop conn <span class=\"synStatement\">=</span> <span class=\"synStatement\">do</span>\n   sequence_ <span class=\"synStatement\">$</span> repeat <span class=\"synStatement\">$</span> <span class=\"synStatement\">do</span>\n       (str, _, _) <span class=\"synStatement\">&lt;-</span> recvFrom conn <span class=\"synConstant\">64</span>\n       send conn str\n   <span class=\"synStatement\">`catch`</span> (<span class=\"synStatement\">\\</span>(SomeException e) <span class=\"synStatement\">-&gt;</span> return ())\n   <span class=\"synStatement\">`finally`</span> close conn\n</pre>\n\n<p><code>catch</code>と<code>finally</code>を追加しています.<br/>\nどちらも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a>とかのそれと同じように動きます.<br/>\n<code>SomeException</code>はすべての例外を補足することが出来ますが, ほんとはあんまり良くないですね. ここではEOFに達した(コネクションが切断された)という場合だけを補足したいので. (どの関数がどういう場合にどんな例外を投げるのかっていうドキュメントがわからなかったのでこのままにしておきました)<br/>\nそして, 例外が発生してもしなくても, 最後にかならずソケットのクローズをするよう<code>finally</code>を使います.</p>\n\n<p><code>SomeException</code>ですべての例外が捕捉出来るのって不思議じゃないですか？<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>には<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A5%D6%A5%B8%A5%A7%A5%AF%A5%C8%BB%D8%B8%FE\">オブジェクト指向</a>っぽい型の階層関係なんてないのに.\n<a href=\"http://d.hatena.ne.jp/kazu-yamamoto/20081024/1224819961\">Haskellの多相性 - あどけない話</a>このへんが関係しているっぽいなという感じがしますが詳しいことはよくわかりませんでした...</p>\n\n<h1>全体</h1>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink><span class=\"synType\">module</span> Main <span class=\"synType\">where</span>\n\n<span class=\"synPreProc\">import</span> Network.Socket\n<span class=\"synPreProc\">import</span> Control.Monad\n<span class=\"synPreProc\">import</span> Control.Concurrent\n<span class=\"synPreProc\">import</span> Control.Exception\n\nmain <span class=\"synStatement\">::</span> IO ()\nmain <span class=\"synStatement\">=</span> <span class=\"synStatement\">do</span>\n    soc <span class=\"synStatement\">&lt;-</span> serveSocket <span class=\"synConstant\">8080</span>\n    listen soc <span class=\"synConstant\">5</span>\n    acceptLoop soc <span class=\"synStatement\">`finally`</span> close soc\n\nserveSocket <span class=\"synStatement\">::</span> PortNumber <span class=\"synStatement\">-&gt;</span> IO Socket\nserveSocket port <span class=\"synStatement\">=</span> <span class=\"synStatement\">do</span>\n    soc <span class=\"synStatement\">&lt;-</span> socket AF_INET Stream defaultProtocol\n    addr <span class=\"synStatement\">&lt;-</span> inet_addr <span class=\"synConstant\">&quot;0.0.0.0&quot;</span>\n    bind soc (SockAddrInet port addr)\n    return soc\n\nacceptLoop <span class=\"synStatement\">::</span> Socket <span class=\"synStatement\">-&gt;</span> IO ()\nacceptLoop soc <span class=\"synStatement\">=</span> forever <span class=\"synStatement\">$</span> <span class=\"synStatement\">do</span>\n    (conn, addr) <span class=\"synStatement\">&lt;-</span> accept soc\n    forkIO <span class=\"synStatement\">$</span> echoLoop conn\n\nechoLoop <span class=\"synStatement\">::</span> Socket <span class=\"synStatement\">-&gt;</span> IO ()\nechoLoop conn <span class=\"synStatement\">=</span> <span class=\"synStatement\">do</span>\n    sequence_ <span class=\"synStatement\">$</span> repeat <span class=\"synStatement\">$</span> <span class=\"synStatement\">do</span>\n      (str, _, _) <span class=\"synStatement\">&lt;-</span> recvFrom conn <span class=\"synConstant\">64</span>\n      send conn str\n    <span class=\"synStatement\">`catch`</span> (<span class=\"synStatement\">\\</span>(SomeException e) <span class=\"synStatement\">-&gt;</span> return ())\n    <span class=\"synStatement\">`finally`</span> close conn\n</pre>\n\n<p><code>main</code>内で <code>listen</code>するのを忘れずに！また, <code>acceptLoop</code>中に例外が発生してもソケットをクローズするように<code>finally</code>を使っています. (まぁプログラム終了するのでいらない気もします)</p>\n\n<h1>動作確認</h1>\n\n<p><code>telnet</code>コマンドでテストします.</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>% telnet localhost 8080\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is &#39;^]&#39;.\ntest\ntest\naaa\naaa\nhooooogle\nhooooogle</pre>\n\n<p>ちょっとわかりづらいですが, 入力した文字列が即座にそのまま帰ってきていることがわかります. バッファリングの関係で, 一行ずつになっていますが.</p>\n\n<h1>まとめ</h1>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>でechoサーバ, 意外とすんなりかけましたね. 例外関係があまりよく理解できていない感じがしますが...<br/>\n非同期版が気になります. 調べてみます.</p>\n\n---\n\n---\n","slug":"Haskellでechoサーバ","title":"Haskellでechoサーバ","timestamp":1437655424000,"tags":[]},{"rawMarkdown":"---\ntitle: \"HaskellのConcurrentについて調べてまとめる (MVar編)\"\ndate: 2015-07-22T01:21:48.000Z\ntags: []\n---\n\n<p>どうもこんにちは.</p>\n\n<p>前回(<a href=\"http://agtn.hatenablog.com/entry/2015/07/21/234658\">HaskellのConcurrentについて調べてまとめる (IORef編) - プログラミングのメモ帳➚</a>)の続きです.</p>\n\n<p>今回はスレッド間協調のために<code>MVar</code>を使う方法について調べたので, まとめたいと思います.</p>\n\n<h2>MVar</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>にかかわらず, 最近の並行処理はメッセージパッシングでやれみたいなのが流行ってますね (<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scala\">Scala</a>のAkkaや<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a>のchanなど).<br/>\n<code>MVar</code>は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>における, 容量1のメッセージボックスのようなものです. <code>MVar</code>を使うことで, スレッド間でメッセージのやり取りを協調的に行うことができます.<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>のスレッドが１つの<code>MVar</code>に対して, メッセージを入れたり取り出したりすることでスレッド間協調を行います.</p>\n\n<p>基本となる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>はこのような感じ</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>newEmptyMVar :: IO (MVar a)\nnewMVar :: a -&gt; IO (MVar a)\ntakeMVar :: MVar a -&gt; IO a\nputMVar :: MVar a -&gt; a -&gt; IO ()\nreadMVar :: MVar a -&gt; IO a</pre>\n\n<p>型を見ればなんとなく使い方もわかる気がしますね.<br/>\n<code>MVar</code>を作るには<code>newEmptyMVar</code>か<code>newMVar</code>を使用します. <code>newEmptyMVar</code>は空のメッセージボックスを作り, <code>newMVar</code>は第一引数を初期値としてもつメッセージボックスを作ります.</p>\n\n<p><code>MVar</code>にメッセージを格納するには, <code>putMVar</code>を使います. <code>putMVar mvar msg</code> で, <code>msg</code>を<code>mvar</code>に格納します.<br/>\nこの際, もし<code>MVar</code>にすでにメッセージが格納されている場合, <code>MVar</code>は容量1のボックスなので, <code>putMVar</code>がブロックされます. 他のスレッドが<code>MVar</code>からメッセージを取り出して空にするまで待ってから, メッセージを格納します.</p>\n\n<p>一方, <code>MVar</code>からメッセージを読み取るには, <code>takeMVar</code>か<code>readMVar</code>を使用します.<br/>\n<code>takeMVar</code>はメッセージを読み取り, その<code>MVar</code>を空にします. <code>readMVar</code>はメッセージを読み取りますが, <code>MVar</code>の中のメッセージはそのまま残します.<br/>\nここで, <code>put</code>の時と同様に, <code>takeMVar</code>も<code>readMVar</code>も<code>MVar</code>にメッセージが格納されていなかった場合, 他のスレッドが<code>MVar</code>にメッセージを格納するまでブロックします.</p>\n\n<p>というわけで簡単なサンプルコード</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>module Main where\n\nimport Control.Concurrent (forkIO, threadDelay)\nimport Control.Concurrent.MVar\n\nmain :: IO ()\nmain = do\n    mvar &lt;- newEmptyMVar\n    forkIO $ do\n        msg &lt;- takeMVar mvar\n        putStrLn $ &#34;recv: &#34; ++ msg\n        threadDelay $ 1 * 10 ^ 6\n        putMVar mvar &#34;B&#34;\n    putStrLn &#34;sleep 1&#34;\n    threadDelay $ 1 * 10 ^ 6\n    putStrLn &#34;wake up&#34;\n    putMVar mvar &#34;A&#34;\n    takeMVar mvar &gt;&gt;= print</pre>\n\n<p>実行結果</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>sleep 1\nwake up\nrecv: A\n&#34;B&#34;</pre>\n\n<p>確かにメッセージが格納されるまで <code>takeMVar</code>がブロックしていることがわかります</p>\n\n<h2>共有変数としてのMVar</h2>\n\n<p>さて, <code>MVar</code>にはもうひとつの使い方があります. 共有変数としての<code>MVar</code>です.</p>\n\n<p><code>MVar</code>の特徴として, 誰かが<code>take</code>してから<code>put</code>するまでの間は, 他のスレッドはだれも<code>MVar</code>の中身に触れないという点が挙げられます.</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>main = do\n    mvar &lt;- newMVar 0\n    forkIO $ do\n        val &lt;- takeMVar mvar\n        -- 他のスレッドはMVarの中身に触れない\n        putMVar mvar $ val + 1\n    ...</pre>\n\n<p>この特徴はまさにロックの特徴といえます. ロックを取得し解放するまでは, 他のスレッドは同じロックで保護された区間にははいれません.<br/>\nというわけで<code>MVar</code>は型レベルでロックがついた共有変数とみなすことができますね！(このへんはRustのMutexに似た空気を感じます. どちらも型レベルでロックとそれが保護する中身がつながっています)<br/>\n型レベルでロックがくっついているので, 中身にアクセスするには必ずロックをとる(<code>takeMVar</code>)必要があり, ロックの取得忘れがありません.</p>\n\n<p>さらに, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>は基本的に破壊的操作があまり登場しない言語であることもこの<code>MVar</code>ロックにプラスに働きます.</p>\n\n<p>例えば, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CF%A2%C1%DB%C7%DB%CE%F3\">連想配列</a>をスレッド間で共有することを考えます. また, ここでは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CF%A2%C1%DB%C7%DB%CE%F3\">連想配列</a>の実装として, hashtableではなく<code>Data.Map</code>を使用するとします(<code>Data.Map</code>はimmutableな構造になっていて, lookupはO(log n)ですが, immutableなので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>上で扱いやすいというメリットがあります).</p>\n\n<p><code>Data.Map</code>はimmutableなので, 一度<code>MVar</code>から取得してしまえばそれ以降変更される可能性もないため, ロックを保持し続ける必要がありません. そこで, 単なる読み込みの場合は, <code>takeMVar</code>してすぐに<code>putMVar</code>で戻すだとか, <code>readMVar</code>で読み込むだけにすることで, ロックの粒度を小さくできます.<br/>\n<code>MVar</code>の中身を書き換えたい場合は, 単純にロックを取得し, 書き換え後の値を<code>putMVar</code>します.</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>module Main where\n\nimport Control.Concurrent (forkIO, threadDelay)\nimport Control.Concurrent.MVar\nimport qualified Data.Map.Strict as M\n\nmain :: IO ()\nmain = do\n    mvar &lt;- newMVar M.empty\n    forkIO $ do\n        table &lt;- takeMVar mvar\n        putMVar mvar table\n        -- tableを使用する操作\n    forkIO $ do\n         table &lt;- readMVar mvar\n         -- tableを使用する操作\n    forkIO $ do\n        table &lt;- takeMVar mvar\n        -- tableを変更する操作\n        let newTable = ...\n        putMVar mvar newTable</pre>\n\n<p>このように<code>MVar</code>とimmutableなデータ構造を組み合わせることで, 粒度の小さいロックを実現することができます.<br/>\n一方, <code>MVar</code>とmutableなデータ構造(<code>IORef</code>など)を組み合わせる場合は, たとえ読み込みしかしない場合であっても操作が終わるまではロックを保持しておく必要があることに注意しなければなりません (<code>IORef</code>には前回紹介したように<code>atomicModifyIORef</code>があるのでなかなかこういう状況は起こりませんね)</p>\n\n<p>また, RustのMutexと違い, <code>MVar</code>によるロックの模倣(?)はロックの解放を自動的には行いません. したがって例外が送出された場合にロックを開放し忘れるケースがあるので, 注意が必要です.</p>\n\n<h2>一旦まとめ</h2>\n\n<p>というわけで今回は<code>MVar</code>について紹介しました. <code>MVar</code>でロックを実現する方に関しては, 散々言われているロックの問題点をそのまま持ってきてしまうのであまり使えないかもしれませんね...<br/>\n<code>MVar</code>は容量1のメッセージボックスでしたが, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>には<code>Chan</code>というものもあります. こちらは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a>のchanにかなり近いもので, 容量の制限がないキューのように働かせることができます. <code>Chan</code>のよみとり専用のスレッドを１つ立てておき, 他の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>のスレッドがタスクを<code>Chan</code>に書き込んでいくといった<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\">ユースケース</a>が考えられますね. こっちのほうが便利そうな気がしてきました.</p>\n\n<p>ロックはいろいろ厄介で, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%C3%A5%C9%A5%ED%A5%C3%A5%AF\">デッドロック</a>とか解放忘れとかの問題がついて回ります. それを解決する１つの方法として<code>STM</code>があるようなので, 次はそれについて調べてみようと思います.</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>どうもこんにちは.</p>\n\n<p>前回(<a href=\"http://agtn.hatenablog.com/entry/2015/07/21/234658\">HaskellのConcurrentについて調べてまとめる (IORef編) - プログラミングのメモ帳➚</a>)の続きです.</p>\n\n<p>今回はスレッド間協調のために<code>MVar</code>を使う方法について調べたので, まとめたいと思います.</p>\n\n<h2>MVar</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>にかかわらず, 最近の並行処理はメッセージパッシングでやれみたいなのが流行ってますね (<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scala\">Scala</a>のAkkaや<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a>のchanなど).<br/>\n<code>MVar</code>は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>における, 容量1のメッセージボックスのようなものです. <code>MVar</code>を使うことで, スレッド間でメッセージのやり取りを協調的に行うことができます.<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>のスレッドが１つの<code>MVar</code>に対して, メッセージを入れたり取り出したりすることでスレッド間協調を行います.</p>\n\n<p>基本となる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>はこのような感じ</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>newEmptyMVar :: IO (MVar a)\nnewMVar :: a -&gt; IO (MVar a)\ntakeMVar :: MVar a -&gt; IO a\nputMVar :: MVar a -&gt; a -&gt; IO ()\nreadMVar :: MVar a -&gt; IO a</pre>\n\n<p>型を見ればなんとなく使い方もわかる気がしますね.<br/>\n<code>MVar</code>を作るには<code>newEmptyMVar</code>か<code>newMVar</code>を使用します. <code>newEmptyMVar</code>は空のメッセージボックスを作り, <code>newMVar</code>は第一引数を初期値としてもつメッセージボックスを作ります.</p>\n\n<p><code>MVar</code>にメッセージを格納するには, <code>putMVar</code>を使います. <code>putMVar mvar msg</code> で, <code>msg</code>を<code>mvar</code>に格納します.<br/>\nこの際, もし<code>MVar</code>にすでにメッセージが格納されている場合, <code>MVar</code>は容量1のボックスなので, <code>putMVar</code>がブロックされます. 他のスレッドが<code>MVar</code>からメッセージを取り出して空にするまで待ってから, メッセージを格納します.</p>\n\n<p>一方, <code>MVar</code>からメッセージを読み取るには, <code>takeMVar</code>か<code>readMVar</code>を使用します.<br/>\n<code>takeMVar</code>はメッセージを読み取り, その<code>MVar</code>を空にします. <code>readMVar</code>はメッセージを読み取りますが, <code>MVar</code>の中のメッセージはそのまま残します.<br/>\nここで, <code>put</code>の時と同様に, <code>takeMVar</code>も<code>readMVar</code>も<code>MVar</code>にメッセージが格納されていなかった場合, 他のスレッドが<code>MVar</code>にメッセージを格納するまでブロックします.</p>\n\n<p>というわけで簡単なサンプルコード</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>module Main where\n\nimport Control.Concurrent (forkIO, threadDelay)\nimport Control.Concurrent.MVar\n\nmain :: IO ()\nmain = do\n    mvar &lt;- newEmptyMVar\n    forkIO $ do\n        msg &lt;- takeMVar mvar\n        putStrLn $ &#34;recv: &#34; ++ msg\n        threadDelay $ 1 * 10 ^ 6\n        putMVar mvar &#34;B&#34;\n    putStrLn &#34;sleep 1&#34;\n    threadDelay $ 1 * 10 ^ 6\n    putStrLn &#34;wake up&#34;\n    putMVar mvar &#34;A&#34;\n    takeMVar mvar &gt;&gt;= print</pre>\n\n<p>実行結果</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>sleep 1\nwake up\nrecv: A\n&#34;B&#34;</pre>\n\n<p>確かにメッセージが格納されるまで <code>takeMVar</code>がブロックしていることがわかります</p>\n\n<h2>共有変数としてのMVar</h2>\n\n<p>さて, <code>MVar</code>にはもうひとつの使い方があります. 共有変数としての<code>MVar</code>です.</p>\n\n<p><code>MVar</code>の特徴として, 誰かが<code>take</code>してから<code>put</code>するまでの間は, 他のスレッドはだれも<code>MVar</code>の中身に触れないという点が挙げられます.</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>main = do\n    mvar &lt;- newMVar 0\n    forkIO $ do\n        val &lt;- takeMVar mvar\n        -- 他のスレッドはMVarの中身に触れない\n        putMVar mvar $ val + 1\n    ...</pre>\n\n<p>この特徴はまさにロックの特徴といえます. ロックを取得し解放するまでは, 他のスレッドは同じロックで保護された区間にははいれません.<br/>\nというわけで<code>MVar</code>は型レベルでロックがついた共有変数とみなすことができますね！(このへんはRustのMutexに似た空気を感じます. どちらも型レベルでロックとそれが保護する中身がつながっています)<br/>\n型レベルでロックがくっついているので, 中身にアクセスするには必ずロックをとる(<code>takeMVar</code>)必要があり, ロックの取得忘れがありません.</p>\n\n<p>さらに, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>は基本的に破壊的操作があまり登場しない言語であることもこの<code>MVar</code>ロックにプラスに働きます.</p>\n\n<p>例えば, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CF%A2%C1%DB%C7%DB%CE%F3\">連想配列</a>をスレッド間で共有することを考えます. また, ここでは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CF%A2%C1%DB%C7%DB%CE%F3\">連想配列</a>の実装として, hashtableではなく<code>Data.Map</code>を使用するとします(<code>Data.Map</code>はimmutableな構造になっていて, lookupはO(log n)ですが, immutableなので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>上で扱いやすいというメリットがあります).</p>\n\n<p><code>Data.Map</code>はimmutableなので, 一度<code>MVar</code>から取得してしまえばそれ以降変更される可能性もないため, ロックを保持し続ける必要がありません. そこで, 単なる読み込みの場合は, <code>takeMVar</code>してすぐに<code>putMVar</code>で戻すだとか, <code>readMVar</code>で読み込むだけにすることで, ロックの粒度を小さくできます.<br/>\n<code>MVar</code>の中身を書き換えたい場合は, 単純にロックを取得し, 書き換え後の値を<code>putMVar</code>します.</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>module Main where\n\nimport Control.Concurrent (forkIO, threadDelay)\nimport Control.Concurrent.MVar\nimport qualified Data.Map.Strict as M\n\nmain :: IO ()\nmain = do\n    mvar &lt;- newMVar M.empty\n    forkIO $ do\n        table &lt;- takeMVar mvar\n        putMVar mvar table\n        -- tableを使用する操作\n    forkIO $ do\n         table &lt;- readMVar mvar\n         -- tableを使用する操作\n    forkIO $ do\n        table &lt;- takeMVar mvar\n        -- tableを変更する操作\n        let newTable = ...\n        putMVar mvar newTable</pre>\n\n<p>このように<code>MVar</code>とimmutableなデータ構造を組み合わせることで, 粒度の小さいロックを実現することができます.<br/>\n一方, <code>MVar</code>とmutableなデータ構造(<code>IORef</code>など)を組み合わせる場合は, たとえ読み込みしかしない場合であっても操作が終わるまではロックを保持しておく必要があることに注意しなければなりません (<code>IORef</code>には前回紹介したように<code>atomicModifyIORef</code>があるのでなかなかこういう状況は起こりませんね)</p>\n\n<p>また, RustのMutexと違い, <code>MVar</code>によるロックの模倣(?)はロックの解放を自動的には行いません. したがって例外が送出された場合にロックを開放し忘れるケースがあるので, 注意が必要です.</p>\n\n<h2>一旦まとめ</h2>\n\n<p>というわけで今回は<code>MVar</code>について紹介しました. <code>MVar</code>でロックを実現する方に関しては, 散々言われているロックの問題点をそのまま持ってきてしまうのであまり使えないかもしれませんね...<br/>\n<code>MVar</code>は容量1のメッセージボックスでしたが, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>には<code>Chan</code>というものもあります. こちらは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/golang\">golang</a>のchanにかなり近いもので, 容量の制限がないキューのように働かせることができます. <code>Chan</code>のよみとり専用のスレッドを１つ立てておき, 他の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>のスレッドがタスクを<code>Chan</code>に書き込んでいくといった<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\">ユースケース</a>が考えられますね. こっちのほうが便利そうな気がしてきました.</p>\n\n<p>ロックはいろいろ厄介で, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%C3%A5%C9%A5%ED%A5%C3%A5%AF\">デッドロック</a>とか解放忘れとかの問題がついて回ります. それを解決する１つの方法として<code>STM</code>があるようなので, 次はそれについて調べてみようと思います.</p>\n\n---\n\n---\n","slug":"HaskellのConcurrentについて調べてまとめる_(MVar編)","title":"HaskellのConcurrentについて調べてまとめる (MVar編)","timestamp":1437528108000,"tags":[]},{"rawMarkdown":"---\ntitle: \"HaskellのConcurrentについて調べてまとめる (IORef編)\"\ndate: 2015-07-21T14:46:58.000Z\ntags: []\n---\n\n<p>こんばんは. <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>(<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GHC\">GHC</a>)で並行処理を必要とするアプリケーションを書いてみようと思ったのですが, 並列処理に関するいろいろについてよくわかっていない部分が多かったので, 調べたついでにまとめておこうと思います.</p>\n\n<p>もし間違い等ありましたらコメントいただけるとありがたいです</p>\n\n<h2>Concurrent v.s. Parallel</h2>\n\n<p>Concurrentは並行, Parallelは並列と訳されます.<br/>\nConcurrentは論理的に同時に実行されることで, 実際に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>のタスクが物理的に同時に実行している必要はありません. 実際どうであれ, 同時に実行しているように見えればOKで, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>のタスクでCPUを細かく交代で使用しながら実行していくといった実行モデルもConcurrentであるといえます.<br/>\nParallelは物理的に同時に実行されることです. 必然的に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>のCPUが必要になります. 物理的に同時に実行されているタスクは, 論理的にも同時に実行しているとみなせるので, ParallelであればConcurrentです.</p>\n\n<p>この記事ではConcurrentについて言及しているつもりです.</p>\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>のスレッド</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>は処理系実装の軽量スレッドを持ちます. OSが提供するネイティブスレッドと違い, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%C6%A5%AD%A5%B9%A5%C8%A5%B9%A5%A4%A5%C3%A5%C1\">コンテキストスイッチ</a>(スレッドの切り替え)のオーバーヘッドが少なく, より気軽に扱えるスレッドのようです. 軽量スレッドといえば <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Erlang\">Erlang</a> や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Golang\">Golang</a> が思い浮かびますね.(<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Erlang\">Erlang</a>は軽量プロセスっていうんでしたっけ)</p>\n\n<p>実際に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>で軽量スレッドを立ち上げてみます.  <br/>\nまずはスレッドを立ち上げない場合です. (threadDelayは指定したマイクロ秒分スレッドをスリープします)</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>module Main where\n\nimport Control.Concurrent (threadDelay)\n\nsleepN :: Int -&gt; IO ()\nsleepN n = do\n    putStrLn $ &#34;sleep &#34; ++ show n\n    threadDelay $ n * 10 ^ 6\n    putStrLn $ &#34;wake up &#34; ++ show n\n\nmain :: IO ()\nmain = do\n    sleepN 3\n    threadDelay $ 2 * 10 ^ 6\n    putStrLn &#34;sleep 2 and wakeup&#34;\n    threadDelay $ 2 * 10 ^ 6\n    putStrLn &#34;end&#34;</pre>\n\n<p>実行結果</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>sleep 3\nwake up 3\nsleep 2 and wakeup\nend</pre>\n\n<p>全体として, 3秒->2秒->2秒とスリープするので7秒ほどの実行時間になります.</p>\n\n<p>つぎにスレッドを立ち上げる場合です<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>でスレッドを立ち上げるには <code>forkIO :: IO () -&gt; IO ThreadId</code> を使用します. <code>IO ()</code>を渡すと, それを新しく立ち上げたスレッド上で実行してくれます.<br/>\n(<code>forkOS :: IO () -&gt; IO ThreadId</code> というものもありますが, こちらは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>の軽量スレッドではなく, ネイティブスレッドを立ち上げます)</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>module Main where\n\nimport Control.Concurrent (forkIO, threadDelay)\n\nsleepN :: Int -&gt; IO ()\nsleepN n = do\n    putStrLn $ &#34;sleep &#34; ++ show n\n    threadDelay $ n * 10 ^ 6\n    putStrLn $ &#34;wake up &#34; ++ show n\n\nmain :: IO ()\nmain = do\n    forkIO $ sleepN 3\n    threadDelay $ 2 * 10 ^ 6\n    putStrLn &#34;sleep 2 and wakeup&#34;\n    threadDelay $ 2 * 10 ^ 6\n    putStrLn &#34;end&#34;</pre>\n\n<p>実行結果</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>sleep 3\nsleep 2 and wakeup\nwake up 3\nend</pre>\n\n<p>１つのスレッドが3秒スリープしている間に, もう一つのスレッドのスリープが始まるので, 全体で4秒ほどの実行時間になります.</p>\n\n<h2>共有変数</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>スレッドによる並行実行を扱うと, どうしても共有変数的なものが欲しくなる場合があります. <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>でスレッド間共有をしたい場合はいくつかの方法があるようです.<br/>\nもっとも直感的(手続きプログラミング出身者にとって)で馴染みやすいのは <code>Data.IORef</code> かと思います. <code>IO</code> の世界の内側でのみ読み書きができる\"変数\"です.</p>\n\n<p>まずは単一スレッドで実際に使ってみます.(以後import などは省略します)</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>add1 :: IORef Int -&gt; IO ()\nadd1 v = do\n    modifyIORef v (+1)\n\nmain :: IO ()\nmain = do\n    ref &lt;- newIORef 0\n    v &lt;- readIORef ref\n    print v\n    add1 ref\n    v&#39; &lt;- readIORef ref\n    print v&#39;</pre>\n\n<p>実行結果</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>0\n1</pre>\n\n<p>このように変数として中身を書き換えることができます.<br/>\nこれは変数なので, ひとつのスレッドで行った書き換えが他のスレッドにも影響を及ぼします.(State<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9\">モナド</a>のように変数を模倣しているだけではこれはできない)</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>add1 :: IORef Int -&gt; IO ()\nadd1 v = modifyIORef v (+1)\n\nspawn :: IORef Int -&gt; IO ()\nspawn ref = do\n    forkIO $ add1 ref\n    return ()\n\nmain :: IO ()\nmain = do\n    ref &lt;- newIORef 0\n    spawn ref\n    spawn ref\n    spawn ref\n    threadDelay 1000000\n    v &lt;- readIORef ref\n    print v</pre>\n\n<h2>データ競合</h2>\n\n<p>一方これを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>スレッドで並列に動かすことを考えます. <code>modifyIORef</code> はアトミックではないので,</p>\n\n<pre><code>v の中身を読む\nv の中身 + 1 を計算する\nv にその結果を入れる\n</code></pre>\n\n<p>というそれぞれの計算の間に別のスレッドでの計算が割り込まれる可能性がある.<br/>\n上の例で, <code>spawn ref &gt;&gt; spawn ref &gt;&gt; spawn ref</code> という部分は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>スレッドから一つの変数を同時に変更しようとしている. そのため, 変更が競合し意図しない動作になる可能性がある.</p>\n\n<p>IORefで競合を防ぐ方法としては <code>atomicModifyIORef :: IORef a -&gt; (a -&gt; (a, b)) -&gt; IO b</code> を使用する方法がある.<br/>\n<code>atomicModifyIORef</code> の第2引数は <code>a -&gt; (a, b)</code> である. これは <code>IORef</code> の中身を引数にとって, <code>(変更後の値, atomicModifyIORefの返り値にしたい値)</code> を返す関数である.</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>inc :: IORef Int -&gt; IO Int\ninc ref = atomicModifyIORef ref (\\n -&gt; (n + 1, n))\n\nmain :: IO ()\nmain = do\n    ref &lt;- newIORef 0\n    res &lt;- inc ref\n    v &lt;- readIORef ref\n    print res\n    print v</pre>\n\n<p><code>inc</code> は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\">C言語</a>の<code>i++;</code>のような動きをする. 加算する前の値を返し, 変数をインクリメントする.<br/>\n<code>atomicModifyIORef</code> は名前の通り atomic な操作であり, 分割不可能になるため他のスレッドと処理が競合することがなくなる.</p>\n\n<h2>一旦まとめ</h2>\n\n<p>長くなってきた &amp; 疲れてきたので一旦きります.<br/>\n今回はスレッド間共有変数のために <code>IORef</code> を使用し, その変更に <code>atomicModifyIORef</code> を使用することでデータ競合を防ぐ方法を紹介した.</p>\n\n<p><code>MVar</code> や <code>STM</code> を使用する方法もあり, そっちのほうが良い場合もあるっぽいのでそっちについてもまとめたいと思います.</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>こんばんは. <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>(<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GHC\">GHC</a>)で並行処理を必要とするアプリケーションを書いてみようと思ったのですが, 並列処理に関するいろいろについてよくわかっていない部分が多かったので, 調べたついでにまとめておこうと思います.</p>\n\n<p>もし間違い等ありましたらコメントいただけるとありがたいです</p>\n\n<h2>Concurrent v.s. Parallel</h2>\n\n<p>Concurrentは並行, Parallelは並列と訳されます.<br/>\nConcurrentは論理的に同時に実行されることで, 実際に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>のタスクが物理的に同時に実行している必要はありません. 実際どうであれ, 同時に実行しているように見えればOKで, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>のタスクでCPUを細かく交代で使用しながら実行していくといった実行モデルもConcurrentであるといえます.<br/>\nParallelは物理的に同時に実行されることです. 必然的に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>のCPUが必要になります. 物理的に同時に実行されているタスクは, 論理的にも同時に実行しているとみなせるので, ParallelであればConcurrentです.</p>\n\n<p>この記事ではConcurrentについて言及しているつもりです.</p>\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>のスレッド</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>は処理系実装の軽量スレッドを持ちます. OSが提供するネイティブスレッドと違い, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%C6%A5%AD%A5%B9%A5%C8%A5%B9%A5%A4%A5%C3%A5%C1\">コンテキストスイッチ</a>(スレッドの切り替え)のオーバーヘッドが少なく, より気軽に扱えるスレッドのようです. 軽量スレッドといえば <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Erlang\">Erlang</a> や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Golang\">Golang</a> が思い浮かびますね.(<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Erlang\">Erlang</a>は軽量プロセスっていうんでしたっけ)</p>\n\n<p>実際に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>で軽量スレッドを立ち上げてみます.  <br/>\nまずはスレッドを立ち上げない場合です. (threadDelayは指定したマイクロ秒分スレッドをスリープします)</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>module Main where\n\nimport Control.Concurrent (threadDelay)\n\nsleepN :: Int -&gt; IO ()\nsleepN n = do\n    putStrLn $ &#34;sleep &#34; ++ show n\n    threadDelay $ n * 10 ^ 6\n    putStrLn $ &#34;wake up &#34; ++ show n\n\nmain :: IO ()\nmain = do\n    sleepN 3\n    threadDelay $ 2 * 10 ^ 6\n    putStrLn &#34;sleep 2 and wakeup&#34;\n    threadDelay $ 2 * 10 ^ 6\n    putStrLn &#34;end&#34;</pre>\n\n<p>実行結果</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>sleep 3\nwake up 3\nsleep 2 and wakeup\nend</pre>\n\n<p>全体として, 3秒->2秒->2秒とスリープするので7秒ほどの実行時間になります.</p>\n\n<p>つぎにスレッドを立ち上げる場合です<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>でスレッドを立ち上げるには <code>forkIO :: IO () -&gt; IO ThreadId</code> を使用します. <code>IO ()</code>を渡すと, それを新しく立ち上げたスレッド上で実行してくれます.<br/>\n(<code>forkOS :: IO () -&gt; IO ThreadId</code> というものもありますが, こちらは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>の軽量スレッドではなく, ネイティブスレッドを立ち上げます)</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>module Main where\n\nimport Control.Concurrent (forkIO, threadDelay)\n\nsleepN :: Int -&gt; IO ()\nsleepN n = do\n    putStrLn $ &#34;sleep &#34; ++ show n\n    threadDelay $ n * 10 ^ 6\n    putStrLn $ &#34;wake up &#34; ++ show n\n\nmain :: IO ()\nmain = do\n    forkIO $ sleepN 3\n    threadDelay $ 2 * 10 ^ 6\n    putStrLn &#34;sleep 2 and wakeup&#34;\n    threadDelay $ 2 * 10 ^ 6\n    putStrLn &#34;end&#34;</pre>\n\n<p>実行結果</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>sleep 3\nsleep 2 and wakeup\nwake up 3\nend</pre>\n\n<p>１つのスレッドが3秒スリープしている間に, もう一つのスレッドのスリープが始まるので, 全体で4秒ほどの実行時間になります.</p>\n\n<h2>共有変数</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>スレッドによる並行実行を扱うと, どうしても共有変数的なものが欲しくなる場合があります. <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>でスレッド間共有をしたい場合はいくつかの方法があるようです.<br/>\nもっとも直感的(手続きプログラミング出身者にとって)で馴染みやすいのは <code>Data.IORef</code> かと思います. <code>IO</code> の世界の内側でのみ読み書きができる\"変数\"です.</p>\n\n<p>まずは単一スレッドで実際に使ってみます.(以後import などは省略します)</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>add1 :: IORef Int -&gt; IO ()\nadd1 v = do\n    modifyIORef v (+1)\n\nmain :: IO ()\nmain = do\n    ref &lt;- newIORef 0\n    v &lt;- readIORef ref\n    print v\n    add1 ref\n    v&#39; &lt;- readIORef ref\n    print v&#39;</pre>\n\n<p>実行結果</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>0\n1</pre>\n\n<p>このように変数として中身を書き換えることができます.<br/>\nこれは変数なので, ひとつのスレッドで行った書き換えが他のスレッドにも影響を及ぼします.(State<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9\">モナド</a>のように変数を模倣しているだけではこれはできない)</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>add1 :: IORef Int -&gt; IO ()\nadd1 v = modifyIORef v (+1)\n\nspawn :: IORef Int -&gt; IO ()\nspawn ref = do\n    forkIO $ add1 ref\n    return ()\n\nmain :: IO ()\nmain = do\n    ref &lt;- newIORef 0\n    spawn ref\n    spawn ref\n    spawn ref\n    threadDelay 1000000\n    v &lt;- readIORef ref\n    print v</pre>\n\n<h2>データ競合</h2>\n\n<p>一方これを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>スレッドで並列に動かすことを考えます. <code>modifyIORef</code> はアトミックではないので,</p>\n\n<pre><code>v の中身を読む\nv の中身 + 1 を計算する\nv にその結果を入れる\n</code></pre>\n\n<p>というそれぞれの計算の間に別のスレッドでの計算が割り込まれる可能性がある.<br/>\n上の例で, <code>spawn ref &gt;&gt; spawn ref &gt;&gt; spawn ref</code> という部分は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4\">複数</a>スレッドから一つの変数を同時に変更しようとしている. そのため, 変更が競合し意図しない動作になる可能性がある.</p>\n\n<p>IORefで競合を防ぐ方法としては <code>atomicModifyIORef :: IORef a -&gt; (a -&gt; (a, b)) -&gt; IO b</code> を使用する方法がある.<br/>\n<code>atomicModifyIORef</code> の第2引数は <code>a -&gt; (a, b)</code> である. これは <code>IORef</code> の中身を引数にとって, <code>(変更後の値, atomicModifyIORefの返り値にしたい値)</code> を返す関数である.</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>inc :: IORef Int -&gt; IO Int\ninc ref = atomicModifyIORef ref (\\n -&gt; (n + 1, n))\n\nmain :: IO ()\nmain = do\n    ref &lt;- newIORef 0\n    res &lt;- inc ref\n    v &lt;- readIORef ref\n    print res\n    print v</pre>\n\n<p><code>inc</code> は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\">C言語</a>の<code>i++;</code>のような動きをする. 加算する前の値を返し, 変数をインクリメントする.<br/>\n<code>atomicModifyIORef</code> は名前の通り atomic な操作であり, 分割不可能になるため他のスレッドと処理が競合することがなくなる.</p>\n\n<h2>一旦まとめ</h2>\n\n<p>長くなってきた &amp; 疲れてきたので一旦きります.<br/>\n今回はスレッド間共有変数のために <code>IORef</code> を使用し, その変更に <code>atomicModifyIORef</code> を使用することでデータ競合を防ぐ方法を紹介した.</p>\n\n<p><code>MVar</code> や <code>STM</code> を使用する方法もあり, そっちのほうが良い場合もあるっぽいのでそっちについてもまとめたいと思います.</p>\n\n---\n\n---\n","slug":"HaskellのConcurrentについて調べてまとめる_(IORef編)","title":"HaskellのConcurrentについて調べてまとめる (IORef編)","timestamp":1437490018000,"tags":[]},{"rawMarkdown":"---\ntitle: \"yukicoder 2015/05/08\"\ndate: 2015-05-08T15:02:19.000Z\ntags: []\n---\n\n<p>yukicoderさんのコンテストに出てきましたー</p>\n\n<p>★から★★★までの四問ということでもしかしたら完答いけるんじゃないかとか甘いことを考えていたのですが...ｗｗ</p>\n\n<h1>結果</h1>\n\n<p>3完で19位でしたー4問目はTLEの連発で...解法全く思いつけませんでしたねー<br/>\nただ前よりはちょっとは力ついてきたのかななんて思ってますｗｗ（甘いかな</p>\n\n<h1>復習</h1>\n\n<h2><a href=\"http://yukicoder.me/problems/526\">No.203 ゴールデン・ウィーク(1) - yukicoder</a></h2>\n\n<p>与えられた2週間の中で最長の連休を求めよという問題ですね！<br/>\n2週間の情報の与え方が</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>oxoooxx\nxxoxxoo</pre>\n\n<p>のように一週間ごとにわかれているのでそのまま素直に一週間ごとに入力受け付けるとハマる気がしますｗ<br/>\n単純に14要素の配列を用意してそこに入れていけば単なる最長の連続区間を求める問題ですね！！</p>\n\n<h2><a href=\"http://yukicoder.me/problems/490\">No.204 ゴールデン・ウィーク(2) - yukicoder</a></h2>\n\n<p>いやーやられまくりましたねｗｗランキングを見るとわかるのですが、めちゃくちゃ罠問題という感じでしたｗ<br/>\nsubmit回数がすごいことになってましたね全体的に</p>\n\n<p>問題は、先ほどの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B4%A1%BC%A5%EB%A5%C7%A5%F3%A5%A6%A5%A3%A1%BC%A5%AF\">ゴールデンウィーク</a>の問題とほぼ一緒なのですが、今回は有給を使うことが出来ます！！幸せっぽいですね<br/>\nこれだけならまあ簡単なのですが...</p>\n\n<p>引っ掛けポイントはこの二週間以外の部分です！</p>\n\n<blockquote><p>2週間分の平日(x)と休日(o)が分かるカレンダーが与えられます。\nこの2週間の期間以外は、平日とします。</p></blockquote>\n\n<p>この文を読み飛ばしているとWAまみれになります。というかなりました...<br/>\nこれさえ見逃さなければ素直にガリガリ数えていくだけですので、実装としてはそこまで難しくはないと思います。<br/>\nもっときれいな実装や解法があるんでしょうけど、それは追々...</p>\n\n<h2><a href=\"http://yukicoder.me/problems/412\">No.205 マージして辞書順最小 - yukicoder</a></h2>\n\n<p>与えられた文字列群の先頭から一文字ずつ選んで組み上げられる文字列のうち、辞書順最小になるものを求めよという問題。<br/>\nすべての文字列の先頭文字のうち、最小のものを選んでいけばよいっぽいのですが、ひっかかりポイントとして、</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>az\nza</pre>\n\n<p>というような問題があります。<br/>\nこの場合、<code>a</code> が最小なので</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>z\nza</pre>\n\n<p>となります。<br/>\n次の一文字を決定する際に、何も考えずに辞書順最小の文字を考えると</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>(空)\nza</pre>\n\n<p>となります。<br/>\nそして出来上がる文字列は <code>azza</code> となります。<br/>\n正しい答えは <code>azaz</code> ですよね。ここがハマリポイントぽいです。</p>\n\n<p>今回はこのコーナーケースがサンプルにあったので発見しやすかったですね。なかったらはまってたと思います。</p>\n\n<h2><a href=\"http://yukicoder.me/problems/440\">No.206 数の積集合を求めるクエリ - yukicoder</a></h2>\n\n<p>わかんなかったー！くそー...</p>\n\n<p>とりあえずナイーブな実装で <code>multiset</code> でAの各要素 - Bの各要素の集合を作り、 <code>0</code>の数が <code>Q = 0</code>の時の解, <code>1</code> の数が <code>Q = 1</code> の時の解, ... というようにしてみました。  解はあっているっぽかったのですが、案の定 TLE ...<br/>\n此の実装だと <code>O(L * M)</code> かな？ <code>L, M</code> は<code>10 ^ 5</code> までいくのでこれじゃダメダメですねー...</p>\n\n<p>で、解答見たのですが、解答読んでもよくわからない...ちょっと考えてみます...</p>\n\n<h1>まとめ</h1>\n\n<p>前よりはまし！すこしだけ！</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>yukicoderさんのコンテストに出てきましたー</p>\n\n<p>★から★★★までの四問ということでもしかしたら完答いけるんじゃないかとか甘いことを考えていたのですが...ｗｗ</p>\n\n<h1>結果</h1>\n\n<p>3完で19位でしたー4問目はTLEの連発で...解法全く思いつけませんでしたねー<br/>\nただ前よりはちょっとは力ついてきたのかななんて思ってますｗｗ（甘いかな</p>\n\n<h1>復習</h1>\n\n<h2><a href=\"http://yukicoder.me/problems/526\">No.203 ゴールデン・ウィーク(1) - yukicoder</a></h2>\n\n<p>与えられた2週間の中で最長の連休を求めよという問題ですね！<br/>\n2週間の情報の与え方が</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>oxoooxx\nxxoxxoo</pre>\n\n<p>のように一週間ごとにわかれているのでそのまま素直に一週間ごとに入力受け付けるとハマる気がしますｗ<br/>\n単純に14要素の配列を用意してそこに入れていけば単なる最長の連続区間を求める問題ですね！！</p>\n\n<h2><a href=\"http://yukicoder.me/problems/490\">No.204 ゴールデン・ウィーク(2) - yukicoder</a></h2>\n\n<p>いやーやられまくりましたねｗｗランキングを見るとわかるのですが、めちゃくちゃ罠問題という感じでしたｗ<br/>\nsubmit回数がすごいことになってましたね全体的に</p>\n\n<p>問題は、先ほどの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B4%A1%BC%A5%EB%A5%C7%A5%F3%A5%A6%A5%A3%A1%BC%A5%AF\">ゴールデンウィーク</a>の問題とほぼ一緒なのですが、今回は有給を使うことが出来ます！！幸せっぽいですね<br/>\nこれだけならまあ簡単なのですが...</p>\n\n<p>引っ掛けポイントはこの二週間以外の部分です！</p>\n\n<blockquote><p>2週間分の平日(x)と休日(o)が分かるカレンダーが与えられます。\nこの2週間の期間以外は、平日とします。</p></blockquote>\n\n<p>この文を読み飛ばしているとWAまみれになります。というかなりました...<br/>\nこれさえ見逃さなければ素直にガリガリ数えていくだけですので、実装としてはそこまで難しくはないと思います。<br/>\nもっときれいな実装や解法があるんでしょうけど、それは追々...</p>\n\n<h2><a href=\"http://yukicoder.me/problems/412\">No.205 マージして辞書順最小 - yukicoder</a></h2>\n\n<p>与えられた文字列群の先頭から一文字ずつ選んで組み上げられる文字列のうち、辞書順最小になるものを求めよという問題。<br/>\nすべての文字列の先頭文字のうち、最小のものを選んでいけばよいっぽいのですが、ひっかかりポイントとして、</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>az\nza</pre>\n\n<p>というような問題があります。<br/>\nこの場合、<code>a</code> が最小なので</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>z\nza</pre>\n\n<p>となります。<br/>\n次の一文字を決定する際に、何も考えずに辞書順最小の文字を考えると</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>(空)\nza</pre>\n\n<p>となります。<br/>\nそして出来上がる文字列は <code>azza</code> となります。<br/>\n正しい答えは <code>azaz</code> ですよね。ここがハマリポイントぽいです。</p>\n\n<p>今回はこのコーナーケースがサンプルにあったので発見しやすかったですね。なかったらはまってたと思います。</p>\n\n<h2><a href=\"http://yukicoder.me/problems/440\">No.206 数の積集合を求めるクエリ - yukicoder</a></h2>\n\n<p>わかんなかったー！くそー...</p>\n\n<p>とりあえずナイーブな実装で <code>multiset</code> でAの各要素 - Bの各要素の集合を作り、 <code>0</code>の数が <code>Q = 0</code>の時の解, <code>1</code> の数が <code>Q = 1</code> の時の解, ... というようにしてみました。  解はあっているっぽかったのですが、案の定 TLE ...<br/>\n此の実装だと <code>O(L * M)</code> かな？ <code>L, M</code> は<code>10 ^ 5</code> までいくのでこれじゃダメダメですねー...</p>\n\n<p>で、解答見たのですが、解答読んでもよくわからない...ちょっと考えてみます...</p>\n\n<h1>まとめ</h1>\n\n<p>前よりはまし！すこしだけ！</p>\n\n---\n\n---\n","slug":"yukicoder_2015_05_08","title":"yukicoder 2015/05/08","timestamp":1431097339000,"tags":[]},{"rawMarkdown":"---\ntitle: \"yukicoder 2015/05/03\"\ndate: 2015-05-04T09:38:47.000Z\ntags: []\n---\n\n<p>今週は土日共に予定があって<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\">AtCoder</a>さんもyukicoderさんも出場したかったのですが出来ず...</p>\n\n<h1><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\">AtCoder</a> - ARC</h1>\n\n<p>今週の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\">AtCoder</a>さんはABCはなかった？ぽくて, ARCに挑むにはまだちょっと力不足かなと思うので, 一旦保留します</p>\n\n<h1>yukicoder</h1>\n\n<p>というわけでyukicoderさんの方の最初の2問についてだけコンテスト後ですが挑戦してみましたー</p>\n\n<h2>　<a href=\"http://yukicoder.me/problems/436\">No.201 yukicoderじゃんけん - yukicoder</a></h2>\n\n<p>ゆるふわなじゃんけんですね。じゃんけんといいつつ、手は全く関係ないただの数値比較ですｗｗ<br/>\nただし、注意しなければならないのが数値の範囲です。<code>10 ^ 1000</code> までという非常に大きな数字を扱う必要があるので、単純に実装すると落ちます。<br/>\n今まであんまりこういった入力数値の範囲について注視していなかったのですが、今回ばっちりひっかかって落ちたので今度からはちゃんと見ないとダメですねｗｗ</p>\n\n<p>あ、あと今回は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>を使用してみましたー競技プログラミングとは別件で最近<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>をよく利用しているので、その流れでDから一旦変えてみましたー</p>\n\n<p>非常に大きな数値を扱う場合、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ruby\">ruby</a>や<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/python\">python</a>であれば自動的に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/BigDecimal\">BigDecimal</a>のようなクラスを使用してくれるので素直に実装すればそのまま通ってしまいますが、今回は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>なので文字列として受け取って桁数を比較する方法で実装しました。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;vector&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;functional&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;algorithm&gt;</span>\n\n<span class=\"synPreProc\">#define REP(i,n) </span><span class=\"synStatement\">for</span><span class=\"synPreProc\">(</span><span class=\"synType\">int</span><span class=\"synPreProc\"> i;i&lt;(n);i++)</span>\n\n<span class=\"synStatement\">using</span> <span class=\"synType\">namespace</span> std;\n\n<span class=\"synType\">int</span> main() {\n    cin.tie(<span class=\"synConstant\">0</span>);\n    ios::sync_with_stdio(<span class=\"synConstant\">false</span>);\n\n    string a, ap, b, bp, g;\n    cin &gt;&gt; a &gt;&gt; ap &gt;&gt; g &gt;&gt; b &gt;&gt; bp &gt;&gt; g;\n    <span class=\"synStatement\">if</span> (ap.length() &gt; bp.length())\n        cout &lt;&lt; a;\n    <span class=\"synStatement\">else</span> <span class=\"synStatement\">if</span> (ap.length() &lt; bp.length())\n        cout &lt;&lt; b;\n    <span class=\"synStatement\">else</span> {\n        <span class=\"synStatement\">if</span> (ap &gt; bp)\n            cout &lt;&lt; a;\n        <span class=\"synStatement\">else</span> <span class=\"synStatement\">if</span> (ap &lt; bp)\n            cout &lt;&lt; b;\n        <span class=\"synStatement\">else</span>\n            cout &lt;&lt; -<span class=\"synConstant\">1</span>;\n    }\n    cout &lt;&lt; endl;\n\n    <span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;\n}\n</pre>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>にもBigInt的なものはあるんですかね？あんまり<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>も詳しくないのでわかりませんが多分あるでしょう。どっちがはやいんだろうなー</p>\n\n<h2><a href=\"http://yukicoder.me/problems/476\">No.202 1円玉投げ - yukicoder</a></h2>\n\n<p>1円玉を1つずつ投げていって重なったら取り除く、を繰り返した時最後に何枚残っているか、という問題ですね。<br/>\n最初にとりあえず書いてみた解答がこちら。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;vector&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;functional&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;algorithm&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;cmath&gt;</span>\n\n<span class=\"synPreProc\">#define REP(i,n) </span><span class=\"synStatement\">for</span><span class=\"synPreProc\">(</span><span class=\"synType\">int</span><span class=\"synPreProc\"> i=</span><span class=\"synConstant\">0</span><span class=\"synPreProc\">;i&lt;(n);i++)</span>\n\n<span class=\"synStatement\">using</span> <span class=\"synType\">namespace</span> std;\n\n<span class=\"synType\">bool</span> is_on(pair&lt;<span class=\"synType\">int</span>,<span class=\"synType\">int</span>&gt; &amp;a, pair&lt;<span class=\"synType\">int</span>, <span class=\"synType\">int</span>&gt; &amp;b)\n{\n    <span class=\"synType\">double</span> dist = (a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second);\n    dist = sqrt(dist);\n    <span class=\"synStatement\">return</span> dist &lt; <span class=\"synConstant\">20</span>;\n}\n\n<span class=\"synType\">int</span> main() {\n    cin.tie(<span class=\"synConstant\">0</span>);\n    ios::sync_with_stdio(<span class=\"synConstant\">false</span>);\n\n    <span class=\"synType\">int</span> N;\n    cin &gt;&gt; N;\n    <span class=\"synType\">int</span> x, y;\n    cin &gt;&gt; x &gt;&gt; y;\n    N--;\n    vector&lt;pair&lt;<span class=\"synType\">int</span>, <span class=\"synType\">int</span>&gt; &gt; coins;\n    coins.emplace_back(x, y);\n\n    REP(i, N) {\n        cin &gt;&gt; x &gt;&gt; y;\n        <span class=\"synType\">auto</span> p = pair&lt;<span class=\"synType\">int</span>,<span class=\"synType\">int</span>&gt;(x, y);\n        <span class=\"synStatement\">if</span> (!any_of(coins.begin(), coins.end(), [&amp;p](pair&lt;<span class=\"synType\">int</span>, <span class=\"synType\">int</span>&gt; &amp;a) <span class=\"synError\">{</span> <span class=\"synStatement\">return</span> is_on(a, p); })) {\n            coins.push_back(move(p));\n        }\n    }\n    cout &lt;&lt; coins.size() &lt;&lt; endl;\n\n    <span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;\n}\n</pre>\n\n<p>投げるたびに、今までのコイン達と重なっているかどうかをチェックし、どれとも重なっていなかった場合は追加する、というナイーブな実装です。これだと答えは合うのですが、TLEになってしまいました。<br/>\nはじめはx軸方向にソートして、x軸方向で20より離れていればチェックの必要がないので、チェックの必要がある部分を二分探索で求めるという方法を考えたのですが、なんかあんまりうまい方法に思えなくて詰まりまくりました。</p>\n\n<p>0 &lt;= x, y &lt;= 20000 というフィールドを 10 × 10 の細かいフィールドに区切ってチェックするという方法がスタンダードみたいですね！なるほど！ <br/>\nというわけで実装してみたのがこちら</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;vector&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;functional&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;algorithm&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;cmath&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;array&gt;</span>\n\n<span class=\"synPreProc\">#define REP(i, n) </span><span class=\"synStatement\">for</span><span class=\"synPreProc\">(</span><span class=\"synType\">int</span><span class=\"synPreProc\"> i=</span><span class=\"synConstant\">0</span><span class=\"synPreProc\">;i&lt;(n);i++)</span>\n\n<span class=\"synStatement\">using</span> <span class=\"synType\">namespace</span> std;\n\n<span class=\"synType\">typedef</span> pair&lt;<span class=\"synType\">int</span>, <span class=\"synType\">int</span>&gt; P;\n\n<span class=\"synType\">const</span> <span class=\"synType\">int</span> MAX_N = <span class=\"synConstant\">100000</span>;\narray&lt;array&lt;vector&lt;P&gt;, <span class=\"synConstant\">2000</span>&gt;, <span class=\"synConstant\">20000</span> / <span class=\"synConstant\">10</span>&gt; fields;\n\n<span class=\"synType\">bool</span> is_on(pair&lt;<span class=\"synType\">int</span>, <span class=\"synType\">int</span>&gt; &amp;a, pair&lt;<span class=\"synType\">int</span>, <span class=\"synType\">int</span>&gt; &amp;b) {\n    <span class=\"synType\">double</span> dist = (a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second);\n    dist = sqrt(dist);\n    <span class=\"synStatement\">return</span> dist &lt; <span class=\"synConstant\">20</span>;\n}\n\n<span class=\"synType\">int</span> main() {\n    cin.tie(<span class=\"synConstant\">0</span>);\n    ios::sync_with_stdio(<span class=\"synConstant\">false</span>);\n\n    <span class=\"synType\">int</span> N;\n    cin &gt;&gt; N;\n    <span class=\"synType\">int</span> x, y;\n    cin &gt;&gt; x &gt;&gt; y;\n    N--;\n    fields[x / <span class=\"synConstant\">20</span>][y / <span class=\"synConstant\">20</span>].emplace_back(x, y);\n\n    <span class=\"synType\">int</span> ans = <span class=\"synConstant\">1</span>;\n\n    REP(k, N) {\n        cin &gt;&gt; x &gt;&gt; y;\n        P current(x, y);\n        <span class=\"synType\">int</span> fx = x / <span class=\"synConstant\">20</span>, fy = y / <span class=\"synConstant\">20</span>;\n        <span class=\"synType\">bool</span> flg = <span class=\"synConstant\">true</span>;\n        <span class=\"synStatement\">for</span> (<span class=\"synType\">int</span> i = -<span class=\"synConstant\">1</span>; i &lt;= <span class=\"synConstant\">1</span> &amp;&amp; flg; ++i) {\n            <span class=\"synStatement\">for</span> (<span class=\"synType\">int</span> j = -<span class=\"synConstant\">1</span>; j &lt;= <span class=\"synConstant\">1</span> &amp;&amp; flg; ++j) {\n                <span class=\"synStatement\">if</span> (fx + i &lt; <span class=\"synConstant\">0</span> || fx + i &gt;= <span class=\"synConstant\">2000</span> || fy + j &lt; <span class=\"synConstant\">0</span> || fy + j &gt;= <span class=\"synConstant\">2000</span>) <span class=\"synStatement\">continue</span>;\n                <span class=\"synStatement\">for</span> (<span class=\"synType\">auto</span> p: fields[fx + i][fy + j]) {\n                    <span class=\"synStatement\">if</span> (is_on(p, current)) {\n                        flg = <span class=\"synConstant\">false</span>;\n                        <span class=\"synStatement\">break</span>;\n                    }\n                }\n            }\n        }\n        <span class=\"synStatement\">if</span> (flg) {\n            fields[fx][fy].push_back(current);\n            ans++;\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n\n    <span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;\n}\n</pre>\n\n<p>10 × 10 のマスに区切って、コインが重なる可能性のある部分(つまり隣接するマス)についてのみチェックをするという実装です。<br/>\n今思ったのですが、10 × 10 のマスに区切ったらその中に存在できるコインの数って多分1子だけですよね？そしたら <code>array&lt; array&lt;P, 2000&gt;, 2000&gt;</code> でもよかったかもですね！(あ、でもそれだとコインが存在しないときの値がよくわからなくなるなーoption型とか欲しくなる)</p>\n\n<h1>まとめ</h1>\n\n<p>やっぱり出場したかったなーあのコンテストの感じがないと集中しきれないというかｗｗ<br/>\nコンテストだと出来ない時にすごく悔しくて次回への勉強のモチベーションがあがるんですよね！だから今後極力出場していこうと思います！</p>\n\n<p>学びとしては、きちんと問題の対象範囲をよく読むことと、検索の範囲を狭めることで解決できる問題の場合はフィールドをマス目状に区切る方法があるということですね！次回に活かします！</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>今週は土日共に予定があって<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\">AtCoder</a>さんもyukicoderさんも出場したかったのですが出来ず...</p>\n\n<h1><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\">AtCoder</a> - ARC</h1>\n\n<p>今週の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\">AtCoder</a>さんはABCはなかった？ぽくて, ARCに挑むにはまだちょっと力不足かなと思うので, 一旦保留します</p>\n\n<h1>yukicoder</h1>\n\n<p>というわけでyukicoderさんの方の最初の2問についてだけコンテスト後ですが挑戦してみましたー</p>\n\n<h2>　<a href=\"http://yukicoder.me/problems/436\">No.201 yukicoderじゃんけん - yukicoder</a></h2>\n\n<p>ゆるふわなじゃんけんですね。じゃんけんといいつつ、手は全く関係ないただの数値比較ですｗｗ<br/>\nただし、注意しなければならないのが数値の範囲です。<code>10 ^ 1000</code> までという非常に大きな数字を扱う必要があるので、単純に実装すると落ちます。<br/>\n今まであんまりこういった入力数値の範囲について注視していなかったのですが、今回ばっちりひっかかって落ちたので今度からはちゃんと見ないとダメですねｗｗ</p>\n\n<p>あ、あと今回は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>を使用してみましたー競技プログラミングとは別件で最近<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>をよく利用しているので、その流れでDから一旦変えてみましたー</p>\n\n<p>非常に大きな数値を扱う場合、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ruby\">ruby</a>や<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/python\">python</a>であれば自動的に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/BigDecimal\">BigDecimal</a>のようなクラスを使用してくれるので素直に実装すればそのまま通ってしまいますが、今回は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>なので文字列として受け取って桁数を比較する方法で実装しました。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;vector&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;functional&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;algorithm&gt;</span>\n\n<span class=\"synPreProc\">#define REP(i,n) </span><span class=\"synStatement\">for</span><span class=\"synPreProc\">(</span><span class=\"synType\">int</span><span class=\"synPreProc\"> i;i&lt;(n);i++)</span>\n\n<span class=\"synStatement\">using</span> <span class=\"synType\">namespace</span> std;\n\n<span class=\"synType\">int</span> main() {\n    cin.tie(<span class=\"synConstant\">0</span>);\n    ios::sync_with_stdio(<span class=\"synConstant\">false</span>);\n\n    string a, ap, b, bp, g;\n    cin &gt;&gt; a &gt;&gt; ap &gt;&gt; g &gt;&gt; b &gt;&gt; bp &gt;&gt; g;\n    <span class=\"synStatement\">if</span> (ap.length() &gt; bp.length())\n        cout &lt;&lt; a;\n    <span class=\"synStatement\">else</span> <span class=\"synStatement\">if</span> (ap.length() &lt; bp.length())\n        cout &lt;&lt; b;\n    <span class=\"synStatement\">else</span> {\n        <span class=\"synStatement\">if</span> (ap &gt; bp)\n            cout &lt;&lt; a;\n        <span class=\"synStatement\">else</span> <span class=\"synStatement\">if</span> (ap &lt; bp)\n            cout &lt;&lt; b;\n        <span class=\"synStatement\">else</span>\n            cout &lt;&lt; -<span class=\"synConstant\">1</span>;\n    }\n    cout &lt;&lt; endl;\n\n    <span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;\n}\n</pre>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>にもBigInt的なものはあるんですかね？あんまり<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>も詳しくないのでわかりませんが多分あるでしょう。どっちがはやいんだろうなー</p>\n\n<h2><a href=\"http://yukicoder.me/problems/476\">No.202 1円玉投げ - yukicoder</a></h2>\n\n<p>1円玉を1つずつ投げていって重なったら取り除く、を繰り返した時最後に何枚残っているか、という問題ですね。<br/>\n最初にとりあえず書いてみた解答がこちら。</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;vector&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;functional&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;algorithm&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;cmath&gt;</span>\n\n<span class=\"synPreProc\">#define REP(i,n) </span><span class=\"synStatement\">for</span><span class=\"synPreProc\">(</span><span class=\"synType\">int</span><span class=\"synPreProc\"> i=</span><span class=\"synConstant\">0</span><span class=\"synPreProc\">;i&lt;(n);i++)</span>\n\n<span class=\"synStatement\">using</span> <span class=\"synType\">namespace</span> std;\n\n<span class=\"synType\">bool</span> is_on(pair&lt;<span class=\"synType\">int</span>,<span class=\"synType\">int</span>&gt; &amp;a, pair&lt;<span class=\"synType\">int</span>, <span class=\"synType\">int</span>&gt; &amp;b)\n{\n    <span class=\"synType\">double</span> dist = (a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second);\n    dist = sqrt(dist);\n    <span class=\"synStatement\">return</span> dist &lt; <span class=\"synConstant\">20</span>;\n}\n\n<span class=\"synType\">int</span> main() {\n    cin.tie(<span class=\"synConstant\">0</span>);\n    ios::sync_with_stdio(<span class=\"synConstant\">false</span>);\n\n    <span class=\"synType\">int</span> N;\n    cin &gt;&gt; N;\n    <span class=\"synType\">int</span> x, y;\n    cin &gt;&gt; x &gt;&gt; y;\n    N--;\n    vector&lt;pair&lt;<span class=\"synType\">int</span>, <span class=\"synType\">int</span>&gt; &gt; coins;\n    coins.emplace_back(x, y);\n\n    REP(i, N) {\n        cin &gt;&gt; x &gt;&gt; y;\n        <span class=\"synType\">auto</span> p = pair&lt;<span class=\"synType\">int</span>,<span class=\"synType\">int</span>&gt;(x, y);\n        <span class=\"synStatement\">if</span> (!any_of(coins.begin(), coins.end(), [&amp;p](pair&lt;<span class=\"synType\">int</span>, <span class=\"synType\">int</span>&gt; &amp;a) <span class=\"synError\">{</span> <span class=\"synStatement\">return</span> is_on(a, p); })) {\n            coins.push_back(move(p));\n        }\n    }\n    cout &lt;&lt; coins.size() &lt;&lt; endl;\n\n    <span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;\n}\n</pre>\n\n<p>投げるたびに、今までのコイン達と重なっているかどうかをチェックし、どれとも重なっていなかった場合は追加する、というナイーブな実装です。これだと答えは合うのですが、TLEになってしまいました。<br/>\nはじめはx軸方向にソートして、x軸方向で20より離れていればチェックの必要がないので、チェックの必要がある部分を二分探索で求めるという方法を考えたのですが、なんかあんまりうまい方法に思えなくて詰まりまくりました。</p>\n\n<p>0 &lt;= x, y &lt;= 20000 というフィールドを 10 × 10 の細かいフィールドに区切ってチェックするという方法がスタンダードみたいですね！なるほど！ <br/>\nというわけで実装してみたのがこちら</p>\n\n<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;iostream&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;string&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;vector&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;functional&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;algorithm&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;cmath&gt;</span>\n<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;array&gt;</span>\n\n<span class=\"synPreProc\">#define REP(i, n) </span><span class=\"synStatement\">for</span><span class=\"synPreProc\">(</span><span class=\"synType\">int</span><span class=\"synPreProc\"> i=</span><span class=\"synConstant\">0</span><span class=\"synPreProc\">;i&lt;(n);i++)</span>\n\n<span class=\"synStatement\">using</span> <span class=\"synType\">namespace</span> std;\n\n<span class=\"synType\">typedef</span> pair&lt;<span class=\"synType\">int</span>, <span class=\"synType\">int</span>&gt; P;\n\n<span class=\"synType\">const</span> <span class=\"synType\">int</span> MAX_N = <span class=\"synConstant\">100000</span>;\narray&lt;array&lt;vector&lt;P&gt;, <span class=\"synConstant\">2000</span>&gt;, <span class=\"synConstant\">20000</span> / <span class=\"synConstant\">10</span>&gt; fields;\n\n<span class=\"synType\">bool</span> is_on(pair&lt;<span class=\"synType\">int</span>, <span class=\"synType\">int</span>&gt; &amp;a, pair&lt;<span class=\"synType\">int</span>, <span class=\"synType\">int</span>&gt; &amp;b) {\n    <span class=\"synType\">double</span> dist = (a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second);\n    dist = sqrt(dist);\n    <span class=\"synStatement\">return</span> dist &lt; <span class=\"synConstant\">20</span>;\n}\n\n<span class=\"synType\">int</span> main() {\n    cin.tie(<span class=\"synConstant\">0</span>);\n    ios::sync_with_stdio(<span class=\"synConstant\">false</span>);\n\n    <span class=\"synType\">int</span> N;\n    cin &gt;&gt; N;\n    <span class=\"synType\">int</span> x, y;\n    cin &gt;&gt; x &gt;&gt; y;\n    N--;\n    fields[x / <span class=\"synConstant\">20</span>][y / <span class=\"synConstant\">20</span>].emplace_back(x, y);\n\n    <span class=\"synType\">int</span> ans = <span class=\"synConstant\">1</span>;\n\n    REP(k, N) {\n        cin &gt;&gt; x &gt;&gt; y;\n        P current(x, y);\n        <span class=\"synType\">int</span> fx = x / <span class=\"synConstant\">20</span>, fy = y / <span class=\"synConstant\">20</span>;\n        <span class=\"synType\">bool</span> flg = <span class=\"synConstant\">true</span>;\n        <span class=\"synStatement\">for</span> (<span class=\"synType\">int</span> i = -<span class=\"synConstant\">1</span>; i &lt;= <span class=\"synConstant\">1</span> &amp;&amp; flg; ++i) {\n            <span class=\"synStatement\">for</span> (<span class=\"synType\">int</span> j = -<span class=\"synConstant\">1</span>; j &lt;= <span class=\"synConstant\">1</span> &amp;&amp; flg; ++j) {\n                <span class=\"synStatement\">if</span> (fx + i &lt; <span class=\"synConstant\">0</span> || fx + i &gt;= <span class=\"synConstant\">2000</span> || fy + j &lt; <span class=\"synConstant\">0</span> || fy + j &gt;= <span class=\"synConstant\">2000</span>) <span class=\"synStatement\">continue</span>;\n                <span class=\"synStatement\">for</span> (<span class=\"synType\">auto</span> p: fields[fx + i][fy + j]) {\n                    <span class=\"synStatement\">if</span> (is_on(p, current)) {\n                        flg = <span class=\"synConstant\">false</span>;\n                        <span class=\"synStatement\">break</span>;\n                    }\n                }\n            }\n        }\n        <span class=\"synStatement\">if</span> (flg) {\n            fields[fx][fy].push_back(current);\n            ans++;\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n\n    <span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;\n}\n</pre>\n\n<p>10 × 10 のマスに区切って、コインが重なる可能性のある部分(つまり隣接するマス)についてのみチェックをするという実装です。<br/>\n今思ったのですが、10 × 10 のマスに区切ったらその中に存在できるコインの数って多分1子だけですよね？そしたら <code>array&lt; array&lt;P, 2000&gt;, 2000&gt;</code> でもよかったかもですね！(あ、でもそれだとコインが存在しないときの値がよくわからなくなるなーoption型とか欲しくなる)</p>\n\n<h1>まとめ</h1>\n\n<p>やっぱり出場したかったなーあのコンテストの感じがないと集中しきれないというかｗｗ<br/>\nコンテストだと出来ない時にすごく悔しくて次回への勉強のモチベーションがあがるんですよね！だから今後極力出場していこうと思います！</p>\n\n<p>学びとしては、きちんと問題の対象範囲をよく読むことと、検索の範囲を狭めることで解決できる問題の場合はフィールドをマス目状に区切る方法があるということですね！次回に活かします！</p>\n\n---\n\n---\n","slug":"yukicoder_2015_05_03","title":"yukicoder 2015/05/03","timestamp":1430732327000,"tags":[]},{"rawMarkdown":"---\ntitle: \"【yukicoder】yukicoder open 2015 small - 3完\"\ndate: 2015-04-26T15:47:58.000Z\ntags: []\n---\n\n<h1>yukicoder open 2015 small に挑戦してきました！</h1>\n\n<p><a href=\"http://yukicoder.me/\">yukicoder</a>さん主催のコンテストに初挑戦してきました！<br/>\n人生二回目のコンテストということで昨日よりは緊張もなく楽しめたかな？<br/>\n言い訳になりますがちょっと同時並行でやらなきゃいけないことがあったので最初の方が変に時間食ってます...</p>\n\n<h1>結果</h1>\n\n<p>3完で<s>44位でしたー</s><br/>\n<strong>追記</strong>\nyukicoderさんのチャレンジなる仕様によって順位が繰り上がりましたｗｗ41位という結果になりましたー<br/>\n<strong>追記ここまで</strong><br/>\n3問目で変にはまってしまったので辛かった...<br/>\nけどまぁ解けなきゃいけない問題は解いたかなーという感じ</p>\n\n<h1>復習</h1>\n\n<h2>191</h2>\n\n<p>これは一旦全部足して1/10の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%EC%A5%C3%A5%B7%A5%E7%A5%EB%A5%C9\">スレッショルド</a>を求めてから、超えていないものの数を数えるだけですねー<br/>\nちゃんとスタートと同時にはじめられて入ればこれはすぐ解けたのになー実際の記録は12分とかかかってますｗｗ</p>\n\n<h2>192</h2>\n\n<p>合成数を求める問題です！正の約数を持っていさえすればいいので偶数にしちゃうのが一番簡単ですかねー<br/>\n僕は奇数だったら1足して出力、偶数だったらそのまま出力としました！<br/>\n想定解はおしゃれでしたねー 整数型 <code>x</code> に対して <code>x / 2 * 2</code> を計算すると切り捨てのお陰で必ず偶数になります！<br/>\n<code>N</code> の制約の関係上、偶数の中で唯一合成数でない2のことを考える必要はありません！</p>\n\n<h2>193</h2>\n\n<p>チャレンジによって <code>eval</code> を使用していたLL勢の多くがWAになっていましたー<br/>\nLeading Zero を <code>eval</code> すると八進数扱いになったりしてしまうようですね！<br/>\n僕はなんか冗長な気もしたけどうまい方法が他に思いつかなかったので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BC%EA%BD%F1%A4%AD\">手書き</a>でパースしてたので助かりましたね<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/D%B8%C0%B8%EC\">D言語</a>を使っていて助かった感がありますｗｗ</p>\n\n<p>入力 <code>S</code> を2つつなげた <code>string l = S ~ S;</code> を定義してウィンドウを横にずらしながらひたすら計算していくという解答にしましたー<br/>\nそしたらなぜか途中からWAになってしまい原因がわからなかったのでウィンドウの作り方を変えてみたり <code>int</code> を <code>long</code> にしてみたりしました<br/>\n結局は考えられる最大値が負になる場合を考慮していなかったのが原因でしたー</p>\n\n<h2>194</h2>\n\n<p>ここから先は全然わかりませんでしたー194に関してはゴリ押しで小さい数字なら求められたのですが、計算量的に全然間に合わないので手が止まってしまいました...<br/>\n<a href=\"http://kmjp.hatenablog.jp/entry/2015/04/27/0900\">yukicoder : No.194 フィボナッチ数列の理解(1) - kmjp's blog</a>で解説してくださっています！</p>\n\n<p>これは思いつくのは無理ｗｗｗ<br/>\nみなさんこれを普通に解いていて驚きますねー...</p>\n\n<h2>195, 196</h2>\n\n<p>この2問は問題文すらろくに見られていないのでまた後日復習したいと思います！</p>\n\n---\n\n---\n","contentMarkdown":"\n<h1>yukicoder open 2015 small に挑戦してきました！</h1>\n\n<p><a href=\"http://yukicoder.me/\">yukicoder</a>さん主催のコンテストに初挑戦してきました！<br/>\n人生二回目のコンテストということで昨日よりは緊張もなく楽しめたかな？<br/>\n言い訳になりますがちょっと同時並行でやらなきゃいけないことがあったので最初の方が変に時間食ってます...</p>\n\n<h1>結果</h1>\n\n<p>3完で<s>44位でしたー</s><br/>\n<strong>追記</strong>\nyukicoderさんのチャレンジなる仕様によって順位が繰り上がりましたｗｗ41位という結果になりましたー<br/>\n<strong>追記ここまで</strong><br/>\n3問目で変にはまってしまったので辛かった...<br/>\nけどまぁ解けなきゃいけない問題は解いたかなーという感じ</p>\n\n<h1>復習</h1>\n\n<h2>191</h2>\n\n<p>これは一旦全部足して1/10の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%EC%A5%C3%A5%B7%A5%E7%A5%EB%A5%C9\">スレッショルド</a>を求めてから、超えていないものの数を数えるだけですねー<br/>\nちゃんとスタートと同時にはじめられて入ればこれはすぐ解けたのになー実際の記録は12分とかかかってますｗｗ</p>\n\n<h2>192</h2>\n\n<p>合成数を求める問題です！正の約数を持っていさえすればいいので偶数にしちゃうのが一番簡単ですかねー<br/>\n僕は奇数だったら1足して出力、偶数だったらそのまま出力としました！<br/>\n想定解はおしゃれでしたねー 整数型 <code>x</code> に対して <code>x / 2 * 2</code> を計算すると切り捨てのお陰で必ず偶数になります！<br/>\n<code>N</code> の制約の関係上、偶数の中で唯一合成数でない2のことを考える必要はありません！</p>\n\n<h2>193</h2>\n\n<p>チャレンジによって <code>eval</code> を使用していたLL勢の多くがWAになっていましたー<br/>\nLeading Zero を <code>eval</code> すると八進数扱いになったりしてしまうようですね！<br/>\n僕はなんか冗長な気もしたけどうまい方法が他に思いつかなかったので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BC%EA%BD%F1%A4%AD\">手書き</a>でパースしてたので助かりましたね<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/D%B8%C0%B8%EC\">D言語</a>を使っていて助かった感がありますｗｗ</p>\n\n<p>入力 <code>S</code> を2つつなげた <code>string l = S ~ S;</code> を定義してウィンドウを横にずらしながらひたすら計算していくという解答にしましたー<br/>\nそしたらなぜか途中からWAになってしまい原因がわからなかったのでウィンドウの作り方を変えてみたり <code>int</code> を <code>long</code> にしてみたりしました<br/>\n結局は考えられる最大値が負になる場合を考慮していなかったのが原因でしたー</p>\n\n<h2>194</h2>\n\n<p>ここから先は全然わかりませんでしたー194に関してはゴリ押しで小さい数字なら求められたのですが、計算量的に全然間に合わないので手が止まってしまいました...<br/>\n<a href=\"http://kmjp.hatenablog.jp/entry/2015/04/27/0900\">yukicoder : No.194 フィボナッチ数列の理解(1) - kmjp's blog</a>で解説してくださっています！</p>\n\n<p>これは思いつくのは無理ｗｗｗ<br/>\nみなさんこれを普通に解いていて驚きますねー...</p>\n\n<h2>195, 196</h2>\n\n<p>この2問は問題文すらろくに見られていないのでまた後日復習したいと思います！</p>\n\n---\n\n---\n","slug":"【yukicoder】yukicoder_open_2015_small_-_3完","title":"【yukicoder】yukicoder open 2015 small - 3完","timestamp":1430063278000,"tags":[]},{"rawMarkdown":"---\ntitle: \"【AtCoder】ABC022 - 競技プログラミング初挑戦！\"\ndate: 2015-04-25T15:05:47.000Z\ntags: []\n---\n\n<h1><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\">AtCoder</a> ABC022に挑戦！</h1>\n\n<p>人生で初めて競技プログラミングのコンテスト(オンライン)に出場してみました！<br/>\n使用言語は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>にしようかと思ったのですが、どっちかというと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/D%B8%C0%B8%EC\">D言語</a>のほうがすきだし、Dlangも十分競技プログラミングに向いているっぽかったので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/D%B8%C0%B8%EC\">D言語</a>で出場しました。</p>\n\n<h1>結果</h1>\n\n<p><strong><em>2完で121位でした</em></strong><br/>\nいやー惨敗でしたねｗｗ<br/>\nA問題がなんか変に時間食っちゃって、焦りました。そしてB問題がするっと出来て、「おっ！」と思ったら案の定C以降にても足も出ませんでした...<br/>\nC問題に関してはそもそも問題文を勘違いしていました（勘違いに気がついても結局できなかったｗｗ）</p>\n\n<h1>復習</h1>\n\n<p>解説放送も聞いてきましたー</p>\n\n<h2>A問題</h2>\n\n<p>普通にたしていった。一回全部入力受けてから計算始めてたけど無駄だったなー受け取りながら計算すればもっと早くなってたはず。<br/>\n今回は簡単な問題だったのでよかったけど、こういうのでTLEになる場合もあるんだろうな</p>\n\n<h2>B問題</h2>\n\n<p>N - (花の種類)というおしゃれ解法もある様子(ただしやることは結局同じで、今まで訪れた花の種類を覚えながら舐める)</p>\n\n<p>ここまでは完答</p>\n\n<h2>C問題</h2>\n\n<p>頂点1に隣接する頂点はちょうど2つなので、その2つをつなぐ最短経路を求めればいい！！<br/>\n発想はなんとなくあってたなー<br/>\n僕が考えていたのは、頂点1から道が伸びてる頂点Xについて、 1 - X間の道を除いたグラフを考えて、X - 1の最短経路を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C0%A5%A4%A5%AF%A5%B9%A5%C8%A5%E9\">ダイクストラ</a>で求めるやり方でした<br/>\n結局実装力不足で死にましたが...<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%28%A1%AD%A1%A6%A6%D8%A1%A6%60%29\">(´・ω・`)</a></p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C0%A5%A4%A5%AF%A5%B9%A5%C8%A5%E9\">ダイクストラ</a>だとO(N<sup>2</sup>) * O(N<sup>2</sup>) = O(N<sup>4</sup>)になっちゃうけど、ワーシャルフロイドを使えばO(N<sup>3</sup>)ですむとのこと。たしかに。<br/>\nワーシャル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%ED%A5%A4%A5%C8\">フロイト</a>は実装らくちんだもんなー<br/>\nなるほどだなー悔しいなこれ。あとちょっとだった。</p>\n\n<h2>D問題</h2>\n\n<p>C問題でつまづきまくってしまい心が折れてたので全然まともに挑んでいないです...<br/>\n解説きいたあとだから言いたい放題なんだけど、これ部分点までならとれた気がするｗｗ<br/>\nいろいろ解法がある様子。とにかく、回転移動や平行移動に惑わされない値に注目してあげれば、相似比は簡単に求まるよねーというお話。<br/>\nぱっと思いついたのは最遠点だったけど、それだとO(NlogN)で部分点らしい。<br/>\n最も初心者向けなのは重心からの最遠点までの距離っぽいです。</p>\n\n<h1>感想などなど</h1>\n\n<p>初めて競技プログラミングのコンテストに出場しましたがめちゃくちゃ楽しいですねこれ！<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\">AtCoder</a>さんの解説放送のおかげでわからなかった問題の理解もできたし、はまりそう.<br/>\nもともとコンテスト外の問題は練習で少しだけ解いたことがあったのですが、全然別物の面白さでしたー<br/>\nとりあえず<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C0%A5%A4%A5%AF%A5%B9%A5%C8%A5%E9\">ダイクストラ</a>とかの基本<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\">アルゴリズム</a>に関してはすらすら実装できるようになりたいなー</p>\n\n<p>明日はyukicoderさんのコンテストがある？のかな？<br/>\n出場してみたいと思います！</p>\n\n<p>では模範解答を写経して寝ます！</p>\n\n---\n\n---\n","contentMarkdown":"\n<h1><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\">AtCoder</a> ABC022に挑戦！</h1>\n\n<p>人生で初めて競技プログラミングのコンテスト(オンライン)に出場してみました！<br/>\n使用言語は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>にしようかと思ったのですが、どっちかというと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/D%B8%C0%B8%EC\">D言語</a>のほうがすきだし、Dlangも十分競技プログラミングに向いているっぽかったので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/D%B8%C0%B8%EC\">D言語</a>で出場しました。</p>\n\n<h1>結果</h1>\n\n<p><strong><em>2完で121位でした</em></strong><br/>\nいやー惨敗でしたねｗｗ<br/>\nA問題がなんか変に時間食っちゃって、焦りました。そしてB問題がするっと出来て、「おっ！」と思ったら案の定C以降にても足も出ませんでした...<br/>\nC問題に関してはそもそも問題文を勘違いしていました（勘違いに気がついても結局できなかったｗｗ）</p>\n\n<h1>復習</h1>\n\n<p>解説放送も聞いてきましたー</p>\n\n<h2>A問題</h2>\n\n<p>普通にたしていった。一回全部入力受けてから計算始めてたけど無駄だったなー受け取りながら計算すればもっと早くなってたはず。<br/>\n今回は簡単な問題だったのでよかったけど、こういうのでTLEになる場合もあるんだろうな</p>\n\n<h2>B問題</h2>\n\n<p>N - (花の種類)というおしゃれ解法もある様子(ただしやることは結局同じで、今まで訪れた花の種類を覚えながら舐める)</p>\n\n<p>ここまでは完答</p>\n\n<h2>C問題</h2>\n\n<p>頂点1に隣接する頂点はちょうど2つなので、その2つをつなぐ最短経路を求めればいい！！<br/>\n発想はなんとなくあってたなー<br/>\n僕が考えていたのは、頂点1から道が伸びてる頂点Xについて、 1 - X間の道を除いたグラフを考えて、X - 1の最短経路を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C0%A5%A4%A5%AF%A5%B9%A5%C8%A5%E9\">ダイクストラ</a>で求めるやり方でした<br/>\n結局実装力不足で死にましたが...<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%28%A1%AD%A1%A6%A6%D8%A1%A6%60%29\">(´・ω・`)</a></p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C0%A5%A4%A5%AF%A5%B9%A5%C8%A5%E9\">ダイクストラ</a>だとO(N<sup>2</sup>) * O(N<sup>2</sup>) = O(N<sup>4</sup>)になっちゃうけど、ワーシャルフロイドを使えばO(N<sup>3</sup>)ですむとのこと。たしかに。<br/>\nワーシャル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%ED%A5%A4%A5%C8\">フロイト</a>は実装らくちんだもんなー<br/>\nなるほどだなー悔しいなこれ。あとちょっとだった。</p>\n\n<h2>D問題</h2>\n\n<p>C問題でつまづきまくってしまい心が折れてたので全然まともに挑んでいないです...<br/>\n解説きいたあとだから言いたい放題なんだけど、これ部分点までならとれた気がするｗｗ<br/>\nいろいろ解法がある様子。とにかく、回転移動や平行移動に惑わされない値に注目してあげれば、相似比は簡単に求まるよねーというお話。<br/>\nぱっと思いついたのは最遠点だったけど、それだとO(NlogN)で部分点らしい。<br/>\n最も初心者向けなのは重心からの最遠点までの距離っぽいです。</p>\n\n<h1>感想などなど</h1>\n\n<p>初めて競技プログラミングのコンテストに出場しましたがめちゃくちゃ楽しいですねこれ！<br/>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AtCoder\">AtCoder</a>さんの解説放送のおかげでわからなかった問題の理解もできたし、はまりそう.<br/>\nもともとコンテスト外の問題は練習で少しだけ解いたことがあったのですが、全然別物の面白さでしたー<br/>\nとりあえず<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C0%A5%A4%A5%AF%A5%B9%A5%C8%A5%E9\">ダイクストラ</a>とかの基本<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0\">アルゴリズム</a>に関してはすらすら実装できるようになりたいなー</p>\n\n<p>明日はyukicoderさんのコンテストがある？のかな？<br/>\n出場してみたいと思います！</p>\n\n<p>では模範解答を写経して寝ます！</p>\n\n---\n\n---\n","slug":"【AtCoder】ABC022_-_競技プログラミング初挑戦！","title":"【AtCoder】ABC022 - 競技プログラミング初挑戦！","timestamp":1429974347000,"tags":[]},{"rawMarkdown":"---\ntitle: \"Rustで自作シェルもどきを作る(単純なコマンド実行編)\"\ndate: 2014-12-21T14:55:51+09:00\ntags: [\"Rust\"]\nurl: https://qiita.com/agatan/items/ed2780628d20a0e343b8\n---\n\nコード全文はこちら\n[agatan/rsh](https://github.com/agatan/rsh)\n\n[Rust で自作シェルもどきを作る(字句解析編) - Qiita](http://qiita.com/agatan/items/8a097ead46df1c1659ff)\n\n前回はユーザからの入力を受け付けてパースするところまで実装したので、今回は実際に入力されたコマンドを実行させてみます。  \nただし、いきなりいろいろやるのはきついので、まずは単純なコマンド(パイプやリダイレクトは一旦無視します)の実行をやってみました。\n\n## Command\n\nRust には`std::io::process::Command`という構造体があります。これを使えば簡単にコマンド実行は出来そうです。\n\n> http://doc.rust-lang.org/std/io/process/struct.Command.htmlより引用\n>\n> ```rust\n> use std::io::Command;\n> ```\n\n> let mut process = match Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").spawn() {\n> Ok(p) => p,\n> Err(e) => panic!(\"failed to execute process: {}\", e),\n> };\n\n> let output = process.stdout.as_mut().unwrap().read_to_end();\n\n````\n\nいろいろと便利そうな関数が定義されているのですが、今回は最も単純にコマンドを実行させるために、`output`という関数を使用してみました。\n\n```rust:exec.rs\nuse std;\nuse std::io::process::Command;\n\nuse parse::Token;\n\npub fn exec(tokens: Vec<Token>) {\n    if tokens.iter()\n             .find(|&t| match t {\n                 &Token::Str(_) => false, _ => true } ).is_some() {\n        panic!(\"Not implemented yet.\");\n    }\n    let first_cmd = tokens.iter()\n                          .take_while(|&t| match t {\n                              &Token::Str(_) => true,\n                              _ => false\n                          })\n                          .map(|ref t| match *t {\n                              &Token::Str(ref x) => x.clone(),\n                              _ => panic!(\"Shouldn't be reached.\"),\n                          })\n                          .collect::<Vec<String>>();\n\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .output() {\n        Ok(p) => p,\n        Err(e) => panic!(\"Failed to execute: {}\", e),\n    };\n\n    print!(\"{}\", String::from_utf8_lossy(output.output.as_slice()));\n\n}\n````\n\n`exec`は`Vec<Token>`を受け取る関数です。\n今回はパイプなどは未実装ですから、`Str(_)`以外の`Token`が含まれていたら`panic!`(例外送出)をしています。\n\nさて、`Command`は`new`で実行したいコマンド名を指定し、それに続けて`arg`や`args`で引数を追加していきます。\nユーザからの入力を利用しているので、ひとつずつしか追加できない`arg`よりは、スライスを渡して複数追加できる`args`を使いたいです。\n\nこれらにあわせて`Vec<Token>`を`Vec<String>`もしくは`Vec<&str>`に変換してあげれば良さそうです。\nということで`let first_cmd = ...`という長い文は、その変換を行っています。\n\n正直まだ`&`と`ref`の関係とか所有権の問題はきちんと理解できていないというか書き方がよくわかっていないので、コンパイラに怒ってもらいながらなんとか直してみました。\nコンパイルを通るように、を第一に書いていったので汚かったり効率悪かったりするかもしれません...\n\nあとは`Command`に登録していって、`output`を読んであげれば完了です。\nただし`output`はバイト列を返すみたいなので、`String::from_utf8_lossy`を使って、文字に直してあげます。\n\n#### 追記(2014/12/21)\n\n---\n\nこのままだと標準入力や標準出力、標準エラー出力が子プロセスと結びついておらず、仮想のパイプとつながったような状態になるようです。\nそのため、標準入力から読み取るような関数を実行しようとするとそのプロセスは失敗します。\n\n修正したのが以下のコードです。(`Command`を作成する部分のみ)\n\n```rust\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .stdin(StdioContainer::InheritFd(STDIN_FILENO))\n                              .stdout(StdioContainer::InheritFd(STDOUT_FILENO))\n                              .stderr(StdioContainer::InheritFd(STDERR_FILENO))\n                              .spawn() {\n        Ok(p) => p,\n        Err(e) => panic!(\"ERROR: {}\", e)\n                              };\n    match output.wait() {\n        Ok(e) => println!(\"Exit: {}\", e),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n```\n\nこのように、`stdout`を標準出力と関連付けることで、前のコードでの`output`から読み取って文字列に変換して出力、という手順は不要になりました。\nC 言語では`fork`したら`wait`しろと言われて育ってきたので、とりあえず`wait`を入れてみていますが、どうも`wait`を入れなくてもゾンビプロセスが残っているようには見えないので謎です。\n調査中です。\n\n### 追記ここまで\n\n## main\n\n先ほどの`exec`関数を`main`で使える形にしてみます。\n\n```rust:main.rs\nuse std::io;\nmod parse;\nmod exec;\n\nfn main() {\n    loop {\n        print!(\"% > \");\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let parser = parse::Parser::new(input);\n        let tokens: Vec<parse::Token> = parser.collect();\n        exec::exec(tokens);\n    }\n}\n```\n\nプロンプトを表示してからユーザーの入力を受付け、パースして`Vec<Token>`になおしてから`exec`に渡しています。\n\n## 実行結果\n\n```\n% > echo hello\nhello\n% > echo \"hello world\"\n\"hello world\"\n% >\n```\n\nあれ？`\"`の扱いなんて考えてなかったのになぜかうまくいってますね。不思議。\n\n検証用に`main.rs`を書き換えて実行してみました。\n\n```\n% > echo hello\nStr(echo)\nStr(hello)\nhello\n% > echo \"hello world\"\nStr(echo)\nStr(\"hello)\nStr(world\")\n\"hello world\"\n% > echo \"hello     world\"\nStr(echo)\nStr(\"hello)\nStr(world\")\n\"hello world\"\n% >\n```\n\n`echo`がうまくやってくれているみたいですね。すごい。\n\n## 今後\n\n次はリダイレクト関連ですかね。パイプや&よりも簡単そうだし。\n毎度のことですが、ご指摘大歓迎です！色々な意見を伺いたくてこれを書いているので、何かありましたらぜひよろしくお願いします！\n\n[agatan/rsh](https://github.com/agatan/rsh)\n","contentMarkdown":"\nコード全文はこちら\n[agatan/rsh](https://github.com/agatan/rsh)\n\n[Rust で自作シェルもどきを作る(字句解析編) - Qiita](http://qiita.com/agatan/items/8a097ead46df1c1659ff)\n\n前回はユーザからの入力を受け付けてパースするところまで実装したので、今回は実際に入力されたコマンドを実行させてみます。  \nただし、いきなりいろいろやるのはきついので、まずは単純なコマンド(パイプやリダイレクトは一旦無視します)の実行をやってみました。\n\n## Command\n\nRust には`std::io::process::Command`という構造体があります。これを使えば簡単にコマンド実行は出来そうです。\n\n> http://doc.rust-lang.org/std/io/process/struct.Command.htmlより引用\n>\n> ```rust\n> use std::io::Command;\n> ```\n\n> let mut process = match Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").spawn() {\n> Ok(p) => p,\n> Err(e) => panic!(\"failed to execute process: {}\", e),\n> };\n\n> let output = process.stdout.as_mut().unwrap().read_to_end();\n\n````\n\nいろいろと便利そうな関数が定義されているのですが、今回は最も単純にコマンドを実行させるために、`output`という関数を使用してみました。\n\n```rust:exec.rs\nuse std;\nuse std::io::process::Command;\n\nuse parse::Token;\n\npub fn exec(tokens: Vec<Token>) {\n    if tokens.iter()\n             .find(|&t| match t {\n                 &Token::Str(_) => false, _ => true } ).is_some() {\n        panic!(\"Not implemented yet.\");\n    }\n    let first_cmd = tokens.iter()\n                          .take_while(|&t| match t {\n                              &Token::Str(_) => true,\n                              _ => false\n                          })\n                          .map(|ref t| match *t {\n                              &Token::Str(ref x) => x.clone(),\n                              _ => panic!(\"Shouldn't be reached.\"),\n                          })\n                          .collect::<Vec<String>>();\n\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .output() {\n        Ok(p) => p,\n        Err(e) => panic!(\"Failed to execute: {}\", e),\n    };\n\n    print!(\"{}\", String::from_utf8_lossy(output.output.as_slice()));\n\n}\n````\n\n`exec`は`Vec<Token>`を受け取る関数です。\n今回はパイプなどは未実装ですから、`Str(_)`以外の`Token`が含まれていたら`panic!`(例外送出)をしています。\n\nさて、`Command`は`new`で実行したいコマンド名を指定し、それに続けて`arg`や`args`で引数を追加していきます。\nユーザからの入力を利用しているので、ひとつずつしか追加できない`arg`よりは、スライスを渡して複数追加できる`args`を使いたいです。\n\nこれらにあわせて`Vec<Token>`を`Vec<String>`もしくは`Vec<&str>`に変換してあげれば良さそうです。\nということで`let first_cmd = ...`という長い文は、その変換を行っています。\n\n正直まだ`&`と`ref`の関係とか所有権の問題はきちんと理解できていないというか書き方がよくわかっていないので、コンパイラに怒ってもらいながらなんとか直してみました。\nコンパイルを通るように、を第一に書いていったので汚かったり効率悪かったりするかもしれません...\n\nあとは`Command`に登録していって、`output`を読んであげれば完了です。\nただし`output`はバイト列を返すみたいなので、`String::from_utf8_lossy`を使って、文字に直してあげます。\n\n#### 追記(2014/12/21)\n\n---\n\nこのままだと標準入力や標準出力、標準エラー出力が子プロセスと結びついておらず、仮想のパイプとつながったような状態になるようです。\nそのため、標準入力から読み取るような関数を実行しようとするとそのプロセスは失敗します。\n\n修正したのが以下のコードです。(`Command`を作成する部分のみ)\n\n```rust\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .stdin(StdioContainer::InheritFd(STDIN_FILENO))\n                              .stdout(StdioContainer::InheritFd(STDOUT_FILENO))\n                              .stderr(StdioContainer::InheritFd(STDERR_FILENO))\n                              .spawn() {\n        Ok(p) => p,\n        Err(e) => panic!(\"ERROR: {}\", e)\n                              };\n    match output.wait() {\n        Ok(e) => println!(\"Exit: {}\", e),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n```\n\nこのように、`stdout`を標準出力と関連付けることで、前のコードでの`output`から読み取って文字列に変換して出力、という手順は不要になりました。\nC 言語では`fork`したら`wait`しろと言われて育ってきたので、とりあえず`wait`を入れてみていますが、どうも`wait`を入れなくてもゾンビプロセスが残っているようには見えないので謎です。\n調査中です。\n\n### 追記ここまで\n\n## main\n\n先ほどの`exec`関数を`main`で使える形にしてみます。\n\n```rust:main.rs\nuse std::io;\nmod parse;\nmod exec;\n\nfn main() {\n    loop {\n        print!(\"% > \");\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let parser = parse::Parser::new(input);\n        let tokens: Vec<parse::Token> = parser.collect();\n        exec::exec(tokens);\n    }\n}\n```\n\nプロンプトを表示してからユーザーの入力を受付け、パースして`Vec<Token>`になおしてから`exec`に渡しています。\n\n## 実行結果\n\n```\n% > echo hello\nhello\n% > echo \"hello world\"\n\"hello world\"\n% >\n```\n\nあれ？`\"`の扱いなんて考えてなかったのになぜかうまくいってますね。不思議。\n\n検証用に`main.rs`を書き換えて実行してみました。\n\n```\n% > echo hello\nStr(echo)\nStr(hello)\nhello\n% > echo \"hello world\"\nStr(echo)\nStr(\"hello)\nStr(world\")\n\"hello world\"\n% > echo \"hello     world\"\nStr(echo)\nStr(\"hello)\nStr(world\")\n\"hello world\"\n% >\n```\n\n`echo`がうまくやってくれているみたいですね。すごい。\n\n## 今後\n\n次はリダイレクト関連ですかね。パイプや&よりも簡単そうだし。\n毎度のことですが、ご指摘大歓迎です！色々な意見を伺いたくてこれを書いているので、何かありましたらぜひよろしくお願いします！\n\n[agatan/rsh](https://github.com/agatan/rsh)\n","slug":"Rustで自作シェルもどきを作る(単純なコマンド実行編)","title":"Rustで自作シェルもどきを作る(単純なコマンド実行編)","timestamp":1419141351000,"tags":["Rust"]},{"rawMarkdown":"---\ntitle: \"Rustで自作シェルもどきを作る(字句解析編)\"\ndate: 2014-12-21T01:15:19+09:00\ntags: [\"Rust\"]\nurl: https://qiita.com/agatan/items/8a097ead46df1c1659ff\n---\n\nRust が最近とてもおもしろいので、勉強がてら自作シェルみたいなものを作ってみたいと思います。  \nとはいえ、C 言語でさえろくにシステムプログラムを書いたことがないので、道は険しくなりそうです。\n\n## バージョン\n\n0.13.0-nightly を使用しました。\n\nコード全文はこちら\n[agatan/rsh](https://github.com/agatan/rsh)\n\n## 字句解析\n\nさて、シェルといったらまずはユーザの入力を受け付けてパースし、コマンドを実行しなくてはなりません。  \nというわけでまず初めにパース部分についてやってみます。  \nさくっと終わらせたかったのですが、どうもまだ`String`と`&str`とかそのへんで詰まってしまいます...\n\n## Token の規定\n\n`enum`を使って`Token`を列挙します。  \n一応最終的にはパイプやらリダイレクトやらも実装したいなーと思っているので、その辺を考慮に入れた実装にしてみました。\n\n```rust\nenum Token {\n\tStr(String),\n\tPipe,\n\tRedirectTo,\n\tRedirectFrom,\n\tAmpersand,\n}\n```\n\n`Str`は特殊な文字以外の文字列ですから、要素として`String`を保持させておきました。\n\n## parser\n\nパースには(おもしろそうだったので)`iterator`トレイトを実装させることにしました。  \n実際つかうときにはいらない気もしますが、ちょっとためしたかったので。\n\n構造体として`Parser`を作ります。ソースとなる文字列と、現在どこまでパース済みなのかを保持する`current`を持たせました。\n\n```rust\npub struct Parser {\n    src: String,\n    pub current: uint,\n}\n```\n\nこの構造体に`Iterator`トレイトを実装すればよいのですが、補助関数としていくつか実装しておきます。\n\n```rust\nimpl Parser {\n    pub fn new(src: String) -> Parser {\n        Parser { src: src, current: 0 }\n    }\n\n    pub fn current_char(&self) -> char {\n        self.src.char_at(self.current)\n    }\n\n    fn skip_whitespace(&mut self) {\n        while self.current_char().is_whitespace() {\n            self.current += 1;\n            if self.current >= self.src.char_len() {\n                return;\n            }\n        }\n    }\n\n    fn get_pipe(&mut self) -> Option<Token> {\n        if self.current_char() == '|' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Pipe)\n        } else {\n            None\n        }\n    }\n\n    fn get_ampersand(&mut self) -> Option<Token> {\n        if self.current_char() == '&' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Ampersand)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_to(&mut self) -> Option<Token> {\n        if self.current_char() == '>' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectTo)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_from(&mut self) -> Option<Token> {\n        if self.current_char() == '<' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectFrom)\n\n    fn get_str(&mut self) -> Option<Token> {\n        let mut i = self.current;\n        while !KEYWORDS.contains_char(self.src.char_at(i)) {\n            i += 1;\n        }\n        if i == self.current {\n            None\n        } else {\n            let result = Some(Token::Str(self.src.slice_chars(self.current, i).to_string()));\n            self.current = i;\n            self.skip_whitespace();\n            result\n        }\n    }\n}\n\n```\n\n`new`は新しいパーサーを生成するための関数です。`Parser`は文字列の所有権を要求していますが、入力された文字列はパースする以外に使い道は無いと思ったので大丈夫と判断しました。\n\n`current_char`は現在注目している文字を返します。\n`skip_whitespace`は空白文字を飛ばすように`self.current`をいじります。パーサーでは、基本的に 1 トークンを読み終えたら空白を飛ばして次のトークンになりうる文字の先頭までジャンプするべきなので、必ずトークンを読んだらこの関数を呼び出します。\n\nのこりの関数は、それぞれの`Token`を取得することを試みる関数です。  \n`Option<Token>`が帰ってくるので、`None`が帰ってきたら今みているトークンは別の種類のものであるといえます。\n\nこれらを用いて`Iterator`を実装しました。\n\n```rust\nimpl std::iter::Iterator<Token> for Parser {\n\n    fn next(&mut self) -> Option<Token> {\n        if self.current >= self.src.char_len() {\n            return None;\n        }\n        let mut result: Option<Token> = self.get_pipe();\n        if result.is_some() { return result; }\n        result = self.get_ampersand();\n        if result.is_some() { return result; }\n        result = self.get_redirect_to();\n        if result.is_some() { return result; }\n        result = self.get_redirect_from();\n        if result.is_some() { return result; }\n        result = self.get_str();\n        if result.is_some() { return result; }\n        None\n    }\n}\n```\n\nきれいじゃないコードですが、うまいやり方が他に思いつかなかったので...  \n純粋にある種類のトークンを取得しようと試みて`None`が帰ってきたら別の種類で試す、ということを繰り返しています。\n先頭で末尾まで読み込んだかを判定しています。\nすべての条件に当てはまらなくなったらパース失敗で`None`を返しています。\n\n## 試す\n\n```rust\nuse std::io;\nmod parse;\n\nfn main() {\n    loop {\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let mut parser = parse::Parser::new(input);\n        for token in parser {\n            println!(\"{}\", token);\n        }\n    }\n}\n```\n\n実行結果\n\n```\nls -a | grep foo\nStr(ls)\nStr(-a)\nPipe\nStr(grep)\nStr(foo)\nls -a| grep foo>result.txt &\nStr(ls)\nStr(-a)\nPipe\nStr(grep)\nStr(foo)\nRedirectTo\nStr(result.txt)\nAmpersand\n```\n\nこのような感じになりました。\n`Iterator`を実装しているので、`for .. in ..`が使えて気持ち良いです。\n\n## 反省点\n\nパースは失敗しうる計算だから`Option`かなーどうせ`Option`かえすなら`Iterator`実装しちゃえばお得かなーとおもって漠然と実装してみましたが、パースは失敗した理由がほしいことがほとんどなのでよく考えたら`Result`を使うべきだった気がしてきました。\n効率とかは正直 Rust での効率のよい書き方がよくわかっていないのであまり気にせず、とりあえず動くものを、と作ってみました。\nあとはパーサを書いたことが殆どなかったので成功法がわからなかったので、もっときれいな書き方があるんじゃないかという気も...\n\n## 今後\n\nとりあえず動くものを、コードをたくさん書こう、の精神で進めてみます。\n次は単純なコマンド実行を実装したいです。\nといっても Rust には`Command`とか`Process`とかがあって、ちょっと読んで見た感じ割りと素直に C 言語の`execvp`とかを呼び出しているようなので、それを使えばそこまで難しくはないのかな？\n\nソースの全文を掲載しますので、Rust 固有であってもそうでなくても、より良い書き方などありましたらご教授いただけると幸いです。よろしくお願いします。\n\n```rust:parse.rs\nuse std;\n\nstatic KEYWORDS: &'static str = \"|&<> \\n\";\n\n#[deriving(Show)]\npub enum Token {\n    Str(String),\n    Pipe,\n    RedirectTo,\n    RedirectFrom,\n    Ampersand,\n}\n\npub struct Parser {\n    src: String,\n    pub current: uint,\n}\n\nimpl Parser {\n\n    pub fn new(src: String) -> Parser {\n        Parser { src: src, current: 0 }\n    }\n\n    pub fn current_char(&self) -> char {\n        self.src.char_at(self.current)\n    }\n\n    fn skip_whitespace(&mut self) {\n        while self.current_char().is_whitespace() {\n            self.current += 1;\n            if self.current >= self.src.char_len() {\n                return;\n            }\n        }\n    }\n\n    fn get_pipe(&mut self) -> Option<Token> {\n        if self.current_char() == '|' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Pipe)\n        } else {\n            None\n        }\n    }\n\n    fn get_ampersand(&mut self) -> Option<Token> {\n        if self.current_char() == '&' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Ampersand)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_to(&mut self) -> Option<Token> {\n        if self.current_char() == '>' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectTo)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_from(&mut self) -> Option<Token> {\n        if self.current_char() == '<' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectFrom)\n        } else {\n            None\n        }\n    }\n\n    fn get_str(&mut self) -> Option<Token> {\n        let mut i = self.current;\n        while !KEYWORDS.contains_char(self.src.char_at(i)) {\n            i += 1;\n        }\n        if i == self.current {\n            None\n        } else {\n            let result = Some(Token::Str(self.src.slice_chars(self.current, i).to_string()));\n            self.current = i;\n            self.skip_whitespace();\n            result\n        }\n    }\n}\n\nimpl std::iter::Iterator<Token> for Parser {\n\n    fn next(&mut self) -> Option<Token> {\n        if self.current >= self.src.char_len() {\n            return None;\n        }\n        let mut result: Option<Token> = self.get_pipe();\n        if result.is_some() { return result; }\n        result = self.get_ampersand();\n        if result.is_some() { return result; }\n        result = self.get_redirect_to();\n        if result.is_some() { return result; }\n        result = self.get_redirect_from();\n        if result.is_some() { return result; }\n        result = self.get_str();\n        if result.is_some() { return result; }\n        None\n    }\n}\n```\n\n```rust:main.rs\nuse std::io;\nmod parse;\n\nfn main() {\n    loop {\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let mut parser = parse::Parser::new(input);\n        for token in parser {\n            println!(\"{}\", token);\n        }\n    }\n}\n```\n","contentMarkdown":"\nRust が最近とてもおもしろいので、勉強がてら自作シェルみたいなものを作ってみたいと思います。  \nとはいえ、C 言語でさえろくにシステムプログラムを書いたことがないので、道は険しくなりそうです。\n\n## バージョン\n\n0.13.0-nightly を使用しました。\n\nコード全文はこちら\n[agatan/rsh](https://github.com/agatan/rsh)\n\n## 字句解析\n\nさて、シェルといったらまずはユーザの入力を受け付けてパースし、コマンドを実行しなくてはなりません。  \nというわけでまず初めにパース部分についてやってみます。  \nさくっと終わらせたかったのですが、どうもまだ`String`と`&str`とかそのへんで詰まってしまいます...\n\n## Token の規定\n\n`enum`を使って`Token`を列挙します。  \n一応最終的にはパイプやらリダイレクトやらも実装したいなーと思っているので、その辺を考慮に入れた実装にしてみました。\n\n```rust\nenum Token {\n\tStr(String),\n\tPipe,\n\tRedirectTo,\n\tRedirectFrom,\n\tAmpersand,\n}\n```\n\n`Str`は特殊な文字以外の文字列ですから、要素として`String`を保持させておきました。\n\n## parser\n\nパースには(おもしろそうだったので)`iterator`トレイトを実装させることにしました。  \n実際つかうときにはいらない気もしますが、ちょっとためしたかったので。\n\n構造体として`Parser`を作ります。ソースとなる文字列と、現在どこまでパース済みなのかを保持する`current`を持たせました。\n\n```rust\npub struct Parser {\n    src: String,\n    pub current: uint,\n}\n```\n\nこの構造体に`Iterator`トレイトを実装すればよいのですが、補助関数としていくつか実装しておきます。\n\n```rust\nimpl Parser {\n    pub fn new(src: String) -> Parser {\n        Parser { src: src, current: 0 }\n    }\n\n    pub fn current_char(&self) -> char {\n        self.src.char_at(self.current)\n    }\n\n    fn skip_whitespace(&mut self) {\n        while self.current_char().is_whitespace() {\n            self.current += 1;\n            if self.current >= self.src.char_len() {\n                return;\n            }\n        }\n    }\n\n    fn get_pipe(&mut self) -> Option<Token> {\n        if self.current_char() == '|' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Pipe)\n        } else {\n            None\n        }\n    }\n\n    fn get_ampersand(&mut self) -> Option<Token> {\n        if self.current_char() == '&' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Ampersand)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_to(&mut self) -> Option<Token> {\n        if self.current_char() == '>' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectTo)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_from(&mut self) -> Option<Token> {\n        if self.current_char() == '<' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectFrom)\n\n    fn get_str(&mut self) -> Option<Token> {\n        let mut i = self.current;\n        while !KEYWORDS.contains_char(self.src.char_at(i)) {\n            i += 1;\n        }\n        if i == self.current {\n            None\n        } else {\n            let result = Some(Token::Str(self.src.slice_chars(self.current, i).to_string()));\n            self.current = i;\n            self.skip_whitespace();\n            result\n        }\n    }\n}\n\n```\n\n`new`は新しいパーサーを生成するための関数です。`Parser`は文字列の所有権を要求していますが、入力された文字列はパースする以外に使い道は無いと思ったので大丈夫と判断しました。\n\n`current_char`は現在注目している文字を返します。\n`skip_whitespace`は空白文字を飛ばすように`self.current`をいじります。パーサーでは、基本的に 1 トークンを読み終えたら空白を飛ばして次のトークンになりうる文字の先頭までジャンプするべきなので、必ずトークンを読んだらこの関数を呼び出します。\n\nのこりの関数は、それぞれの`Token`を取得することを試みる関数です。  \n`Option<Token>`が帰ってくるので、`None`が帰ってきたら今みているトークンは別の種類のものであるといえます。\n\nこれらを用いて`Iterator`を実装しました。\n\n```rust\nimpl std::iter::Iterator<Token> for Parser {\n\n    fn next(&mut self) -> Option<Token> {\n        if self.current >= self.src.char_len() {\n            return None;\n        }\n        let mut result: Option<Token> = self.get_pipe();\n        if result.is_some() { return result; }\n        result = self.get_ampersand();\n        if result.is_some() { return result; }\n        result = self.get_redirect_to();\n        if result.is_some() { return result; }\n        result = self.get_redirect_from();\n        if result.is_some() { return result; }\n        result = self.get_str();\n        if result.is_some() { return result; }\n        None\n    }\n}\n```\n\nきれいじゃないコードですが、うまいやり方が他に思いつかなかったので...  \n純粋にある種類のトークンを取得しようと試みて`None`が帰ってきたら別の種類で試す、ということを繰り返しています。\n先頭で末尾まで読み込んだかを判定しています。\nすべての条件に当てはまらなくなったらパース失敗で`None`を返しています。\n\n## 試す\n\n```rust\nuse std::io;\nmod parse;\n\nfn main() {\n    loop {\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let mut parser = parse::Parser::new(input);\n        for token in parser {\n            println!(\"{}\", token);\n        }\n    }\n}\n```\n\n実行結果\n\n```\nls -a | grep foo\nStr(ls)\nStr(-a)\nPipe\nStr(grep)\nStr(foo)\nls -a| grep foo>result.txt &\nStr(ls)\nStr(-a)\nPipe\nStr(grep)\nStr(foo)\nRedirectTo\nStr(result.txt)\nAmpersand\n```\n\nこのような感じになりました。\n`Iterator`を実装しているので、`for .. in ..`が使えて気持ち良いです。\n\n## 反省点\n\nパースは失敗しうる計算だから`Option`かなーどうせ`Option`かえすなら`Iterator`実装しちゃえばお得かなーとおもって漠然と実装してみましたが、パースは失敗した理由がほしいことがほとんどなのでよく考えたら`Result`を使うべきだった気がしてきました。\n効率とかは正直 Rust での効率のよい書き方がよくわかっていないのであまり気にせず、とりあえず動くものを、と作ってみました。\nあとはパーサを書いたことが殆どなかったので成功法がわからなかったので、もっときれいな書き方があるんじゃないかという気も...\n\n## 今後\n\nとりあえず動くものを、コードをたくさん書こう、の精神で進めてみます。\n次は単純なコマンド実行を実装したいです。\nといっても Rust には`Command`とか`Process`とかがあって、ちょっと読んで見た感じ割りと素直に C 言語の`execvp`とかを呼び出しているようなので、それを使えばそこまで難しくはないのかな？\n\nソースの全文を掲載しますので、Rust 固有であってもそうでなくても、より良い書き方などありましたらご教授いただけると幸いです。よろしくお願いします。\n\n```rust:parse.rs\nuse std;\n\nstatic KEYWORDS: &'static str = \"|&<> \\n\";\n\n#[deriving(Show)]\npub enum Token {\n    Str(String),\n    Pipe,\n    RedirectTo,\n    RedirectFrom,\n    Ampersand,\n}\n\npub struct Parser {\n    src: String,\n    pub current: uint,\n}\n\nimpl Parser {\n\n    pub fn new(src: String) -> Parser {\n        Parser { src: src, current: 0 }\n    }\n\n    pub fn current_char(&self) -> char {\n        self.src.char_at(self.current)\n    }\n\n    fn skip_whitespace(&mut self) {\n        while self.current_char().is_whitespace() {\n            self.current += 1;\n            if self.current >= self.src.char_len() {\n                return;\n            }\n        }\n    }\n\n    fn get_pipe(&mut self) -> Option<Token> {\n        if self.current_char() == '|' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Pipe)\n        } else {\n            None\n        }\n    }\n\n    fn get_ampersand(&mut self) -> Option<Token> {\n        if self.current_char() == '&' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::Ampersand)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_to(&mut self) -> Option<Token> {\n        if self.current_char() == '>' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectTo)\n        } else {\n            None\n        }\n    }\n\n    fn get_redirect_from(&mut self) -> Option<Token> {\n        if self.current_char() == '<' {\n            self.current += 1;\n            self.skip_whitespace();\n            Some(Token::RedirectFrom)\n        } else {\n            None\n        }\n    }\n\n    fn get_str(&mut self) -> Option<Token> {\n        let mut i = self.current;\n        while !KEYWORDS.contains_char(self.src.char_at(i)) {\n            i += 1;\n        }\n        if i == self.current {\n            None\n        } else {\n            let result = Some(Token::Str(self.src.slice_chars(self.current, i).to_string()));\n            self.current = i;\n            self.skip_whitespace();\n            result\n        }\n    }\n}\n\nimpl std::iter::Iterator<Token> for Parser {\n\n    fn next(&mut self) -> Option<Token> {\n        if self.current >= self.src.char_len() {\n            return None;\n        }\n        let mut result: Option<Token> = self.get_pipe();\n        if result.is_some() { return result; }\n        result = self.get_ampersand();\n        if result.is_some() { return result; }\n        result = self.get_redirect_to();\n        if result.is_some() { return result; }\n        result = self.get_redirect_from();\n        if result.is_some() { return result; }\n        result = self.get_str();\n        if result.is_some() { return result; }\n        None\n    }\n}\n```\n\n```rust:main.rs\nuse std::io;\nmod parse;\n\nfn main() {\n    loop {\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let mut parser = parse::Parser::new(input);\n        for token in parser {\n            println!(\"{}\", token);\n        }\n    }\n}\n```\n","slug":"Rustで自作シェルもどきを作る(字句解析編)","title":"Rustで自作シェルもどきを作る(字句解析編)","timestamp":1419092119000,"tags":["Rust"]},{"rawMarkdown":"---\ntitle: \"RubyでLinuxコマンドの再実装(tree編)\"\ndate: 2014-10-16T16:20:33+09:00\ntags: [\"Ruby\", \"Linux\"]\nurl: https://qiita.com/agatan/items/4c50554ae22aa4181cc1\n---\n\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## tree\n\n`tree`コマンドに挑戦します。\n`tree`コマンドは, 指定したディレクトリ以下のファイルを木構造にして表示してくれます。\n\n![スクリーンショット 2014-10-16 16.16.08.png](https://qiita-image-store.s3.amazonaws.com/0/39030/b3ca62be-bc22-ec39-a836-70032b76521d.png \"スクリーンショット 2014-10-16 16.16.08.png\")\n\n```tree.rb\n#! /usr/bin/env ruby -w\n#\n# tree: 引数で指定されたディレクトリ以下のファイルを\n#       再帰的に木構造として表示する.\n\nrequire 'optparse'\n\noptions = ARGV.getopts('aF')\n\n# parentは絶対パス.\ndef display_entries(parent, prefix, options)\n  # '.', '..'を除く. 無限に再帰することを防ぐ\n  entries = Dir.entries(parent).delete_if do |entry|\n    entry == '.' or entry == '..' or !options['a'] && entry.start_with?('.')\n  end\n\n  entries.each_with_index do |entry, index|\n    fullpath = File.join(parent, entry)\n    entry = f_option(parent, entry) if options['F']\n    # 最後の要素かどうか\n    if index == entries.size - 1\n      puts \"#{prefix}└── #{entry}\"\n      next_prefix = prefix + '    '\n    else\n      puts \"#{prefix}├── #{entry}\"\n      next_prefix = prefix + '│   '\n    end\n    if File.directory? fullpath\n      display_entries(fullpath, next_prefix, options)\n    end\n  end\nend\n\ndef f_option(parent, entry)\n  case File.ftype(File.join(parent, entry))\n  when \"file\"\n    if File.executable? File.join(parent, entry)\n      \"#{entry}*\"\n    else\n      entry\n    end\n  when \"directory\"\n    \"#{entry}/\"\n  when \"link\"\n    \"#{entry}@\"\n  else\n    entry\n  end\nend\n\ntarget = ARGV[0] || '.'\ntarget_fullpath = File.absolute_path target\ninit_prefix = ''\n\nputs target\ndisplay_entries target_fullpath, init_prefix, options\n```\n\nファイルのタイプを調べる際の処理を ls 編とちょっとだけ変えてみました。\nシンボリックリンクのリンク先を表示する修正が必要ですね...\n`color`は`ls`のときとほとんど変わらないので省きました。\n`File.ftype`では実行可能ファイルかどうかは判定できないんですかね??そこがちょっと気になります。\nあとはオプションのあたりなど複雑になってしまっているので綺麗にしたいです。\n","contentMarkdown":"\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## tree\n\n`tree`コマンドに挑戦します。\n`tree`コマンドは, 指定したディレクトリ以下のファイルを木構造にして表示してくれます。\n\n![スクリーンショット 2014-10-16 16.16.08.png](https://qiita-image-store.s3.amazonaws.com/0/39030/b3ca62be-bc22-ec39-a836-70032b76521d.png \"スクリーンショット 2014-10-16 16.16.08.png\")\n\n```tree.rb\n#! /usr/bin/env ruby -w\n#\n# tree: 引数で指定されたディレクトリ以下のファイルを\n#       再帰的に木構造として表示する.\n\nrequire 'optparse'\n\noptions = ARGV.getopts('aF')\n\n# parentは絶対パス.\ndef display_entries(parent, prefix, options)\n  # '.', '..'を除く. 無限に再帰することを防ぐ\n  entries = Dir.entries(parent).delete_if do |entry|\n    entry == '.' or entry == '..' or !options['a'] && entry.start_with?('.')\n  end\n\n  entries.each_with_index do |entry, index|\n    fullpath = File.join(parent, entry)\n    entry = f_option(parent, entry) if options['F']\n    # 最後の要素かどうか\n    if index == entries.size - 1\n      puts \"#{prefix}└── #{entry}\"\n      next_prefix = prefix + '    '\n    else\n      puts \"#{prefix}├── #{entry}\"\n      next_prefix = prefix + '│   '\n    end\n    if File.directory? fullpath\n      display_entries(fullpath, next_prefix, options)\n    end\n  end\nend\n\ndef f_option(parent, entry)\n  case File.ftype(File.join(parent, entry))\n  when \"file\"\n    if File.executable? File.join(parent, entry)\n      \"#{entry}*\"\n    else\n      entry\n    end\n  when \"directory\"\n    \"#{entry}/\"\n  when \"link\"\n    \"#{entry}@\"\n  else\n    entry\n  end\nend\n\ntarget = ARGV[0] || '.'\ntarget_fullpath = File.absolute_path target\ninit_prefix = ''\n\nputs target\ndisplay_entries target_fullpath, init_prefix, options\n```\n\nファイルのタイプを調べる際の処理を ls 編とちょっとだけ変えてみました。\nシンボリックリンクのリンク先を表示する修正が必要ですね...\n`color`は`ls`のときとほとんど変わらないので省きました。\n`File.ftype`では実行可能ファイルかどうかは判定できないんですかね??そこがちょっと気になります。\nあとはオプションのあたりなど複雑になってしまっているので綺麗にしたいです。\n","slug":"RubyでLinuxコマンドの再実装(tree編)","title":"RubyでLinuxコマンドの再実装(tree編)","timestamp":1413444033000,"tags":["Ruby","Linux"]},{"rawMarkdown":"---\ntitle: \"RubyでLinuxコマンドの再実装(ls編)\"\ndate: 2014-10-13T23:10:08+09:00\ntags: [\"Ruby\", \"Linux\"]\nurl: https://qiita.com/agatan/items/af0c3bbc881f60667c85\n---\n\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## ls\n\nではまずは`ls`です。簡単そうだったし個人的に一番良く使うコマンドなので。\n\n```rb\n#! /usr/bin/env ruby\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir::entries(target)\n\nentries.select!{|entry| entry[0] != '.'}\n\nentries.map! do |entry|\n  if File::directory?(File.join(target, entry))\n    \"#{entry}/\"\n  else\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\nディレクトリの場合は末尾に`/`をつけるようにしています。\n\n`-a`オプションで隠しファイル隠しディレクトリも表示するようにしたり, `--color`オプションで色をつけたりすることが目標です。\n\nコマンドライン引数の順番や, `-a -l -F`と`-alF`などややこしそうな部分は制約をつけてお茶を濁してしまうかもしれません...\n\n### 追記\n\n---\n\n@riocampos さんにコメントでコマンドライン引数の利用方法を教えていただきました！\n`require 'optparse'`とすればパーサが利用できるようになります。\n\nというわけでこれを反映し修正したものがこちらです。\n\n```ls.rb\n#! /usr/bin/env ruby -w\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\nrequire 'optparse'\n\ndef set_color_and_reset(entry, color)\n  case color\n  when :red\n    \"\\e[31m#{entry}\\e[0m\"\n  when :green\n    \"\\e[32m#{entry}\\e[0m\"\n  when :blue\n    \"\\e[34m#{entry}\\e[0m\"\n  when :cyan\n    \"\\e[36m#{entry}\\e[0m\"\n  else\n    entry\n  end\nend\n\noptions = ARGV.getopts('aF', 'color')\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir.entries(target)\n\nif options['a']\n  options['a'] = false\nelse\n  entries.select! { |entry| entry[0] != '.' }\nend\n\nif options.value? true\n  entries.map! do |entry|\n    fullpath = \"#{target}/#{entry}\"\n    case\n    when File.directory?(fullpath)\n      entry = set_color_and_reset entry, :blue if options['color']\n      entry += '/' if options['F']\n    when File.symlink?(fullpath)\n      entry = set_color_and_reset entry, :cyan if options['color']\n      entry += '@' if options['F']\n    when File.executable?(fullpath)\n      entry = set_color_and_reset entry, :red if options['color']\n      entry += '*' if options['F']\n    end\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\n`-l`オプションは対応していません...`-aF --color`に対応しました。\n表示の桁揃えとかしたほうが綺麗なんでしょうけれど...\n\n次は`tree`に挑戦してみます。\n","contentMarkdown":"\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## ls\n\nではまずは`ls`です。簡単そうだったし個人的に一番良く使うコマンドなので。\n\n```rb\n#! /usr/bin/env ruby\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir::entries(target)\n\nentries.select!{|entry| entry[0] != '.'}\n\nentries.map! do |entry|\n  if File::directory?(File.join(target, entry))\n    \"#{entry}/\"\n  else\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\nディレクトリの場合は末尾に`/`をつけるようにしています。\n\n`-a`オプションで隠しファイル隠しディレクトリも表示するようにしたり, `--color`オプションで色をつけたりすることが目標です。\n\nコマンドライン引数の順番や, `-a -l -F`と`-alF`などややこしそうな部分は制約をつけてお茶を濁してしまうかもしれません...\n\n### 追記\n\n---\n\n@riocampos さんにコメントでコマンドライン引数の利用方法を教えていただきました！\n`require 'optparse'`とすればパーサが利用できるようになります。\n\nというわけでこれを反映し修正したものがこちらです。\n\n```ls.rb\n#! /usr/bin/env ruby -w\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\nrequire 'optparse'\n\ndef set_color_and_reset(entry, color)\n  case color\n  when :red\n    \"\\e[31m#{entry}\\e[0m\"\n  when :green\n    \"\\e[32m#{entry}\\e[0m\"\n  when :blue\n    \"\\e[34m#{entry}\\e[0m\"\n  when :cyan\n    \"\\e[36m#{entry}\\e[0m\"\n  else\n    entry\n  end\nend\n\noptions = ARGV.getopts('aF', 'color')\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir.entries(target)\n\nif options['a']\n  options['a'] = false\nelse\n  entries.select! { |entry| entry[0] != '.' }\nend\n\nif options.value? true\n  entries.map! do |entry|\n    fullpath = \"#{target}/#{entry}\"\n    case\n    when File.directory?(fullpath)\n      entry = set_color_and_reset entry, :blue if options['color']\n      entry += '/' if options['F']\n    when File.symlink?(fullpath)\n      entry = set_color_and_reset entry, :cyan if options['color']\n      entry += '@' if options['F']\n    when File.executable?(fullpath)\n      entry = set_color_and_reset entry, :red if options['color']\n      entry += '*' if options['F']\n    end\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\n`-l`オプションは対応していません...`-aF --color`に対応しました。\n表示の桁揃えとかしたほうが綺麗なんでしょうけれど...\n\n次は`tree`に挑戦してみます。\n","slug":"RubyでLinuxコマンドの再実装(ls編)","title":"RubyでLinuxコマンドの再実装(ls編)","timestamp":1413209408000,"tags":["Ruby","Linux"]},{"rawMarkdown":"---\ntitle: \"QiitaAPIを通じて複数のタグを持つ記事を検索する\"\ndate: 2014-10-13T18:11:43+09:00\ntags: [\"Qiita\", \"Ruby\"]\nurl: https://qiita.com/agatan/items/55dce1d2bc887de0cd71\n---\n\nRuby 初心者なのでなにかお気づきの点がありましたらご教授いただけると幸いです。\n\n## QiitaApiAccessor\n\nQiitaAPI との通信, 受信情報のハッシュ化を担当している。\n`@result_json`をローカル変数にしたいのだけど, `open`ブロック内のローカル変数になってしまうので出来ない...\n`get_with_tag`内のローカル変数にならできるけど結局`result_json = {}`として`open`内で更新みたいな書き方になってしまって綺麗じゃない...\n\n```ruby\nrequire 'open-uri'\nrequire 'json'\n\nclass QiitaApiAccessor\n\n  def initialize\n    @qiita_url = 'http://qiita.com/api/v2'\n    @result_json = {}\n  end\n\n  def get_with_tag(tag_name)\n    open(\"#{@qiita_url}/tags/#{tag_name}/items?page=1&per_page=100\") do |uri|\n      @result_json = JSON.parse(uri.read, symbolize_names: true)\n    end\n    @result_json\n  end\n\nend\n```\n\n## QiitaArticle\n\n一つの記事についての情報を保持する。\n`has_tag?`メソッドでは, 大文字小文字にかかわらず判定が出来るよう`upcase`を使用している。\n\n```rb\nclass QiitaArticle\n\n  def initialize (article_hash)\n    @data = article_hash\n    @title = article_hash[:title]\n    @url = \"http://qiita.com/api/v2/items/#{article_hash[:id]}\"\n    @tags = article_hash[:tags].map { |tag| tag[:name] }\n    @body = article_hash[:body]\n  end\n\n  attr_reader :title, :url, :tags, :body\n\n  def has_tag?(tag_name)\n    tags = @data[:tags]\n    tags.any?{ |tag_info| tag_info[:name].upcase == tag_name.upcase }\n  end\n\nend\n```\n\n## MultiTagsSearcher\n\nこれがメインのクラス。コンストラクタに`QiitaApiAccessor#get_with_tag`の戻り値と検索したいタグのリストを渡してやる。\n`group_by_relevance`によって含んでいる対象タグの数によってグループ化する。\n\n```rb\nclass MultiTagsSearcher\n\n  def initialize(articles_data, tags)\n    @articles = articles_data.map { |data| QiitaArticle.new(data) }\n    @tags = tags\n  end\n\n  attr_reader :articles\n\n  def group_by_relevance\n    @articles.group_by do |article|\n      @tags.count { |tag| article.has_tag?(tag) }\n    end\n  end\n\nend\n```\n\n## 使い方\n\n`QiitaApiAccessor#get_with_tag`にメインとなるキーワードタグを渡す。\nその戻り値と、キーワードタグを含む検索したいタグ名のリストを、`MultiTagsSearcher`に渡して`group_by_relevance`してやる。\nすると`含んでいる対象タグ数 => [QiitaArticleのインスタンス]`というハッシュが得られるので、適当に`QiitaArticle#url`とかで記事の url を取ってこられます。\n\n## 問題点・改善点\n\nQiitaAPI の都合上一度に 100 件までしか記事の情報を取得できないので, 本当はループで全件取得してから`MultiTagsSearcher`に渡したい。\nが、そうすると 5000 件とか普通に行く場合もあるから`QiitaArticle`のインスタンスが無駄に大量生成されてしまうし、時間もかかる。\nなので、検索の際のキーワードタグには記事数の少なそうなものを選ぶことでお茶を濁す...\n`ruby`ではなく`sinatra`をキーワードにするだけで結果がかなり違ってくる。\nけどそれじゃ根本的な解決になってない。なにか良い方法ありましたら教えて下さい。\n","contentMarkdown":"\nRuby 初心者なのでなにかお気づきの点がありましたらご教授いただけると幸いです。\n\n## QiitaApiAccessor\n\nQiitaAPI との通信, 受信情報のハッシュ化を担当している。\n`@result_json`をローカル変数にしたいのだけど, `open`ブロック内のローカル変数になってしまうので出来ない...\n`get_with_tag`内のローカル変数にならできるけど結局`result_json = {}`として`open`内で更新みたいな書き方になってしまって綺麗じゃない...\n\n```ruby\nrequire 'open-uri'\nrequire 'json'\n\nclass QiitaApiAccessor\n\n  def initialize\n    @qiita_url = 'http://qiita.com/api/v2'\n    @result_json = {}\n  end\n\n  def get_with_tag(tag_name)\n    open(\"#{@qiita_url}/tags/#{tag_name}/items?page=1&per_page=100\") do |uri|\n      @result_json = JSON.parse(uri.read, symbolize_names: true)\n    end\n    @result_json\n  end\n\nend\n```\n\n## QiitaArticle\n\n一つの記事についての情報を保持する。\n`has_tag?`メソッドでは, 大文字小文字にかかわらず判定が出来るよう`upcase`を使用している。\n\n```rb\nclass QiitaArticle\n\n  def initialize (article_hash)\n    @data = article_hash\n    @title = article_hash[:title]\n    @url = \"http://qiita.com/api/v2/items/#{article_hash[:id]}\"\n    @tags = article_hash[:tags].map { |tag| tag[:name] }\n    @body = article_hash[:body]\n  end\n\n  attr_reader :title, :url, :tags, :body\n\n  def has_tag?(tag_name)\n    tags = @data[:tags]\n    tags.any?{ |tag_info| tag_info[:name].upcase == tag_name.upcase }\n  end\n\nend\n```\n\n## MultiTagsSearcher\n\nこれがメインのクラス。コンストラクタに`QiitaApiAccessor#get_with_tag`の戻り値と検索したいタグのリストを渡してやる。\n`group_by_relevance`によって含んでいる対象タグの数によってグループ化する。\n\n```rb\nclass MultiTagsSearcher\n\n  def initialize(articles_data, tags)\n    @articles = articles_data.map { |data| QiitaArticle.new(data) }\n    @tags = tags\n  end\n\n  attr_reader :articles\n\n  def group_by_relevance\n    @articles.group_by do |article|\n      @tags.count { |tag| article.has_tag?(tag) }\n    end\n  end\n\nend\n```\n\n## 使い方\n\n`QiitaApiAccessor#get_with_tag`にメインとなるキーワードタグを渡す。\nその戻り値と、キーワードタグを含む検索したいタグ名のリストを、`MultiTagsSearcher`に渡して`group_by_relevance`してやる。\nすると`含んでいる対象タグ数 => [QiitaArticleのインスタンス]`というハッシュが得られるので、適当に`QiitaArticle#url`とかで記事の url を取ってこられます。\n\n## 問題点・改善点\n\nQiitaAPI の都合上一度に 100 件までしか記事の情報を取得できないので, 本当はループで全件取得してから`MultiTagsSearcher`に渡したい。\nが、そうすると 5000 件とか普通に行く場合もあるから`QiitaArticle`のインスタンスが無駄に大量生成されてしまうし、時間もかかる。\nなので、検索の際のキーワードタグには記事数の少なそうなものを選ぶことでお茶を濁す...\n`ruby`ではなく`sinatra`をキーワードにするだけで結果がかなり違ってくる。\nけどそれじゃ根本的な解決になってない。なにか良い方法ありましたら教えて下さい。\n","slug":"QiitaAPIを通じて複数のタグを持つ記事を検索する","title":"QiitaAPIを通じて複数のタグを持つ記事を検索する","timestamp":1413191503000,"tags":["Qiita","Ruby"]}]},"__N_SSG":true}