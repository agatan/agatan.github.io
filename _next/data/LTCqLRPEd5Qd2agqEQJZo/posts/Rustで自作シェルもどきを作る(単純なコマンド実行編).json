{"pageProps":{"post":{"content":"<p>コード全文はこちら\n<a href=\"https://github.com/agatan/rsh\">agatan/rsh</a></p>\n<p><a href=\"http://qiita.com/agatan/items/8a097ead46df1c1659ff\">Rust で自作シェルもどきを作る(字句解析編) - Qiita</a></p>\n<p>前回はユーザからの入力を受け付けてパースするところまで実装したので、今回は実際に入力されたコマンドを実行させてみます。<br>\nただし、いきなりいろいろやるのはきついので、まずは単純なコマンド(パイプやリダイレクトは一旦無視します)の実行をやってみました。</p>\n<h2>Command</h2>\n<p>Rust には<code>std::io::process::Command</code>という構造体があります。これを使えば簡単にコマンド実行は出来そうです。</p>\n<blockquote>\n<p><a href=\"http://doc.rust-lang.org/std/io/process/struct.Command.html%E3%82%88%E3%82%8A%E5%BC%95%E7%94%A8\">http://doc.rust-lang.org/std/io/process/struct.Command.htmlより引用</a></p>\n<div class=\"remark-highlight\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>io<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">Command</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n</blockquote>\n<blockquote>\n<p>let mut process = match Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").spawn() {\nOk(p) => p,\nErr(e) => panic!(\"failed to execute process: {}\", e),\n};</p>\n</blockquote>\n<blockquote>\n<p>let output = process.stdout.as_mut().unwrap().read_to_end();</p>\n</blockquote>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">\nいろいろと便利そうな関数が定義されているのですが、今回は最も単純にコマンドを実行させるために、`output`という関数を使用してみました。\n\n```rust:exec.rs\nuse std;\nuse std::io::process::Command;\n\nuse parse::Token;\n\npub fn exec(tokens: Vec&#x26;lt;Token&#x26;gt;) {\n    if tokens.iter()\n             .find(|&#x26;amp;t| match t {\n                 &#x26;amp;Token::Str(_) =&#x26;gt; false, _ =&#x26;gt; true } ).is_some() {\n        panic!(&#x26;quot;Not implemented yet.&#x26;quot;);\n    }\n    let first_cmd = tokens.iter()\n                          .take_while(|&#x26;amp;t| match t {\n                              &#x26;amp;Token::Str(_) =&#x26;gt; true,\n                              _ =&#x26;gt; false\n                          })\n                          .map(|ref t| match *t {\n                              &#x26;amp;Token::Str(ref x) =&#x26;gt; x.clone(),\n                              _ =&#x26;gt; panic!(&#x26;quot;Shouldn&#x26;#39;t be reached.&#x26;quot;),\n                          })\n                          .collect::&#x26;lt;Vec&#x26;lt;String&#x26;gt;&#x26;gt;();\n\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .output() {\n        Ok(p) =&#x26;gt; p,\n        Err(e) =&#x26;gt; panic!(&#x26;quot;Failed to execute: {}&#x26;quot;, e),\n    };\n\n    print!(&#x26;quot;{}&#x26;quot;, String::from_utf8_lossy(output.output.as_slice()));\n\n}</code></pre></div>\n<p><code>exec</code>は<code>Vec&#x3C;Token></code>を受け取る関数です。\n今回はパイプなどは未実装ですから、<code>Str(_)</code>以外の<code>Token</code>が含まれていたら<code>panic!</code>(例外送出)をしています。</p>\n<p>さて、<code>Command</code>は<code>new</code>で実行したいコマンド名を指定し、それに続けて<code>arg</code>や<code>args</code>で引数を追加していきます。\nユーザからの入力を利用しているので、ひとつずつしか追加できない<code>arg</code>よりは、スライスを渡して複数追加できる<code>args</code>を使いたいです。</p>\n<p>これらにあわせて<code>Vec&#x3C;Token></code>を<code>Vec&#x3C;String></code>もしくは<code>Vec&#x3C;&#x26;str></code>に変換してあげれば良さそうです。\nということで<code>let first_cmd = ...</code>という長い文は、その変換を行っています。</p>\n<p>正直まだ<code>&#x26;</code>と<code>ref</code>の関係とか所有権の問題はきちんと理解できていないというか書き方がよくわかっていないので、コンパイラに怒ってもらいながらなんとか直してみました。\nコンパイルを通るように、を第一に書いていったので汚かったり効率悪かったりするかもしれません...</p>\n<p>あとは<code>Command</code>に登録していって、<code>output</code>を読んであげれば完了です。\nただし<code>output</code>はバイト列を返すみたいなので、<code>String::from_utf8_lossy</code>を使って、文字に直してあげます。</p>\n<h4>追記(2014/12/21)</h4>\n<hr>\n<p>このままだと標準入力や標準出力、標準エラー出力が子プロセスと結びついておらず、仮想のパイプとつながったような状態になるようです。\nそのため、標準入力から読み取るような関数を実行しようとするとそのプロセスは失敗します。</p>\n<p>修正したのが以下のコードです。(<code>Command</code>を作成する部分のみ)</p>\n<div class=\"remark-highlight\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> output <span class=\"token operator\">=</span> <span class=\"token keyword\">match</span> <span class=\"token class-name\">Command</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span>first_cmd<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">as_slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                              <span class=\"token punctuation\">.</span><span class=\"token function\">args</span><span class=\"token punctuation\">(</span>first_cmd<span class=\"token punctuation\">.</span><span class=\"token function\">as_slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">tail</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                              <span class=\"token punctuation\">.</span><span class=\"token function\">stdin</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StdioContainer</span><span class=\"token punctuation\">::</span><span class=\"token class-name\">InheritFd</span><span class=\"token punctuation\">(</span><span class=\"token constant\">STDIN_FILENO</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                              <span class=\"token punctuation\">.</span><span class=\"token function\">stdout</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StdioContainer</span><span class=\"token punctuation\">::</span><span class=\"token class-name\">InheritFd</span><span class=\"token punctuation\">(</span><span class=\"token constant\">STDOUT_FILENO</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                              <span class=\"token punctuation\">.</span><span class=\"token function\">stderr</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StdioContainer</span><span class=\"token punctuation\">::</span><span class=\"token class-name\">InheritFd</span><span class=\"token punctuation\">(</span><span class=\"token constant\">STDERR_FILENO</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                              <span class=\"token punctuation\">.</span><span class=\"token function\">spawn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> p<span class=\"token punctuation\">,</span>\n        <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token macro property\">panic!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ERROR: {}\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span>\n                              <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">match</span> output<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Exit: {}\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error: {}\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>このように、<code>stdout</code>を標準出力と関連付けることで、前のコードでの<code>output</code>から読み取って文字列に変換して出力、という手順は不要になりました。\nC 言語では<code>fork</code>したら<code>wait</code>しろと言われて育ってきたので、とりあえず<code>wait</code>を入れてみていますが、どうも<code>wait</code>を入れなくてもゾンビプロセスが残っているようには見えないので謎です。\n調査中です。</p>\n<h3>追記ここまで</h3>\n<h2>main</h2>\n<p>先ほどの<code>exec</code>関数を<code>main</code>で使える形にしてみます。</p>\n<div class=\"remark-highlight\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span></span>io<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">mod</span> <span class=\"token module-declaration namespace\">parse</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">mod</span> <span class=\"token module-declaration namespace\">exec</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">loop</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token macro property\">print!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"% > \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">let</span> input <span class=\"token operator\">=</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>io<span class=\"token punctuation\">::</span></span><span class=\"token function\">stdin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">read_line</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ok</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">expect</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Failed to read.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">let</span> parser <span class=\"token operator\">=</span> <span class=\"token namespace\">parse<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">Parser</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">let</span> tokens<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Vec</span><span class=\"token operator\">&#x3C;</span><span class=\"token namespace\">parse<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">Token</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> parser<span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token namespace\">exec<span class=\"token punctuation\">::</span></span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>tokens<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>プロンプトを表示してからユーザーの入力を受付け、パースして<code>Vec&#x3C;Token></code>になおしてから<code>exec</code>に渡しています。</p>\n<h2>実行結果</h2>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">% &#x26;gt; echo hello\nhello\n% &#x26;gt; echo &#x26;quot;hello world&#x26;quot;\n&#x26;quot;hello world&#x26;quot;\n% &#x26;gt;</code></pre></div>\n<p>あれ？<code>\"</code>の扱いなんて考えてなかったのになぜかうまくいってますね。不思議。</p>\n<p>検証用に<code>main.rs</code>を書き換えて実行してみました。</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">% &#x26;gt; echo hello\nStr(echo)\nStr(hello)\nhello\n% &#x26;gt; echo &#x26;quot;hello world&#x26;quot;\nStr(echo)\nStr(&#x26;quot;hello)\nStr(world&#x26;quot;)\n&#x26;quot;hello world&#x26;quot;\n% &#x26;gt; echo &#x26;quot;hello     world&#x26;quot;\nStr(echo)\nStr(&#x26;quot;hello)\nStr(world&#x26;quot;)\n&#x26;quot;hello world&#x26;quot;\n% &#x26;gt;</code></pre></div>\n<p><code>echo</code>がうまくやってくれているみたいですね。すごい。</p>\n<h2>今後</h2>\n<p>次はリダイレクト関連ですかね。パイプや&#x26;よりも簡単そうだし。\n毎度のことですが、ご指摘大歓迎です！色々な意見を伺いたくてこれを書いているので、何かありましたらぜひよろしくお願いします！</p>\n<p><a href=\"https://github.com/agatan/rsh\">agatan/rsh</a></p>\n","meta":{"rawMarkdown":"---\ntitle: \"Rustで自作シェルもどきを作る(単純なコマンド実行編)\"\ndate: 2014-12-21T14:55:51+09:00\ntags: [\"Rust\"]\nurl: https://qiita.com/agatan/items/ed2780628d20a0e343b8\n---\n\nコード全文はこちら\n[agatan/rsh](https://github.com/agatan/rsh)\n\n[Rust で自作シェルもどきを作る(字句解析編) - Qiita](http://qiita.com/agatan/items/8a097ead46df1c1659ff)\n\n前回はユーザからの入力を受け付けてパースするところまで実装したので、今回は実際に入力されたコマンドを実行させてみます。  \nただし、いきなりいろいろやるのはきついので、まずは単純なコマンド(パイプやリダイレクトは一旦無視します)の実行をやってみました。\n\n## Command\n\nRust には`std::io::process::Command`という構造体があります。これを使えば簡単にコマンド実行は出来そうです。\n\n> http://doc.rust-lang.org/std/io/process/struct.Command.htmlより引用\n>\n> ```rust\n> use std::io::Command;\n> ```\n\n> let mut process = match Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").spawn() {\n> Ok(p) => p,\n> Err(e) => panic!(\"failed to execute process: {}\", e),\n> };\n\n> let output = process.stdout.as_mut().unwrap().read_to_end();\n\n````\n\nいろいろと便利そうな関数が定義されているのですが、今回は最も単純にコマンドを実行させるために、`output`という関数を使用してみました。\n\n```rust:exec.rs\nuse std;\nuse std::io::process::Command;\n\nuse parse::Token;\n\npub fn exec(tokens: Vec<Token>) {\n    if tokens.iter()\n             .find(|&t| match t {\n                 &Token::Str(_) => false, _ => true } ).is_some() {\n        panic!(\"Not implemented yet.\");\n    }\n    let first_cmd = tokens.iter()\n                          .take_while(|&t| match t {\n                              &Token::Str(_) => true,\n                              _ => false\n                          })\n                          .map(|ref t| match *t {\n                              &Token::Str(ref x) => x.clone(),\n                              _ => panic!(\"Shouldn't be reached.\"),\n                          })\n                          .collect::<Vec<String>>();\n\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .output() {\n        Ok(p) => p,\n        Err(e) => panic!(\"Failed to execute: {}\", e),\n    };\n\n    print!(\"{}\", String::from_utf8_lossy(output.output.as_slice()));\n\n}\n````\n\n`exec`は`Vec<Token>`を受け取る関数です。\n今回はパイプなどは未実装ですから、`Str(_)`以外の`Token`が含まれていたら`panic!`(例外送出)をしています。\n\nさて、`Command`は`new`で実行したいコマンド名を指定し、それに続けて`arg`や`args`で引数を追加していきます。\nユーザからの入力を利用しているので、ひとつずつしか追加できない`arg`よりは、スライスを渡して複数追加できる`args`を使いたいです。\n\nこれらにあわせて`Vec<Token>`を`Vec<String>`もしくは`Vec<&str>`に変換してあげれば良さそうです。\nということで`let first_cmd = ...`という長い文は、その変換を行っています。\n\n正直まだ`&`と`ref`の関係とか所有権の問題はきちんと理解できていないというか書き方がよくわかっていないので、コンパイラに怒ってもらいながらなんとか直してみました。\nコンパイルを通るように、を第一に書いていったので汚かったり効率悪かったりするかもしれません...\n\nあとは`Command`に登録していって、`output`を読んであげれば完了です。\nただし`output`はバイト列を返すみたいなので、`String::from_utf8_lossy`を使って、文字に直してあげます。\n\n#### 追記(2014/12/21)\n\n---\n\nこのままだと標準入力や標準出力、標準エラー出力が子プロセスと結びついておらず、仮想のパイプとつながったような状態になるようです。\nそのため、標準入力から読み取るような関数を実行しようとするとそのプロセスは失敗します。\n\n修正したのが以下のコードです。(`Command`を作成する部分のみ)\n\n```rust\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .stdin(StdioContainer::InheritFd(STDIN_FILENO))\n                              .stdout(StdioContainer::InheritFd(STDOUT_FILENO))\n                              .stderr(StdioContainer::InheritFd(STDERR_FILENO))\n                              .spawn() {\n        Ok(p) => p,\n        Err(e) => panic!(\"ERROR: {}\", e)\n                              };\n    match output.wait() {\n        Ok(e) => println!(\"Exit: {}\", e),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n```\n\nこのように、`stdout`を標準出力と関連付けることで、前のコードでの`output`から読み取って文字列に変換して出力、という手順は不要になりました。\nC 言語では`fork`したら`wait`しろと言われて育ってきたので、とりあえず`wait`を入れてみていますが、どうも`wait`を入れなくてもゾンビプロセスが残っているようには見えないので謎です。\n調査中です。\n\n### 追記ここまで\n\n## main\n\n先ほどの`exec`関数を`main`で使える形にしてみます。\n\n```rust:main.rs\nuse std::io;\nmod parse;\nmod exec;\n\nfn main() {\n    loop {\n        print!(\"% > \");\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let parser = parse::Parser::new(input);\n        let tokens: Vec<parse::Token> = parser.collect();\n        exec::exec(tokens);\n    }\n}\n```\n\nプロンプトを表示してからユーザーの入力を受付け、パースして`Vec<Token>`になおしてから`exec`に渡しています。\n\n## 実行結果\n\n```\n% > echo hello\nhello\n% > echo \"hello world\"\n\"hello world\"\n% >\n```\n\nあれ？`\"`の扱いなんて考えてなかったのになぜかうまくいってますね。不思議。\n\n検証用に`main.rs`を書き換えて実行してみました。\n\n```\n% > echo hello\nStr(echo)\nStr(hello)\nhello\n% > echo \"hello world\"\nStr(echo)\nStr(\"hello)\nStr(world\")\n\"hello world\"\n% > echo \"hello     world\"\nStr(echo)\nStr(\"hello)\nStr(world\")\n\"hello world\"\n% >\n```\n\n`echo`がうまくやってくれているみたいですね。すごい。\n\n## 今後\n\n次はリダイレクト関連ですかね。パイプや&よりも簡単そうだし。\n毎度のことですが、ご指摘大歓迎です！色々な意見を伺いたくてこれを書いているので、何かありましたらぜひよろしくお願いします！\n\n[agatan/rsh](https://github.com/agatan/rsh)\n","contentMarkdown":"\nコード全文はこちら\n[agatan/rsh](https://github.com/agatan/rsh)\n\n[Rust で自作シェルもどきを作る(字句解析編) - Qiita](http://qiita.com/agatan/items/8a097ead46df1c1659ff)\n\n前回はユーザからの入力を受け付けてパースするところまで実装したので、今回は実際に入力されたコマンドを実行させてみます。  \nただし、いきなりいろいろやるのはきついので、まずは単純なコマンド(パイプやリダイレクトは一旦無視します)の実行をやってみました。\n\n## Command\n\nRust には`std::io::process::Command`という構造体があります。これを使えば簡単にコマンド実行は出来そうです。\n\n> http://doc.rust-lang.org/std/io/process/struct.Command.htmlより引用\n>\n> ```rust\n> use std::io::Command;\n> ```\n\n> let mut process = match Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").spawn() {\n> Ok(p) => p,\n> Err(e) => panic!(\"failed to execute process: {}\", e),\n> };\n\n> let output = process.stdout.as_mut().unwrap().read_to_end();\n\n````\n\nいろいろと便利そうな関数が定義されているのですが、今回は最も単純にコマンドを実行させるために、`output`という関数を使用してみました。\n\n```rust:exec.rs\nuse std;\nuse std::io::process::Command;\n\nuse parse::Token;\n\npub fn exec(tokens: Vec<Token>) {\n    if tokens.iter()\n             .find(|&t| match t {\n                 &Token::Str(_) => false, _ => true } ).is_some() {\n        panic!(\"Not implemented yet.\");\n    }\n    let first_cmd = tokens.iter()\n                          .take_while(|&t| match t {\n                              &Token::Str(_) => true,\n                              _ => false\n                          })\n                          .map(|ref t| match *t {\n                              &Token::Str(ref x) => x.clone(),\n                              _ => panic!(\"Shouldn't be reached.\"),\n                          })\n                          .collect::<Vec<String>>();\n\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .output() {\n        Ok(p) => p,\n        Err(e) => panic!(\"Failed to execute: {}\", e),\n    };\n\n    print!(\"{}\", String::from_utf8_lossy(output.output.as_slice()));\n\n}\n````\n\n`exec`は`Vec<Token>`を受け取る関数です。\n今回はパイプなどは未実装ですから、`Str(_)`以外の`Token`が含まれていたら`panic!`(例外送出)をしています。\n\nさて、`Command`は`new`で実行したいコマンド名を指定し、それに続けて`arg`や`args`で引数を追加していきます。\nユーザからの入力を利用しているので、ひとつずつしか追加できない`arg`よりは、スライスを渡して複数追加できる`args`を使いたいです。\n\nこれらにあわせて`Vec<Token>`を`Vec<String>`もしくは`Vec<&str>`に変換してあげれば良さそうです。\nということで`let first_cmd = ...`という長い文は、その変換を行っています。\n\n正直まだ`&`と`ref`の関係とか所有権の問題はきちんと理解できていないというか書き方がよくわかっていないので、コンパイラに怒ってもらいながらなんとか直してみました。\nコンパイルを通るように、を第一に書いていったので汚かったり効率悪かったりするかもしれません...\n\nあとは`Command`に登録していって、`output`を読んであげれば完了です。\nただし`output`はバイト列を返すみたいなので、`String::from_utf8_lossy`を使って、文字に直してあげます。\n\n#### 追記(2014/12/21)\n\n---\n\nこのままだと標準入力や標準出力、標準エラー出力が子プロセスと結びついておらず、仮想のパイプとつながったような状態になるようです。\nそのため、標準入力から読み取るような関数を実行しようとするとそのプロセスは失敗します。\n\n修正したのが以下のコードです。(`Command`を作成する部分のみ)\n\n```rust\n    let mut output = match Command::new(first_cmd[0].as_slice())\n                              .args(first_cmd.as_slice().tail())\n                              .stdin(StdioContainer::InheritFd(STDIN_FILENO))\n                              .stdout(StdioContainer::InheritFd(STDOUT_FILENO))\n                              .stderr(StdioContainer::InheritFd(STDERR_FILENO))\n                              .spawn() {\n        Ok(p) => p,\n        Err(e) => panic!(\"ERROR: {}\", e)\n                              };\n    match output.wait() {\n        Ok(e) => println!(\"Exit: {}\", e),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n```\n\nこのように、`stdout`を標準出力と関連付けることで、前のコードでの`output`から読み取って文字列に変換して出力、という手順は不要になりました。\nC 言語では`fork`したら`wait`しろと言われて育ってきたので、とりあえず`wait`を入れてみていますが、どうも`wait`を入れなくてもゾンビプロセスが残っているようには見えないので謎です。\n調査中です。\n\n### 追記ここまで\n\n## main\n\n先ほどの`exec`関数を`main`で使える形にしてみます。\n\n```rust:main.rs\nuse std::io;\nmod parse;\nmod exec;\n\nfn main() {\n    loop {\n        print!(\"% > \");\n        let input = std::io::stdin().read_line().ok().expect(\"Failed to read.\");\n        let parser = parse::Parser::new(input);\n        let tokens: Vec<parse::Token> = parser.collect();\n        exec::exec(tokens);\n    }\n}\n```\n\nプロンプトを表示してからユーザーの入力を受付け、パースして`Vec<Token>`になおしてから`exec`に渡しています。\n\n## 実行結果\n\n```\n% > echo hello\nhello\n% > echo \"hello world\"\n\"hello world\"\n% >\n```\n\nあれ？`\"`の扱いなんて考えてなかったのになぜかうまくいってますね。不思議。\n\n検証用に`main.rs`を書き換えて実行してみました。\n\n```\n% > echo hello\nStr(echo)\nStr(hello)\nhello\n% > echo \"hello world\"\nStr(echo)\nStr(\"hello)\nStr(world\")\n\"hello world\"\n% > echo \"hello     world\"\nStr(echo)\nStr(\"hello)\nStr(world\")\n\"hello world\"\n% >\n```\n\n`echo`がうまくやってくれているみたいですね。すごい。\n\n## 今後\n\n次はリダイレクト関連ですかね。パイプや&よりも簡単そうだし。\n毎度のことですが、ご指摘大歓迎です！色々な意見を伺いたくてこれを書いているので、何かありましたらぜひよろしくお願いします！\n\n[agatan/rsh](https://github.com/agatan/rsh)\n","slug":"Rustで自作シェルもどきを作る(単純なコマンド実行編)","title":"Rustで自作シェルもどきを作る(単純なコマンド実行編)","timestamp":1419141351000,"tags":["Rust"]}}},"__N_SSG":true}