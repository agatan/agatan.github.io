{"pageProps":{"post":{"content":"<p>Ruby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。</p>\n<p>少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。</p>\n<p><a href=\"http://qiita.com/agatan/items/af0c3bbc881f60667c85\">Ruby で Linux コマンドの再実装(ls 編) - Qiita</a>\n<a href=\"http://qiita.com/agatan/items/4c50554ae22aa4181cc1\">Ruby で Linux コマンドの再実装(tree 編) - Qiita</a></p>\n<h2>ls</h2>\n<p>ではまずは<code>ls</code>です。簡単そうだったし個人的に一番良く使うコマンドなので。</p>\n<div class=\"remark-highlight\"><pre class=\"language-rb\"><code class=\"language-rb\"><span class=\"token comment\">#! /usr/bin/env ruby</span>\n<span class=\"token comment\">#</span>\n<span class=\"token comment\"># ls: 引数なしの場合現在のディレクトリの状態を返す。</span>\n<span class=\"token comment\">#     引数ありの場合そのディレクトリの状態を返す。</span>\n\ntarget <span class=\"token operator\">=</span> <span class=\"token constant\">ARGV</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token builtin\">Dir</span><span class=\"token punctuation\">.</span>pwd\n\nentries <span class=\"token operator\">=</span> <span class=\"token builtin\">Dir</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>entries<span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span>\n\nentries<span class=\"token punctuation\">.</span>select<span class=\"token operator\">!</span><span class=\"token punctuation\">{</span><span class=\"token operator\">|</span>entry<span class=\"token operator\">|</span> entry<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token string\">'.'</span><span class=\"token punctuation\">}</span>\n\nentries<span class=\"token punctuation\">.</span>map<span class=\"token operator\">!</span> <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>entry<span class=\"token operator\">|</span>\n  <span class=\"token keyword\">if</span> <span class=\"token builtin\">File</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>directory<span class=\"token operator\">?</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">File</span><span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> entry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span>entry<span class=\"token delimiter tag\">}</span></span>/\"</span>\n  <span class=\"token keyword\">else</span>\n    entry\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n\nputs entries<span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<p>ディレクトリの場合は末尾に<code>/</code>をつけるようにしています。</p>\n<p><code>-a</code>オプションで隠しファイル隠しディレクトリも表示するようにしたり, <code>--color</code>オプションで色をつけたりすることが目標です。</p>\n<p>コマンドライン引数の順番や, <code>-a -l -F</code>と<code>-alF</code>などややこしそうな部分は制約をつけてお茶を濁してしまうかもしれません...</p>\n<h3>追記</h3>\n<hr>\n<p>@riocampos さんにコメントでコマンドライン引数の利用方法を教えていただきました！\n<code>require 'optparse'</code>とすればパーサが利用できるようになります。</p>\n<p>というわけでこれを反映し修正したものがこちらです。</p>\n<div class=\"remark-highlight\"><pre class=\"language-ls\"><code class=\"language-ls\">#! /usr/bin/env ruby -w\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\nrequire &#x26;#39;optparse&#x26;#39;\n\ndef set_color_and_reset(entry, color)\n  case color\n  when :red\n    &#x26;quot;\\e[31m#{entry}\\e[0m&#x26;quot;\n  when :green\n    &#x26;quot;\\e[32m#{entry}\\e[0m&#x26;quot;\n  when :blue\n    &#x26;quot;\\e[34m#{entry}\\e[0m&#x26;quot;\n  when :cyan\n    &#x26;quot;\\e[36m#{entry}\\e[0m&#x26;quot;\n  else\n    entry\n  end\nend\n\noptions = ARGV.getopts(&#x26;#39;aF&#x26;#39;, &#x26;#39;color&#x26;#39;)\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir.entries(target)\n\nif options[&#x26;#39;a&#x26;#39;]\n  options[&#x26;#39;a&#x26;#39;] = false\nelse\n  entries.select! { |entry| entry[0] != &#x26;#39;.&#x26;#39; }\nend\n\nif options.value? true\n  entries.map! do |entry|\n    fullpath = &#x26;quot;#{target}/#{entry}&#x26;quot;\n    case\n    when File.directory?(fullpath)\n      entry = set_color_and_reset entry, :blue if options[&#x26;#39;color&#x26;#39;]\n      entry += &#x26;#39;/&#x26;#39; if options[&#x26;#39;F&#x26;#39;]\n    when File.symlink?(fullpath)\n      entry = set_color_and_reset entry, :cyan if options[&#x26;#39;color&#x26;#39;]\n      entry += &#x26;#39;@&#x26;#39; if options[&#x26;#39;F&#x26;#39;]\n    when File.executable?(fullpath)\n      entry = set_color_and_reset entry, :red if options[&#x26;#39;color&#x26;#39;]\n      entry += &#x26;#39;*&#x26;#39; if options[&#x26;#39;F&#x26;#39;]\n    end\n    entry\n  end\nend\n\nputs entries.join(&#x26;#39; &#x26;#39;)</code></pre></div>\n<p><code>-l</code>オプションは対応していません...<code>-aF --color</code>に対応しました。\n表示の桁揃えとかしたほうが綺麗なんでしょうけれど...</p>\n<p>次は<code>tree</code>に挑戦してみます。</p>\n","meta":{"rawMarkdown":"---\ntitle: \"RubyでLinuxコマンドの再実装(ls編)\"\ndate: 2014-10-13T23:10:08+09:00\ntags: [\"Ruby\", \"Linux\"]\nurl: https://qiita.com/agatan/items/af0c3bbc881f60667c85\n---\n\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## ls\n\nではまずは`ls`です。簡単そうだったし個人的に一番良く使うコマンドなので。\n\n```rb\n#! /usr/bin/env ruby\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir::entries(target)\n\nentries.select!{|entry| entry[0] != '.'}\n\nentries.map! do |entry|\n  if File::directory?(File.join(target, entry))\n    \"#{entry}/\"\n  else\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\nディレクトリの場合は末尾に`/`をつけるようにしています。\n\n`-a`オプションで隠しファイル隠しディレクトリも表示するようにしたり, `--color`オプションで色をつけたりすることが目標です。\n\nコマンドライン引数の順番や, `-a -l -F`と`-alF`などややこしそうな部分は制約をつけてお茶を濁してしまうかもしれません...\n\n### 追記\n\n---\n\n@riocampos さんにコメントでコマンドライン引数の利用方法を教えていただきました！\n`require 'optparse'`とすればパーサが利用できるようになります。\n\nというわけでこれを反映し修正したものがこちらです。\n\n```ls.rb\n#! /usr/bin/env ruby -w\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\nrequire 'optparse'\n\ndef set_color_and_reset(entry, color)\n  case color\n  when :red\n    \"\\e[31m#{entry}\\e[0m\"\n  when :green\n    \"\\e[32m#{entry}\\e[0m\"\n  when :blue\n    \"\\e[34m#{entry}\\e[0m\"\n  when :cyan\n    \"\\e[36m#{entry}\\e[0m\"\n  else\n    entry\n  end\nend\n\noptions = ARGV.getopts('aF', 'color')\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir.entries(target)\n\nif options['a']\n  options['a'] = false\nelse\n  entries.select! { |entry| entry[0] != '.' }\nend\n\nif options.value? true\n  entries.map! do |entry|\n    fullpath = \"#{target}/#{entry}\"\n    case\n    when File.directory?(fullpath)\n      entry = set_color_and_reset entry, :blue if options['color']\n      entry += '/' if options['F']\n    when File.symlink?(fullpath)\n      entry = set_color_and_reset entry, :cyan if options['color']\n      entry += '@' if options['F']\n    when File.executable?(fullpath)\n      entry = set_color_and_reset entry, :red if options['color']\n      entry += '*' if options['F']\n    end\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\n`-l`オプションは対応していません...`-aF --color`に対応しました。\n表示の桁揃えとかしたほうが綺麗なんでしょうけれど...\n\n次は`tree`に挑戦してみます。\n","contentMarkdown":"\nRuby の勉強に Ruby で有名ドコロの Linux コマンドたちを再実装してみたいとおもいます。\n\n少しずつ追記する形にできればと思っています。よりよい実装方法などありましたらぜひご教授いただけると幸いです。\n\n[Ruby で Linux コマンドの再実装(ls 編) - Qiita](http://qiita.com/agatan/items/af0c3bbc881f60667c85)\n[Ruby で Linux コマンドの再実装(tree 編) - Qiita](http://qiita.com/agatan/items/4c50554ae22aa4181cc1)\n\n## ls\n\nではまずは`ls`です。簡単そうだったし個人的に一番良く使うコマンドなので。\n\n```rb\n#! /usr/bin/env ruby\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir::entries(target)\n\nentries.select!{|entry| entry[0] != '.'}\n\nentries.map! do |entry|\n  if File::directory?(File.join(target, entry))\n    \"#{entry}/\"\n  else\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\nディレクトリの場合は末尾に`/`をつけるようにしています。\n\n`-a`オプションで隠しファイル隠しディレクトリも表示するようにしたり, `--color`オプションで色をつけたりすることが目標です。\n\nコマンドライン引数の順番や, `-a -l -F`と`-alF`などややこしそうな部分は制約をつけてお茶を濁してしまうかもしれません...\n\n### 追記\n\n---\n\n@riocampos さんにコメントでコマンドライン引数の利用方法を教えていただきました！\n`require 'optparse'`とすればパーサが利用できるようになります。\n\nというわけでこれを反映し修正したものがこちらです。\n\n```ls.rb\n#! /usr/bin/env ruby -w\n#\n# ls: 引数なしの場合現在のディレクトリの状態を返す。\n#     引数ありの場合そのディレクトリの状態を返す。\n\nrequire 'optparse'\n\ndef set_color_and_reset(entry, color)\n  case color\n  when :red\n    \"\\e[31m#{entry}\\e[0m\"\n  when :green\n    \"\\e[32m#{entry}\\e[0m\"\n  when :blue\n    \"\\e[34m#{entry}\\e[0m\"\n  when :cyan\n    \"\\e[36m#{entry}\\e[0m\"\n  else\n    entry\n  end\nend\n\noptions = ARGV.getopts('aF', 'color')\ntarget = ARGV[0] || Dir.pwd\n\nentries = Dir.entries(target)\n\nif options['a']\n  options['a'] = false\nelse\n  entries.select! { |entry| entry[0] != '.' }\nend\n\nif options.value? true\n  entries.map! do |entry|\n    fullpath = \"#{target}/#{entry}\"\n    case\n    when File.directory?(fullpath)\n      entry = set_color_and_reset entry, :blue if options['color']\n      entry += '/' if options['F']\n    when File.symlink?(fullpath)\n      entry = set_color_and_reset entry, :cyan if options['color']\n      entry += '@' if options['F']\n    when File.executable?(fullpath)\n      entry = set_color_and_reset entry, :red if options['color']\n      entry += '*' if options['F']\n    end\n    entry\n  end\nend\n\nputs entries.join(' ')\n```\n\n`-l`オプションは対応していません...`-aF --color`に対応しました。\n表示の桁揃えとかしたほうが綺麗なんでしょうけれど...\n\n次は`tree`に挑戦してみます。\n","slug":"RubyでLinuxコマンドの再実装(ls編)","title":"RubyでLinuxコマンドの再実装(ls編)","timestamp":1413209408000,"tags":["Ruby","Linux"]}}},"__N_SSG":true}