{"pageProps":{"post":{"content":"<p>Rust のパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>ライブラリの一つである <a href=\"https://github.com/Marwes/combine\">Marwes/combine: A parser combinator library for Rust</a> を使ってみています．<br/>\n詳しい使い方はきちんとしたドキュメントがあるのでそちらを参照してください．<br/>\nざっくりいうと <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> の <a href=\"https://hackage.haskell.org/package/parsec\">parsec: Monadic parser combinators | Hackage</a> の Rust 版という感じです．</p>\n<p>(ちなみに私も combine を参考に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>を作ってみたりしました. )\n<iframe src=\"http://agtn.hatenablog.com/embed/2016/04/30/003009\" title=\"C++ でパーサコンビネータを書きました - 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://agtn.hatenablog.com/entry/2016/04/30/003009\">agtn.hatenablog.com</a></cite></p>\n<p>で、このライブラリ、とても<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なコードで書かれているので、かなり<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間が増加します&hellip; (Boost.Spirit 系に近いです． <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーなどは遥かに読みやすいのであまり困ることはないですが)  <br/>\nパーサを書いている時にはテストは頻繁に行いたいので，ちょっと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>がおそいのはつらい．</p>\n<p>なにか解決策はないかなぁと思っていたら本家に issue がたっていました．<br/>\n<a href=\"https://github.com/Marwes/combine/issues/21\">Extremely long compile times · Issue #21 · Marwes/combine</a></p>\n<p>今回この issue にかかれていた内容を検証してみたので，ここでまとめておこうと思います．</p>\n<h2>結論</h2>\n<p>パーサの定義を，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体のメソッドとして定義すると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間が大幅に短くなる</p>\n<h2>方法</h2>\n<p>まずはじめに言われているのは，入力ストリーム型を<code>I: Stream&lt;Item=char&gt;</code> から <code>&amp;str</code> にしてしまうという方法です．</p>\n<blockquote><p>(It might be possible to specialize the parsers directly as well, say\n<code>\nfn expr(input: State&lt;&amp;str&gt;) -&gt; ParseResult&lt;Expr, &amp;str&gt;\n</code>\ninstead of\n<code>\nfn expr&lt;I: Stream&gt;(input: State&lt;I&gt;) -&gt; ParseResult&lt;I, &amp;str&gt;\n</code>\n)</p></blockquote>\n<p>これは作ったパーサを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な入力に対して適用することができなくなりますが，ライブラリの利用者側としては，<code>char</code> のストリームといったらだいたい <code>&amp;str</code> だと思うので，ぶっちゃけ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>じゃなくてもいいじゃんという感じです．</p>\n<p>そしてもう一つが,  <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体を作って，パーサの定義をその中に閉じ込めるという方法です．<br/>\nちょっとこちらはコード例を実際に見たほうがわかりやすいと思うので後で説明します．</p>\n<h2>実験コード</h2>\n<p>というわけで，</p>\n<ol>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なパーサ</li>\n<li>&amp;str のみを受理するパーサ</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体の中に定義された<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>でないパーサ</li>\n</ol>\n<p>の三種類について，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間をはかってみます．</p>\n<p>パーサ界のハローワールド，計算機で実験してみます．\nまずは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なパーサです．</p>\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synType\">*</span>;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">primitives</span><span class=\"synSpecial\">::</span>Stream;\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">integer</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synIdentifier\">many1</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>_<span class=\"synStatement\">&gt;</span>, _<span class=\"synStatement\">&gt;</span>(<span class=\"synIdentifier\">digit</span>())\n        .<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>is<span class=\"synStatement\">|</span> is.<span class=\"synIdentifier\">into_iter</span>().<span class=\"synIdentifier\">fold</span>(<span class=\"synConstant\">0</span>, <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> lhs <span class=\"synStatement\">+</span> (rhs <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span> <span class=\"synStatement\">-</span> <span class=\"synConstant\">'0'</span> <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span>)))\n        .<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">factor</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synIdentifier\">between</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'('</span>), <span class=\"synType\">char</span>(<span class=\"synConstant\">')'</span>), <span class=\"synIdentifier\">parser</span>(expr)).<span class=\"synIdentifier\">or</span>(<span class=\"synIdentifier\">parser</span>(integer)).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">term</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'*'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'/'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n        <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n            <span class=\"synConstant\">'*'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">*</span> rhs,\n            <span class=\"synConstant\">'/'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">/</span> rhs,\n            _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n        }\n    });\n    <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(factor), op).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">expr</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'+'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'-'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n        <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n            <span class=\"synConstant\">'+'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">+</span> rhs,\n            <span class=\"synConstant\">'-'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">-</span> rhs,\n            _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n        }\n    });\n    <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(term), op).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">parse</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: I) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span>(<span class=\"synType\">i64</span>, I), ParseError<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synIdentifier\">parser</span>(expr).<span class=\"synIdentifier\">parse</span>(input)\n}\n</pre>\n<p>それぞれの関数が一つのパーサの役割を担います．それぞれのパーサが独立していて，それぞれ別々に型変数を導入しています．</p>\n<p>次に <code>&amp;str</code> だけを受け取るパーサです．これは上記の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なパーサの，型変数を <code>&amp;str</code> に置き換えるだけなのでとても簡単です．<br/>\n一部だけ掲載します．</p>\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">expr</span>(input: State<span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, <span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;</span> {\n     <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'+'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'-'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n        <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n            <span class=\"synConstant\">'+'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">+</span> rhs,\n            <span class=\"synConstant\">'-'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">-</span> rhs,\n            _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n        }\n    });\n    <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(term), op).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">parse</span>(input: <span class=\"synType\">&amp;str</span>) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span>(<span class=\"synType\">i64</span>, <span class=\"synType\">&amp;str</span>), ParseError<span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;&gt;</span> {\n    <span class=\"synIdentifier\">parser</span>(expr).<span class=\"synIdentifier\">parse</span>(input)\n}\n</pre>\n<p>最後が，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体のメソッド中に，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>でないパーサを定義して閉じ込める方法です．</p>\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synType\">*</span>;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">primitives</span><span class=\"synSpecial\">::</span>Stream;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">std</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">marker</span><span class=\"synSpecial\">::</span>PhantomData;\n\n truct P<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(PhantomData<span class=\"synStatement\">&lt;fn</span>(I) <span class=\"synStatement\">-&gt;</span> I<span class=\"synStatement\">&gt;</span>);\n\n<span class=\"synStatement\">impl&lt;</span>I<span class=\"synStatement\">&gt;</span> P<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span> <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span> {\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">integer</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synIdentifier\">many1</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>_<span class=\"synStatement\">&gt;</span>, _<span class=\"synStatement\">&gt;</span>(<span class=\"synIdentifier\">digit</span>())\n            .<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>is<span class=\"synStatement\">|</span> is.<span class=\"synIdentifier\">into_iter</span>().<span class=\"synIdentifier\">fold</span>(<span class=\"synConstant\">0</span>, <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> lhs <span class=\"synStatement\">+</span> (rhs <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span> <span class=\"synStatement\">-</span> <span class=\"synConstant\">'0'</span> <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span>)))\n            .<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">factor</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synIdentifier\">between</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'('</span>), <span class=\"synType\">char</span>(<span class=\"synConstant\">')'</span>), <span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>expr))\n            .<span class=\"synIdentifier\">or</span>(<span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>integer))\n            .<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">term</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'*'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'/'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n            <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n                <span class=\"synConstant\">'*'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">*</span> rhs,\n                <span class=\"synConstant\">'/'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">/</span> rhs,\n                _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n            }\n        });\n        <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>factor), op).<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">expr</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'+'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'-'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n            <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n                <span class=\"synConstant\">'+'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">+</span> rhs,\n                <span class=\"synConstant\">'-'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">-</span> rhs,\n                _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n            }\n        });\n        <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>term), op).<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">parse</span>(input: <span class=\"synType\">&amp;str</span>) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span>(<span class=\"synType\">i64</span>, <span class=\"synType\">&amp;str</span>), ParseError<span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;&gt;</span> {\n    <span class=\"synIdentifier\">parser</span>(<span class=\"synPreProc\">P</span><span class=\"synSpecial\">::</span>expr).<span class=\"synIdentifier\">parse</span>(input)\n}\n</pre>\n<p>言葉で説明すると難しいのですが，型変数を導入する部分を構造体の定義部分だけにしてあげることで，型変数をそれぞれのパーサが別々に導入する必要がなくなっています．<br/>\nコードも割りとすっきりしますね．</p>\n<h2>結果</h2>\n<p>上記をコードを <code>cfg</code> を使って<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時に切り替えながら<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>してみました．<br/>\n本当はきちんと繰り返し計測すべきですが，ちょっとサボっています．まぁ何度実行してもだいたい同じくらいになったので許してください．</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left;\"> 実装方法 </th>\n<th style=\"text-align:right;\"> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left;\"> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a> </td>\n<td style=\"text-align:right;\"> 2.666s </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> <code>&amp;str</code> </td>\n<td style=\"text-align:right;\"> 1.70s </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> 構造体内で定義 </td>\n<td style=\"text-align:right;\"> 1.55s </td>\n</tr>\n</tbody>\n</table>\n<p>このような結果になりました．<br/>\nつまり，先ほどの issue で述べられている<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間の短縮方法はかなり効き目があるということですね．<br/>\n構造体の中に閉じ込める方法が，<code>&amp;str</code> しか受理しないようにする方法よりもはやく<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>できるのは意外でした&hellip; 参照を引数にとると暗黙に lifetime 変数が導入されたと記憶しているので，その関係なのかな？</p>\n<p>構造体内で定義する方法では，<code>&amp;str</code> 以外の入力ストリーム型を受けつけることを可能にしつつも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間を短縮できるということで，積極的にこの方式でパーサを定義するべきということがわかりました．</p>\n<p>注意点として，構造体内で別のパーサを呼ぶときには，必ず <code>P::term</code> という形ではなく，<code>P::&lt;I&gt;::term</code> という形で呼び出すようにする必要があるようです．<br/>\nきちんと明示的に指定しないと，結局<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>するはめになって意味がないということのようです．</p>\n<hr>\n<p>COMMENT:\nAUTHOR: anevaden\nEMAIL: <a href=\"mailto:pgbsajrq@gmail.com\">pgbsajrq@gmail.com</a>\nURL: <a href=\"http://cialisvipsale.com\">http://cialisvipsale.com</a>\nIP: 60.173.69.118\nDATE: 03/24/2018 13:14:29</p>\n<p>Regards. Quite a lot of posts.</p>\n<p>tadalafil 20 mg <a href=\"http://cialisvipsale.com\">cialis tablets australia</a>\ninteractions for cialis <a href=\"http://cialisvipsale.com\"><a href=\"http://cialisvipsale.com\">http://cialisvipsale.com</a></a>\ncialis 5mg prix <a href=\"http://cialisvipsale.com\">cialis generico</a>\ncialis dose 30mg</p>\n<hr>\n<hr>\n","meta":{"rawMarkdown":"---\ntitle: \"Rust のパーサコンビネータライブラリ combine を使う時の tips\"\ndate: 2016-05-14T16:03:19.000Z\ntags: []\n---\n\n<p>Rust のパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>ライブラリの一つである <a href=\"https://github.com/Marwes/combine\">Marwes/combine: A parser combinator library for Rust</a> を使ってみています．<br/>\n詳しい使い方はきちんとしたドキュメントがあるのでそちらを参照してください．<br/>\nざっくりいうと <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> の <a href=\"https://hackage.haskell.org/package/parsec\">parsec: Monadic parser combinators | Hackage</a> の Rust 版という感じです．</p>\n\n<p>(ちなみに私も combine を参考に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>を作ってみたりしました. )\n<iframe src=\"http://agtn.hatenablog.com/embed/2016/04/30/003009\" title=\"C++ でパーサコンビネータを書きました - 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://agtn.hatenablog.com/entry/2016/04/30/003009\">agtn.hatenablog.com</a></cite></p>\n\n<p>で、このライブラリ、とても<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なコードで書かれているので、かなり<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間が増加します&hellip; (Boost.Spirit 系に近いです． <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーなどは遥かに読みやすいのであまり困ることはないですが)  <br/>\nパーサを書いている時にはテストは頻繁に行いたいので，ちょっと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>がおそいのはつらい．</p>\n\n<p>なにか解決策はないかなぁと思っていたら本家に issue がたっていました．<br/>\n<a href=\"https://github.com/Marwes/combine/issues/21\">Extremely long compile times · Issue #21 · Marwes/combine</a></p>\n\n<p>今回この issue にかかれていた内容を検証してみたので，ここでまとめておこうと思います．</p>\n\n<h2>結論</h2>\n\n<p>パーサの定義を，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体のメソッドとして定義すると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間が大幅に短くなる</p>\n\n<h2>方法</h2>\n\n<p>まずはじめに言われているのは，入力ストリーム型を<code>I: Stream&lt;Item=char&gt;</code> から <code>&amp;str</code> にしてしまうという方法です．</p>\n\n<blockquote><p>(It might be possible to specialize the parsers directly as well, say\n<code>\nfn expr(input: State&lt;&amp;str&gt;) -&gt; ParseResult&lt;Expr, &amp;str&gt;\n</code>\ninstead of\n<code>\nfn expr&lt;I: Stream&gt;(input: State&lt;I&gt;) -&gt; ParseResult&lt;I, &amp;str&gt;\n</code>\n)</p></blockquote>\n\n<p>これは作ったパーサを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な入力に対して適用することができなくなりますが，ライブラリの利用者側としては，<code>char</code> のストリームといったらだいたい <code>&amp;str</code> だと思うので，ぶっちゃけ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>じゃなくてもいいじゃんという感じです．</p>\n\n<p>そしてもう一つが,  <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体を作って，パーサの定義をその中に閉じ込めるという方法です．<br/>\nちょっとこちらはコード例を実際に見たほうがわかりやすいと思うので後で説明します．</p>\n\n<h2>実験コード</h2>\n\n<p>というわけで，</p>\n\n<ol>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なパーサ</li>\n<li>&amp;str のみを受理するパーサ</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体の中に定義された<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>でないパーサ</li>\n</ol>\n\n<p>の三種類について，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間をはかってみます．</p>\n\n<p>パーサ界のハローワールド，計算機で実験してみます．\nまずは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なパーサです．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synType\">*</span>;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">primitives</span><span class=\"synSpecial\">::</span>Stream;\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">integer</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synIdentifier\">many1</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>_<span class=\"synStatement\">&gt;</span>, _<span class=\"synStatement\">&gt;</span>(<span class=\"synIdentifier\">digit</span>())\n        .<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>is<span class=\"synStatement\">|</span> is.<span class=\"synIdentifier\">into_iter</span>().<span class=\"synIdentifier\">fold</span>(<span class=\"synConstant\">0</span>, <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> lhs <span class=\"synStatement\">+</span> (rhs <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span> <span class=\"synStatement\">-</span> <span class=\"synConstant\">'0'</span> <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span>)))\n        .<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">factor</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synIdentifier\">between</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'('</span>), <span class=\"synType\">char</span>(<span class=\"synConstant\">')'</span>), <span class=\"synIdentifier\">parser</span>(expr)).<span class=\"synIdentifier\">or</span>(<span class=\"synIdentifier\">parser</span>(integer)).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">term</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'*'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'/'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n        <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n            <span class=\"synConstant\">'*'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">*</span> rhs,\n            <span class=\"synConstant\">'/'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">/</span> rhs,\n            _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n        }\n    });\n    <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(factor), op).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">expr</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'+'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'-'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n        <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n            <span class=\"synConstant\">'+'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">+</span> rhs,\n            <span class=\"synConstant\">'-'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">-</span> rhs,\n            _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n        }\n    });\n    <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(term), op).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">parse</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: I) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span>(<span class=\"synType\">i64</span>, I), ParseError<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synIdentifier\">parser</span>(expr).<span class=\"synIdentifier\">parse</span>(input)\n}\n</pre>\n\n<p>それぞれの関数が一つのパーサの役割を担います．それぞれのパーサが独立していて，それぞれ別々に型変数を導入しています．</p>\n\n<p>次に <code>&amp;str</code> だけを受け取るパーサです．これは上記の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なパーサの，型変数を <code>&amp;str</code> に置き換えるだけなのでとても簡単です．<br/>\n一部だけ掲載します．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">expr</span>(input: State<span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, <span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;</span> {\n     <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'+'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'-'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n        <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n            <span class=\"synConstant\">'+'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">+</span> rhs,\n            <span class=\"synConstant\">'-'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">-</span> rhs,\n            _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n        }\n    });\n    <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(term), op).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">parse</span>(input: <span class=\"synType\">&amp;str</span>) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span>(<span class=\"synType\">i64</span>, <span class=\"synType\">&amp;str</span>), ParseError<span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;&gt;</span> {\n    <span class=\"synIdentifier\">parser</span>(expr).<span class=\"synIdentifier\">parse</span>(input)\n}\n</pre>\n\n<p>最後が，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体のメソッド中に，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>でないパーサを定義して閉じ込める方法です．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synType\">*</span>;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">primitives</span><span class=\"synSpecial\">::</span>Stream;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">std</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">marker</span><span class=\"synSpecial\">::</span>PhantomData;\n\n truct P<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(PhantomData<span class=\"synStatement\">&lt;fn</span>(I) <span class=\"synStatement\">-&gt;</span> I<span class=\"synStatement\">&gt;</span>);\n\n<span class=\"synStatement\">impl&lt;</span>I<span class=\"synStatement\">&gt;</span> P<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span> <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span> {\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">integer</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synIdentifier\">many1</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>_<span class=\"synStatement\">&gt;</span>, _<span class=\"synStatement\">&gt;</span>(<span class=\"synIdentifier\">digit</span>())\n            .<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>is<span class=\"synStatement\">|</span> is.<span class=\"synIdentifier\">into_iter</span>().<span class=\"synIdentifier\">fold</span>(<span class=\"synConstant\">0</span>, <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> lhs <span class=\"synStatement\">+</span> (rhs <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span> <span class=\"synStatement\">-</span> <span class=\"synConstant\">'0'</span> <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span>)))\n            .<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">factor</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synIdentifier\">between</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'('</span>), <span class=\"synType\">char</span>(<span class=\"synConstant\">')'</span>), <span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>expr))\n            .<span class=\"synIdentifier\">or</span>(<span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>integer))\n            .<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">term</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'*'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'/'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n            <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n                <span class=\"synConstant\">'*'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">*</span> rhs,\n                <span class=\"synConstant\">'/'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">/</span> rhs,\n                _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n            }\n        });\n        <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>factor), op).<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">expr</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'+'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'-'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n            <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n                <span class=\"synConstant\">'+'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">+</span> rhs,\n                <span class=\"synConstant\">'-'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">-</span> rhs,\n                _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n            }\n        });\n        <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>term), op).<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">parse</span>(input: <span class=\"synType\">&amp;str</span>) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span>(<span class=\"synType\">i64</span>, <span class=\"synType\">&amp;str</span>), ParseError<span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;&gt;</span> {\n    <span class=\"synIdentifier\">parser</span>(<span class=\"synPreProc\">P</span><span class=\"synSpecial\">::</span>expr).<span class=\"synIdentifier\">parse</span>(input)\n}\n</pre>\n\n<p>言葉で説明すると難しいのですが，型変数を導入する部分を構造体の定義部分だけにしてあげることで，型変数をそれぞれのパーサが別々に導入する必要がなくなっています．<br/>\nコードも割りとすっきりしますね．</p>\n\n<h2>結果</h2>\n\n<p>上記をコードを <code>cfg</code> を使って<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時に切り替えながら<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>してみました．<br/>\n本当はきちんと繰り返し計測すべきですが，ちょっとサボっています．まぁ何度実行してもだいたい同じくらいになったので許してください．</p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left;\"> 実装方法 </th>\n<th style=\"text-align:right;\"> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left;\"> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a> </td>\n<td style=\"text-align:right;\"> 2.666s </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> <code>&amp;str</code> </td>\n<td style=\"text-align:right;\"> 1.70s </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> 構造体内で定義 </td>\n<td style=\"text-align:right;\"> 1.55s </td>\n</tr>\n</tbody>\n</table>\n\n<p>このような結果になりました．<br/>\nつまり，先ほどの issue で述べられている<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間の短縮方法はかなり効き目があるということですね．<br/>\n構造体の中に閉じ込める方法が，<code>&amp;str</code> しか受理しないようにする方法よりもはやく<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>できるのは意外でした&hellip; 参照を引数にとると暗黙に lifetime 変数が導入されたと記憶しているので，その関係なのかな？</p>\n\n<p>構造体内で定義する方法では，<code>&amp;str</code> 以外の入力ストリーム型を受けつけることを可能にしつつも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間を短縮できるということで，積極的にこの方式でパーサを定義するべきということがわかりました．</p>\n\n<p>注意点として，構造体内で別のパーサを呼ぶときには，必ず <code>P::term</code> という形ではなく，<code>P::&lt;I&gt;::term</code> という形で呼び出すようにする必要があるようです．<br/>\nきちんと明示的に指定しないと，結局<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>するはめになって意味がないということのようです．</p>\n\n---\n\nCOMMENT:\nAUTHOR: anevaden\nEMAIL: pgbsajrq@gmail.com\nURL: http://cialisvipsale.com\nIP: 60.173.69.118\nDATE: 03/24/2018 13:14:29\n\nRegards. Quite a lot of posts.\n\ntadalafil 20 mg <a href=\"http://cialisvipsale.com\">cialis tablets australia</a>\ninteractions for cialis <a href=\"http://cialisvipsale.com\">http://cialisvipsale.com</a>\ncialis 5mg prix <a href=\"http://cialisvipsale.com\">cialis generico</a>\ncialis dose 30mg\n\n---\n\n---\n","contentMarkdown":"\n<p>Rust のパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>ライブラリの一つである <a href=\"https://github.com/Marwes/combine\">Marwes/combine: A parser combinator library for Rust</a> を使ってみています．<br/>\n詳しい使い方はきちんとしたドキュメントがあるのでそちらを参照してください．<br/>\nざっくりいうと <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> の <a href=\"https://hackage.haskell.org/package/parsec\">parsec: Monadic parser combinators | Hackage</a> の Rust 版という感じです．</p>\n\n<p>(ちなみに私も combine を参考に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a> でパーサ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D3%A5%CD%A1%BC%A5%BF\">コンビネータ</a>を作ってみたりしました. )\n<iframe src=\"http://agtn.hatenablog.com/embed/2016/04/30/003009\" title=\"C++ でパーサコンビネータを書きました - 右上➚\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"http://agtn.hatenablog.com/entry/2016/04/30/003009\">agtn.hatenablog.com</a></cite></p>\n\n<p>で、このライブラリ、とても<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なコードで書かれているので、かなり<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間が増加します&hellip; (Boost.Spirit 系に近いです． <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>エラーなどは遥かに読みやすいのであまり困ることはないですが)  <br/>\nパーサを書いている時にはテストは頻繁に行いたいので，ちょっと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>がおそいのはつらい．</p>\n\n<p>なにか解決策はないかなぁと思っていたら本家に issue がたっていました．<br/>\n<a href=\"https://github.com/Marwes/combine/issues/21\">Extremely long compile times · Issue #21 · Marwes/combine</a></p>\n\n<p>今回この issue にかかれていた内容を検証してみたので，ここでまとめておこうと思います．</p>\n\n<h2>結論</h2>\n\n<p>パーサの定義を，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体のメソッドとして定義すると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間が大幅に短くなる</p>\n\n<h2>方法</h2>\n\n<p>まずはじめに言われているのは，入力ストリーム型を<code>I: Stream&lt;Item=char&gt;</code> から <code>&amp;str</code> にしてしまうという方法です．</p>\n\n<blockquote><p>(It might be possible to specialize the parsers directly as well, say\n<code>\nfn expr(input: State&lt;&amp;str&gt;) -&gt; ParseResult&lt;Expr, &amp;str&gt;\n</code>\ninstead of\n<code>\nfn expr&lt;I: Stream&gt;(input: State&lt;I&gt;) -&gt; ParseResult&lt;I, &amp;str&gt;\n</code>\n)</p></blockquote>\n\n<p>これは作ったパーサを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な入力に対して適用することができなくなりますが，ライブラリの利用者側としては，<code>char</code> のストリームといったらだいたい <code>&amp;str</code> だと思うので，ぶっちゃけ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>じゃなくてもいいじゃんという感じです．</p>\n\n<p>そしてもう一つが,  <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体を作って，パーサの定義をその中に閉じ込めるという方法です．<br/>\nちょっとこちらはコード例を実際に見たほうがわかりやすいと思うので後で説明します．</p>\n\n<h2>実験コード</h2>\n\n<p>というわけで，</p>\n\n<ol>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なパーサ</li>\n<li>&amp;str のみを受理するパーサ</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体の中に定義された<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>でないパーサ</li>\n</ol>\n\n<p>の三種類について，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間をはかってみます．</p>\n\n<p>パーサ界のハローワールド，計算機で実験してみます．\nまずは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なパーサです．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synType\">*</span>;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">primitives</span><span class=\"synSpecial\">::</span>Stream;\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">integer</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synIdentifier\">many1</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>_<span class=\"synStatement\">&gt;</span>, _<span class=\"synStatement\">&gt;</span>(<span class=\"synIdentifier\">digit</span>())\n        .<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>is<span class=\"synStatement\">|</span> is.<span class=\"synIdentifier\">into_iter</span>().<span class=\"synIdentifier\">fold</span>(<span class=\"synConstant\">0</span>, <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> lhs <span class=\"synStatement\">+</span> (rhs <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span> <span class=\"synStatement\">-</span> <span class=\"synConstant\">'0'</span> <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span>)))\n        .<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">factor</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synIdentifier\">between</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'('</span>), <span class=\"synType\">char</span>(<span class=\"synConstant\">')'</span>), <span class=\"synIdentifier\">parser</span>(expr)).<span class=\"synIdentifier\">or</span>(<span class=\"synIdentifier\">parser</span>(integer)).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">term</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'*'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'/'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n        <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n            <span class=\"synConstant\">'*'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">*</span> rhs,\n            <span class=\"synConstant\">'/'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">/</span> rhs,\n            _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n        }\n    });\n    <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(factor), op).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">expr</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'+'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'-'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n        <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n            <span class=\"synConstant\">'+'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">+</span> rhs,\n            <span class=\"synConstant\">'-'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">-</span> rhs,\n            _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n        }\n    });\n    <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(term), op).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">parse</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(input: I) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span>(<span class=\"synType\">i64</span>, I), ParseError<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;&gt;</span>\n    <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span>\n{\n    <span class=\"synIdentifier\">parser</span>(expr).<span class=\"synIdentifier\">parse</span>(input)\n}\n</pre>\n\n<p>それぞれの関数が一つのパーサの役割を担います．それぞれのパーサが独立していて，それぞれ別々に型変数を導入しています．</p>\n\n<p>次に <code>&amp;str</code> だけを受け取るパーサです．これは上記の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>なパーサの，型変数を <code>&amp;str</code> に置き換えるだけなのでとても簡単です．<br/>\n一部だけ掲載します．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">expr</span>(input: State<span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, <span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;</span> {\n     <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'+'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'-'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n        <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n            <span class=\"synConstant\">'+'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">+</span> rhs,\n            <span class=\"synConstant\">'-'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">-</span> rhs,\n            _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n        }\n    });\n    <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(term), op).<span class=\"synIdentifier\">parse_state</span>(input)\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">parse</span>(input: <span class=\"synType\">&amp;str</span>) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span>(<span class=\"synType\">i64</span>, <span class=\"synType\">&amp;str</span>), ParseError<span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;&gt;</span> {\n    <span class=\"synIdentifier\">parser</span>(expr).<span class=\"synIdentifier\">parse</span>(input)\n}\n</pre>\n\n<p>最後が，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>な構造体のメソッド中に，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a>でないパーサを定義して閉じ込める方法です．</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synType\">*</span>;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">combine</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">primitives</span><span class=\"synSpecial\">::</span>Stream;\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">std</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">marker</span><span class=\"synSpecial\">::</span>PhantomData;\n\n truct P<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>(PhantomData<span class=\"synStatement\">&lt;fn</span>(I) <span class=\"synStatement\">-&gt;</span> I<span class=\"synStatement\">&gt;</span>);\n\n<span class=\"synStatement\">impl&lt;</span>I<span class=\"synStatement\">&gt;</span> P<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span> <span class=\"synStatement\">where</span> I: Stream<span class=\"synStatement\">&lt;</span>Item <span class=\"synStatement\">=</span> <span class=\"synType\">char</span><span class=\"synStatement\">&gt;</span> {\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">integer</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synIdentifier\">many1</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span>_<span class=\"synStatement\">&gt;</span>, _<span class=\"synStatement\">&gt;</span>(<span class=\"synIdentifier\">digit</span>())\n            .<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>is<span class=\"synStatement\">|</span> is.<span class=\"synIdentifier\">into_iter</span>().<span class=\"synIdentifier\">fold</span>(<span class=\"synConstant\">0</span>, <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> lhs <span class=\"synStatement\">+</span> (rhs <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span> <span class=\"synStatement\">-</span> <span class=\"synConstant\">'0'</span> <span class=\"synStatement\">as</span> <span class=\"synType\">i64</span>)))\n            .<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">factor</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synIdentifier\">between</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'('</span>), <span class=\"synType\">char</span>(<span class=\"synConstant\">')'</span>), <span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>expr))\n            .<span class=\"synIdentifier\">or</span>(<span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>integer))\n            .<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">term</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'*'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'/'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n            <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n                <span class=\"synConstant\">'*'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">*</span> rhs,\n                <span class=\"synConstant\">'/'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">/</span> rhs,\n                _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n            }\n        });\n        <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>factor), op).<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n\n    <span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">expr</span>(input: State<span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span>) <span class=\"synStatement\">-&gt;</span> ParseResult<span class=\"synStatement\">&lt;</span><span class=\"synType\">i64</span>, I<span class=\"synStatement\">&gt;</span> {\n        <span class=\"synStatement\">let</span> op <span class=\"synStatement\">=</span> <span class=\"synType\">char</span>(<span class=\"synConstant\">'+'</span>).<span class=\"synIdentifier\">or</span>(<span class=\"synType\">char</span>(<span class=\"synConstant\">'-'</span>)).<span class=\"synIdentifier\">map</span>(<span class=\"synStatement\">|</span>c<span class=\"synStatement\">|</span> {\n            <span class=\"synType\">move</span> <span class=\"synStatement\">|</span>lhs, rhs<span class=\"synStatement\">|</span> <span class=\"synStatement\">match</span> c {\n                <span class=\"synConstant\">'+'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">+</span> rhs,\n                <span class=\"synConstant\">'-'</span> <span class=\"synStatement\">=&gt;</span> lhs <span class=\"synStatement\">-</span> rhs,\n                _ <span class=\"synStatement\">=&gt;</span> <span class=\"synPreProc\">unreachable!</span>(),\n            }\n        });\n        <span class=\"synIdentifier\">chainl1</span>(<span class=\"synIdentifier\">parser</span>(<span class=\"synIdentifier\">P</span><span class=\"synSpecial\">::</span><span class=\"synStatement\">&lt;</span>I<span class=\"synStatement\">&gt;</span><span class=\"synSpecial\">::</span>term), op).<span class=\"synIdentifier\">parse_state</span>(input)\n    }\n}\n\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">parse</span>(input: <span class=\"synType\">&amp;str</span>) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">Result</span><span class=\"synStatement\">&lt;</span>(<span class=\"synType\">i64</span>, <span class=\"synType\">&amp;str</span>), ParseError<span class=\"synStatement\">&lt;</span><span class=\"synType\">&amp;str</span><span class=\"synStatement\">&gt;&gt;</span> {\n    <span class=\"synIdentifier\">parser</span>(<span class=\"synPreProc\">P</span><span class=\"synSpecial\">::</span>expr).<span class=\"synIdentifier\">parse</span>(input)\n}\n</pre>\n\n<p>言葉で説明すると難しいのですが，型変数を導入する部分を構造体の定義部分だけにしてあげることで，型変数をそれぞれのパーサが別々に導入する必要がなくなっています．<br/>\nコードも割りとすっきりしますね．</p>\n\n<h2>結果</h2>\n\n<p>上記をコードを <code>cfg</code> を使って<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時に切り替えながら<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>してみました．<br/>\n本当はきちんと繰り返し計測すべきですが，ちょっとサボっています．まぁ何度実行してもだいたい同じくらいになったので許してください．</p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left;\"> 実装方法 </th>\n<th style=\"text-align:right;\"> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left;\"> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%C3%A5%AF\">ジェネリック</a> </td>\n<td style=\"text-align:right;\"> 2.666s </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> <code>&amp;str</code> </td>\n<td style=\"text-align:right;\"> 1.70s </td>\n</tr>\n<tr>\n<td style=\"text-align:left;\"> 構造体内で定義 </td>\n<td style=\"text-align:right;\"> 1.55s </td>\n</tr>\n</tbody>\n</table>\n\n<p>このような結果になりました．<br/>\nつまり，先ほどの issue で述べられている<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間の短縮方法はかなり効き目があるということですね．<br/>\n構造体の中に閉じ込める方法が，<code>&amp;str</code> しか受理しないようにする方法よりもはやく<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>できるのは意外でした&hellip; 参照を引数にとると暗黙に lifetime 変数が導入されたと記憶しているので，その関係なのかな？</p>\n\n<p>構造体内で定義する方法では，<code>&amp;str</code> 以外の入力ストリーム型を受けつけることを可能にしつつも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時間を短縮できるということで，積極的にこの方式でパーサを定義するべきということがわかりました．</p>\n\n<p>注意点として，構造体内で別のパーサを呼ぶときには，必ず <code>P::term</code> という形ではなく，<code>P::&lt;I&gt;::term</code> という形で呼び出すようにする必要があるようです．<br/>\nきちんと明示的に指定しないと，結局<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%BF%BF%E4%CF%C0\">型推論</a>するはめになって意味がないということのようです．</p>\n\n---\n\nCOMMENT:\nAUTHOR: anevaden\nEMAIL: pgbsajrq@gmail.com\nURL: http://cialisvipsale.com\nIP: 60.173.69.118\nDATE: 03/24/2018 13:14:29\n\nRegards. Quite a lot of posts.\n\ntadalafil 20 mg <a href=\"http://cialisvipsale.com\">cialis tablets australia</a>\ninteractions for cialis <a href=\"http://cialisvipsale.com\">http://cialisvipsale.com</a>\ncialis 5mg prix <a href=\"http://cialisvipsale.com\">cialis generico</a>\ncialis dose 30mg\n\n---\n\n---\n","slug":"Rust_のパーサコンビネータライブラリ_combine_を使う時の_tips","title":"Rust のパーサコンビネータライブラリ combine を使う時の tips","timestamp":1463241799000,"tags":[]}}},"__N_SSG":true}