{"pageProps":{"post":{"content":"<p>ちょっとはまったのでメモ</p>\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">struct</span> <span class=\"synIdentifier\">A</span> {\n    foo: <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">i32</span><span class=\"synStatement\">&gt;</span>,\n    bar: <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">bool</span><span class=\"synStatement\">&gt;</span>,\n}\n</pre>\n<p>こんな構造体があったとする。\n普通、<code>A</code> の所有権を分解して <code>foo</code> と <code>bar</code> にしたいときは</p>\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">xxx</span>(x: A) <span class=\"synStatement\">-&gt;</span> (<span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">i32</span><span class=\"synStatement\">&gt;</span>, <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">bool</span><span class=\"synStatement\">&gt;</span>) {\n    <span class=\"synStatement\">let</span> A { foo, bar } <span class=\"synStatement\">=</span> x;\n    (foo, bar)\n}\n</pre>\n<p>とやれば良い（この例だともっと簡単に書ける気もするけど）</p>\n<p>一方、<code>Box&lt;A&gt;</code> から <code>foo</code> と <code>bar</code> に分解したい場合は話が変わってくる。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>fn error1(x: Box&lt;A&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;bool&gt;) {\n    (x.foo, x.bar)\n}\n\nfn error2(x: Box&lt;A&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;bool&gt;) {\n    let A { foo, bar } = *x;\n    (foo, bar)\n}</pre>\n<p>これらは両方共<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>できない。\n人間から見ると，<code>Box&lt;A&gt;</code> は <code>A</code> の所有権を持っているのだから、<code>A</code> -> <code>foo/bar</code> に分解できるなら <code>Box&lt;A&gt;</code> も同様にできる気がする。</p>\n<p>実際にはこのようにすると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>が通る。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>fn success(x: Box&lt;A&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;bool&gt;) {\n    let x = *x;\n    let A { foo, bar } = x;\n    (foo, bar)\n}</pre>\n<p>うーん、エラーになるケースだと <code>Deref</code> トレイトの機能を経由している感じになるのかな？\n<code>Deref</code> 経由で <code>foo</code> の所有権をとるとその時点で <code>Box&lt;A&gt;</code> の所有権は奪われちゃうから <code>bar</code> の所有権が取れないということなのだと想像した。\n<code>success</code> のようなコードが突然出てきたら混乱しそうだ。</p>\n<hr>\n<hr>\n","meta":{"rawMarkdown":"---\ntitle: \"Rust で Box に包まれた構造体の所有権分解\"\ndate: 2016-12-04T07:45:12.000Z\ntags: []\n---\n\n<p>ちょっとはまったのでメモ</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">struct</span> <span class=\"synIdentifier\">A</span> {\n    foo: <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">i32</span><span class=\"synStatement\">&gt;</span>,\n    bar: <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">bool</span><span class=\"synStatement\">&gt;</span>,\n}\n</pre>\n\n<p>こんな構造体があったとする。\n普通、<code>A</code> の所有権を分解して <code>foo</code> と <code>bar</code> にしたいときは</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">xxx</span>(x: A) <span class=\"synStatement\">-&gt;</span> (<span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">i32</span><span class=\"synStatement\">&gt;</span>, <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">bool</span><span class=\"synStatement\">&gt;</span>) {\n    <span class=\"synStatement\">let</span> A { foo, bar } <span class=\"synStatement\">=</span> x;\n    (foo, bar)\n}\n</pre>\n\n<p>とやれば良い（この例だともっと簡単に書ける気もするけど）</p>\n\n<p>一方、<code>Box&lt;A&gt;</code> から <code>foo</code> と <code>bar</code> に分解したい場合は話が変わってくる。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>fn error1(x: Box&lt;A&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;bool&gt;) {\n    (x.foo, x.bar)\n}\n\nfn error2(x: Box&lt;A&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;bool&gt;) {\n    let A { foo, bar } = *x;\n    (foo, bar)\n}</pre>\n\n<p>これらは両方共<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>できない。\n人間から見ると，<code>Box&lt;A&gt;</code> は <code>A</code> の所有権を持っているのだから、<code>A</code> -> <code>foo/bar</code> に分解できるなら <code>Box&lt;A&gt;</code> も同様にできる気がする。</p>\n\n<p>実際にはこのようにすると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>が通る。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>fn success(x: Box&lt;A&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;bool&gt;) {\n    let x = *x;\n    let A { foo, bar } = x;\n    (foo, bar)\n}</pre>\n\n<p>うーん、エラーになるケースだと <code>Deref</code> トレイトの機能を経由している感じになるのかな？\n<code>Deref</code> 経由で <code>foo</code> の所有権をとるとその時点で <code>Box&lt;A&gt;</code> の所有権は奪われちゃうから <code>bar</code> の所有権が取れないということなのだと想像した。\n<code>success</code> のようなコードが突然出てきたら混乱しそうだ。</p>\n\n---\n\n---\n","contentMarkdown":"\n<p>ちょっとはまったのでメモ</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">struct</span> <span class=\"synIdentifier\">A</span> {\n    foo: <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">i32</span><span class=\"synStatement\">&gt;</span>,\n    bar: <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">bool</span><span class=\"synStatement\">&gt;</span>,\n}\n</pre>\n\n<p>こんな構造体があったとする。\n普通、<code>A</code> の所有権を分解して <code>foo</code> と <code>bar</code> にしたいときは</p>\n\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">xxx</span>(x: A) <span class=\"synStatement\">-&gt;</span> (<span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">i32</span><span class=\"synStatement\">&gt;</span>, <span class=\"synType\">Vec</span><span class=\"synStatement\">&lt;</span><span class=\"synType\">bool</span><span class=\"synStatement\">&gt;</span>) {\n    <span class=\"synStatement\">let</span> A { foo, bar } <span class=\"synStatement\">=</span> x;\n    (foo, bar)\n}\n</pre>\n\n<p>とやれば良い（この例だともっと簡単に書ける気もするけど）</p>\n\n<p>一方、<code>Box&lt;A&gt;</code> から <code>foo</code> と <code>bar</code> に分解したい場合は話が変わってくる。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>fn error1(x: Box&lt;A&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;bool&gt;) {\n    (x.foo, x.bar)\n}\n\nfn error2(x: Box&lt;A&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;bool&gt;) {\n    let A { foo, bar } = *x;\n    (foo, bar)\n}</pre>\n\n<p>これらは両方共<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>できない。\n人間から見ると，<code>Box&lt;A&gt;</code> は <code>A</code> の所有権を持っているのだから、<code>A</code> -> <code>foo/bar</code> に分解できるなら <code>Box&lt;A&gt;</code> も同様にできる気がする。</p>\n\n<p>実際にはこのようにすると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>が通る。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>fn success(x: Box&lt;A&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;bool&gt;) {\n    let x = *x;\n    let A { foo, bar } = x;\n    (foo, bar)\n}</pre>\n\n<p>うーん、エラーになるケースだと <code>Deref</code> トレイトの機能を経由している感じになるのかな？\n<code>Deref</code> 経由で <code>foo</code> の所有権をとるとその時点で <code>Box&lt;A&gt;</code> の所有権は奪われちゃうから <code>bar</code> の所有権が取れないということなのだと想像した。\n<code>success</code> のようなコードが突然出てきたら混乱しそうだ。</p>\n\n---\n\n---\n","slug":"Rust_で_Box_に包まれた構造体の所有権分解","title":"Rust で Box に包まれた構造体の所有権分解","timestamp":1480837512000,"tags":[]}}},"__N_SSG":true}